import { reactive, watch, unref, computed, ref, watchEffect, type Ref } from "vue";
import {
  normalizeControlValue,
  calculateAutoRange,
  isVectorLike,
  clampValue,
  setObjectProperty,
  inferInstanceTypes,
  generateLabel,
  type ControlsConfig,
  type ControlPanel,
  type MetaValue,
} from "../util/controls";

export function useControls<T extends ControlsConfig | string[]>(targetRef: Ref<any>, config: T): ControlPanel {
  const controlsConfig = config || Object.keys(targetRef?.value || targetRef || {});

  const getConfigObject = () => {
    if (Array.isArray(controlsConfig)) {
      return controlsConfig.reduce((acc, key) => {
        const target = unref(targetRef);
        if (target && key in target) {
          acc[key] = target[key];
        } else {
          acc[key] = 0; // default value
        }
        return acc;
      }, {} as Record<string, any>);
    }
    return controlsConfig;
  };

  const normalizedConfig = ref<Record<string, MetaValue<any>>>({});

  // Function to update normalized config
  const updateNormalizedConfig = () => {
    const configObject = getConfigObject();
    const newConfig = Object.entries(configObject).reduce((acc, [key, value]) => {
      acc[key] = normalizeControlValue(value, key);
      return acc;
    }, {} as Record<string, MetaValue<any>>);
    normalizedConfig.value = newConfig;
  };

  // Initial config setup
  updateNormalizedConfig();

  const state = reactive({} as Record<string, any>);

  // Function to update state from normalized config
  const updateState = () => {
    Object.entries(normalizedConfig.value).forEach(([key, meta]) => {
      state[key] = meta.value;
    });
  };

  // Initial state setup
  updateState();

  const meta = reactive({} as Record<string, any>);

  // Function to update meta from normalized config
  const updateMeta = () => {
    Object.entries(normalizedConfig.value).forEach(([key, metaValue]) => {
      const autoRange = calculateAutoRange(metaValue.value);
      meta[key] = {
        disabled: metaValue.disabled || false,
        min: metaValue.min ?? autoRange.min,
        max: metaValue.max ?? autoRange.max,
        step: metaValue.step ?? autoRange.step,
        label: metaValue.label || key,
        type: metaValue.type || "slider",
      };
    });
  };

  // Initial meta setup
  updateMeta();

  const label = computed(() => generateLabel(targetRef));

  const ranges = computed(() => {
    return Object.entries(meta).reduce((acc, [key, metaValue]) => {
      if (typeof state[key] === "number") {
        acc[key] = {
          min: metaValue.min,
          max: metaValue.max,
          step: metaValue.step,
        };
      } else if (isVectorLike(state[key])) {
        acc[key] = {
          x: {
            min: metaValue.min ?? -10,
            max: metaValue.max ?? 10,
            step: metaValue.step ?? 0.01,
          },
          y: {
            min: metaValue.min ?? -10,
            max: metaValue.max ?? 10,
            step: metaValue.step ?? 0.01,
          },
          z: {
            min: metaValue.min ?? -10,
            max: metaValue.max ?? 10,
            step: metaValue.step ?? 0.01,
          },
        };
      }
      return acc;
    }, {} as Record<string, any>);
  });

  // Watch targetRef for changes and update controls accordingly
  watchEffect(() => {
    if (Array.isArray(controlsConfig)) {
      updateNormalizedConfig();
      updateState();
      updateMeta();
    }
  });

  // Set up watchers for state changes - only once
  const watcherStops = ref<(() => void)[]>([]);

  const setupStateWatchers = () => {
    // Clean up existing watchers
    watcherStops.value.forEach((stop) => stop());
    watcherStops.value = [];

    Object.keys(state).forEach((key) => {
      const stopWatcher = watch(
        () => state[key],
        (newValue) => {
          if (meta[key]?.disabled) return;

          if (typeof newValue === "number") {
            const clampedValue = clampValue(newValue, meta[key].min, meta[key].max);
            if (clampedValue !== newValue) {
              state[key] = clampedValue;
              return;
            }
          }

          const target = unref(targetRef);
          setObjectProperty(target, key, newValue);
        },
        {
          immediate: true,
          deep: true,
        }
      );
      watcherStops.value.push(stopWatcher);
    });
  };

  // Initial watcher setup
  setupStateWatchers();

  // Watch for changes in normalized config to re-setup watchers
  watch(
    normalizedConfig,
    () => {
      setupStateWatchers();
    },
    { deep: true }
  );

  const setValue = (key: string, value: any) => {
    if (key in state) {
      state[key] = value;
    }
  };

  const setDisabled = (key: string, disabled: boolean) => {
    if (key in meta) {
      meta[key].disabled = disabled;
    }
  };

  const reset = () => {
    Object.entries(normalizedConfig.value).forEach(([key, metaValue]) => {
      state[key] = metaValue.value;
    });
  };

  const onInput = (key: string, value: any) => {
    if (typeof value === "boolean") {
      setValue(key, value);
    } else if (isVectorLike(value)) {
      setValue(key, {
        x: Number(Number(value.x).toFixed(3)),
        y: Number(Number(value.y).toFixed(3)),
        z: Number(Number(value.z).toFixed(3)),
      });
    } else {
      setValue(key, Number(Number(value).toFixed(2)));
    }
  };

  return {
    label,
    state,
    meta,
    ranges,
    setValue,
    setDisabled,
    reset,
    onInput,
    $types: computed(() => inferInstanceTypes(targetRef)),
  };
}
