[
  {
    "_id": "66d11670577f4e8cedfc9e98",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01227268448795181
        },
        "iterator": {
          "value": 1.1649585843373496
        },
        "iterations": {
          "value": 33
        },
        "colorShift": {
          "value": 95.97937217620483
        },
        "colorOffset": {
          "value": 27.55784073795181
        },
        "contrast": {
          "value": 2.532153614457832
        },
        "orbSize": {
          "value": 56.92372716244819
        },
        "div": {
          "value": 329.4535185899849
        },
        "radius": {
          "value": 78.15404743975904
        },
        "wave": {
          "value": 1081.757605421687
        },
        "split": {
          "value": 14.857868975903617
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb5",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .47)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.157784262048196
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 2.33
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.68
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 0.49
        },
        "multiplier": {
          "value": 64
        },
        "ballSize": {
          "value": 1.1
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 6.19
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.84005370031426
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.119977205335353
        },
        "multiplier": {
          "value": 8.310778794401344
        },
        "ballSize": {
          "value": 1.6599921687041703
        },
        "contrast": {
          "value": 0.8500047547153251
        },
        "radius": {
          "value": 4.0500299267376345
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.11999832186517936
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.879949935644517
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ebe",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/2.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/5. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 17.4867
        },
        "ballSize": {
          "value": 16.60383
        },
        "contrast": {
          "value": 3.05951
        },
        "radius": {
          "value": 44.22667
        },
        "yOuter": {
          "value": 0.0136
        },
        "xOuter": {
          "value": 13.50143
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.09265
        },
        "yMultiplier": {
          "value": 1.6046
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.65104
        }
      },
      {
        "zoom": {
          "value": 10.799115478202873
        },
        "ballSize": {
          "value": 2
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed1",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv)), radius*\n                  cos(- yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 50
        },
        "ballSize": {
          "value": 5.644772596244353
        },
        "contrast": {
          "value": 2.0819725358342556
        },
        "radius": {
          "value": 101.77377080342856
        },
        "yOuter": {
          "value": 0.0057841932917215766
        },
        "xOuter": {
          "value": 1.3756925605865846
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.6530241908797301
        },
        "yMultiplier": {
          "value": 1.1673474157861918
        },
        "divider": {
          "value": 0.8504663674228163
        },
        "rotation": {
          "value": 0.4485766399337586
        },
        "yDiv": {
          "value": 527.8882773525744
        },
        "yDiv2": {
          "value": 23.835829475127074
        },
        "xDiv": {
          "value": 0.26825157533209015
        }
      },
      {
        "zoom": {
          "value": 45.44008038991905
        },
        "ballSize": {
          "value": 10.514816946006684
        },
        "contrast": {
          "value": 4.8104031880222715
        },
        "radius": {
          "value": 211.61748679287467
        },
        "yOuter": {
          "value": 0.018582703004400417
        },
        "xOuter": {
          "value": 1.4502035669533604
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.12136745223079821
        },
        "yMultiplier": {
          "value": 0.5327326946947949
        },
        "divider": {
          "value": 0.6384254187406873
        },
        "rotation": {
          "value": 1.2509849961981718
        },
        "yDiv": {
          "value": 11.422082832060672
        },
        "yDiv2": {
          "value": 17.16405588173005
        },
        "xDiv": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 66.1722807367164
        },
        "ballSize": {
          "value": 12.605021134342056
        },
        "contrast": {
          "value": 2.4117830575230617
        },
        "radius": {
          "value": 190.85365479250993
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1.3054196874779391
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.005347911421074928
        },
        "yMultiplier": {
          "value": 0.9057663515389685
        },
        "divider": {
          "value": 0.3392575735069184
        },
        "rotation": {
          "value": 1.523927619658321
        },
        "yDiv": {
          "value": 767.1698688597661
        },
        "yDiv2": {
          "value": 40.448379112151734
        },
        "xDiv": {
          "value": 0.2818832948983434
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb2",
    "shader": "\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.418
        },
        "iterator": {
          "value": 1.014
        },
        "iterations": {
          "value": 18
        },
        "colorShift": {
          "value": 0.266
        },
        "colorOffset": {
          "value": 25.265
        },
        "contrast": {
          "value": 0.831
        },
        "orbSize": {
          "value": 10.426
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 73.725
        },
        "wave": {
          "value": 1222
        },
        "split": {
          "value": 5.288
        }
      },
      {
        "zoom": {
          "value": 12.26
        },
        "iterator": {
          "value": 1.079
        },
        "iterations": {
          "value": 15
        },
        "colorShift": {
          "value": 0.271
        },
        "colorOffset": {
          "value": 18.968
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 5.174
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 32.407
        },
        "wave": {
          "value": 0
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 8.452
        },
        "iterator": {
          "value": 0.978
        },
        "iterations": {
          "value": 13
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 17.673
        },
        "contrast": {
          "value": 1.146
        },
        "orbSize": {
          "value": 26.704
        },
        "div": {
          "value": 3.174
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 865.131
        },
        "split": {
          "value": 17.958
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb9",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.157784262048196
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 2.33
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.68
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 0.49
        },
        "multiplier": {
          "value": 64
        },
        "ballSize": {
          "value": 1.1
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 6.19
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.84
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.12
        },
        "multiplier": {
          "value": 8.31
        },
        "ballSize": {
          "value": 1.66
        },
        "contrast": {
          "value": 0.85
        },
        "radius": {
          "value": 4.05
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.12
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.88
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9a",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -3.);\n  uv = abs(uv);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0012443524096385546
        },
        "iterator": {
          "value": 0.7577447289156627
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 48.10121893825301
        },
        "colorOffset": {
          "value": 18.446018448795183
        },
        "contrast": {
          "value": 1.693994728915663
        },
        "orbSize": {
          "value": 701.3161285768074
        },
        "div": {
          "value": 329.4535185899849
        },
        "radius": {
          "value": 212
        },
        "wave": {
          "value": 1333
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.0012968320198683304
        },
        "iterator": {
          "value": 0.8880798192771083
        },
        "iterations": {
          "value": 20.03311841114458
        },
        "colorShift": {
          "value": 63.033107943787634
        },
        "colorOffset": {
          "value": 29.441665097891565
        },
        "contrast": {
          "value": 2.379245105421687
        },
        "orbSize": {
          "value": 242.2608669051205
        },
        "div": {
          "value": 333
        },
        "radius": {
          "value": 98.25054593373497
        },
        "wave": {
          "value": 309.7205534731702
        },
        "split": {
          "value": 59.95820783132531
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec0",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 4.641638929691454
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 12.163733057228916
        },
        "ballSize": {
          "value": 5
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 60.4480421686747
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 0.4060146837349398
        },
        "rotation": {
          "value": 0.3975432981927712
        },
        "yDiv": {
          "value": 5.762471762048194
        },
        "yDiv2": {
          "value": 4.357078313253012
        },
        "xDiv": {
          "value": 0.7352974397590362
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed5",
    "shader": "void main () {\n  float stream = stream  /16.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/-3.);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/1.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/fuck-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (200.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.38083793915898
        },
        "ballSize": {
          "value": 4.262981598635755
        },
        "contrast": {
          "value": 2.5889260165662655
        },
        "radius": {
          "value": 4.875361982598363
        },
        "yOuter": {
          "value": 1.3027315438511862
        },
        "xOuter": {
          "value": 21.918668080525233
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.2610395500458869
        },
        "yMultiplier": {
          "value": 0.5742157625864788
        },
        "divider": {
          "value": 3.949900420315295
        },
        "rotation": {
          "value": 2.962652091520379
        },
        "fuck": {
          "value": 1.4575311499905876
        },
        "xDiv": {
          "value": 4.871233395496048
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e97",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006632153614457834
        },
        "iterator": {
          "value": 1.5
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 48.10121893825301
        },
        "colorOffset": {
          "value": 18.446018448795183
        },
        "contrast": {
          "value": 2.025352974397591
        },
        "orbSize": {
          "value": 171.06751223644582
        },
        "div": {
          "value": 1022.0045497458585
        },
        "radius": {
          "value": 73.36788403614459
        },
        "wave": {
          "value": 959.7436888177713
        },
        "split": {
          "value": 9.479103915662652
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec5",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.764354292168676
        },
        "ballSize": {
          "value": 30.02166792168675
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 48.605751129518076
        },
        "yOuter": {
          "value": 0.28322665662650603
        },
        "xOuter": {
          "value": 81.74359939759037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.788685993975904
        },
        "yMultiplier": {
          "value": 2.4412114081325305
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 4.2250564759036155
        },
        "yDiv": {
          "value": 4.170557228915664
        },
        "yDiv2": {
          "value": 8.153840361445786
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed2",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream+xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv)), radius*\n                  cos(- yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 50
        },
        "ballSize": {
          "value": 5.644772596244353
        },
        "contrast": {
          "value": 2.0819725358342556
        },
        "radius": {
          "value": 101.77377080342856
        },
        "yOuter": {
          "value": 0.0057841932917215766
        },
        "xOuter": {
          "value": 1.3756925605865846
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.6530241908797301
        },
        "yMultiplier": {
          "value": 1.1673474157861918
        },
        "divider": {
          "value": 0.8504663674228163
        },
        "rotation": {
          "value": 0.4485766399337586
        },
        "yDiv": {
          "value": 527.8882773525744
        },
        "yDiv2": {
          "value": 23.835829475127074
        },
        "xDiv": {
          "value": 0.26825157533209015
        }
      },
      {
        "zoom": {
          "value": 45.44008038991905
        },
        "ballSize": {
          "value": 3.7502623776355426
        },
        "contrast": {
          "value": 2.0365335625338274
        },
        "radius": {
          "value": 182.3945488987199
        },
        "yOuter": {
          "value": 0.018582703004400417
        },
        "xOuter": {
          "value": 1.4502035669533604
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.12136745223079821
        },
        "yMultiplier": {
          "value": 0.5327326946947949
        },
        "divider": {
          "value": 0.6384254187406873
        },
        "rotation": {
          "value": 1.2509849961981718
        },
        "yDiv": {
          "value": 11.422082832060672
        },
        "yDiv2": {
          "value": 17.16405588173005
        },
        "xDiv": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 66.1722807367164
        },
        "ballSize": {
          "value": 12.605021134342056
        },
        "contrast": {
          "value": 2.4117830575230617
        },
        "radius": {
          "value": 190.85365479250993
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1.3054196874779391
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.005347911421074928
        },
        "yMultiplier": {
          "value": 0.9057663515389685
        },
        "divider": {
          "value": 0.3392575735069184
        },
        "rotation": {
          "value": 1.523927619658321
        },
        "yDiv": {
          "value": 767.1698688597661
        },
        "yDiv2": {
          "value": 40.448379112151734
        },
        "xDiv": {
          "value": 0.2818832948983434
        }
      },
      {
        "zoom": {
          "value": 29.53490475574172
        },
        "ballSize": {
          "value": 18.763334894754802
        },
        "contrast": {
          "value": 2.4117830575230617
        },
        "radius": {
          "value": 6.786545213446561
        },
        "yOuter": {
          "value": 0.18734175900378863
        },
        "xOuter": {
          "value": 2.0486279499099918
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.0833488556275885
        },
        "yMultiplier": {
          "value": 0.037316765842667556
        },
        "divider": {
          "value": 0.3392575735069184
        },
        "rotation": {
          "value": 0.6698602883212539
        },
        "yDiv": {
          "value": 537.9855964384884
        },
        "yDiv2": {
          "value": 21.203650196489086
        },
        "xDiv": {
          "value": 0.41686075968914726
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea1",
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -15.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-3.21605);\n    float d = radius * wave * cos(split * uv.y  - stream /0.346);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.)/1. * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6465079066265061
        },
        "iterator": {
          "value": 1.3677409638554219
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 1.5186370481927711
        },
        "colorOffset": {
          "value": 18.31640625
        },
        "contrast": {
          "value": 1.1740634412650603
        },
        "orbSize": {
          "value": 0.5971385542168676
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.226694277108434
        },
        "wave": {
          "value": 0.6340361445783134
        },
        "split": {
          "value": 15.149849397590366
        }
      },
      {
        "zoom": {
          "value": 1.8872270331325305
        },
        "iterator": {
          "value": 1.2201590737951808
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 0.5885212725903615
        },
        "colorOffset": {
          "value": 20.50647119728916
        },
        "contrast": {
          "value": 1.3051157756024097
        },
        "orbSize": {
          "value": 1
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.707699548192772
        },
        "wave": {
          "value": 1.2741905120481931
        },
        "split": {
          "value": 2.777334337349398
        }
      },
      {
        "zoom": {
          "value": 0.20455572289156632
        },
        "iterator": {
          "value": 2.0409450301204823
        },
        "iterations": {
          "value": 7.585899849397592
        },
        "colorShift": {
          "value": 6.072355045180723
        },
        "colorOffset": {
          "value": 16.54249811746988
        },
        "contrast": {
          "value": 0.857741905120482
        },
        "orbSize": {
          "value": 0.19678087349397594
        },
        "div": {
          "value": 3.954046216114458
        },
        "radius": {
          "value": 4.343053463855423
        },
        "wave": {
          "value": 0.9644201807228918
        },
        "split": {
          "value": 15.434064382530124
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea2",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.675150886158583
        },
        "iterator": {
          "value": 1.1274359939759038
        },
        "iterations": {
          "value": 7.958174887048194
        },
        "colorShift": {
          "value": 0.32937217619416226
        },
        "colorOffset": {
          "value": 15
        },
        "contrast": {
          "value": 0.831
        },
        "orbSize": {
          "value": 25.7765389683735
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 73.725
        },
        "wave": {
          "value": 197.5915568524097
        },
        "split": {
          "value": 6.847326807228917
        }
      },
      {
        "zoom": {
          "value": 1.93
        },
        "iterator": {
          "value": 1.079
        },
        "iterations": {
          "value": 15
        },
        "colorShift": {
          "value": 0.271
        },
        "colorOffset": {
          "value": 18.968
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 5.174
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 32.407
        },
        "wave": {
          "value": 0
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 8.452
        },
        "iterator": {
          "value": 0.978
        },
        "iterations": {
          "value": 13
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 17.673
        },
        "contrast": {
          "value": 1.146
        },
        "orbSize": {
          "value": 26.704
        },
        "div": {
          "value": 3.174
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 865.131
        },
        "split": {
          "value": 17.958
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea5",
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 0.6);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6465079066265061
        },
        "iterator": {
          "value": 1.3677409638554219
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 1.5186370481927711
        },
        "colorOffset": {
          "value": 18.31640625
        },
        "contrast": {
          "value": 1.1740634412650603
        },
        "orbSize": {
          "value": 0.5971385542168676
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.226694277108434
        },
        "wave": {
          "value": 0.6340361445783134
        },
        "split": {
          "value": 15.149849397590366
        }
      },
      {
        "zoom": {
          "value": 1.8872270331325305
        },
        "iterator": {
          "value": 1.2201590737951808
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 0.5885212725903615
        },
        "colorOffset": {
          "value": 20.50647119728916
        },
        "contrast": {
          "value": 1.3051157756024097
        },
        "orbSize": {
          "value": 1
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.707699548192772
        },
        "wave": {
          "value": 1.2741905120481931
        },
        "split": {
          "value": 2.777334337349398
        }
      },
      {
        "zoom": {
          "value": 0.9513930722891566
        },
        "iterator": {
          "value": 1.823339137801205
        },
        "iterations": {
          "value": 27.0210796310241
        },
        "colorShift": {
          "value": 0
        },
        "colorOffset": {
          "value": 26.667286332831328
        },
        "contrast": {
          "value": 1.1627470948138394
        },
        "orbSize": {
          "value": 0.3594597138554217
        },
        "div": {
          "value": 5.113429028614458
        },
        "radius": {
          "value": 4.177099021084338
        },
        "wave": {
          "value": 0.7246799698795182
        },
        "split": {
          "value": 4.043100527108434
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb1",
    "shader": "\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 14.886
        },
        "iterator": {
          "value": 1.006
        },
        "iterations": {
          "value": 26
        },
        "colorShift": {
          "value": 0.07
        },
        "colorOffset": {
          "value": 28.499
        },
        "contrast": {
          "value": 1.146
        },
        "orbSize": {
          "value": 239.719
        },
        "div": {
          "value": 8.811
        },
        "radius": {
          "value": 50.228
        },
        "wave": {
          "value": 651.105
        },
        "split": {
          "value": 21.39
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb4",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/2.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.157784262048196
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 2.33
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 18.95431570030121
        },
        "yDivider": {
          "value": 25.59162509412651
        },
        "xDivider": {
          "value": 0.6188427146084339
        },
        "multiplier": {
          "value": 6.285826477786146
        },
        "ballSize": {
          "value": 1.5564006024096386
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 12.120933734939761
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.36300357680722894
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.7258377259036145
        },
        "e": {
          "value": 0.04823983433734941
        }
      },
      {
        "zoom": {
          "value": 16.84005370031426
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.119977205335353
        },
        "multiplier": {
          "value": 8.310778794401344
        },
        "ballSize": {
          "value": 1.6599921687041703
        },
        "contrast": {
          "value": 0.8500047547153251
        },
        "radius": {
          "value": 4.0500299267376345
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.11999832186517936
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.879949935644517
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec4",
    "shader": "void main () {\n  float stream = stream/4. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume,.5)* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 2.3806736222232683
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ecd",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/5.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.9502541415662655
        },
        "ballSize": {
          "value": 6.678379141566266
        },
        "contrast": {
          "value": 4.247623305722891
        },
        "radius": {
          "value": 0.010951618975903618
        },
        "yOuter": {
          "value": 28.494415003765063
        },
        "xOuter": {
          "value": 14.311078689759038
        },
        "xMultiplier": {
          "value": 3.790050828313254
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 18.47632718373494
        },
        "rotation": {
          "value": 0
        },
        "xDiv": {
          "value": 0.638441265060241
        },
        "yDiv": {
          "value": 0.20608998493975908
        },
        "yDiv2": {
          "value": 0.757464231927711
        },
        "uvDiv": {
          "value": 130.7125423569277
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed3",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 169.99143347682727
        },
        "ballSize": {
          "value": 5.722396960890437
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.713377987045845
        },
        "yOuter": {
          "value": 0.847429169804217
        },
        "xOuter": {
          "value": 12.030296049922347
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.3520320294851281
        },
        "yMultiplier": {
          "value": 3.2669278285015064
        },
        "divider": {
          "value": 0.41733546431168683
        },
        "rotation": {
          "value": 0.6490649947200915
        },
        "yDiv": {
          "value": 8.247158693980024
        },
        "yDiv2": {
          "value": 51.70744459772685
        },
        "xDiv": {
          "value": 24.251763842479296
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e95",
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -5.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / .5);\n    float b = radius * sin(uv.y + stream / -1.);\n    float c = radius * wave * sin(split * uv.x - stream /11.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea6",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 9.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -2.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb0",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -8.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.);\n    float b = radius * sin(uv.y + stream / -4.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ebb",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/130.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.829
        },
        "yDivider": {
          "value": 2.56557
        },
        "xDivider": {
          "value": 0.97527
        },
        "multiplier": {
          "value": 66.97836
        },
        "ballSize": {
          "value": 1.57538
        },
        "contrast": {
          "value": 0.4939
        },
        "radius": {
          "value": 11.43989
        },
        "rotation": {
          "value": 0
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 0.04909
        },
        "d": {
          "value": 2.93478
        },
        "e": {
          "value": 0.47379
        },
        "f": {
          "value": 0.0721
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec3",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/2. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 2.3806736222232683
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 31.472457518060526
        },
        "ballSize": {
          "value": 2.110821689467832
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 24.179171826466025
        },
        "yOuter": {
          "value": 1.428772046192583
        },
        "xOuter": {
          "value": 20.940836976522426
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0.3408098979168628
        },
        "divider": {
          "value": 1.023770785044475
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 0.7667471644390061
        },
        "yDiv2": {
          "value": 43.96754676175405
        },
        "xDiv": {
          "value": 1.7746264354292172
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9b",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0012443524096385546
        },
        "iterator": {
          "value": 0.7577447289156627
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 48.10121893825301
        },
        "colorOffset": {
          "value": 18.446018448795183
        },
        "contrast": {
          "value": 1.693994728915663
        },
        "orbSize": {
          "value": 701.3161285768074
        },
        "div": {
          "value": 329.4535185899849
        },
        "radius": {
          "value": 212
        },
        "wave": {
          "value": 1333
        },
        "split": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb3",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 40.433
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 1.07475
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.68
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 0.49
        },
        "multiplier": {
          "value": 64
        },
        "ballSize": {
          "value": 1.1
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 6.19
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.84005370031426
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.119977205335353
        },
        "multiplier": {
          "value": 8.310778794401344
        },
        "ballSize": {
          "value": 1.6599921687041703
        },
        "contrast": {
          "value": 0.8500047547153251
        },
        "radius": {
          "value": 4.0500299267376345
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.11999832186517936
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.879949935644517
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eae",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.);\n    float b = radius * sin(uv.y + stream / -4.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .3)/1.5 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ece",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x/shape+ sin(stream + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(.001*yOuter*uv.x/.5+t+yMultiplier+1.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.8318806475903617
        },
        "ballSize": {
          "value": 128.00044710090364
        },
        "contrast": {
          "value": 3.7043957078313254
        },
        "radius": {
          "value": 3.9535391566265066
        },
        "yOuter": {
          "value": 0.6684017319277109
        },
        "xOuter": {
          "value": 69.76950771837349
        },
        "xMultiplier": {
          "value": 29.147307981927714
        },
        "yMultiplier": {
          "value": 172.48564570783137
        },
        "divider": {
          "value": 38.312782379518076
        },
        "rotation": {
          "value": 2.2631541792168677
        },
        "yDiv": {
          "value": 0.2586690512048193
        },
        "dhspr": {
          "value": 1
        },
        "shape": {
          "value": 1.2469691265060243
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed4",
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation + stream/-100. + sin(uv.x/xDiv*\n                                                sin(stream/30.)));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/1.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/fuck-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (200.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1.1/pow(volume, .0), 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.8758408511977605
        },
        "ballSize": {
          "value": 37.76308937532357
        },
        "contrast": {
          "value": 2.5889260165662655
        },
        "radius": {
          "value": 17.113900095008947
        },
        "yOuter": {
          "value": 1.3027315438511862
        },
        "xOuter": {
          "value": 23.2248299839985
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.925161246793816
        },
        "yMultiplier": {
          "value": 2.6590740709419713
        },
        "divider": {
          "value": 3.949900420315295
        },
        "rotation": {
          "value": 2.962652091520379
        },
        "fuck": {
          "value": 1.4575311499905876
        },
        "xDiv": {
          "value": 4.871233395496048
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eaa",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6465079066265061
        },
        "iterator": {
          "value": 1.3677409638554219
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 1.5186370481927711
        },
        "colorOffset": {
          "value": 18.31640625
        },
        "contrast": {
          "value": 1.1740634412650603
        },
        "orbSize": {
          "value": 0.5971385542168676
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.226694277108434
        },
        "wave": {
          "value": 0.6340361445783134
        },
        "split": {
          "value": 15.149849397590366
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 1.5
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 2.4140625000000004
        },
        "colorOffset": {
          "value": 15
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.5174228162650604
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 4.123590484371238
        },
        "split": {
          "value": 2.3798945783132535
        }
      },
      {
        "zoom": {
          "value": 2.3402814382530126
        },
        "iterator": {
          "value": -0.6901025978915662
        },
        "iterations": {
          "value": 19.132017131024103
        },
        "colorShift": {
          "value": 1.8957831325301209
        },
        "colorOffset": {
          "value": 19.664203689759034
        },
        "contrast": {
          "value": 0.6084713855421688
        },
        "orbSize": {
          "value": 0.28940135542168677
        },
        "div": {
          "value": 3.5612359751506024
        },
        "radius": {
          "value": 1.3431664156626508
        },
        "wave": {
          "value": 5.866528614457832
        },
        "split": {
          "value": 5.772684487951808
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e99",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -2.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * tan(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.012176675451807232
        },
        "iterator": {
          "value": 0.9413253012048193
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 48.10121893825301
        },
        "colorOffset": {
          "value": 18.446018448795183
        },
        "contrast": {
          "value": 2.025352974397591
        },
        "orbSize": {
          "value": 250.5209196159639
        },
        "div": {
          "value": 489.837401214232
        },
        "radius": {
          "value": 20.803896837349402
        },
        "wave": {
          "value": 1333
        },
        "split": {
          "value": 10.636295180722893
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb8",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c - stream);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)/cos(uv.y/100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1112. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 28.25
        },
        "yDivider": {
          "value": 9.4
        },
        "xDivider": {
          "value": 3.96
        },
        "multiplier": {
          "value": 22069.06
        },
        "ballSize": {
          "value": 5.68
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 19.36
        },
        "rotation": {
          "value": 0.31
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 1.06
        },
        "d": {
          "value": 2.06
        },
        "e": {
          "value": 0.53
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9d",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv = abs(uv);\n  uv *=\n  uv *= k_rotate2d(stream / -1.);\n  for (float i = 2.; i < 17.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -.5);\n    float b = radius * sin(uv.y / div + stream / -.8);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / .5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05941076807228917
        },
        "iterator": {
          "value": 0.9375640060240964
        },
        "iterations": {
          "value": 4.923597515060242
        },
        "colorShift": {
          "value": 44.49821159638555
        },
        "colorOffset": {
          "value": 16.446771460843372
        },
        "contrast": {
          "value": 2.193425263554217
        },
        "orbSize": {
          "value": 105.40193900602412
        },
        "div": {
          "value": 5333
        },
        "radius": {
          "value": 4.278953313253012
        },
        "wave": {
          "value": 3812.620039533133
        },
        "split": {
          "value": 86.38253012048195
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea8",
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 2.125);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6465079066265061
        },
        "iterator": {
          "value": 1.3677409638554219
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 1.5186370481927711
        },
        "colorOffset": {
          "value": 18.31640625
        },
        "contrast": {
          "value": 1.1740634412650603
        },
        "orbSize": {
          "value": 0.5971385542168676
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.226694277108434
        },
        "wave": {
          "value": 0.6340361445783134
        },
        "split": {
          "value": 15.149849397590366
        }
      },
      {
        "zoom": {
          "value": 1.8872270331325305
        },
        "iterator": {
          "value": 1.2201590737951808
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 0.5885212725903615
        },
        "colorOffset": {
          "value": 20.50647119728916
        },
        "contrast": {
          "value": 1.3051157756024097
        },
        "orbSize": {
          "value": 1
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.707699548192772
        },
        "wave": {
          "value": 1.2741905120481931
        },
        "split": {
          "value": 2.777334337349398
        }
      },
      {
        "zoom": {
          "value": 0.9513930722891566
        },
        "iterator": {
          "value": 1.823339137801205
        },
        "iterations": {
          "value": 27.0210796310241
        },
        "colorShift": {
          "value": 0
        },
        "colorOffset": {
          "value": 20.030379329819276
        },
        "contrast": {
          "value": 1.1627470948138394
        },
        "orbSize": {
          "value": 0.3594597138554217
        },
        "div": {
          "value": 5.113429028614458
        },
        "radius": {
          "value": 4.177099021084338
        },
        "wave": {
          "value": 0.7246799698795182
        },
        "split": {
          "value": 4.043100527108434
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eba",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.73
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 2.33
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.68
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 0.49
        },
        "multiplier": {
          "value": 64
        },
        "ballSize": {
          "value": 1.1
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 6.19
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.84
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.12
        },
        "multiplier": {
          "value": 8.31
        },
        "ballSize": {
          "value": 1.66
        },
        "contrast": {
          "value": 0.85
        },
        "radius": {
          "value": 4.05
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.12
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.88
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea9",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 4.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * abs(.1+abs(tan((stream-uv.x + div))));\n    float b = radius * cos(stream + uv.y - div);\n    float c = radius * wave * sin(split * uv.x - stream /-.0605);\n    float d = radius * wave * cos(split * uv.y  - stream / 2.9125);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.9513930722891566
        },
        "iterator": {
          "value": 1.823339137801205
        },
        "iterations": {
          "value": 27.0210796310241
        },
        "colorShift": {
          "value": 0
        },
        "colorOffset": {
          "value": 26.667286332831328
        },
        "contrast": {
          "value": 1.1627470948138394
        },
        "orbSize": {
          "value": 0.3594597138554217
        },
        "div": {
          "value": 5.113429028614458
        },
        "radius": {
          "value": 4.177099021084338
        },
        "wave": {
          "value": 0.7246799698795182
        },
        "split": {
          "value": 4.043100527108434
        }
      },
      {
        "zoom": {
          "value": 2.6071253765060245
        },
        "iterator": {
          "value": 0.7
        },
        "iterations": {
          "value": 0
        },
        "colorShift": {
          "value": 0.0254376882530121
        },
        "colorOffset": {
          "value": 28.594526543674704
        },
        "contrast": {
          "value": 1.1222609186746988
        },
        "orbSize": {
          "value": 0.3232868975903615
        },
        "div": {
          "value": 15
        },
        "radius": {
          "value": 2.036803463855422
        },
        "wave": {
          "value": 1.4388177710843377
        },
        "split": {
          "value": 17.269813629518076
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea7",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.289744917168675
        },
        "iterator": {
          "value": 1.336984186746988
        },
        "iterations": {
          "value": 19.638944841867474
        },
        "colorShift": {
          "value": 3
        },
        "colorOffset": {
          "value": 18.935876317771083
        },
        "contrast": {
          "value": 1.1055299322289158
        },
        "orbSize": {
          "value": 0.5138225659350154
        },
        "div": {
          "value": 5.55512890625
        },
        "radius": {
          "value": 2.675207078313253
        },
        "wave": {
          "value": 1.3555158132530123
        },
        "split": {
          "value": 2.469479480421687
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eab",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.4446906864375482
        },
        "iterator": {
          "value": 1.336984186746988
        },
        "iterations": {
          "value": 19.638944841867474
        },
        "colorShift": {
          "value": 1.2591161521084338
        },
        "colorOffset": {
          "value": 22.498735586912325
        },
        "contrast": {
          "value": 0.8990822665662651
        },
        "orbSize": {
          "value": 0.4297678884425685
        },
        "div": {
          "value": 3.102181334713856
        },
        "radius": {
          "value": 3.1522307981927717
        },
        "wave": {
          "value": 7.64432837097393
        },
        "split": {
          "value": 2.469479480421687
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ead",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.418
        },
        "iterator": {
          "value": 1.014
        },
        "iterations": {
          "value": 18
        },
        "colorShift": {
          "value": 0.266
        },
        "colorOffset": {
          "value": 25.265
        },
        "contrast": {
          "value": 0.831
        },
        "orbSize": {
          "value": 10.426
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 73.725
        },
        "wave": {
          "value": 1222
        },
        "split": {
          "value": 5.288
        }
      },
      {
        "zoom": {
          "value": 1.93
        },
        "iterator": {
          "value": 1.079
        },
        "iterations": {
          "value": 15
        },
        "colorShift": {
          "value": 0.271
        },
        "colorOffset": {
          "value": 18.968
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 5.174
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 32.407
        },
        "wave": {
          "value": 0
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 8.452
        },
        "iterator": {
          "value": 0.978
        },
        "iterations": {
          "value": 13
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 17.673
        },
        "contrast": {
          "value": 1.146
        },
        "orbSize": {
          "value": 26.704
        },
        "div": {
          "value": 3.174
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 865.131
        },
        "split": {
          "value": 17.958
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec2",
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/12.);\n  float dist = length(uv);\n  for (float i = 0.; i < 40.; i++) {\n    uv *= k_rotate2d(rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/100.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 2.3806736222232683
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 31.472457518060526
        },
        "ballSize": {
          "value": 2.110821689467832
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 24.179171826466025
        },
        "yOuter": {
          "value": 1.428772046192583
        },
        "xOuter": {
          "value": 20.940836976522426
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0.3408098979168628
        },
        "divider": {
          "value": 1.023770785044475
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 0.7667471644390061
        },
        "yDiv2": {
          "value": 43.96754676175405
        },
        "xDiv": {
          "value": 1.7746264354292172
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 76.04349848735765
        },
        "ballSize": {
          "value": 7
        },
        "contrast": {
          "value": 1.6782306648162477
        },
        "radius": {
          "value": 46.73833272543298
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 121.90263440235556
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4497109654438065
        },
        "yMultiplier": {
          "value": 0.9904435643541671
        },
        "divider": {
          "value": 0.4888161349009319
        },
        "rotation": {
          "value": 5
        },
        "yDiv": {
          "value": 5.318059162921217
        },
        "yDiv2": {
          "value": 66.56326227762614
        },
        "xDiv": {
          "value": 5.000529057146556
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 2.512914450771838
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 31.12488712172911
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 35.98427204913405
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5644670969032382
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 2.512914450771838
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 31.12488712172911
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 35.98427204913405
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5644670969032382
        },
        "yMultiplier": {
          "value": 12
        },
        "divider": {
          "value": 0.2073346609092621
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 16.904170254626912
        },
        "yDiv2": {
          "value": 5.818779598373966
        },
        "xDiv": {
          "value": 1.3528976256588858
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec8",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /2.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.756140619300935
        },
        "ballSize": {
          "value": 45.40572738647462
        },
        "contrast": {
          "value": 2.723491561226182
        },
        "radius": {
          "value": 34
        },
        "yOuter": {
          "value": 1.814596318624106
        },
        "xOuter": {
          "value": 109.75608219008849
        },
        "xMultiplier": {
          "value": 11.466961596385545
        },
        "yMultiplier": {
          "value": 3.877400225903615
        },
        "divider": {
          "value": 8.398908132530122
        },
        "rotation": {
          "value": 2.103468561746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ecc",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 169.99143347682727
        },
        "ballSize": {
          "value": 7.6826047598597516
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 45.23564166333303
        },
        "yOuter": {
          "value": 0.8148220567818149
        },
        "xOuter": {
          "value": 0
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.13444751142019254
        },
        "yMultiplier": {
          "value": 2.553389377823796
        },
        "divider": {
          "value": 0.5201743803828596
        },
        "rotation": {
          "value": 2.665821305240494
        },
        "yDiv": {
          "value": 8.247158693980024
        },
        "yDiv2": {
          "value": 51.70744459772685
        },
        "xDiv": {
          "value": 24.251763842479296
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed0",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 4.641638929691454
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9c",
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv = abs(uv);\n  uv *=\n  uv *= k_rotate2d(stream / -1.);\n  for (float i = 2.; i < 4.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -.8);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(splitY * uv.y / div - stream / 2.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.3039443712349398
        },
        "iterator": {
          "value": 0.9804518072289157
        },
        "iterations": {
          "value": 14.394013554216869
        },
        "colorShift": {
          "value": 44.49821159638555
        },
        "colorOffset": {
          "value": 25.174204631024097
        },
        "contrast": {
          "value": 2.193425263554217
        },
        "orbSize": {
          "value": 36.37590361445784
        },
        "div": {
          "value": 4082.999342714609
        },
        "radius": {
          "value": 3.138704819277109
        },
        "wave": {
          "value": 152.38319371234942
        },
        "split": {
          "value": 336.14759036144585
        },
        "splitY": {
          "value": 2222
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea3",
    "shader": "void main () {\n  float stream =stream * 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -9.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.184
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec6",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.764354292168676
        },
        "ballSize": {
          "value": 30.02166792168675
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 48.605751129518076
        },
        "yOuter": {
          "value": 0.28322665662650603
        },
        "xOuter": {
          "value": 81.74359939759037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.788685993975904
        },
        "yMultiplier": {
          "value": 2.4412114081325305
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 4.2250564759036155
        },
        "yDiv": {
          "value": 4.170557228915664
        },
        "yDiv2": {
          "value": 8.153840361445786
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      },
      {
        "zoom": {
          "value": 27.986163403614462
        },
        "ballSize": {
          "value": 30.118298192771086
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 35.58805534638555
        },
        "yOuter": {
          "value": 1.2504471009036147
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.8991434487951809
        },
        "yMultiplier": {
          "value": 1.1380355798192774
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 4.2250564759036155
        },
        "yDiv": {
          "value": 4.170557228915664
        },
        "yDiv2": {
          "value": 8.153840361445786
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      },
      {
        "zoom": {
          "value": 27.986163403614462
        },
        "ballSize": {
          "value": 30.118298192771086
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 35.58805534638555
        },
        "yOuter": {
          "value": -0.4964937876506023
        },
        "xOuter": {
          "value": 100.0960090361446
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.373635165662651
        },
        "yMultiplier": {
          "value": 2.555668298192771
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0.5422628012048194
        },
        "yDiv": {
          "value": 23.19743034638555
        },
        "yDiv2": {
          "value": 20.34111445783133
        },
        "xDiv": {
          "value": 0.7005271084337351
        }
      },
      {
        "zoom": {
          "value": 33.30431099397591
        },
        "ballSize": {
          "value": 4.467959337349398
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 47.4550545933735
        },
        "yOuter": {
          "value": 6.027861445783134
        },
        "xOuter": {
          "value": 117.67243975903617
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.8636577560240974
        },
        "yMultiplier": {
          "value": 1.62468561746988
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 94.5881965361446
        },
        "yDiv2": {
          "value": 112
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ecb",
    "shader": "void main () {\n  float stream = time/1.2 + pow(stream, .85) * 12.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/300.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(1.5);// + stream/50.;\n    vec2 p = vec2(xOuter-volume*(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/4. -uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/-40. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .8)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 169.99143347682727
        },
        "ballSize": {
          "value": 5.722396960890437
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.713377987045845
        },
        "yOuter": {
          "value": 0.847429169804217
        },
        "xOuter": {
          "value": 12.030296049922347
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.3520320294851281
        },
        "yMultiplier": {
          "value": 3.2669278285015064
        },
        "divider": {
          "value": 0.41733546431168683
        },
        "rotation": {
          "value": 0.6490649947200915
        },
        "yDiv": {
          "value": 8.247158693980024
        },
        "yDiv2": {
          "value": 51.70744459772685
        },
        "xDiv": {
          "value": 24.251763842479296
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 162.2453896396132
        },
        "ballSize": {
          "value": 3.0370996314359004
        },
        "contrast": {
          "value": 1.1543580939970826
        },
        "radius": {
          "value": 150
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 34.43159944465362
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.7613210213902486
        },
        "divider": {
          "value": 1.523868119672102
        },
        "rotation": {
          "value": 1.8953206625329444
        },
        "yDiv": {
          "value": 10
        },
        "yDiv2": {
          "value": 32.300220608998494
        },
        "xDiv": {
          "value": 6.118289331642979
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 12.824288793357022
        },
        "ballSize": {
          "value": 13.057620459866813
        },
        "contrast": {
          "value": 5.0040220697242095
        },
        "radius": {
          "value": 24.45897849209338
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 37.8479404679264
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.484278667403992
        },
        "yMultiplier": {
          "value": 21.752694415356743
        },
        "divider": {
          "value": 0.1945240152716073
        },
        "rotation": {
          "value": 1.316509660468044
        },
        "yDiv": {
          "value": 3.2968676463667173
        },
        "yDiv2": {
          "value": 24.586253265013184
        },
        "xDiv": {
          "value": 1.3163675055446398
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e96",
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0009083207831325305
        },
        "iterator": {
          "value": 1.0063290662650601
        },
        "iterations": {
          "value": 11.885466867469882
        },
        "colorShift": {
          "value": 11
        },
        "colorOffset": {
          "value": 24.787478817442864
        },
        "contrast": {
          "value": 1.8087396460843377
        },
        "orbSize": {
          "value": 728.2701430722893
        },
        "div": {
          "value": 224.36903125000003
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 1333
        },
        "split": {
          "value": 5.037838855421688
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea0",
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.675150886158583
        },
        "iterator": {
          "value": 1.1274359939759038
        },
        "iterations": {
          "value": 7.958174887048194
        },
        "colorShift": {
          "value": 0.32937217619416226
        },
        "colorOffset": {
          "value": 15
        },
        "contrast": {
          "value": 0.831
        },
        "orbSize": {
          "value": 25.7765389683735
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 73.725
        },
        "wave": {
          "value": 197.5915568524097
        },
        "split": {
          "value": 6.847326807228917
        }
      },
      {
        "zoom": {
          "value": 1.93
        },
        "iterator": {
          "value": 1.079
        },
        "iterations": {
          "value": 15
        },
        "colorShift": {
          "value": 0.271
        },
        "colorOffset": {
          "value": 18.968
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 5.174
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 32.407
        },
        "wave": {
          "value": 0
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.034158509036144584
        },
        "iterator": {
          "value": 1.2030685240963856
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 11
        },
        "colorOffset": {
          "value": 24.787478817442864
        },
        "contrast": {
          "value": 1.5351986069277113
        },
        "orbSize": {
          "value": 251.05905026355427
        },
        "div": {
          "value": 77.85446338478917
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 1306.0802757906629
        },
        "split": {
          "value": 35.035561300634974
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ebc",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.1 + wow * sin(stream/.5 - length(uv)));\n\n  uv.x += sin(uv.y/fuck) * sin(uv.y+stream);\n\n  uv += shit*sin(stream/1.1 - dot(uv, uv)/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * tan(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, pink * color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.453303840361446
        },
        "contrast": {
          "value": 1.1512989457831329
        },
        "orbSize": {
          "value": 0.40576995481927713
        },
        "radius": {
          "value": 4.253859186746989
        },
        "colorShift": {
          "value": 3.487217620481928
        },
        "pink": {
          "value": [0.8, 0.2, 0.6]
        },
        "fuck": {
          "value": 0.2044615963855422
        },
        "shit": {
          "value": 4.951073042168675
        },
        "wow": {
          "value": 0.5113140060240964
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9e",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.22349
        },
        "iterator": {
          "value": 3.08602
        },
        "iterations": {
          "value": 27.10833
        },
        "colorShift": {
          "value": 4.91799
        },
        "colorOffset": {
          "value": 1
        },
        "contrast": {
          "value": 1.3316
        },
        "orbSize": {
          "value": 2109.05161
        },
        "div": {
          "value": 778.14317
        },
        "radius": {
          "value": 185.26612
        },
        "wave": {
          "value": 7442.65944
        },
        "split": {
          "value": 16.47992
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ea4",
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 0.6);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6465079066265061
        },
        "iterator": {
          "value": 1.3677409638554219
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 1.5186370481927711
        },
        "colorOffset": {
          "value": 18.31640625
        },
        "contrast": {
          "value": 1.1740634412650603
        },
        "orbSize": {
          "value": 0.5971385542168676
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.226694277108434
        },
        "wave": {
          "value": 0.6340361445783134
        },
        "split": {
          "value": 15.149849397590366
        }
      },
      {
        "zoom": {
          "value": 1.8872270331325305
        },
        "iterator": {
          "value": 1.2201590737951808
        },
        "iterations": {
          "value": 23.672467996987955
        },
        "colorShift": {
          "value": 0.5885212725903615
        },
        "colorOffset": {
          "value": 20.50647119728916
        },
        "contrast": {
          "value": 1.3051157756024097
        },
        "orbSize": {
          "value": 1
        },
        "div": {
          "value": 5.05099421121988
        },
        "radius": {
          "value": 3.707699548192772
        },
        "wave": {
          "value": 1.2741905120481931
        },
        "split": {
          "value": 2.777334337349398
        }
      },
      {
        "zoom": {
          "value": 0.9513930722891566
        },
        "iterator": {
          "value": 1.823339137801205
        },
        "iterations": {
          "value": 27.0210796310241
        },
        "colorShift": {
          "value": 0
        },
        "colorOffset": {
          "value": 26.667286332831328
        },
        "contrast": {
          "value": 1.1627470948138394
        },
        "orbSize": {
          "value": 0.3594597138554217
        },
        "div": {
          "value": 5.113429028614458
        },
        "radius": {
          "value": 4.177099021084338
        },
        "wave": {
          "value": 0.7246799698795182
        },
        "split": {
          "value": 4.043100527108434
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb6",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.39
        },
        "yDivider": {
          "value": 9.62
        },
        "xDivider": {
          "value": 4.19
        },
        "multiplier": {
          "value": 4079.47
        },
        "ballSize": {
          "value": 1.43
        },
        "contrast": {
          "value": 0.98
        },
        "radius": {
          "value": 6.55
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.11
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 1.23
        },
        "d": {
          "value": 2.08
        },
        "e": {
          "value": 0.65
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e9f",
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034158509036144584
        },
        "iterator": {
          "value": 1.2030685240963856
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 11
        },
        "colorOffset": {
          "value": 24.787478817442864
        },
        "contrast": {
          "value": 1.5351986069277113
        },
        "orbSize": {
          "value": 251.05905026355427
        },
        "div": {
          "value": 77.85446338478917
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 1306.0802757906629
        },
        "split": {
          "value": 35.035561300634974
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eb7",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.39
        },
        "yDivider": {
          "value": 9.62
        },
        "xDivider": {
          "value": 4.19
        },
        "multiplier": {
          "value": 4079.47
        },
        "ballSize": {
          "value": 1.43
        },
        "contrast": {
          "value": 0.98
        },
        "radius": {
          "value": 6.55
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.11
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 1.23
        },
        "d": {
          "value": 2.08
        },
        "e": {
          "value": 0.65
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 7.58
        },
        "yDivider": {
          "value": 1.3
        },
        "xDivider": {
          "value": 5.09
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 1.06
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 3.19
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.06
        },
        "b": {
          "value": 0.06
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ebf",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /4.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*abs(cos(stream - uv.x/20. + sin(stream + uv.y/.52)));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.25+t+yMultiplier+1.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.756140619300935
        },
        "ballSize": {
          "value": 4.494423004518073
        },
        "contrast": {
          "value": 2.723491561226182
        },
        "radius": {
          "value": 34
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 202.30496987951813
        },
        "xMultiplier": {
          "value": 11.466961596385545
        },
        "yMultiplier": {
          "value": 3.805111069277109
        },
        "divider": {
          "value": 8.398908132530122
        },
        "rotation": {
          "value": 2.103468561746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eca",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * (.6 + .3 * sin(uv.y/yDiv-stream/1.4))), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 169.99143347682727
        },
        "ballSize": {
          "value": 5.722396960890437
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.713377987045845
        },
        "yOuter": {
          "value": 0.847429169804217
        },
        "xOuter": {
          "value": 12.030296049922347
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.3520320294851281
        },
        "yMultiplier": {
          "value": 3.2669278285015064
        },
        "divider": {
          "value": 0.41733546431168683
        },
        "rotation": {
          "value": 0.6490649947200915
        },
        "yDiv": {
          "value": 8.247158693980024
        },
        "yDiv2": {
          "value": 51.70744459772685
        },
        "xDiv": {
          "value": 24.251763842479296
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ecf",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .25)/2.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 7.336954066265062
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9e94",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00353
        },
        "shapeMultiplier": {
          "value": 2714.93266
        },
        "rotation": {
          "value": 30.1
        },
        "xMultiplier": {
          "value": 1246.07946
        },
        "yMultiplier": {
          "value": 256.11565
        },
        "colorSpread": {
          "value": 0.00011
        },
        "colorMultiplier": {
          "value": 7.27113
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 9.26335
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5.40886
        },
        "radius": {
          "value": 8.12585
        },
        "col": {
          "value": 2.15358
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eac",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i - iterations, colorShift, sin(length(uv/1.1)/1.1-stream/.015));\n    float a = radius * cos(uv.x * div);\n    float b = radius * cos(uv.y * div);\n    float c = wave * sin(split * uv.x - stream);\n    float d = wave * cos(split * uv.y  - stream);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9360504518072297
        },
        "iterator": {
          "value": 1.1357097138554217
        },
        "iterations": {
          "value": 0.21614975527108435
        },
        "colorShift": {
          "value": 0.1667756965361446
        },
        "colorOffset": {
          "value": 24.866057981927714
        },
        "contrast": {
          "value": 1.1175592996987953
        },
        "orbSize": {
          "value": 0.7946489081325303
        },
        "div": {
          "value": 3.0465191076807234
        },
        "radius": {
          "value": 6
        },
        "wave": {
          "value": 14.466961596385545
        },
        "split": {
          "value": 3.4255929969879526
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eaf",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.418
        },
        "iterator": {
          "value": 1.014
        },
        "iterations": {
          "value": 18
        },
        "colorShift": {
          "value": 0.266
        },
        "colorOffset": {
          "value": 25.265
        },
        "contrast": {
          "value": 0.831
        },
        "orbSize": {
          "value": 10.426
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 73.725
        },
        "wave": {
          "value": 1222
        },
        "split": {
          "value": 5.288
        }
      },
      {
        "zoom": {
          "value": 1.93
        },
        "iterator": {
          "value": 1.079
        },
        "iterations": {
          "value": 15
        },
        "colorShift": {
          "value": 0.271
        },
        "colorOffset": {
          "value": 18.968
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 5.174
        },
        "div": {
          "value": 4.782
        },
        "radius": {
          "value": 32.407
        },
        "wave": {
          "value": 0
        },
        "split": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 8.452
        },
        "iterator": {
          "value": 0.978
        },
        "iterations": {
          "value": 13
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 17.673
        },
        "contrast": {
          "value": 1.146
        },
        "orbSize": {
          "value": 26.704
        },
        "div": {
          "value": 3.174
        },
        "radius": {
          "value": 79.158
        },
        "wave": {
          "value": 865.131
        },
        "split": {
          "value": 17.958
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ebd",
    "shader": "#define orbs 15.\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.1 + wow * sin(stream/.5 - length(uv)));\n\n  uv.x += sin(uv.y/fuck) * sin(uv.y+stream);\n\n  uv += shit*sin(stream/1.1 - dot(uv, uv)/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * tan(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, pink * color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.453303840361446
        },
        "contrast": {
          "value": 1.1512989457831329
        },
        "orbSize": {
          "value": 0.40576995481927713
        },
        "radius": {
          "value": 4.253859186746989
        },
        "colorShift": {
          "value": 3.487217620481928
        },
        "pink": {
          "value": [0.8, 0.2, 0.6]
        },
        "fuck": {
          "value": 0.2044615963855422
        },
        "shit": {
          "value": 4.951073042168675
        },
        "wow": {
          "value": 0.5113140060240964
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec7",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/2.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/5. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eda",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.2-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 98.6929431593562
        },
        "ballSize": {
          "value": 5.52510052416698
        },
        "contrast": {
          "value": 1.6600951465185185
        },
        "radius": {
          "value": 57.937847734933875
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.11999418879129803
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 38.26181390601469
        },
        "xDiv": {
          "value": 3.6583544995411335
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0f",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n   uv *= k_rotate2d(-stream/4.);\n\n uv = k_kale(uv, vec2(0.),sides);\n   uv *= k_rotate2d(stream/10.);\n\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  // uv *= k_rotate2d(rotation*stream/9.);\n  for (float i = 0.; i < 22.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-1.16);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/-2.9);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n    \n  }\n  gl_FragColor = k_hue(gl_FragColor, colorShift);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.10960007674990807
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.5761122458584342
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 11.727513177710845
        },
        "sides": {
          "value": 6
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0.65417921686747
        },
        "cosMul": {
          "value": 1.8823653990963858
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 2.2388271837349403
        },
        "xDivide": {
          "value": 3.883353727409639
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f15",
    "shader": "#define orbs 20.\n\nvoid main( ) {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0.);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul ) + cos(uv.y / yDivide - stream);\n    uv.y += cosMul * cos(uv.x * xMul) - sin(uv.x / xDivide - stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12831795933734944
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "contrast": {
          "value": 0.18341490963855425
        },
        "orbSize": {
          "value": 16.973806918435542
        },
        "radius": {
          "value": 10.246100840333934
        },
        "colorShift": {
          "value": 10.699804770356076
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.6060240963855428
        },
        "yMul": {
          "value": 0.07099962349397591
        },
        "xMul": {
          "value": 0.2037697665662651
        },
        "yDivide": {
          "value": 4.311429036179833
        },
        "xDivide": {
          "value": 4.846658260793775
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed8",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 2.2154850143984146
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 15.88807067411492
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 28.503943468576463
        },
        "xMultiplier": {
          "value": 20.76713074833514
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 32.78597406594151
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef2",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.1)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 0.6764400987740024
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 3.485498175563583
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 10.29427609730916
        },
        "xMultiplier": {
          "value": 64.29451646000507
        },
        "yMultiplier": {
          "value": 362.13499121608504
        },
        "divider": {
          "value": 9.619286778461504
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 23
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.13272710593349965
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 2.0719639743667058
        },
        "ballSize": {
          "value": 25.215378190691247
        },
        "contrast": {
          "value": 3.3798278900514176
        },
        "radius": {
          "value": 0.14887378187064668
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.194977266242707
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 34.414792348103354
        },
        "rotation": {
          "value": 4.1073160746011395
        },
        "xDiv": {
          "value": 0.9732506074101094
        },
        "yDiv": {
          "value": 1.2935981474727036
        },
        "yDiv2": {
          "value": 0.5701666958360787
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9efd",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream/1.5 + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.t/2.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.756140619300935
        },
        "ballSize": {
          "value": 45.40572738647462
        },
        "contrast": {
          "value": 2.723491561226182
        },
        "radius": {
          "value": 34
        },
        "yOuter": {
          "value": 1.814596318624106
        },
        "xOuter": {
          "value": 109.75608219008849
        },
        "xMultiplier": {
          "value": 11.466961596385545
        },
        "yMultiplier": {
          "value": 3.877400225903615
        },
        "divider": {
          "value": 8.398908132530122
        },
        "rotation": {
          "value": 2.103468561746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed9",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 2.2154850143984146
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9edc",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 36.246470256024104
        },
        "ballSize": {
          "value": 20
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 0.015615116716867473
        },
        "xOuter": {
          "value": 97.3038403614458
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22948042168674704
        },
        "yMultiplier": {
          "value": 0.3789241340361446
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 9.248164533132531
        },
        "ballSize": {
          "value": 9.403896837349398
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 7.808028990963857
        },
        "yOuter": {
          "value": 0.009356880647590363
        },
        "xOuter": {
          "value": 5.24698795180723
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1
        },
        "yMultiplier": {
          "value": 0.2
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 13.802240210843376
        },
        "ballSize": {
          "value": 20
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 0.015615116716867473
        },
        "xOuter": {
          "value": 97.3038403614458
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22948042168674704
        },
        "yMultiplier": {
          "value": 0.3789241340361446
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 6.220169976592644
        },
        "ballSize": {
          "value": 8.297458584337349
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.2287650602409639
        },
        "xOuter": {
          "value": 1.3874246987951813
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.0312500000000004
        },
        "yMultiplier": {
          "value": 0.9511238704819278
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 1.7532473644578315
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eef",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 24.188629518072297
        },
        "ballSize": {
          "value": 32.67104668674699
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 232.6218938253012
        },
        "yOuter": {
          "value": 0.0010238610692771088
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0.49793862951807233
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9efe",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation + stream/4./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.y/20.+ cos(stream-uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 33.) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.9950065888554223
        },
        "ballSize": {
          "value": 11.836751694277112
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 11.370670180722895
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 3.485498175563583
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 10.29427609730916
        },
        "xMultiplier": {
          "value": 64.29451646000507
        },
        "yMultiplier": {
          "value": 362.13499121608504
        },
        "divider": {
          "value": 9.619286778461504
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 23
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.13272710593349965
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 2.0719639743667058
        },
        "ballSize": {
          "value": 25.215378190691247
        },
        "contrast": {
          "value": 3.3798278900514176
        },
        "radius": {
          "value": 0.14887378187064668
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.194977266242707
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 34.414792348103354
        },
        "rotation": {
          "value": 4.1073160746011395
        },
        "xDiv": {
          "value": 0.9732506074101094
        },
        "yDiv": {
          "value": 1.2935981474727036
        },
        "yDiv2": {
          "value": 0.5701666958360787
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef6",
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/1.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 68.17255271084338
        },
        "ballSize": {
          "value": 8.56362951807229
        },
        "contrast": {
          "value": 2.8231598268072293
        },
        "radius": {
          "value": 59.41100338855423
        },
        "yOuter": {
          "value": 2.0321912650602414
        },
        "xOuter": {
          "value": 72.87236445783132
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 152.81835937500003
        },
        "yMultiplier": {
          "value": 4.17531061746988
        },
        "divider": {
          "value": 56.23923374162738
        },
        "rotation": {
          "value": 3.958419615963856
        },
        "xDiv": {
          "value": 256.81297063253015
        },
        "yDiv": {
          "value": 2.611314006024097
        },
        "yDiv2": {
          "value": 21.816556852409644
        },
        "xDiv3": {
          "value": 200.19099209337355
        },
        "div": {
          "value": 103.22031250000002
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f06",
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 13.209459713855425
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 17.647628012048195
        },
        "ballSize": {
          "value": 43.71983245481929
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 55.744658320783145
        },
        "yOuter": {
          "value": 16.551152945464164
        },
        "xOuter": {
          "value": 103.83358433734941
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.2462820030120487
        },
        "yMultiplier": {
          "value": 9.4296875
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.5707963268
        }
      },
      {
        "zoom": {
          "value": 16.598362198795183
        },
        "ballSize": {
          "value": 42.25292733433736
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 325
        },
        "yOuter": {
          "value": 7.271743222891567
        },
        "xOuter": {
          "value": 59.877259036144586
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.10918674698795185
        },
        "yMultiplier": {
          "value": 0.18924134036144583
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 0.3854715737951808
        }
      },
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 17.53494917168675
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 31.667921686746997
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.739410768072291
        },
        "yMultiplier": {
          "value": 2.6839231927710845
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 0.7260918674698796
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0a",
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter*(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/1.)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 0.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 12.551233057228918
        },
        "contrast": {
          "value": 2.571983245481928
        },
        "radius": {
          "value": 7.949101091867472
        },
        "yOuter": {
          "value": 7.7498117469879535
        },
        "xOuter": {
          "value": 2.282073606927711
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4946347891566266
        },
        "yMultiplier": {
          "value": 1.9728915662650606
        },
        "divider": {
          "value": 3.5445124246987953
        },
        "rotation": {
          "value": 1.1198336314006025
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9efa",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 2.2154850143984146
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 15.88807067411492
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 28.503943468576463
        },
        "xMultiplier": {
          "value": 20.76713074833514
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 32.78597406594151
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 23
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.13272710593349965
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 2.0719639743667058
        },
        "ballSize": {
          "value": 25.215378190691247
        },
        "contrast": {
          "value": 3.3798278900514176
        },
        "radius": {
          "value": 0.14887378187064668
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.194977266242707
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 34.414792348103354
        },
        "rotation": {
          "value": 4.1073160746011395
        },
        "xDiv": {
          "value": 0.9732506074101094
        },
        "yDiv": {
          "value": 1.2935981474727036
        },
        "yDiv2": {
          "value": 0.5701666958360787
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee6",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.138648343373497
        },
        "ballSize": {
          "value": 15.823861069277111
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.82177146084338
        },
        "yOuter": {
          "value": 0.468655873493976
        },
        "xOuter": {
          "value": 20.044804216867476
        },
        "xMultiplier": {
          "value": 1.9600432981927716
        },
        "yMultiplier": {
          "value": 0.863190888554217
        },
        "divider": {
          "value": 1.0117187500000002
        },
        "rotation": {
          "value": 2.331681951304134
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec1",
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/12.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/100.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 4.089656526496611
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 76.04349848735765
        },
        "ballSize": {
          "value": 7
        },
        "contrast": {
          "value": 1.6782306648162477
        },
        "radius": {
          "value": 46.73833272543298
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 121.90263440235556
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4497109654438065
        },
        "yMultiplier": {
          "value": 0.9904435643541671
        },
        "divider": {
          "value": 0.4888161349009319
        },
        "rotation": {
          "value": 5
        },
        "yDiv": {
          "value": 5.318059162921217
        },
        "yDiv2": {
          "value": 66.56326227762614
        },
        "xDiv": {
          "value": 5.000529057146556
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 2.512914450771838
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 31.12488712172911
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 35.98427204913405
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5644670969032382
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee9",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0.23066641566265064
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef3",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f03",
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/6. + sin(uv.y/50. + stream/10.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .4)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 17.22788027108434
        },
        "ballSize": {
          "value": 14.472628012048197
        },
        "contrast": {
          "value": 2.1693806475903616
        },
        "radius": {
          "value": 32.883918486445786
        },
        "yOuter": {
          "value": 0.04762330572289158
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5703595632530123
        },
        "yMultiplier": {
          "value": 0.352456701807229
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 17.22788027108434
        },
        "ballSize": {
          "value": 29.301534262048197
        },
        "contrast": {
          "value": 3.1542931904625604
        },
        "radius": {
          "value": 53.459502070783145
        },
        "yOuter": {
          "value": 0.05249435240963857
        },
        "xOuter": {
          "value": 15.192394578313257
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 8.853774472891567
        },
        "yMultiplier": {
          "value": 2.4906344126506026
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 6.410937500000001
        },
        "ballSize": {
          "value": 14.472628012048197
        },
        "contrast": {
          "value": 2.1693806475903616
        },
        "radius": {
          "value": 32.883918486445786
        },
        "yOuter": {
          "value": 0.04762330572289158
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5703595632530123
        },
        "yMultiplier": {
          "value": 0.352456701807229
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 7.577793427373488
        },
        "ballSize": {
          "value": 58.52993222891567
        },
        "contrast": {
          "value": 2.1693806475903616
        },
        "radius": {
          "value": 146.9326359518514
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.080148719879518
        },
        "yMultiplier": {
          "value": 1.4089796686746991
        },
        "divider": {
          "value": 35.120011295180724
        },
        "rotation": {
          "value": 1.7179499246987953
        }
      },
      {
        "zoom": {
          "value": 3.7691359186746993
        },
        "ballSize": {
          "value": 2.939090737951808
        },
        "contrast": {
          "value": 2.613069465361446
        },
        "radius": {
          "value": 6.540380271084339
        },
        "yOuter": {
          "value": 1.0349397590361447
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0.699077560240964
        },
        "divider": {
          "value": 35.07200677710844
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 6.12082078313253
        },
        "ballSize": {
          "value": 6
        },
        "contrast": {
          "value": 4.603421498493976
        },
        "radius": {
          "value": 2.5390625000000013
        },
        "yOuter": {
          "value": 1.9721573795180727
        },
        "xOuter": {
          "value": 15.500753012048198
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.380835843373494
        },
        "yMultiplier": {
          "value": 1.0129423945783136
        },
        "divider": {
          "value": 1.1751694277108438
        },
        "rotation": {
          "value": 0.7095726656626506
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0e",
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.07584582078313254
        },
        "contrast": {
          "value": 0.20117573418674703
        },
        "orbSize": {
          "value": 7.28865606174699
        },
        "radius": {
          "value": 10.575385918674701
        },
        "colorShift": {
          "value": 5.054118975903616
        },
        "sides": {
          "value": 0.7601185993975904
        },
        "rotation": {
          "value": 1.2313253012048195
        },
        "sinMul": {
          "value": 0.6959807981927711
        },
        "cosMul": {
          "value": 6.535983810240964
        },
        "yMul": {
          "value": 0.3850009412650603
        },
        "xMul": {
          "value": 0.4664166039156627
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0022381682981927713
        },
        "yDivide": {
          "value": 3.05937311746988
        },
        "xDivide": {
          "value": 3.200705948795181
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f12",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream /8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 12.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 12.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.137
        },
        "orbSize": {
          "value": 7.11
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9edd",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n\n  float i = 1.;\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 36.246470256024104
        },
        "ballSize": {
          "value": 20
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 0.015615116716867473
        },
        "xOuter": {
          "value": 97.3038403614458
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22948042168674704
        },
        "yMultiplier": {
          "value": 0.3789241340361446
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 9.248164533132531
        },
        "ballSize": {
          "value": 9.403896837349398
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 7.808028990963857
        },
        "yOuter": {
          "value": 0.009356880647590363
        },
        "xOuter": {
          "value": 5.24698795180723
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1
        },
        "yMultiplier": {
          "value": 0.2
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 13.802240210843376
        },
        "ballSize": {
          "value": 20
        },
        "contrast": {
          "value": 1.9728445030120483
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 0.015615116716867473
        },
        "xOuter": {
          "value": 97.3038403614458
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22948042168674704
        },
        "yMultiplier": {
          "value": 0.3789241340361446
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.258400790662651
        }
      },
      {
        "zoom": {
          "value": 17.042545180722893
        },
        "ballSize": {
          "value": 52.903049698795186
        },
        "contrast": {
          "value": 2.3970491340361453
        },
        "radius": {
          "value": 5.784779743975905
        },
        "yOuter": {
          "value": 0.7183546686746989
        },
        "xOuter": {
          "value": 18.679216867469883
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4366057981927712
        },
        "yMultiplier": {
          "value": 1.3538874246987953
        },
        "divider": {
          "value": 6.722232680722893
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9edf",
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;\n    float a = cos(xMultiplier*uv.x - stream);\n    float b = uv.x/yMultiplier;\n    float c = PI+radius*cos(t-stream/-5.);\n    float d = yMultiplier*cos(stream/9. -uv.x* sin(uv.y/4.-stream/.6));\n    float x = xOuter - a - b *c * d;\n    float y = cos(stream/3. - .91 * yOuter*  uv.x / xDiv +t+yMultiplier+1.);\n    vec2 p = vec2(radius2  *x, radius * y);\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 22
        },
        "ballSize": {
          "value": 222
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 230.54075677710847
        },
        "yOuter": {
          "value": 22.523060993975907
        },
        "xOuter": {
          "value": 125.5440512048193
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 20.496987951807235
        },
        "rotation": {
          "value": 1.8675404743975905
        },
        "radius2": {
          "value": 1.6828878012048196
        },
        "xDiv": {
          "value": 19.27454819277109
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eec",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 6.476543674698796
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 31.092338102409645
        },
        "yOuter": {
          "value": 0.0005304028614457833
        },
        "xOuter": {
          "value": 130.72176204819277
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.1696630271084338
        },
        "yMultiplier": {
          "value": 1.1726844879518075
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 13.757765436746988
        },
        "ballSize": {
          "value": 6.476543674698796
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 10.042356927710845
        },
        "yOuter": {
          "value": 0.011533635853503293
        },
        "xOuter": {
          "value": 18.25225903614458
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.8655402861445785
        },
        "yMultiplier": {
          "value": 2
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f07",
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 13.209459713855425
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 7.1110692771084345
        },
        "ballSize": {
          "value": 68.75438629518074
        },
        "contrast": {
          "value": 2.900848972223537
        },
        "radius": {
          "value": 97.87321159638554
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 77.33847891566266
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 2.3576336596385543
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      },
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 24.060796310240967
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 52.09666792168676
        },
        "xOuter": {
          "value": 20.664909638554224
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.739410768072291
        },
        "yMultiplier": {
          "value": 6.721667921686748
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 30.776807228915672
        },
        "ballSize": {
          "value": 24.154828689759043
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 55.744658320783145
        },
        "yOuter": {
          "value": 16.551152945464164
        },
        "xOuter": {
          "value": 103.83358433734941
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.338855421686747
        },
        "yMultiplier": {
          "value": 0.8790945030120484
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.5707963268
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f13",
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09821507906626509
        },
        "contrast": {
          "value": 0.183140436746988
        },
        "orbSize": {
          "value": 12.909258659638557
        },
        "radius": {
          "value": 19.90608856669016
        },
        "colorShift": {
          "value": 8.129428463855422
        },
        "sides": {
          "value": 0.7601185993975904
        },
        "rotation": {
          "value": 0.33273719879518077
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.505228915662651
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0020074077560240967
        },
        "yDivide": {
          "value": 2.2532360692771087
        },
        "xDivide": {
          "value": 0.8332261859939759
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eea",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0.23066641566265064
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f02",
    "shader": "void main () {\n  float stream = stream  /1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation + stream/10.);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.0384615384615383
        },
        "ballSize": {
          "value": 31.316961596385546
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 36.36363636363637
        },
        "yOuter": {
          "value": 0.4300699300699301
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 2.56331890060241
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 7.1110692771084345
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 77.33847891566266
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.5005647590361446
        },
        "yMultiplier": {
          "value": 0.19545368975903618
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      },
      {
        "zoom": {
          "value": 4.713723644578314
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.2896743222891573
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0.11183640813253015
        },
        "xOuter": {
          "value": 33.473644578313255
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.087255271084339
        },
        "yMultiplier": {
          "value": 0.19545368975903618
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0b",
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 20.337114081325307
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 7.1110692771084345
        },
        "ballSize": {
          "value": 68.75438629518074
        },
        "contrast": {
          "value": 2.900848972223537
        },
        "radius": {
          "value": 97.87321159638554
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 77.33847891566266
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 2.3576336596385543
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      },
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 24.060796310240967
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 52.09666792168676
        },
        "xOuter": {
          "value": 20.664909638554224
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.739410768072291
        },
        "yMultiplier": {
          "value": 6.721667921686748
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee0",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 16.946536144578314
        },
        "ballSize": {
          "value": 4.591603915662651
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 129.8467741759196
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 56.4175451807229
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.665333207831327
        },
        "yMultiplier": {
          "value": 1.1659497364457834
        },
        "divider": {
          "value": 1924.404183923193
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eee",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d((i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.832638704121344
        },
        "ballSize": {
          "value": 4.407340158987528
        },
        "contrast": {
          "value": 5.053075235628817
        },
        "radius": {
          "value": 11.050260000214896
        },
        "yOuter": {
          "value": 0.04999356892232551
        },
        "xOuter": {
          "value": 6.847317946075236
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.19113066136076556
        },
        "yMultiplier": {
          "value": 1.3790737271967741
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.6071400877272546
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 34.833866716867476
        },
        "ballSize": {
          "value": 4.406927710843373
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 11.047628012048195
        },
        "yOuter": {
          "value": 0.05
        },
        "xOuter": {
          "value": 6.846385542168676
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.19093561746987955
        },
        "yMultiplier": {
          "value": 1.3790982680722894
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ec9",
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d((.2*stream/(i+1.))+rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(1);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream/.1-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.15)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 4.089656526496611
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 1350
        },
        "ballSize": {
          "value": 88
        },
        "contrast": {
          "value": 3.3665371630565235
        },
        "radius": {
          "value": 896.0313424719387
        },
        "yOuter": {
          "value": 4
        },
        "xOuter": {
          "value": 184.70476633094881
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1
        },
        "yMultiplier": {
          "value": 1.3178916471550266
        },
        "divider": {
          "value": 1.4259570386036335
        },
        "rotation": {
          "value": 3.8320608483739655
        },
        "yDiv": {
          "value": 16.398728290236143
        },
        "yDiv2": {
          "value": 68.05689506071161
        },
        "xDiv": {
          "value": 212
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 2.512914450771838
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 31.12488712172911
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 35.98427204913405
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.5644670969032382
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef1",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 169.99143347682727
        },
        "ballSize": {
          "value": 7.6826047598597516
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 45.23564166333303
        },
        "yOuter": {
          "value": 0.8148220567818149
        },
        "xOuter": {
          "value": 0
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.13444751142019254
        },
        "yMultiplier": {
          "value": 2.553389377823796
        },
        "divider": {
          "value": 0.5201743803828596
        },
        "rotation": {
          "value": 2.665821305240494
        },
        "yDiv": {
          "value": 8.247158693980024
        },
        "yDiv2": {
          "value": 51.70744459772685
        },
        "xDiv": {
          "value": 24.251763842479296
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 18.764354292168676
        },
        "ballSize": {
          "value": 30.02166792168675
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 48.605751129518076
        },
        "yOuter": {
          "value": 0.28322665662650603
        },
        "xOuter": {
          "value": 81.74359939759037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.788685993975904
        },
        "yMultiplier": {
          "value": 2.4412114081325305
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 4.2250564759036155
        },
        "yDiv": {
          "value": 4.170557228915664
        },
        "yDiv2": {
          "value": 8.153840361445786
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9efc",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 2.2154850143984146
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 3.485498175563583
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 10.29427609730916
        },
        "xMultiplier": {
          "value": 64.29451646000507
        },
        "yMultiplier": {
          "value": 362.13499121608504
        },
        "divider": {
          "value": 9.619286778461504
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 23
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.13272710593349965
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      },
      {
        "zoom": {
          "value": 2.0719639743667058
        },
        "ballSize": {
          "value": 25.215378190691247
        },
        "contrast": {
          "value": 3.3798278900514176
        },
        "radius": {
          "value": 0.14887378187064668
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.194977266242707
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 34.414792348103354
        },
        "rotation": {
          "value": 4.1073160746011395
        },
        "xDiv": {
          "value": 0.9732506074101094
        },
        "yDiv": {
          "value": 1.2935981474727036
        },
        "yDiv2": {
          "value": 0.5701666958360787
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0d",
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09821507906626509
        },
        "contrast": {
          "value": 0.183140436746988
        },
        "orbSize": {
          "value": 4.850500941265062
        },
        "radius": {
          "value": 10.575385918674701
        },
        "colorShift": {
          "value": 6.237557981927711
        },
        "sides": {
          "value": 0.7601185993975904
        },
        "rotation": {
          "value": 0.8464984939759037
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.7214832454819278
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.3449747740963856
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0020074077560240967
        },
        "yDivide": {
          "value": 2.2532360692771087
        },
        "xDivide": {
          "value": 0.8332261859939759
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f14",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08638846009036147
        },
        "contrast": {
          "value": 0.11821997364457834
        },
        "orbSize": {
          "value": 3.960884789156627
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.38
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.28
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.99
        },
        "xDivide": {
          "value": 6.27
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.033166980421686754
        },
        "contrast": {
          "value": 0.12439815512048197
        },
        "orbSize": {
          "value": 9.584353162650604
        },
        "radius": {
          "value": 22
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.8233670933734941
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.4288580572289158
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 0.7236063629518074
        },
        "xDivide": {
          "value": 8.498375941265062
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.008450865963855424
        },
        "contrast": {
          "value": 0.12439815512048197
        },
        "orbSize": {
          "value": 85.2886669804217
        },
        "radius": {
          "value": 360.3195406626507
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.8233670933734941
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.02921762048192772
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 8.053467338102411
        },
        "xDivide": {
          "value": 12.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9edb",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.2-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 7.336954066265062
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.071959713855422
        },
        "yMultiplier": {
          "value": 1.3968373493975907
        },
        "divider": {
          "value": 0.4658226656626506
        },
        "rotation": {
          "value": 2.081160579819277
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 98.6929431593562
        },
        "ballSize": {
          "value": 5.52510052416698
        },
        "contrast": {
          "value": 1.6600951465185185
        },
        "radius": {
          "value": 57.937847734933875
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.11999418879129803
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 38.26181390601469
        },
        "xDiv": {
          "value": 3.6583544995411335
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee5",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.138648343373497
        },
        "ballSize": {
          "value": 15.823861069277111
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.82177146084338
        },
        "yOuter": {
          "value": 0.468655873493976
        },
        "xOuter": {
          "value": 20.044804216867476
        },
        "xMultiplier": {
          "value": 1.9600432981927716
        },
        "yMultiplier": {
          "value": 0.863190888554217
        },
        "divider": {
          "value": 1.0117187500000002
        },
        "rotation": {
          "value": 2.331681951304134
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9efb",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.9559209203841617
        },
        "ballSize": {
          "value": 2.2154850143984146
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.03184048756059395
        },
        "yOuter": {
          "value": 0.017453195273158067
        },
        "xOuter": {
          "value": 7.812164580103863
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 573.5728769738992
        },
        "divider": {
          "value": 18.25563063104469
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.4550589320171311
        },
        "yDiv": {
          "value": 0.23577797211796409
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 12.515899603050876
        },
        "ballSize": {
          "value": 15.88807067411492
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.02487082883536098
        },
        "yOuter": {
          "value": 0.03216003555849375
        },
        "xOuter": {
          "value": 28.503943468576463
        },
        "xMultiplier": {
          "value": 20.76713074833514
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 32.78597406594151
        },
        "rotation": {
          "value": 1.3997481932123024
        },
        "xDiv": {
          "value": 0.1232371870293675
        },
        "yDiv": {
          "value": 1.3197303588131826
        },
        "yDiv2": {
          "value": 0.39814647077077847
        },
        "uvDiv": {
          "value": 11.854713007915453
        }
      },
      {
        "zoom": {
          "value": 3.3430857371134937
        },
        "ballSize": {
          "value": 6.370043228333255
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 0.010405317559299703
        },
        "yOuter": {
          "value": 0.046984939575195325
        },
        "xOuter": {
          "value": 6.67446219662586
        },
        "xMultiplier": {
          "value": 53.282295291852456
        },
        "yMultiplier": {
          "value": 1330
        },
        "divider": {
          "value": 30.613560044621853
        },
        "rotation": {
          "value": 1.9098261178257956
        },
        "xDiv": {
          "value": 0.7193660230521697
        },
        "yDiv": {
          "value": 0.7171324120946678
        },
        "yDiv2": {
          "value": 0.3574060830725245
        },
        "uvDiv": {
          "value": 5.76971131290298
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f00",
    "shader": "#define BALLS 5\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/111.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/5.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.  / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.185560993975907
        },
        "ballSize": {
          "value": 25.938309487951813
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0.29838102409638584
        },
        "xOuter": {
          "value": 7.768072289156628
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0.1593
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f01",
    "shader": "void main () {\n  float stream = stream  /1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.556758283132533
        },
        "ballSize": {
          "value": 31.316961596385546
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 2.56331890060241
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      },
      {
        "zoom": {
          "value": 7.1110692771084345
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 1.7615540286144582
        },
        "xOuter": {
          "value": 77.33847891566266
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.5005647590361446
        },
        "yMultiplier": {
          "value": 0.19545368975903618
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      },
      {
        "zoom": {
          "value": 4.713723644578314
        },
        "ballSize": {
          "value": 34.510928087349406
        },
        "contrast": {
          "value": 2.2896743222891573
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0.11183640813253015
        },
        "xOuter": {
          "value": 33.473644578313255
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.087255271084339
        },
        "yMultiplier": {
          "value": 0.19545368975903618
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 3.675263554216868
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ede",
    "shader": "void main () {\n  float stream = stream / 10.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/yDiv2-stream/1.6)), radius*\n                  cos(stream/11. - yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv-stream/1.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 19.60866905120482
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 40.1065982680723
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.5201901355421688
        },
        "yMultiplier": {
          "value": 1.6588827183734942
        },
        "divider": {
          "value": 2.30464984939759
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 3.276618975903615
        },
        "yDiv2": {
          "value": 16.096686746987956
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee1",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/120.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(100.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - .1*yOuter*uv.x/.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 22.012424698795183
        },
        "ballSize": {
          "value": 4.484186746987952
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 36.5726185993976
        },
        "yOuter": {
          "value": 0.01675381212349398
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4025790662650603
        },
        "yMultiplier": {
          "value": 0.3666745105421687
        },
        "divider": {
          "value": 549.270218373494
        },
        "rotation": {
          "value": 0.5101421310240966
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee8",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 14.781626506024098
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.4503482680722897
        },
        "yMultiplier": {
          "value": 0.7763761295180723
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 4.338808358433735
        },
        "yDiv2": {
          "value": 19.944201807228918
        },
        "xDiv": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef4",
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 10.43550451807229
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef8",
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 89.15967620481929
        },
        "ballSize": {
          "value": 4.9001082454819285
        },
        "contrast": {
          "value": 2.8231598268072293
        },
        "radius": {
          "value": 26.735104480421693
        },
        "yOuter": {
          "value": 2.0321912650602414
        },
        "xOuter": {
          "value": 72.87236445783132
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 102.42890625000001
        },
        "yMultiplier": {
          "value": 4.814335466867471
        },
        "divider": {
          "value": 24.287932981927714
        },
        "rotation": {
          "value": 0.31049981174698804
        },
        "xDiv": {
          "value": 280.8920368975904
        },
        "yDiv": {
          "value": 1.3295792545180725
        },
        "yDiv2": {
          "value": 12.641613328313255
        },
        "xDiv3": {
          "value": 42
        },
        "div": {
          "value": 103.22031250000002
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f04",
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + sin(uv.x/10.*\n                                                sin(stream/2.)));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .5), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.985203313253013
        },
        "ballSize": {
          "value": 19.99858810240964
        },
        "contrast": {
          "value": 2.5889260165662655
        },
        "radius": {
          "value": 28.156250000000004
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 3.7390813253012056
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.3571630271084345
        },
        "yMultiplier": {
          "value": 0.8000282379518074
        },
        "divider": {
          "value": 10.18425263554217
        },
        "rotation": {
          "value": 1.6163638930722892
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f05",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  \n  for (float i = 1.; i < 6.; i++) {\n    uv *= k_rotate2d((rotation - i) + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) - divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)- stream), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .5), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.797618599397591
        },
        "ballSize": {
          "value": 6.738328313253014
        },
        "contrast": {
          "value": 1.2748023343373498
        },
        "radius": {
          "value": 4.569230045180723
        },
        "yOuter": {
          "value": 0.10073889307228917
        },
        "xOuter": {
          "value": 1
        },
        "xMultiplier": {
          "value": 17.385777484939762
        },
        "yMultiplier": {
          "value": 4.878012048192772
        },
        "divider": {
          "value": 3.1055158132530125
        },
        "rotation": {
          "value": 2.3890248493975905
        }
      },
      {
        "zoom": {
          "value": 5.151694277108434
        },
        "ballSize": {
          "value": 22.96265530873494
        },
        "contrast": {
          "value": 1.2748023343373498
        },
        "radius": {
          "value": 5.819267695783134
        },
        "yOuter": {
          "value": 0.2970632530120483
        },
        "xOuter": {
          "value": 38.66490963855422
        },
        "xMultiplier": {
          "value": 34.81918298192771
        },
        "yMultiplier": {
          "value": 10
        },
        "divider": {
          "value": 3.3943900602409642
        },
        "rotation": {
          "value": 0.9234045557228918
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f08",
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/1.)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 0.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 20.337114081325307
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 1.844597138554217
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed7",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(PI/.2 * rotation + stream/8./(i+1.) + .5 + .3 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-20.)), length(uv)/zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .05)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.726694378220893
        },
        "ballSize": {
          "value": 4.62000617521355
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 3.5971404293933555
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0.5854752965720305
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 10
        },
        "divider": {
          "value": 17.388596592179265
        },
        "rotation": {
          "value": 1.6389976869146508
        },
        "xDiv": {
          "value": 0.5166686276355422
        },
        "yDiv": {
          "value": 0.5852864093091115
        },
        "yDiv2": {
          "value": 0.7892679421298476
        },
        "uvDiv": {
          "value": 6.699874740049065
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eed",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef7",
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p =vec2(radius * xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)),radius * \n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 53.43126882530121
        },
        "ballSize": {
          "value": 7.950512989457832
        },
        "contrast": {
          "value": 2.8231598268072293
        },
        "radius": {
          "value": 0.936050451807229
        },
        "yOuter": {
          "value": 32.44305346385543
        },
        "xOuter": {
          "value": 82.93637048192772
        },
        "xMultiplier": {
          "value": 180.22617187500003
        },
        "yMultiplier": {
          "value": 1.434252635542169
        },
        "divider": {
          "value": 37.18844126506025
        },
        "rotation": {
          "value": 0.4398296310240965
        },
        "xDiv": {
          "value": 162.5990634412651
        },
        "yDiv": {
          "value": 10.444212953170046
        },
        "yDiv2": {
          "value": 4.441933358433736
        },
        "xDiv3": {
          "value": 9.845726656626507
        },
        "div": {
          "value": 58.914062500000014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eff",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /4.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(100.1*yOuter*uv.x/xDiv+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.756140619300935
        },
        "ballSize": {
          "value": 0.5078473746058454
        },
        "contrast": {
          "value": 3.7571877858724942
        },
        "radius": {
          "value": 2.7378595558993792
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 1.078976952886007
        },
        "divider": {
          "value": 17.388596592179265
        },
        "rotation": {
          "value": 0.44312153092349876
        },
        "xDiv": {
          "value": 0.10408700230609942
        },
        "yDiv": {
          "value": 0.9242708321077279
        },
        "yDiv2": {
          "value": 0.7795379270990211
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f09",
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter*(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/11. -uv.x * sin(uv.y/yDiv2-stream/1.)), radius*\n                  cos(stream/11. - .1*yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.40838540364059
        },
        "ballSize": {
          "value": 93.23414909638555
        },
        "contrast": {
          "value": 5.104927522590362
        },
        "radius": {
          "value": 108.7621187876506
        },
        "yOuter": {
          "value": 8.498682228915664
        },
        "xOuter": {
          "value": 9.706904179216867
        },
        "xMultiplier": {
          "value": 3.080948795180723
        },
        "yMultiplier": {
          "value": 5.837114081325302
        },
        "divider": {
          "value": 2.619154743975904
        },
        "rotation": {
          "value": 0.803296780873494
        },
        "xDiv": {
          "value": 2.942137543154226
        },
        "yDiv": {
          "value": 2.405440512048193
        },
        "yDiv2": {
          "value": 45.54506777108435
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f10",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/9.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/-1.9);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n    \n  }\n  gl_FragColor = k_hue(gl_FragColor, colorShift);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.13627164909638556
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.15886671686747
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 14.394220632530123
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0.65417921686747
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -0.5496234939759033
        },
        "ySpeed": {
          "value": -3
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 4.308617281626506
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ed6",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.756140619300935
        },
        "ballSize": {
          "value": 45.40572738647462
        },
        "contrast": {
          "value": 2.723491561226182
        },
        "radius": {
          "value": 34
        },
        "yOuter": {
          "value": 1.814596318624106
        },
        "xOuter": {
          "value": 109.75608219008849
        },
        "xMultiplier": {
          "value": 11.466961596385545
        },
        "yMultiplier": {
          "value": 3.877400225903615
        },
        "divider": {
          "value": 8.398908132530122
        },
        "rotation": {
          "value": 2.103468561746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee2",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee3",
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.45823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/1.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 14.781626506024098
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.4503482680722897
        },
        "yMultiplier": {
          "value": 0.7763761295180723
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef9",
    "shader": "void main () {\n    float stream = stream /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n    uv *= k_rotate2d(-stream/10.);\n\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/100. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.393561746987956
        },
        "ballSize": {
          "value": 10.43550451807229
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 28.024519954819286
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.22
        },
        "yMultiplier": {
          "value": 1.45
        },
        "divider": {
          "value": 1.2570594879518076
        },
        "rotation": {
          "value": 2.778567394578314
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f0c",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = tan(t-stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)- stream), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .225), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.76263
        },
        "ballSize": {
          "value": 62.38067112198795
        },
        "contrast": {
          "value": 2.723491561226182
        },
        "radius": {
          "value": 10.933189006024097
        },
        "yOuter": {
          "value": 1.5610786897590363
        },
        "xOuter": {
          "value": 59.18260542168675
        },
        "xMultiplier": {
          "value": 11.466961596385545
        },
        "yMultiplier": {
          "value": 3.877400225903615
        },
        "divider": {
          "value": 8.398908132530122
        },
        "rotation": {
          "value": 2.103468561746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f11",
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = stream / 2.5;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream /8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / -2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.137
        },
        "orbSize": {
          "value": 7.11
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 9.4728546686747
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee4",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  float stream = stream / 2.;\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.9)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.138648343373497
        },
        "ballSize": {
          "value": 15.823861069277111
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.82177146084338
        },
        "yOuter": {
          "value": 0.468655873493976
        },
        "xOuter": {
          "value": 20.044804216867476
        },
        "xMultiplier": {
          "value": 1.9600432981927716
        },
        "yMultiplier": {
          "value": 0.863190888554217
        },
        "divider": {
          "value": 1.0117187500000002
        },
        "rotation": {
          "value": 2.331681951304134
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 3.256071159638555
        },
        "ballSize": {
          "value": 8.369634789156628
        },
        "contrast": {
          "value": 4.271554969879518
        },
        "radius": {
          "value": 25.5202842620482
        },
        "yOuter": {
          "value": 4
        },
        "xOuter": {
          "value": 1
        },
        "xMultiplier": {
          "value": 1.9600432981927716
        },
        "yMultiplier": {
          "value": 0.863190888554217
        },
        "divider": {
          "value": 1.0117187500000002
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.094785391566266
        },
        "ballSize": {
          "value": 9.303350903614458
        },
        "contrast": {
          "value": 3.1080101656626513
        },
        "radius": {
          "value": 4.077089608433735
        },
        "yOuter": {
          "value": 4
        },
        "xOuter": {
          "value": 27.933358433734945
        },
        "xMultiplier": {
          "value": 0.4031438253012049
        },
        "yMultiplier": {
          "value": 0.2
        },
        "divider": {
          "value": 0.6639118975903615
        },
        "rotation": {
          "value": 5
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9eeb",
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/1.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 14.781626506024098
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.4503482680722897
        },
        "yMultiplier": {
          "value": 0.7763761295180723
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 91.82205384036146
        },
        "ballSize": {
          "value": 24.87360692771085
        },
        "contrast": {
          "value": 1.959713855421687
        },
        "radius": {
          "value": 85.86031626506026
        },
        "yOuter": {
          "value": 0.6169615963855423
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.36454254518072293
        },
        "yMultiplier": {
          "value": 0.8480440512048194
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 4.831395896084338
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 62.11498493975905
        },
        "xDiv": {
          "value": 9.780101656626508
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef5",
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/1.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 68.17255271084338
        },
        "ballSize": {
          "value": 8.56362951807229
        },
        "contrast": {
          "value": 2.8231598268072293
        },
        "radius": {
          "value": 59.41100338855423
        },
        "yOuter": {
          "value": 2.0321912650602414
        },
        "xOuter": {
          "value": 72.87236445783132
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 152.81835937500003
        },
        "yMultiplier": {
          "value": 4.17531061746988
        },
        "divider": {
          "value": 56.23923374162738
        },
        "rotation": {
          "value": 3.958419615963856
        },
        "xDiv": {
          "value": 256.81297063253015
        },
        "yDiv": {
          "value": 2.611314006024097
        },
        "yDiv2": {
          "value": 21.816556852409644
        },
        "xDiv3": {
          "value": 200.19099209337355
        },
        "div": {
          "value": 103.22031250000002
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f23",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f29",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide+stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 0.168
        },
        "orbSize": {
          "value": 4.15
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10.64
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0.1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.93
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.46
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": -1
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.01
        },
        "xDivide": {
          "value": 6.97
        },
        "mirror": {
          "value": false
        },
        "col": {
          "value": 0.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f32",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.004230092243975904
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 572.8845067771085
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.0028510918674698794
        },
        "colorMultiplier": {
          "value": 1.1550451807228916
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 6.708819653614459
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.1656100288222486
        },
        "radius": {
          "value": 9.566547439759038
        },
        "col": {
          "value": 2.335363328313253
        },
        "r": {
          "value": 0
        },
        "g": {
          "value": 1
        },
        "b": {
          "value": -1
        }
      },
      {
        "zoom": {
          "value": 0.001252565406891237
        },
        "shapeMultiplier": {
          "value": 1038.1714234869166
        },
        "rotation": {
          "value": 1.0737520700477694
        },
        "xMultiplier": {
          "value": 458.79628744470074
        },
        "yMultiplier": {
          "value": 253.24566822373455
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.8454003943018171
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 4.879474685852787
        },
        "ballSize": {
          "value": 13.348558517823738
        },
        "glow": {
          "value": 0.2331257647778615
        },
        "contrast": {
          "value": 2.169806790639119
        },
        "radius": {
          "value": 4.719248208654933
        },
        "col": {
          "value": 0.48043036403426215
        },
        "r": {
          "value": 1
        },
        "g": {
          "value": 1
        },
        "b": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.005071751973715174
        },
        "shapeMultiplier": {
          "value": 499.16060114481365
        },
        "rotation": {
          "value": 1.6588170890348506
        },
        "xMultiplier": {
          "value": 582.7281905944089
        },
        "yMultiplier": {
          "value": 571.9553476356599
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.1512100587408227
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 6.684393411659334
        },
        "glow": {
          "value": 2.334541633330196
        },
        "contrast": {
          "value": 4.050712769290051
        },
        "radius": {
          "value": 7.976359172039722
        },
        "col": {
          "value": 1.7341189832572481
        },
        "r": {
          "value": 0
        },
        "g": {
          "value": 1.5417580110480988
        },
        "b": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f30",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002891330948795181
        },
        "shapeMultiplier": {
          "value": 3788.091820406627
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 1560.1044215926206
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00007496355539344881
        },
        "colorMultiplier": {
          "value": 0.7095667827560241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 1.2520472515060241
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3f",
    "shader": "void main() {\n  float stream = stream / 4.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/10.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.16);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1606359186746988
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 21.267764118975908
        },
        "ballSize": {
          "value": 44.899672910391565
        },
        "colorSpread": {
          "value": 0.029814570783132547
        },
        "colorMultiplier": {
          "value": 445.51694700677723
        },
        "shapeMultiplier": {
          "value": 56.08766434487952
        },
        "glow": {
          "value": 4900.67022496235
        },
        "contrast": {
          "value": 3.103421498493976
        },
        "brightness": {
          "value": 11.57032793674699
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 8.024077560240965
        },
        "radius": {
          "value": 5.128962725903616
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        },
        "shape": {
          "value": 0.005611351656626507
        },
        "xDiv": {
          "value": 1118.053765060241
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f42",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.004230092243975904
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 572.8845067771085
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.0028510918674698794
        },
        "colorMultiplier": {
          "value": 1.1550451807228916
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 6.708819653614459
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.1656100288222486
        },
        "radius": {
          "value": 9.566547439759038
        },
        "col": {
          "value": 2.335363328313253
        },
        "r": {
          "value": 0
        },
        "g": {
          "value": 1
        },
        "b": {
          "value": -1
        }
      },
      {
        "zoom": {
          "value": 0.0032695237125258854
        },
        "shapeMultiplier": {
          "value": 958.5411163697761
        },
        "rotation": {
          "value": 0.07531402220208963
        },
        "xMultiplier": {
          "value": 458.79628744470074
        },
        "yMultiplier": {
          "value": 253.24566822373455
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.1770482810146838
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 6.708819653614459
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.2273183615810908
        },
        "radius": {
          "value": 9.566547439759038
        },
        "col": {
          "value": 1.9071265163191835
        },
        "r": {
          "value": 1
        },
        "g": {
          "value": 1
        },
        "b": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.005206392127347282
        },
        "shapeMultiplier": {
          "value": 359.8970344267696
        },
        "rotation": {
          "value": 0.07531402220208963
        },
        "xMultiplier": {
          "value": 819.6193189506073
        },
        "yMultiplier": {
          "value": 266.17671552910866
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.1770482810146838
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.3203389730798196
        },
        "ballSize": {
          "value": 5.9304377544357125
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 4.154999882341868
        },
        "radius": {
          "value": 9.566547439759038
        },
        "col": {
          "value": 1.9071265163191835
        },
        "r": {
          "value": 1
        },
        "g": {
          "value": 1
        },
        "b": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f48",
    "shader": "void main() {\n  float stream = stream / 62.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.026278473268072294
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 31.806092338102417
        },
        "ballSize": {
          "value": 4.534667145143073
        },
        "colorSpread": {
          "value": 2.8148529273343375
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 8.467989457831326
        },
        "glow": {
          "value": 9317.067772260922
        },
        "contrast": {
          "value": 3.3251070689006026
        },
        "brightness": {
          "value": 5.406551204819277
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 38.61648155120483
        },
        "radius": {
          "value": 0.6829230986445783
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f50",
    "shader": "#define BALLS 30\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/2.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist - stream/150.));\n  float _grid = (cos(uv.x * xMultiplier - stream/-5.) - sin(uv.y * yMultiplier + stream/-3.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), tan(t));\n    p += cos(stream/30. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 9. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. / gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.165
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 163.325
        },
        "ballSize": {
          "value": 0.809
        },
        "colorSpread": {
          "value": 1.864
        },
        "colorMultiplier": {
          "value": 197.23
        },
        "shapeMultiplier": {
          "value": 284.312
        },
        "glow": {
          "value": 5303.896
        },
        "contrast": {
          "value": 6.031
        },
        "rotation": {
          "value": 23.538
        },
        "brightness": {
          "value": 3794.182
        },
        "sides": {
          "value": 2
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f51",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.23
        },
        "xMultiplier": {
          "value": 29.96
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.68
        },
        "colorSpread": {
          "value": 1.79
        },
        "colorMultiplier": {
          "value": 383.24
        },
        "shapeMultiplier": {
          "value": 13.45
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 11.628
        },
        "brightness": {
          "value": 8078.46
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2e",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      },
      {
        "zoom": {
          "value": 0.015395801957831329
        },
        "shapeMultiplier": {
          "value": 638.9213102409639
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 402.9485128012049
        },
        "yMultiplier": {
          "value": 384.40794427710847
        },
        "colorSpread": {
          "value": 0.00742722138554217
        },
        "colorMultiplier": {
          "value": 1.3159429284081192
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.3544804216867474
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 5.837161144578314
        },
        "col": {
          "value": 0.4254894578313254
        }
      },
      {
        "zoom": {
          "value": 0.02155873493975904
        },
        "shapeMultiplier": {
          "value": 664.222515060241
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 101.98136295180726
        },
        "yMultiplier": {
          "value": 505.7605421686748
        },
        "colorSpread": {
          "value": 0.002387699284719246
        },
        "colorMultiplier": {
          "value": 1.8847279743975907
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.3544804216867474
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.798098644578314
        },
        "radius": {
          "value": 15.26440135542169
        },
        "col": {
          "value": 1.5800122364457834
        }
      },
      {
        "zoom": {
          "value": 0.01465455572289157
        },
        "shapeMultiplier": {
          "value": 115.95444277108437
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 131.5888554216868
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.008179141566265062
        },
        "colorMultiplier": {
          "value": 0.8356315888554218
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.761389307228916
        },
        "ballSize": {
          "value": 36.31610033885543
        },
        "glow": {
          "value": 1.7608245481927713
        },
        "contrast": {
          "value": 3.6879000376506035
        },
        "radius": {
          "value": 15.26440135542169
        },
        "col": {
          "value": 1.5800122364457834
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f39",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 2.1;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume , .2)* ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.015301204819277112
        },
        "shapeMultiplier": {
          "value": 465.06024096385545
        },
        "rotation": {
          "value": 3.766937093381839
        },
        "xMultiplier": {
          "value": 424.6987951807229
        },
        "yMultiplier": {
          "value": 268.67469879518075
        },
        "colorSpread": {
          "value": 0.00013810843373493977
        },
        "colorMultiplier": {
          "value": 1.8361445783132533
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 9.843373493975903
        },
        "ballSize": {
          "value": 223.6927710843374
        },
        "glow": {
          "value": 3.572119728915663
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 30.755421686746995
        },
        "col": {
          "value": 0.18579160391566268
        }
      },
      {
        "zoom": {
          "value": 0.003879518072289157
        },
        "shapeMultiplier": {
          "value": 1874.698795180723
        },
        "rotation": {
          "value": 6.0356626506024105
        },
        "xMultiplier": {
          "value": 625.3012048192771
        },
        "yMultiplier": {
          "value": 572.2891566265062
        },
        "colorSpread": {
          "value": 0.000028807228915662654
        },
        "colorMultiplier": {
          "value": 1.391566265060241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 64.28554216867471
        },
        "ballSize": {
          "value": 187.7650602409639
        },
        "glow": {
          "value": 3.572119728915663
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 36.56746987951808
        },
        "col": {
          "value": 1.987951807228916
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f41",
    "shader": "void main() {\n  float stream = pow(stream ,1.5)/620.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.212);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .52) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1822475527108434
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 21.267764118975908
        },
        "ballSize": {
          "value": 2.186469032379518
        },
        "colorSpread": {
          "value": 4.021717338102411
        },
        "colorMultiplier": {
          "value": 58.88867846385543
        },
        "shapeMultiplier": {
          "value": 50.70687405873495
        },
        "glow": {
          "value": 4900.67022496235
        },
        "contrast": {
          "value": 3.3251070689006026
        },
        "brightness": {
          "value": 3.1475173192771093
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 26.054179216867475
        },
        "radius": {
          "value": 2.5349962349397597
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4f",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.769
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f53",
    "shader": "\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = 1. - (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.34
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 31.14
        },
        "ballSize": {
          "value": 4.67
        },
        "colorSpread": {
          "value": 5.67
        },
        "colorMultiplier": {
          "value": 114.15
        },
        "shapeMultiplier": {
          "value": 13.02
        },
        "glow": {
          "value": 9222.34
        },
        "contrast": {
          "value": 3.75
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1f",
    "shader": "\n  #define orbs 20.\n\n  \n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1e",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 19900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09
        },
        "contrast": {
          "value": 0.43
        },
        "orbSize": {
          "value": 7.54
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 5.43
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.49
        },
        "cosMul": {
          "value": 2.87
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.44
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 5.78
        },
        "xDivide": {
          "value": 5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f38",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02447853915662651
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 10.43147590361446
        },
        "col": {
          "value": 0.7912348800524701
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f25",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide+stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 0.168
        },
        "orbSize": {
          "value": 4.15
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10.64
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0.1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.93
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.46
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": -1
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.01
        },
        "xDivide": {
          "value": 6.97
        },
        "mirror": {
          "value": false
        },
        "col": {
          "value": 0.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f26",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5.66
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2d",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5.66
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f43",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f45",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .004*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.04466
        },
        "shapeMultiplier": {
          "value": 83.35476
        },
        "rotation": {
          "value": 0.0153725883759648
        },
        "xMultiplier": {
          "value": 163.26853
        },
        "yMultiplier": {
          "value": 100.61898
        },
        "colorSpread": {
          "value": 0.0009439968430852318
        },
        "colorMultiplier": {
          "value": 1
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.992922495646649
        },
        "ballSize": {
          "value": 23.91730200526226
        },
        "glow": {
          "value": 1.7764066029743977
        },
        "contrast": {
          "value": 4.3513181755341686
        },
        "radius": {
          "value": 17.692998433708883
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4e",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.769
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f54",
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 4.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 4.) + sin(uv.y * yMultiplier + stream / 10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x += uv.y; // / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "shapeMultiplier": {
          "value": 203.13
        },
        "rotation": {
          "value": 0.05
        },
        "xMultiplier": {
          "value": 59.27
        },
        "yMultiplier": {
          "value": 88
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.81
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 3.86
        },
        "ballSize": {
          "value": 36.72
        },
        "glow": {
          "value": 1.22
        },
        "contrast": {
          "value": 2.72
        },
        "radius": {
          "value": 16.24
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f18",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08638846009036147
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.46
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.38
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.28
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.99
        },
        "xDivide": {
          "value": 6.27
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.033166980421686754
        },
        "contrast": {
          "value": 0.12439815512048197
        },
        "orbSize": {
          "value": 9.584353162650604
        },
        "radius": {
          "value": 22
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.8233670933734941
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.4288580572289158
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 0.7236063629518074
        },
        "xDivide": {
          "value": 8.498375941265062
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.008450865963855424
        },
        "contrast": {
          "value": 0.12439815512048197
        },
        "orbSize": {
          "value": 85.2886669804217
        },
        "radius": {
          "value": 360.3195406626507
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.8233670933734941
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.02921762048192772
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 8.053467338102411
        },
        "xDivide": {
          "value": 12.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f36",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0015165919108563162
        },
        "shapeMultiplier": {
          "value": 3205.0498135118605
        },
        "rotation": {
          "value": 1.7442496058452563
        },
        "xMultiplier": {
          "value": 3466.821977362576
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.00015843905610666358
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 3.2414770700845383
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 3.933267984045558
        },
        "radius": {
          "value": 6.233824948230422
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 0.30809296757341875
        },
        "b": {
          "value": 0.4314934787980046
        }
      },
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 0.869916286238705
        },
        "contrast": {
          "value": 4.6129678933017235
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 0.14978036535791608
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f19",
    "shader": "\n  #define orbs 20.\n\n \treturn uv; \n}\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n  uv *= k_rotate2d(-stream/40.);\n  uv = k_swap(uv, k_kale(uv, vec2(0.),sides), kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d(stream/10.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\tuv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.29
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 2.32
        },
        "radius": {
          "value": 3.69
        },
        "colorShift": {
          "value": 8.96
        },
        "sides": {
          "value": 8
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0.09
        },
        "cosMul": {
          "value": 0.51
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0041
        },
        "yDivide": {
          "value": 1.13
        },
        "xDivide": {
          "value": 1.47
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ef0",
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/.4)), radius*\n                  cos(stream/21. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 14.781626506024098
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.56339420180724
        },
        "yOuter": {
          "value": 0.20745481927710846
        },
        "xOuter": {
          "value": 22.210090361445786
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.4503482680722897
        },
        "yMultiplier": {
          "value": 0.7763761295180723
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 68.64279583256703
        },
        "ballSize": {
          "value": 8.67511295180723
        },
        "contrast": {
          "value": 5.334502070783133
        },
        "radius": {
          "value": 37.61742281626507
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 192.88166415662656
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.4011671686746988
        },
        "yMultiplier": {
          "value": 1.3276346009036146
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 2.778567394578314
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 8.098493975903617
        },
        "xDiv": {
          "value": 1.7434770331325304
        }
      },
      {
        "zoom": {
          "value": 26.91665097891567
        },
        "ballSize": {
          "value": 5.19921875
        },
        "contrast": {
          "value": 1.7383400498471584
        },
        "radius": {
          "value": 50
        },
        "yOuter": {
          "value": 0.07575301204819279
        },
        "xOuter": {
          "value": 42.83960843373495
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.22849209337349405
        },
        "yMultiplier": {
          "value": 1.0121686746987952
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.39937876506024106
        },
        "yDiv": {
          "value": 9.797910391566266
        },
        "yDiv2": {
          "value": 33.01069277108434
        },
        "xDiv": {
          "value": 0.46692394578313257
        }
      },
      {
        "zoom": {
          "value": 62.13196536144579
        },
        "ballSize": {
          "value": 5.748752823795181
        },
        "contrast": {
          "value": 1.5164486069277112
        },
        "radius": {
          "value": 73.47938629518073
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0.14090416836516378
        },
        "yMultiplier": {
          "value": 0.5855666415662651
        },
        "divider": {
          "value": 0.31706513554216875
        },
        "rotation": {
          "value": 1.9195689006024097
        },
        "yDiv": {
          "value": 5.4796216114457845
        },
        "yDiv2": {
          "value": 22.009412650602414
        },
        "xDiv": {
          "value": 3.2801769578313253
        }
      },
      {
        "zoom": {
          "value": 20.40709713855422
        },
        "ballSize": {
          "value": 30.064984939759036
        },
        "contrast": {
          "value": 3.5711831701807233
        },
        "radius": {
          "value": 50.229433358433745
        },
        "yOuter": {
          "value": 0.2781061746987952
        },
        "xOuter": {
          "value": 51.656626506024104
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.460890436746989
        },
        "yMultiplier": {
          "value": 1.6981579442771089
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0.3976138930722892
        },
        "yDiv": {
          "value": 1.8983904367469886
        },
        "yDiv2": {
          "value": 4.981701807228917
        },
        "xDiv": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f33",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 0.869916286238705
        },
        "contrast": {
          "value": 4.6129678933017235
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 0.14978036535791608
        }
      },
      {
        "zoom": {
          "value": 0.002629553002047252
        },
        "shapeMultiplier": {
          "value": 2220.700321427311
        },
        "rotation": {
          "value": 0.3912666964243694
        },
        "xMultiplier": {
          "value": 751.4546360797194
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 3.933267984045558
        },
        "radius": {
          "value": 39.377560167427525
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 0.30809296757341875
        },
        "b": {
          "value": 0.4314934787980046
        }
      },
      {
        "zoom": {
          "value": 0.0012806754054793396
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 1.6306559918874721
        },
        "xMultiplier": {
          "value": 2452.3762628026757
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 29.790788673492806
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 4.846765173486917
        },
        "radius": {
          "value": 24.204514469008853
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.8626607504235694
        },
        "g": {
          "value": 0.7242171322006777
        },
        "b": {
          "value": 1.9394326399761599
        }
      },
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.153767229562783
        },
        "ballSize": {
          "value": 18.93753672220621
        },
        "glow": {
          "value": 0.28189998764589613
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 12.95189179569842
        },
        "col": {
          "value": 0.3760011787874154
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f35",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 0.869916286238705
        },
        "contrast": {
          "value": 4.6129678933017235
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 0.14978036535791608
        }
      },
      {
        "zoom": {
          "value": 0.002629553002047252
        },
        "shapeMultiplier": {
          "value": 2220.700321427311
        },
        "rotation": {
          "value": 0.3912666964243694
        },
        "xMultiplier": {
          "value": 751.4546360797194
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 3.933267984045558
        },
        "radius": {
          "value": 39.377560167427525
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 0.30809296757341875
        },
        "b": {
          "value": 0.4314934787980046
        }
      },
      {
        "zoom": {
          "value": 0.0012806754054793396
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 1.6306559918874721
        },
        "xMultiplier": {
          "value": 2452.3762628026757
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 29.790788673492806
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 4.846765173486917
        },
        "radius": {
          "value": 24.204514469008853
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.8626607504235694
        },
        "g": {
          "value": 0.7242171322006777
        },
        "b": {
          "value": 1.9394326399761599
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f31",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002891330948795181
        },
        "shapeMultiplier": {
          "value": 3788.091820406627
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 1560.1044215926206
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00007496355539344881
        },
        "colorMultiplier": {
          "value": 0.7095667827560241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 1.2520472515060241
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      },
      {
        "zoom": {
          "value": 0.002629553002047252
        },
        "shapeMultiplier": {
          "value": 2220.700321427311
        },
        "rotation": {
          "value": 0.3912666964243694
        },
        "xMultiplier": {
          "value": 751.4546360797194
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 3.933267984045558
        },
        "radius": {
          "value": 39.377560167427525
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 0.30809296757341875
        },
        "b": {
          "value": 0.4314934787980046
        }
      },
      {
        "zoom": {
          "value": 0.0012806754054793396
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 1.6306559918874721
        },
        "xMultiplier": {
          "value": 2452.3762628026757
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 29.790788673492806
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 4.846765173486917
        },
        "radius": {
          "value": 24.204514469008853
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.8626607504235694
        },
        "g": {
          "value": 0.7242171322006777
        },
        "b": {
          "value": 1.9394326399761599
        }
      },
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.153767229562783
        },
        "ballSize": {
          "value": 18.93753672220621
        },
        "glow": {
          "value": 0.28189998764589613
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 12.95189179569842
        },
        "col": {
          "value": 0.3760011787874154
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3e",
    "shader": "void main() {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.33);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-.425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(pow(volume, 1.24) * ballSize, .7) / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1606359186746988
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 21.267764118975908
        },
        "ballSize": {
          "value": 2.186469032379518
        },
        "colorSpread": {
          "value": 4.021717338102411
        },
        "colorMultiplier": {
          "value": 58.88867846385543
        },
        "shapeMultiplier": {
          "value": 23.783773908132535
        },
        "glow": {
          "value": 4900.67022496235
        },
        "contrast": {
          "value": 3.3251070689006026
        },
        "brightness": {
          "value": 6.846585090361446
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 26.054179216867475
        },
        "radius": {
          "value": 2.5349962349397597
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4c",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.769
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4d",
    "shader": "#define BALLS 5\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "shapeMultiplier": {
          "value": 203.13
        },
        "rotation": {
          "value": 0.05
        },
        "xMultiplier": {
          "value": 59.27
        },
        "yMultiplier": {
          "value": 88
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.81
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 3.86
        },
        "ballSize": {
          "value": 36.72
        },
        "glow": {
          "value": 1.22
        },
        "contrast": {
          "value": 2.72
        },
        "radius": {
          "value": 16.24
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f21",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.07
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.46
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.38
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.28
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.99
        },
        "xDivide": {
          "value": 6.27
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2a",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2c",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/18900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.058
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 2.38
        },
        "radius": {
          "value": 6.38
        },
        "colorShift": {
          "value": 5.43
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": -1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -1.5
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.56
        },
        "xDivide": {
          "value": 5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3a",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 9.1;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.005787838855421688
        },
        "shapeMultiplier": {
          "value": 33.21724397590362
        },
        "rotation": {
          "value": 7.260325677710845
        },
        "xMultiplier": {
          "value": 454.3698230421687
        },
        "yMultiplier": {
          "value": 308.2784262048193
        },
        "colorSpread": {
          "value": 0.0004538973079819278
        },
        "colorMultiplier": {
          "value": 1.6406250000000004
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.244964231927712
        },
        "ballSize": {
          "value": 65.16575677710844
        },
        "glow": {
          "value": 3.572119728915663
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 15.978539156626507
        },
        "col": {
          "value": 0.18579160391566268
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3b",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/.4);\n  uv *= k_rotate2d(rotation + 1.1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(length(uv*zoom) / pow(volume, .2) * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.016035391566265066
        },
        "shapeMultiplier": {
          "value": 1401.7978162650604
        },
        "rotation": {
          "value": 2.2002870858433736
        },
        "xMultiplier": {
          "value": 415.48616340361446
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      },
      {
        "zoom": {
          "value": 0.015395801957831329
        },
        "shapeMultiplier": {
          "value": 638.9213102409639
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 402.9485128012049
        },
        "yMultiplier": {
          "value": 384.40794427710847
        },
        "colorSpread": {
          "value": 0.00742722138554217
        },
        "colorMultiplier": {
          "value": 1.3159429284081192
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.3544804216867474
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 5.837161144578314
        },
        "col": {
          "value": 0.4254894578313254
        }
      },
      {
        "zoom": {
          "value": 0.02155873493975904
        },
        "shapeMultiplier": {
          "value": 664.222515060241
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 101.98136295180726
        },
        "yMultiplier": {
          "value": 505.7605421686748
        },
        "colorSpread": {
          "value": 0.002387699284719246
        },
        "colorMultiplier": {
          "value": 1.8847279743975907
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.3544804216867474
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.798098644578314
        },
        "radius": {
          "value": 15.26440135542169
        },
        "col": {
          "value": 1.5800122364457834
        }
      },
      {
        "zoom": {
          "value": 0.01465455572289157
        },
        "shapeMultiplier": {
          "value": 115.95444277108437
        },
        "rotation": {
          "value": 1.610448042168675
        },
        "xMultiplier": {
          "value": 131.5888554216868
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.008179141566265062
        },
        "colorMultiplier": {
          "value": 0.8356315888554218
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.761389307228916
        },
        "ballSize": {
          "value": 36.31610033885543
        },
        "glow": {
          "value": 1.7608245481927713
        },
        "contrast": {
          "value": 3.6879000376506035
        },
        "radius": {
          "value": 15.26440135542169
        },
        "col": {
          "value": 1.5800122364457834
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f16",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.11358595656421253
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 5.804883385285957
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.044943060344178255
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 9.409707095513692
        },
        "xDivide": {
          "value": 12.76840419598715
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.07
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 5.53
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.97
        },
        "yMul": {
          "value": 3.45
        },
        "xMul": {
          "value": 0.14
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.02
        },
        "contrast": {
          "value": 0.1
        },
        "orbSize": {
          "value": 5.53
        },
        "radius": {
          "value": 6.59
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.97
        },
        "yMul": {
          "value": 3.45
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ee7",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.138648343373497
        },
        "ballSize": {
          "value": 15.823861069277111
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 38.82177146084338
        },
        "yOuter": {
          "value": 0.468655873493976
        },
        "xOuter": {
          "value": 20.044804216867476
        },
        "xMultiplier": {
          "value": 1.9600432981927716
        },
        "yMultiplier": {
          "value": 0.863190888554217
        },
        "divider": {
          "value": 1.0117187500000002
        },
        "rotation": {
          "value": 2.331681951304134
        },
        "yDiv": {
          "value": 3.222279743975904
        },
        "yDiv2": {
          "value": 3.7387801204819286
        },
        "xDiv": {
          "value": 0.503765060240964
        },
        "xDiv2": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f20",
    "shader": "  #define orbs 20.\n\n  \n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f24",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.137
        },
        "orbSize": {
          "value": 7.11
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2b",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/19900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.09
        },
        "contrast": {
          "value": 0.43
        },
        "orbSize": {
          "value": 7.54
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 5.43
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.49
        },
        "cosMul": {
          "value": 2.87
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.44
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 5.78
        },
        "xDivide": {
          "value": 5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f34",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 0.869916286238705
        },
        "contrast": {
          "value": 4.6129678933017235
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 0.14978036535791608
        }
      },
      {
        "zoom": {
          "value": 0.002629553002047252
        },
        "shapeMultiplier": {
          "value": 2220.700321427311
        },
        "rotation": {
          "value": 0.3912666964243694
        },
        "xMultiplier": {
          "value": 751.4546360797194
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 55
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 3.933267984045558
        },
        "radius": {
          "value": 39.377560167427525
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 0.30809296757341875
        },
        "b": {
          "value": 0.4314934787980046
        }
      },
      {
        "zoom": {
          "value": 0.0012806754054793396
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 1.6306559918874721
        },
        "xMultiplier": {
          "value": 2452.3762628026757
        },
        "yMultiplier": {
          "value": 2133.7535444512428
        },
        "colorSpread": {
          "value": 0.000047810932352456705
        },
        "colorMultiplier": {
          "value": 0.3967557424522309
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 29.790788673492806
        },
        "glow": {
          "value": 0.8978996552616718
        },
        "contrast": {
          "value": 4.846765173486917
        },
        "radius": {
          "value": 24.204514469008853
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.8626607504235694
        },
        "g": {
          "value": 0.7242171322006777
        },
        "b": {
          "value": 1.9394326399761599
        }
      },
      {
        "zoom": {
          "value": 0.0008370846208319609
        },
        "shapeMultiplier": {
          "value": 5000
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 2876.168172721404
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00003663346969420652
        },
        "colorMultiplier": {
          "value": 0.7390385179634554
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.153767229562783
        },
        "ballSize": {
          "value": 18.93753672220621
        },
        "glow": {
          "value": 0.28189998764589613
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 12.95189179569842
        },
        "col": {
          "value": 0.3760011787874154
        },
        "r": {
          "value": 2
        },
        "g": {
          "value": 2
        },
        "b": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3c",
    "shader": "void main() {\n  float stream = pow(stream ,1.3)/90.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.212);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .2) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09918053463855425
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 21.267764118975908
        },
        "ballSize": {
          "value": 3.88734422063253
        },
        "colorSpread": {
          "value": 10.493669239457834
        },
        "colorMultiplier": {
          "value": 58.88867846385543
        },
        "shapeMultiplier": {
          "value": 39.67082850150603
        },
        "glow": {
          "value": 15674.245313441268
        },
        "contrast": {
          "value": 3.3251070689006026
        },
        "brightness": {
          "value": 8.960690512048194
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 26.054179216867475
        },
        "radius": {
          "value": 1.2730609939759039
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f46",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.9764835164835164
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f47",
    "shader": "void main() {\n  float stream = stream / 45.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/2.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.026278473268072294
        },
        "xMultiplier": {
          "value": 5.364285344503013
        },
        "yMultiplier": {
          "value": 15.957271507906627
        },
        "ballSize": {
          "value": 4.534667145143073
        },
        "colorSpread": {
          "value": 3.3978505035768074
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 137.48647896272593
        },
        "glow": {
          "value": 9317.067772260922
        },
        "contrast": {
          "value": 2.5810811605798194
        },
        "brightness": {
          "value": 0.4651073042168676
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 28.11217526355422
        },
        "radius": {
          "value": 1.0314500188253015
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f52",
    "shader": "\n\n#define BALLS 15\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist - stream/200.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.21
        },
        "xMultiplier": {
          "value": 49.77
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 1.37
        },
        "colorSpread": {
          "value": 1.21
        },
        "colorMultiplier": {
          "value": 500
        },
        "shapeMultiplier": {
          "value": 17.27
        },
        "glow": {
          "value": 2080.32
        },
        "contrast": {
          "value": 4.53
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 6430.09
        },
        "sides": {
          "value": 9
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f17",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1b",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.137
        },
        "orbSize": {
          "value": 7.11
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f28",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.137
        },
        "orbSize": {
          "value": 7.11
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f2f",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002891330948795181
        },
        "shapeMultiplier": {
          "value": 3788.091820406627
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 1560.1044215926206
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00007496355539344881
        },
        "colorMultiplier": {
          "value": 0.7095667827560241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 1.2520472515060241
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      },
      {
        "zoom": {
          "value": 0.00030632294804216873
        },
        "shapeMultiplier": {
          "value": 3788.091820406627
        },
        "rotation": {
          "value": 2
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.000006393407614834339
        },
        "colorMultiplier": {
          "value": 0.7095667827560241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 36.36424604668675
        },
        "glow": {
          "value": 1.8864212915287457
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 20
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      },
      {
        "zoom": {
          "value": 0.0010805722891566267
        },
        "shapeMultiplier": {
          "value": 3788.091820406627
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 1560.1044215926206
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00007496355539344881
        },
        "colorMultiplier": {
          "value": 1.0814606080572289
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 1.2520472515060241
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      },
      {
        "zoom": {
          "value": 0.0020881377070783138
        },
        "shapeMultiplier": {
          "value": 630.8240775602411
        },
        "rotation": {
          "value": 0.5176957831325302
        },
        "xMultiplier": {
          "value": 1560.1044215926206
        },
        "yMultiplier": {
          "value": 3456.9860894996004
        },
        "colorSpread": {
          "value": 0.00007496355539344881
        },
        "colorMultiplier": {
          "value": 0.7095667827560241
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.510078889777863
        },
        "ballSize": {
          "value": 18.486439164862578
        },
        "glow": {
          "value": 1.2520472515060241
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 13.537957800440044
        },
        "col": {
          "value": 0.6504346916474493
        },
        "r": {
          "value": 0.18946748296898536
        },
        "g": {
          "value": 1.3596809111445787
        },
        "b": {
          "value": 1.6122340926204821
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f44",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .002 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.004617375753012049
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4b",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n    gl_FragColor.rgb *= sap;\n  gl_FragColor.r *= .001;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00384683264307229
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.007697853915662651
        },
        "colorMultiplier": {
          "value": 0.773472797439759
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 10
        },
        "ballSize": {
          "value": 8.248511624623497
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.6166698042168677
        },
        "radius": {
          "value": 8.394319465361447
        },
        "col": {
          "value": 1.4261930534638556
        },
        "sap": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f27",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.07
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.46
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.38
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.28
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.99
        },
        "xDivide": {
          "value": 6.27
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f37",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.004230092243975904
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 572.8845067771085
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.0028510918674698794
        },
        "colorMultiplier": {
          "value": 1.1550451807228916
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 6.708819653614459
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.1656100288222486
        },
        "radius": {
          "value": 9.566547439759038
        },
        "col": {
          "value": 2.335363328313253
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f3d",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .4)*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/20. + sin(uv.x/10. - stream/10.));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f40",
    "shader": "void main() {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.13);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-.425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .4) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1606359186746988
        },
        "xMultiplier": {
          "value": 13.236713220067774
        },
        "yMultiplier": {
          "value": 21.267764118975908
        },
        "ballSize": {
          "value": 2.186469032379518
        },
        "colorSpread": {
          "value": 4.021717338102411
        },
        "colorMultiplier": {
          "value": 58.88867846385543
        },
        "shapeMultiplier": {
          "value": 37.93467789909639
        },
        "glow": {
          "value": 4900.67022496235
        },
        "contrast": {
          "value": 3.3251070689006026
        },
        "brightness": {
          "value": 6.846585090361446
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 26.054179216867475
        },
        "radius": {
          "value": 2.5349962349397597
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f4a",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.769
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.169
        },
        "xMultiplier": {
          "value": 21.69
        },
        "yMultiplier": {
          "value": 25.112
        },
        "ballSize": {
          "value": 1.712
        },
        "colorSpread": {
          "value": 0.299
        },
        "colorMultiplier": {
          "value": 30.706
        },
        "shapeMultiplier": {
          "value": 226.04
        },
        "glow": {
          "value": 6069.68
        },
        "contrast": {
          "value": 1.791
        },
        "brightness": {
          "value": 12.119
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 101.544
        },
        "radius": {
          "value": 9.65
        }
      },
      {
        "zoom": {
          "value": 0.11
        },
        "xMultiplier": {
          "value": 62.497
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 2.957
        },
        "colorSpread": {
          "value": 0.539
        },
        "colorMultiplier": {
          "value": 30.706
        },
        "shapeMultiplier": {
          "value": 31.454
        },
        "glow": {
          "value": 6069.68
        },
        "contrast": {
          "value": 1.791
        },
        "brightness": {
          "value": 12.119
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 121.691
        },
        "radius": {
          "value": 13.27
        }
      },
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 40.74
        },
        "yMultiplier": {
          "value": 14.076
        },
        "ballSize": {
          "value": 5.257
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 499.03
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 2.997
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 27.692
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1a",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.37
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 3.34
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 1.8
        },
        "xDivide": {
          "value": 2.09
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f22",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/18900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.058
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 2.38
        },
        "radius": {
          "value": 6.38
        },
        "colorShift": {
          "value": 5.43
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": -1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -1.5
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.56
        },
        "xDivide": {
          "value": 5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f49",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/-20.);\n  uv *= zoom;\n  // uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/-1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/-1.) * sin(uv.y * yMultiplier + stream/-1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + uv.y/150. + float(i) / 5.)) * 0.25 + 0.25;\n    gl_FragColor += vec4(volume * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 1700.47
        },
        "rotation": {
          "value": 0.22591
        },
        "xMultiplier": {
          "value": 444.91
        },
        "yMultiplier": {
          "value": 498.49
        },
        "colorSpread": {
          "value": 0.000046
        },
        "colorMultiplier": {
          "value": 3
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 4.36
        },
        "ballSize": {
          "value": 24.47
        },
        "glow": {
          "value": 1.27
        },
        "contrast": {
          "value": 2.28
        },
        "radius": {
          "value": 6.66
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f55",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.053
        },
        "shapeMultiplier": {
          "value": 223.96
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 217.723
        },
        "yMultiplier": {
          "value": 157.966
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.863
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.636
        },
        "ballSize": {
          "value": 17.795
        },
        "glow": {
          "value": 0.714
        },
        "contrast": {
          "value": 2.278
        },
        "radius": {
          "value": 15.459
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f75",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.x / yDiv + stream / .9);// - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.);// - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * sin(t / multiplier + stream / 11.), yMul * tan(t / multiplier + stream / 5.));\n    p /= sin(PI * cos(uv.x / xDiv3 + stream / 9.) - sin(uv.y / yDiv3 - stream / 9.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize *1. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.786
        },
        "xDiv": {
          "value": 1.108
        },
        "yDiv": {
          "value": 6.093
        },
        "xDiv3": {
          "value": 0.475
        },
        "yDiv3": {
          "value": 0.365
        },
        "multiplier": {
          "value": 8.31
        },
        "ballSize": {
          "value": 1.829
        },
        "contrast": {
          "value": 2.808
        },
        "radius": {
          "value": 12.458
        },
        "rotation": {
          "value": 0.000571
        },
        "xMul": {
          "value": 0.342
        },
        "yMul": {
          "value": 0.777
        },
        "oY": {
          "value": 57.237
        },
        "oX": {
          "value": 45.861
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7e",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom + (zoom * .5 * sin(stream / 15.));\n  uv *= k_rotate2d(stream/12.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 49.443
        },
        "xDiv": {
          "value": 13.853
        },
        "yDiv": {
          "value": 2.857
        },
        "xDiv2": {
          "value": 2.597
        },
        "yDiv2": {
          "value": 2.424
        },
        "xDiv3": {
          "value": 27.706
        },
        "yDiv3": {
          "value": 17.13
        },
        "multiplier": {
          "value": 1.779
        },
        "ballSize": {
          "value": 1.818
        },
        "contrast": {
          "value": 1.61
        },
        "radius": {
          "value": 1.271
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 24.589
        },
        "yMul": {
          "value": 4.329
        },
        "oY": {
          "value": 80
        },
        "oX": {
          "value": 32.035
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f83",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 90.275
        },
        "yDivider": {
          "value": 18.646
        },
        "xDivider": {
          "value": 9.294
        },
        "multiplier": {
          "value": 1.219
        },
        "ballSize": {
          "value": 34.82
        },
        "contrast": {
          "value": 1.8
        },
        "radius": {
          "value": 76.67
        },
        "rotation": {
          "value": 14.858
        },
        "yDivide": {
          "value": 307.888
        },
        "xDivide": {
          "value": 0.408
        },
        "yShape": {
          "value": 200
        },
        "shape": {
          "value": 14.966
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f84",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, 1.26)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 362.832
        },
        "xDiv": {
          "value": 11.463
        },
        "yDiv": {
          "value": 122.317
        },
        "xDiv2": {
          "value": 7.522
        },
        "yDiv2": {
          "value": 2.89
        },
        "xDiv3": {
          "value": 15.832
        },
        "yDiv3": {
          "value": 172.525
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 70.762
        },
        "contrast": {
          "value": 1.714
        },
        "radius": {
          "value": 18.079
        },
        "rotation": {
          "value": 0.000054
        },
        "xMul": {
          "value": 0
        },
        "yMul": {
          "value": 13.037
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f88",
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.135
        },
        "iterator": {
          "value": 1.071
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 18.705
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f90",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.411
        },
        "contrast": {
          "value": 2.19
        },
        "orbSize": {
          "value": 0.573
        },
        "radius": {
          "value": 2.499
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 3.248
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.388
        },
        "sinMul": {
          "value": 6.426
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa0",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.509076148343374
        },
        "orbSize": {
          "value": 0.5489348644578315
        },
        "radius": {
          "value": 4.144187123493976
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb4",
    "shader": "\n#define orbs 20.\n\n   \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= k_rotate2d(stream/13.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 26.95
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.24
        },
        "radius": {
          "value": 11.34
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.64
        },
        "x2": {
          "value": 0.34
        },
        "y1": {
          "value": 0.41
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc3",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.);\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 3.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = (vUv+(o-n)*.5)/n.y,\n          m       = mouse.xy/n*2.-1.;\n          \n    for (float a = 0.; a < 100.; a++) {\n        vec3 p = r*vec3(i*.35 - m*.05, 1.);\n        p.xy  *= mat2(cos(r*m.x*.07 + vec4(0,33,11,0)));\n        p.z   += stream*.6; p = abs(fract(p)-.5);            \n        r += t = (p.x + p.y + p.z - .12)*.6;        \n    }\n    tot += mix(.7 - vec3(r*r*2e-4), \n        1.5*cos(r*(vec3(5.7, 5.76, 5.82) + length(i))), \n        exp(-r*.07) * (1.2-length(i))); \n_AA_END \n} ",
    "variants": [
      {
        "zoom": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe3",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1276364.983
        },
        "ballSize": {
          "value": 9105.983
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 52570255.53
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 133300768.7
        },
        "y": {
          "value": 7915426.66
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 96.5
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 39960.707
        },
        "div2": {
          "value": 916935.078
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fed",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 2.;\n  mat2 rotation = k_rotate2d(stream/(PI*10.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .58) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.049
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 4.962735316265062
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.5863422439759036
        },
        "colorOffset": {
          "value": 9.61846762048193
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.45104942723058306
        },
        "div": {
          "value": 0.12494399472891568
        },
        "radius": {
          "value": 1.8993411144578316
        }
      },
      {
        "zoom": {
          "value": 0.38244540662650606
        },
        "iterator": {
          "value": 1.3380082831325304
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 22.118138177710847
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.10004955760542171
        },
        "radius": {
          "value": 2.93386671686747
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff2",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = abs(uv);\n  uv *= tanMul * tan(logMul * log(abs(uv)) + stream/1.5);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 1.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.2740185534982027
        },
        "contrast": {
          "value": 1.769083618187107
        },
        "ballSize": {
          "value": 0.2369975037592189
        },
        "radius": {
          "value": 37.791448683102594
        },
        "tanMul": {
          "value": 1.104046078583356
        },
        "logMul": {
          "value": 1.031424398377955
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff6",
    "shader": "void main() { \n  float stream = stream / 40.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv + sin(uv - stream)); \n  float i = sin(uv.x) * cos(uv.y);\n  float rot = rotation * abs(dist / wobble);\n  uv *= k_rotate2d(stream / 01. - rot); \n  float t = i * PI / i * (5. + 1.);\n  float a = cos(yOuter * uv.y);\n  float b = cos(xOuter * uv.x * sin(stream+uv.y / 1.)); \n  float c = sin(t) * b;\n  vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n  vec3 col = k_rainbow(i, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.799
        },
        "ballSize": {
          "value": 1.4232967569006496
        },
        "contrast": {
          "value": 1.0016479198042174
        },
        "radius": {
          "value": 0.48578690678240316
        },
        "yOuter": {
          "value": 1.2013437815863983
        },
        "xOuter": {
          "value": 7.477495764307228
        },
        "rotation": {
          "value": 0.01897741662450584
        },
        "wobble": {
          "value": 0.193156892707549
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd4",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = k_kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= k_rotate2d(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.64
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca016",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 17;\n\n#define PHI   sin(sqrt(PI))\n#define TAU   (PI*PI)\n#define TTIME (stream)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.5/_z, .5*_x) * dot(z-vec3(size,0.,.2),plnormal);\n        \n  dmin = abs(dmin) - width*0.05*(0.105 + 0.05/sin(1.0*length(p) - 1.5*p.y + TTIME/20.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =11.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.434
        },
        "size": {
          "value": 3.495
        },
        "offc": {
          "value": 0
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 7.311
        },
        "_x": {
          "value": 8.265
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02d",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 2.19
        },
        "yDivider": {
          "value": 238.11
        },
        "xDivider": {
          "value": 0.2
        },
        "multiplier": {
          "value": 2.62
        },
        "ballSize": {
          "value": 0.101
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 9.38
        },
        "xOuter": {
          "value": 0.72
        },
        "yOuter": {
          "value": 0.06
        },
        "xDiv": {
          "value": 71.248
        },
        "xDiv2": {
          "value": 4
        },
        "warp": {
          "value": 274.655
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca054",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(i) + stream;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 31. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.25150756835938
        },
        "ballSize": {
          "value": 2.3322930308524503
        },
        "contrast": {
          "value": 9.391235995005415
        },
        "radius": {
          "value": 131.4271090404097
        },
        "yOuter": {
          "value": 1.0550338184382608
        },
        "xOuter": {
          "value": 222.85680931734757
        },
        "xMultiplier": {
          "value": 5.567485892054547
        },
        "yMultiplier": {
          "value": 1.2840676135327445
        },
        "divider": {
          "value": 0.81470752394343
        },
        "rotation": {
          "value": 1
        },
        "yDiv": {
          "value": 1.999332933540804
        },
        "yDiv2": {
          "value": 0.1528573139604316
        },
        "xDiv": {
          "value": 0.6099122380635825
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05c",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.46
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 2.32
        },
        "colorShift": {
          "value": 6.24
        },
        "outer": {
          "value": 2.78
        },
        "inner": {
          "value": 0.03
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca071",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/1.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 17.22
        },
        "contrast": {
          "value": 1.39
        },
        "orbSize": {
          "value": 3.81
        },
        "radius": {
          "value": 19.08
        },
        "colorShift": {
          "value": 28.21
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 50
        },
        "sinMul": {
          "value": 3.65
        },
        "cosMul": {
          "value": 1.39
        },
        "yMul": {
          "value": 0.2
        },
        "xMul": {
          "value": 0.75
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.002
        },
        "yDivide": {
          "value": 19
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca081",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv) - stream)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  // uv /= dot(sin(uv+stream), cos(uv+stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 5000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca083",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08a",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = i/radius * tan(t + stream/6.) * sin(t-stream/3.);\n    float y = i/radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 1.)* orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 33.63
        },
        "contrast": {
          "value": 0.85
        },
        "orbSize": {
          "value": 0.29
        },
        "radius": {
          "value": 5.57
        },
        "colorShift": {
          "value": 12.71
        },
        "div": {
          "value": 9.908
        },
        "div2": {
          "value": 12.178
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca095",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *=k_rotate2d(stream/70.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/20)*cos(uv.y/yDivider + stream/21.) + sin(uv.x/50. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider + stream/21.) * sin(uv.y/50. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 58.06
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.2
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a4",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += .2*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/12.);\n    uv.x += .2*float(i)*sin(uv.x/xDivider - stream/11.) - sin(uv.y/20. + stream/12.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a8",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.22
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.203
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ac",
    "shader": "\n#define BALLS 20.\n  \n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      },
      {
        "zoom": {
          "value": 0.71
        },
        "contrast": {
          "value": 4.38
        },
        "ballSize": {
          "value": 0.021
        },
        "radius": {
          "value": 104.1
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.3039
        },
        "contrast": {
          "value": 4.18
        },
        "ballSize": {
          "value": 0.015
        },
        "radius": {
          "value": 259.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 2.72
        }
      },
      {
        "zoom": {
          "value": 1.49
        },
        "contrast": {
          "value": 4.18
        },
        "ballSize": {
          "value": 0.02
        },
        "radius": {
          "value": 188.51
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.07
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 5.39
        },
        "ballSize": {
          "value": 0.06
        },
        "radius": {
          "value": 188.51
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": -16.76
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0be",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.19
        },
        "contrast": {
          "value": 4.95
        },
        "ballSize": {
          "value": 0.08
        },
        "radius": {
          "value": 1
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0cd",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/50.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) + sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/350. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.003
        },
        "shapeMultiplier": {
          "value": 1000
        },
        "rotation": {
          "value": 0.00912
        },
        "xMultiplier": {
          "value": 3094.4
        },
        "yMultiplier": {
          "value": 288.23
        },
        "colorSpread": {
          "value": 0.00003
        },
        "colorMultiplier": {
          "value": 1.2
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.69
        },
        "ballSize": {
          "value": 8.04
        },
        "glow": {
          "value": 1.01
        },
        "contrast": {
          "value": 2.25
        },
        "radius": {
          "value": 6.23
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d4",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 64.73
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 1.05
        },
        "radius": {
          "value": 11.83
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 17.328
        },
        "div2": {
          "value": 14.483
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca114",
    "shader": "\n\n#define BALLS 5\n\n\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.64
        },
        "xMultiplier": {
          "value": 86.71
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 2.25
        },
        "colorSpread": {
          "value": 3.36
        },
        "colorMultiplier": {
          "value": 115.44
        },
        "shapeMultiplier": {
          "value": 13.45
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8c",
    "shader": "void main () {\n  float stream = stream  / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize,vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.668
        },
        "iterator": {
          "value": 1.186
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 23.76
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        },
        "orbSize": {
          "value": 0.071
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8e",
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.199
        },
        "contrast": {
          "value": 1.262
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 0.825
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.43
        },
        "colorOffset": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.307
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 2.979
        },
        "colorShift": {
          "value": 0
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 4.12
        }
      },
      {
        "zoom": {
          "value": 0.145
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 8.789
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 1.277
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 5
        },
        "b": {
          "value": 0.19
        },
        "c": {
          "value": 1.77
        },
        "d": {
          "value": 0.47
        },
        "colorOffset": {
          "value": 2.06
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.994
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.8
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      },
      {
        "zoom": {
          "value": 0.089
        },
        "contrast": {
          "value": 0.617
        },
        "orbSize": {
          "value": 0.993
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.227
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 0
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f99",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 10
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 1.76
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc0",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = k_uv();\n          i *= zoom;\n\n    i *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      {
        "zoom": {
          "value": 0.033
        },
        "mul": {
          "value": 0.46
        },
        "rot": {
          "value": 489.87
        },
        "sub": {
          "value": 42.73
        },
        "A": {
          "value": 2.34
        },
        "B": {
          "value": 5.57
        },
        "C": {
          "value": 10.18
        },
        "D": {
          "value": 3.59
        },
        "dep": {
          "value": 0.11
        },
        "wap": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc5",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 7.7158
        },
        "contrast": {
          "value": 1.13968
        },
        "orbSize": {
          "value": 0.44755
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 81.54882
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 0.88063
        },
        "sides": {
          "value": 2.75927
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd7",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.2);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .14) * _uv.y/div - stream/.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.43 - t*PI), radius*tan(t - stream/-.9));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.13- uv.y/(.7*y + .3*y*sin(stream/.7393))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.4  * float(i) / 6.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1227038.805
        },
        "ballSize": {
          "value": 12794.352
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 57335073.78
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 164362793.61
        },
        "y": {
          "value": 17556518.17
        },
        "rotation": {
          "value": 0.00224
        },
        "colorOffset": {
          "value": 330.39
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 63549.947
        },
        "div2": {
          "value": 551932.42
        },
        "wad": {
          "value": 4.882
        },
        "woot": {
          "value": 0.135
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fea",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.1) * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0015747364457831328
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 1.0034073795180722
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 13.64527014307229
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.7545274849397591
        },
        "colorOffset": {
          "value": 37.88460090361446
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.2960278614457832
        },
        "div": {
          "value": 0.03972143260542169
        },
        "radius": {
          "value": 1.8993411144578316
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6151637801204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 7.6585843373493985
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.07135316265060243
        },
        "radius": {
          "value": 2.93386671686747
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff9",
    "shader": "void main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  float i = sin(uv.x);\n  float rot = -rotation * abs(stream + dist / .2);\n  uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n  float t = i * PI / i * (5. + 1.);\n  float a = cos(uv.y - stream / .5);\n  float b = cos(uv.x * sin(uv.y / 1.)); \n  float c = radius * sin(stream+t) * 20. * b;\n  vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n  vec3 col = k_rainbow(i / 5. * i, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs((gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n} ",
    "variants": [
      {
        "zoom": {
          "value": 8.304
        },
        "ballSize": {
          "value": 2.304
        },
        "contrast": {
          "value": 1.113
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.216
        },
        "xOuter": {
          "value": 12.54
        },
        "rotation": {
          "value": 0.02
        },
        "wobble": {
          "value": 0.15
        }
      },
      {
        "zoom": {
          "value": 7.405
        },
        "ballSize": {
          "value": 0.861
        },
        "contrast": {
          "value": 0.999
        },
        "radius": {
          "value": 0.789
        },
        "yOuter": {
          "value": 2.32
        },
        "xOuter": {
          "value": 20.4
        },
        "rotation": {
          "value": 0
        },
        "wobble": {
          "value": 0.7
        }
      },
      {
        "zoom": {
          "value": 5.969
        },
        "ballSize": {
          "value": 1.511
        },
        "contrast": {
          "value": 0.961
        },
        "radius": {
          "value": 0.789
        },
        "yOuter": {
          "value": 0.258
        },
        "xOuter": {
          "value": 60.148
        },
        "rotation": {
          "value": -0.07
        },
        "wobble": {
          "value": 1.29
        }
      },
      {
        "zoom": {
          "value": 2.275
        },
        "ballSize": {
          "value": 0.489
        },
        "contrast": {
          "value": 1.133
        },
        "radius": {
          "value": 0.789
        },
        "yOuter": {
          "value": 2.32
        },
        "xOuter": {
          "value": 20.4
        },
        "rotation": {
          "value": 0
        },
        "wobble": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fff",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.224
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca012",
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale =2.5;\nconst float shell = .1243;\nconst float carve = .8393;\nconst float falloff = 3.1;\nconst float blend = .22;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n  float stream = stream / .5;\n    vec3 pp = p;\n    float d = 10.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 4.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -=  .025 + .505 * (.01*cos(.5 + .1 * sin(i * PI + i / PI)));\n        d = smin(d, abs(mul*sin(dot(p, p)/30.*.00001030215*shape*dot(1.2*cos(stream/-5. + p),2.*cos(stream/2.5*shape2 - p.yzx)))*scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    // d += abs(.1 - .25 * cos(p.z/zid+stream*warpSpeed)) * cos(1./length(p)/.92+stream*warpSpeed);\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(3.51,-0.5);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n  float stream = stream / .5;\n    // coordinates\n    vec2 uv = k_uv() * zoom;\n    vec3 ray = normalize(vec3(uv, -0.0014325));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 10.;\n    const float count = 10.;\n    for (float index = count; index > 0.; --index)\n    {\n        pos += ray*map(pos);\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.3*normal;\n    float backLight = dot(normal, vec3(-1,-.5,.5))*.25+.25;\n    float bottomLight = 1.*dot(normal, vec3(0,-1,-2))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*20.-stream/10. * pow(5.*volume, .9)*sin(.00015*length(.5*uv))- stream/15.);\n    color += pow(volume, .5)*vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002
        },
        "warpSpeed": {
          "value": 2.439
        },
        "mul": {
          "value": 1531.318
        },
        "zid": {
          "value": 36.043
        },
        "shape": {
          "value": 1.481
        },
        "shape2": {
          "value": 0.317
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02c",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv); \n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.72
        },
        "yDivider": {
          "value": 99.63
        },
        "xDivider": {
          "value": 0.33
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.182
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 3.01
        },
        "xOuter": {
          "value": 2.47
        },
        "yOuter": {
          "value": 0.21
        },
        "xDiv": {
          "value": 26.512
        },
        "xDiv2": {
          "value": 0.321
        },
        "warp": {
          "value": 9.129
        }
      },
      {
        "zoom": {
          "value": 1.22
        },
        "yDivider": {
          "value": 99.63
        },
        "xDivider": {
          "value": 0.33
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.129
        },
        "contrast": {
          "value": 1.02
        },
        "radius": {
          "value": 3.01
        },
        "xOuter": {
          "value": 1.12
        },
        "yOuter": {
          "value": 0.15
        },
        "xDiv": {
          "value": 53.776
        },
        "xDiv2": {
          "value": 0.12
        },
        "warp": {
          "value": 1.121
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca038",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * sin( .001 * dot(uv, uv) + stream/5.) * sin(.0001 * dot(uv, uv)-stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * cos(t+stream/-10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 27.12
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 1.52
        },
        "radius": {
          "value": 3.73
        },
        "colorShift": {
          "value": 26.54
        },
        "div": {
          "value": 29.235
        },
        "div2": {
          "value": 28.885
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca045",
    "shader": "#define orbs 12.\n\nconst vec3 TEENAGE_DREAM[6] = vec3[6](\n  vec3(0.51,0.816,0.855),\n  vec3(0.78,0.886,0.8),\n  vec3(0.596,0.749,0.863),\n  vec3(0.337,0.475,0.604),\n  vec3(0.416,0.369,0.592),\n  vec3(0.631,0.278,0.451)\n);\n\nconst vec3 NEVER_REALLY_OVER[6] = vec3[6](\n  vec3(0.996,0.737,0.114),\n  vec3(0.98,0.576,0.204),\n  vec3(0.631,0.278,0.451),\n  vec3(0.306,0.702,0.843),\n  vec3(0.596,0.749,0.863),\n  vec3(0.988,0.937,0.824)\n);\n\nconst vec3 WAKING_UP_IN_VEGAS[6] = vec3[6](\n  vec3(0.737,0.235,0.216),\n  vec3(0.518,0.231,0.251), \n  vec3(0.925,0.812,0.761),\n  vec3(0.988,0.855,0.537),\n  vec3(0.98,0.576,0.204),\n  vec3(0.631,0.278,0.451)\n);\n\n}\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n \tconst vec3 palette[6] = TEENAGE_DREAM;\n  float dist = length(uv);\n  gl_FragColor += .1 * vec4(palette[0], 1.);\n  vec2 _swirl = uv * k_rotate2d(sin(distMul * dist + stream/1.1) + rotation*stream/3.);\n  vec2 _warp = uv / dot(uv, uv);\n\tuv = k_swap(uv, _swirl, swirl, swirlTween, swirlTweenProgress);\n  uv = k_swap(uv, _warp, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) { \n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-3.);\n    uv.y += cos(cosMul *  uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = palette[int(i)];\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 9.18
        },
        "contrast": {
          "value": 2.03
        },
        "orbSize": {
          "value": 2.13
        },
        "radius": {
          "value": 5.23
        },
        "colorShift": {
          "value": 6.88
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0.19
        },
        "cosMul": {
          "value": 0.11
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 3.12
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": -0.8
        },
        "gloop": {
          "value": 0.0036
        },
        "yDivide": {
          "value": 2
        },
        "xDivide": {
          "value": 0.99
        },
        "swirl": {
          "value": false
        },
        "warp": {
          "value": false
        },
        "distMul": {
          "value": 0.67
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca047",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/41.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 20.75
        },
        "contrast": {
          "value": 0.96
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 3.65
        },
        "colorShift": {
          "value": 8.07
        },
        "div": {
          "value": 10.673
        },
        "div2": {
          "value": 16.837
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca055",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i <3.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.))* k_rotate2d(stream/-10.);;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-43.+uv.x/xDiv * sin(stream/5.4-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(1.11*uv.y/yDiv2+stream/21.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 38.853428263836605
        },
        "ballSize": {
          "value": 4.33719298581043
        },
        "contrast": {
          "value": 11.279379541655185
        },
        "radius": {
          "value": 13.15456667980516
        },
        "yOuter": {
          "value": 3.9243387612951808
        },
        "xOuter": {
          "value": 241
        },
        "xMultiplier": {
          "value": 0.18037186588149476
        },
        "yMultiplier": {
          "value": 22
        },
        "divider": {
          "value": 0.81470752394343
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 8.593662675604763
        },
        "yDiv2": {
          "value": 1.3630719655967622
        },
        "xDiv": {
          "value": 3.2700821658214894
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 97.72096903237953
        },
        "ballSize": {
          "value": 4.8438897006482975
        },
        "contrast": {
          "value": 5.919895493840597
        },
        "radius": {
          "value": 11.349076190626766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 89.56573143924577
        },
        "xMultiplier": {
          "value": 0.37678829330995867
        },
        "yMultiplier": {
          "value": 0.4365751059658557
        },
        "divider": {
          "value": 0.81470752394343
        },
        "rotation": {
          "value": 0.41953459130712306
        },
        "yDiv": {
          "value": 65.15596486286945
        },
        "yDiv2": {
          "value": 1
        },
        "xDiv": {
          "value": 2
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 24.11030300518538
        },
        "ballSize": {
          "value": 2.3485876726816937
        },
        "contrast": {
          "value": 11.279379541655185
        },
        "radius": {
          "value": 80.28082277918438
        },
        "yOuter": {
          "value": 3.9243387612951808
        },
        "xOuter": {
          "value": 241
        },
        "xMultiplier": {
          "value": 1
        },
        "yMultiplier": {
          "value": 3.899312461025745
        },
        "divider": {
          "value": 0.81470752394343
        },
        "rotation": {
          "value": 0.37987304365778546
        },
        "yDiv": {
          "value": 8.593662675604763
        },
        "yDiv2": {
          "value": 1.3630719655967622
        },
        "xDiv": {
          "value": 3.2700821658214894
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 21.858797666250947
        },
        "ballSize": {
          "value": 1.8032996763665994
        },
        "contrast": {
          "value": 15
        },
        "radius": {
          "value": 12.57758987610599
        },
        "yOuter": {
          "value": 0.8930718479386297
        },
        "xOuter": {
          "value": 241
        },
        "xMultiplier": {
          "value": 2
        },
        "yMultiplier": {
          "value": 5.592455407567772
        },
        "divider": {
          "value": 0.81470752394343
        },
        "rotation": {
          "value": 0.607568800592997
        },
        "yDiv": {
          "value": 6.869864084634437
        },
        "yDiv2": {
          "value": 322.07657191265065
        },
        "xDiv": {
          "value": 57.74705273731646
        },
        "xDiv2": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 301.28439117799326
        },
        "ballSize": {
          "value": 47.95304866928653
        },
        "contrast": {
          "value": 7.721214432314219
        },
        "radius": {
          "value": 24.617146076558566
        },
        "yOuter": {
          "value": 2.617563367712016
        },
        "xOuter": {
          "value": 3.853854627494353
        },
        "xMultiplier": {
          "value": 0.04411929946347892
        },
        "yMultiplier": {
          "value": 22
        },
        "divider": {
          "value": 0.8680771425545935
        },
        "rotation": {
          "value": 2.0988518404673386
        },
        "yDiv": {
          "value": 1.882273662521179
        },
        "yDiv2": {
          "value": 0.8095045618264072
        },
        "xDiv": {
          "value": 121.48361413062824
        },
        "xDiv2": {
          "value": 231918.70456432668
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca051",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0003 * dot(uv, uv) - stream) * sin(.00005 * dot(uv, uv)+stream/.98378);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 67.31
        },
        "contrast": {
          "value": 1.49
        },
        "orbSize": {
          "value": 0.93
        },
        "radius": {
          "value": 3.36
        },
        "colorShift": {
          "value": 15.2
        },
        "div": {
          "value": 12.15
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06c",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/21.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/21.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .7)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 31.68
        },
        "contrast": {
          "value": 1.03
        },
        "orbSize": {
          "value": 2
        },
        "radius": {
          "value": 13
        },
        "colorShift": {
          "value": 7.12
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 0.94
        },
        "yMul": {
          "value": 0.14
        },
        "xMul": {
          "value": 0.05
        },
        "xSpeed": {
          "value": -0.5
        },
        "ySpeed": {
          "value": 0.5
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 3.2
        },
        "xDivide": {
          "value": 2.08
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca080",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv) - stream)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  // uv /= dot(sin(uv+stream), cos(uv+stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 13.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 6000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 19.15
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 378.53
        },
        "ballSize": {
          "value": 0.87
        },
        "contrast": {
          "value": 1.77
        },
        "radius": {
          "value": 11.96
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.76
        },
        "_pow": {
          "value": 4.09
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08e",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = i/radius * tan(t + stream/6.) * sin(t-stream/3.);\n    float y = i/radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 1.)* orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 33.63
        },
        "contrast": {
          "value": 0.85
        },
        "orbSize": {
          "value": 0.29
        },
        "radius": {
          "value": 5.57
        },
        "colorShift": {
          "value": 12.71
        },
        "div": {
          "value": 9.908
        },
        "div2": {
          "value": 12.178
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca092",
    "shader": "precision highp float;\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv *=k_rotate2d(1.);\n  vec2 p = 1.3 / abs(vec2(1. / shape));\n  p /= abs(tan(sin(xShape * uv.x-stream) * (cos(yShape * uv.y - stream))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (time / 3.23 + colorShape * uv.x)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y - cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.b *= .42;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.032
        },
        "xShape": {
          "value": 11
        },
        "yShape": {
          "value": 11
        },
        "colorShape": {
          "value": 11
        },
        "contrast": {
          "value": 0.376
        },
        "ballSize": {
          "value": 1
        },
        "shape": {
          "value": 0.016
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09c",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 61.35
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.2
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0bb",
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.513
        },
        "contrast": {
          "value": 2.1
        },
        "ballSize": {
          "value": 0.0083
        },
        "radius": {
          "value": 105.45
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 1.61
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e5",
    "shader": "\n#define BALLS 10.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *=k_rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.896
        },
        "contrast": {
          "value": 1.51
        },
        "ballSize": {
          "value": 0.1211
        },
        "radius": {
          "value": 2.2
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 4.35
        },
        "sinMul": {
          "value": 2.8
        }
      },
      {
        "zoom": {
          "value": 23.182
        },
        "contrast": {
          "value": 1.99
        },
        "ballSize": {
          "value": 0.9576
        },
        "radius": {
          "value": 18
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 35.05
        },
        "sinMul": {
          "value": 2.8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e8",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2. * stream / 3. + log(.1 * abs(uv))));\n  uv *= k_rotate2d(dist - rotation - stream / .5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv)))) - stream / .5) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(t), sin(radius * t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5) * pow(dist, 2.) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.896
        },
        "contrast": {
          "value": 1.51
        },
        "ballSize": {
          "value": 0.1211
        },
        "radius": {
          "value": 2.2
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 4.35
        },
        "sinMul": {
          "value": 2.8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0eb",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n // uv = sin(stream*1.+(1.-log(sin(uv)))); \n // uv *=k_rotate2d(stream);\n  uv += sin(dotMultiplier*(cos(dot(abs(uv), log(abs(uv)))) - stream/1.));\n // uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = radius*vec2(tanMul*tan(t), sinMul*sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.778
        },
        "contrast": {
          "value": 5
        },
        "ballSize": {
          "value": 0.1491
        },
        "radius": {
          "value": 2.25
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 2.17
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0.9
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ed",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n // uv = sin(stream*1.+(1.-log(sin(uv)))); \n // uv *=k_rotate2d(stream);\n  uv += sin(dotMultiplier*(cos(dot(abs(uv), log(abs(uv)))) - stream/1.));\n // uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = radius*vec2(tanMul*tan(t), sinMul*sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.778
        },
        "contrast": {
          "value": 5
        },
        "ballSize": {
          "value": 0.1491
        },
        "radius": {
          "value": 2.25
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 2.17
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0.9
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca106",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/20. - i);\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/11.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .802716175) * orbSize, vec2(radius*abs(sin(stream/.3-uv.x/div)) * L * sin(stream - (-1. + 2. * vUv / resolution.xy).y), radius*cos(stream/11.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 571.305
        },
        "iterator": {
          "value": 0.518
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 24.905
        },
        "L": {
          "value": 4.002
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 1.791
        },
        "colorOffset": {
          "value": 22.942
        },
        "contrast": {
          "value": 2.614
        },
        "orbSize": {
          "value": 2.212
        },
        "div": {
          "value": 0.994
        },
        "radius": {
          "value": 5.661
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca10c",
    "shader": "\n\n#define BALLS 3\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.94
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 8.09
        },
        "colorSpread": {
          "value": 7
        },
        "colorMultiplier": {
          "value": 111.05
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f58",
    "shader": "\n\n#define BALLS 15\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/1.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/2.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.23
        },
        "xMultiplier": {
          "value": 29.96
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.68
        },
        "colorSpread": {
          "value": 1.79
        },
        "colorMultiplier": {
          "value": 383.24
        },
        "shapeMultiplier": {
          "value": 13.45
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 11.628
        },
        "brightness": {
          "value": 8078.46
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f61",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.55
        },
        "xMultiplier": {
          "value": 114.44
        },
        "yMultiplier": {
          "value": 102.79
        },
        "ballSize": {
          "value": 1.04
        },
        "colorSpread": {
          "value": 0.17
        },
        "colorMultiplier": {
          "value": 282.59
        },
        "shapeMultiplier": {
          "value": 210
        },
        "glow": {
          "value": 53480.75
        },
        "contrast": {
          "value": 4.57
        },
        "rotation": {
          "value": 3.784
        },
        "brightness": {
          "value": 4926.49
        },
        "sides": {
          "value": 6
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6c",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .7);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.3;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .9)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 14808.906439864471
        },
        "ballSize": {
          "value": 5646.8056502539575
        },
        "contrast": {
          "value": 1.4018456312432348
        },
        "radius": {
          "value": 20278.94704856131
        },
        "yOuter": {
          "value": 2184.1534747983637
        },
        "xOuter": {
          "value": 16.83638119010466
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.2490805134600906
        },
        "yMultiplier": {
          "value": 5.983607041324478
        },
        "divider": {
          "value": 2.87705232551299
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7a",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 43.29
        },
        "xDiv": {
          "value": 32.251
        },
        "yDiv": {
          "value": 1.558
        },
        "xDiv2": {
          "value": 0.606
        },
        "yDiv2": {
          "value": 3.463
        },
        "xDiv3": {
          "value": 19.048
        },
        "yDiv3": {
          "value": 5.277
        },
        "multiplier": {
          "value": 0.649
        },
        "ballSize": {
          "value": 19.697
        },
        "contrast": {
          "value": 2.234
        },
        "radius": {
          "value": 13.117
        },
        "rotation": {
          "value": 0.000242
        },
        "xMul": {
          "value": 0.346
        },
        "yMul": {
          "value": 3.29
        },
        "oY": {
          "value": 39.81
        },
        "oX": {
          "value": 5.455
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9d",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/23.);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream/5.), uv));\n  uv *= k_rotate2d(stream/-21.);\n  uv /= dot(tan(uv), cos(uv));\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/5.)-stream/9.);\n    float y = radius * cos(sin(t+stream/5.)+stream)/4.;\n    vec2 position = vec2(x, y);\n    vec3 color = col + cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 7.95
        },
        "contrast": {
          "value": 2.93
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 7.05
        },
        "center": {
          "value": 2.13
        },
        "sides": {
          "value": 8
        },
        "dotMul": {
          "value": 0.2
        },
        "sinMul": {
          "value": 10
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa8",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 24.7
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.204
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 2.6
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 0.394
        },
        "center": {
          "value": 13.273
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 11.101
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.003
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 4.625
        },
        "x1": {
          "value": 0.053
        },
        "x2": {
          "value": 1.82
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 3.72
        },
        "center": {
          "value": 3.859
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fab",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 24.7
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.204
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 2.6
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 0.394
        },
        "center": {
          "value": 13.273
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 11.101
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.003
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 4.625
        },
        "x1": {
          "value": 0.053
        },
        "x2": {
          "value": 1.82
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 3.72
        },
        "center": {
          "value": 3.859
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fbf",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = k_uv();\n          i *= zoom;\n\n    i *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      {
        "zoom": {
          "value": 0.033
        },
        "mul": {
          "value": 0.46
        },
        "rot": {
          "value": 489.87
        },
        "sub": {
          "value": 42.73
        },
        "A": {
          "value": 2.34
        },
        "B": {
          "value": 5.57
        },
        "C": {
          "value": 10.18
        },
        "D": {
          "value": 3.59
        },
        "dep": {
          "value": 0.11
        },
        "wap": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc7",
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/3.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 9.79
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe4",
    "shader": "#define orbs 15.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / -6.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (.3 + .22*sin(6.*cos(_uv.x/div2 + stream / 3.) * _uv.y/div - stream/1.19));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(.5*tan(t*PI), .5*sin(t/PI));\n    p /= sin(stream/1.+PI * sin(uv.x/x)*cos(stream+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1834.822
        },
        "ballSize": {
          "value": 0.036
        },
        "contrast": {
          "value": 4
        },
        "radius": {
          "value": 140.06
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50.41
        },
        "y": {
          "value": 85.83
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 915.9
        },
        "sides": {
          "value": 2
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 3785.106
        },
        "div2": {
          "value": 580.357
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9feb",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / -6.;\n  mat2 rotation = k_rotate2d(stream/(PI*2.));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.720) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.0015747364457831328
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 3.5794004141566274
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.7545274849397591
        },
        "colorOffset": {
          "value": 37.88460090361446
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.2960278614457832
        },
        "div": {
          "value": 0.03972143260542169
        },
        "radius": {
          "value": 1.8993411144578316
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6151637801204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 7.6585843373493985
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.07135316265060243
        },
        "radius": {
          "value": 2.93386671686747
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe8",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.5)/shape * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0015747364457831328
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 1.0034073795180722
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 13.64527014307229
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.7545274849397591
        },
        "colorOffset": {
          "value": 37.88460090361446
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.2960278614457832
        },
        "div": {
          "value": 0.03972143260542169
        },
        "radius": {
          "value": 1.8993411144578316
        },
        "shape": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6151637801204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 7.6585843373493985
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.07135316265060243
        },
        "radius": {
          "value": 2.93386671686747
        },
        "shape": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6268825301204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 8.869992469879518
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.5174934111445784
        },
        "orbSize": {
          "value": 0.732445406626506
        },
        "div": {
          "value": 0.20228308546686752
        },
        "radius": {
          "value": 2.93386671686747
        },
        "shape": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff5",
    "shader": "#define BALLS 10.\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *=k_rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.37
        },
        "ballSize": {
          "value": 0.13
        },
        "radius": {
          "value": 22.12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca014",
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 2.;\nconst float shell = .43;\nconst float carve = .3;\nconst float falloff = 2.8;\nconst float blend = .2;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 10.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 4.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -=  .025 + .205 * (.01*cos(.5 + .1 * sin(i * PI + i / PI)));\n        d = smin(d, abs(mul*sin(dot(p, p)/20.*.0000000215*dot(cos(stream + p),cos(stream - p.yzx)- stream))*scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += abs(.1 - .25 * cos(p.z/zid+stream*warpSpeed)) * cos(1./length(p)/.92+stream*warpSpeed);\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n    // coordinates\n    vec2 uv = k_uv() * zoom;\n    float dither = hash12(vUv);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 10.;\n    const float count = 12.;\n    for (float index = count; index > 0.; --index)\n    {\n        pos += ray*map(pos/3.);\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-stream);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.467
        },
        "warpSpeed": {
          "value": 0.041
        },
        "mul": {
          "value": 97.97
        },
        "zid": {
          "value": 1177.219
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca023",
    "shader": "mat2 r2d(in float degree) {\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p) {\n  p = vec2(dot(p, vec2(1227.1, 311.7)),\n    dot(p, vec2(269.5, 183.3)));\n\n  return -1. + 120. * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(1.));\n}\n\nfloat fbm(in vec2 p) {\n  mat2 rot = r2d(0.);\n  float d = noise(p);\n  p *= rot;\n  d += .625 * noise(p);\n\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale) {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  return uv;\n}\n\nvoid main() {\n  vec2 uv = mapToScreen(vUv / resolution.xy, zoom);\n  uv = uv * sin(1.14 * (dot(uv, uv)) - stream / 5.) + cos(sin(stream * .1) * (dot(uv, uv) * 2.) - stream * .391);;\n  float thicc = thickness * length(abs(uv)) / length(size * cos(uv + stream));\n  float d1 = abs(sin(stream + uv.x * (sin(stream / 8.)) * haze) * thicc * (cos(uv.x + stream) + fbm(uv + stream) * .023));\n  float d2 = abs(log(stream - yMul * uv.y * -haze) * thicc * (sin(xMul * uv.y - stream / 17.) * fbm(uv + stream * .987)));\n  float d3 = abs(.1 * cos(stream / 6. + (xMul * uv.x) - (yMul * uv.y)) * thicc / (1. - uv.x + log(uv.y) + fbm(uv - 1. * stream / 4.)));\n  vec3 col = vec3(.0) * haze;\n  col += d1 * size * abs(sin(col1 - stream / 5.));\n  col *= d2 * size * abs(cos(col2 - stream / 13.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.54
        },
        "thickness": {
          "value": 0.4587
        },
        "haze": {
          "value": 39.37
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 2.46
        },
        "yMul": {
          "value": 5.2
        },
        "xMul": {
          "value": 200
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca027",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.52
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02e",
    "shader": "#define BALLS 10.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/-8. - length(uv/warp) + (.25 + .25 * (.0015*dot(cos(length(uv) - stream/1.)/log(stream), -.5101*(stream)))));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/11.*sin(uv.y/yDivider - stream/10.) - sin(uv.x/xDiv - stream/21.);\n    uv.x += yOuter*float(i)/11.95*cos(uv.y/xDivider - stream/11.) - (.5 + .5 *cos(stream/2. - uv.x/xDiv2));\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec3 color = k_rainbow(i / BALLS, 1., 1.);\n    gl_FragColor += length(.5/uv) * k_orb(uv, volume*ballSize, vec2(t), color, contrast);\n    // gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.260)) / length(uv  * 0.9) * k_orb * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.77
        },
        "yDivider": {
          "value": 2.69
        },
        "xDivider": {
          "value": 2.21
        },
        "multiplier": {
          "value": 60.33
        },
        "ballSize": {
          "value": 0.201
        },
        "contrast": {
          "value": 0.92
        },
        "radius": {
          "value": 390.57
        },
        "xOuter": {
          "value": 11
        },
        "yOuter": {
          "value": 1.14
        },
        "xDiv": {
          "value": 1.327
        },
        "xDiv2": {
          "value": 4.538
        },
        "warp": {
          "value": 1.751
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca058",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(i) + stream;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 31. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 44
        },
        "ballSize": {
          "value": 3.888313376185406
        },
        "contrast": {
          "value": 15
        },
        "radius": {
          "value": 463.90730998946964
        },
        "yOuter": {
          "value": 2.6622053399143453
        },
        "xOuter": {
          "value": 119.49976394837165
        },
        "xMultiplier": {
          "value": 9.87278689648732
        },
        "yMultiplier": {
          "value": 2.2934277049604668
        },
        "divider": {
          "value": 1.8808178269719504
        },
        "rotation": {
          "value": 0.3062661228409733
        },
        "yDiv": {
          "value": 5.945459572665664
        },
        "yDiv2": {
          "value": 0.8229053796055806
        },
        "xDiv": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04f",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv - cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 8.24
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09e",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 20.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 66.15
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.29
        },
        "contrast": {
          "value": 2.07
        },
        "radius": {
          "value": 7.65
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0bf",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius*tan(t), radius*sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.26
        },
        "contrast": {
          "value": 6.4
        },
        "ballSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.54
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0.98
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d6",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 64.73
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 1.05
        },
        "radius": {
          "value": 11.83
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 17.328
        },
        "div2": {
          "value": 14.483
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d8",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 67.31
        },
        "contrast": {
          "value": 1.49
        },
        "orbSize": {
          "value": 1.05
        },
        "radius": {
          "value": 3.77
        },
        "colorShift": {
          "value": 23.99
        },
        "div": {
          "value": 17.974
        },
        "div2": {
          "value": 27.909
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0db",
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.67
        },
        "yDivider": {
          "value": 0.69
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 5.86
        },
        "ballSize": {
          "value": 0.39
        },
        "contrast": {
          "value": 0.87
        },
        "radius": {
          "value": 1.14
        },
        "rotation": {
          "value": 0.22587259377776392
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0.18
        },
        "c": {
          "value": 1.61
        },
        "d": {
          "value": 3.05
        },
        "e": {
          "value": 0.34
        },
        "f": {
          "value": 0.95
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0fc",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.688
        },
        "iterator": {
          "value": 1.043
        },
        "ot": {
          "value": 44.606
        },
        "I": {
          "value": 2.374
        },
        "J": {
          "value": 0.918
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 38
        },
        "L": {
          "value": 13
        },
        "M": {
          "value": 6.292
        },
        "colorShift": {
          "value": 0.768
        },
        "colorOffset": {
          "value": 21.783
        },
        "contrast": {
          "value": 1.612
        },
        "orbSize": {
          "value": 1
        },
        "div": {
          "value": 4.452
        },
        "radius": {
          "value": 0.727
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0fd",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  uv *= 2. * sin( length(uv) * .000091 * dot(uv, uv) + stream / 16. );\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 41.603
        },
        "iterator": {
          "value": 0.873
        },
        "ot": {
          "value": 79.283
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 3
        },
        "K": {
          "value": 111
        },
        "iterations": {
          "value": 16.982
        },
        "L": {
          "value": 0.906
        },
        "M": {
          "value": 2.962
        },
        "colorShift": {
          "value": 0.685
        },
        "colorOffset": {
          "value": 42.639
        },
        "contrast": {
          "value": 2.499
        },
        "orbSize": {
          "value": 3.026
        },
        "div": {
          "value": 3.848
        },
        "radius": {
          "value": 26.428
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca110",
    "shader": "\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\tuv = k_kale(uv, vec2(center), 12.);\n  uv *=k_rotate2d(stream/1.);//+ max((5.2*pow(volume, .2)), .001));\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.91
        },
        "xMultiplier": {
          "value": 20
        },
        "yMultiplier": {
          "value": 80.77
        },
        "ballSize": {
          "value": 6.38
        },
        "colorSpread": {
          "value": 7
        },
        "colorMultiplier": {
          "value": 98.61
        },
        "shapeMultiplier": {
          "value": 13.02
        },
        "glow": {
          "value": 597.16
        },
        "contrast": {
          "value": 3.75
        },
        "brightness": {
          "value": 14.91
        },
        "center": {
          "value": 0.2
        },
        "granularity": {
          "value": 51.47
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6e",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .7);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.48;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t), radius *\ncos(t + yMultiplier + -1. + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 1. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.6)/8.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2162.18
        },
        "ballSize": {
          "value": 823.2115042224565
        },
        "contrast": {
          "value": 1.5036299622317397
        },
        "radius": {
          "value": 7099.501722680518
        },
        "yOuter": {
          "value": 23.179561450268853
        },
        "xOuter": {
          "value": 30.54
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.1705011261755147
        },
        "yMultiplier": {
          "value": 10.696722047001483
        },
        "divider": {
          "value": 8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7d",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom + (zoom * .5 * sin(stream / 15.));\n  uv *= k_rotate2d(stream/10.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / -1.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 2.) - sin(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 68.065
        },
        "xDiv": {
          "value": 13.853
        },
        "yDiv": {
          "value": 2.857
        },
        "xDiv2": {
          "value": 2.597
        },
        "yDiv2": {
          "value": 2.424
        },
        "xDiv3": {
          "value": 27.706
        },
        "yDiv3": {
          "value": 17.13
        },
        "multiplier": {
          "value": 1.779
        },
        "ballSize": {
          "value": 1.818
        },
        "contrast": {
          "value": 1.61
        },
        "radius": {
          "value": 1.271
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 24.589
        },
        "yMul": {
          "value": 4.329
        },
        "oY": {
          "value": 80
        },
        "oX": {
          "value": 32.035
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8b",
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.135
        },
        "iterator": {
          "value": 1.071
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 18.705
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f93",
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.831
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.685
        },
        "radius": {
          "value": 2.435
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f97",
    "shader": "#define orbs 35.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.94
        },
        "contrast": {
          "value": 2.34
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb6",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd9",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 0.4) * _uv.y/div - stream/-.25));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*sin(t + stream), radius*cos(t - stream));\n    p /= (cos(wad * cos(stream/-.2 - uv.x/x))+sin(stream/-.635- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 175436.315
        },
        "ballSize": {
          "value": 5124.44
        },
        "contrast": {
          "value": 2.8
        },
        "radius": {
          "value": 6991118.11
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 25909282.53
        },
        "y": {
          "value": 8873738.81
        },
        "rotation": {
          "value": 0.0029
        },
        "colorOffset": {
          "value": 1412.22
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 5736.673
        },
        "div2": {
          "value": 556866.94
        },
        "wad": {
          "value": 14.718
        },
        "woot": {
          "value": 0.153
        },
        "wat": {
          "value": 1.428
        },
        "wob": {
          "value": 34.031
        },
        "outer": {
          "value": 120.684
        },
        "outer2": {
          "value": 46.748
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 15914.588
        },
        "ballSize": {
          "value": 99.53
        },
        "contrast": {
          "value": 2.7
        },
        "radius": {
          "value": 1400070.68
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 122414.56
        },
        "y": {
          "value": 79591.9
        },
        "rotation": {
          "value": 0.00386
        },
        "colorOffset": {
          "value": 1971.97
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 7434.224
        },
        "div2": {
          "value": 121617.307
        },
        "wad": {
          "value": 2.126
        },
        "woot": {
          "value": 0.596
        },
        "wat": {
          "value": 1.423
        },
        "wob": {
          "value": 14.902
        },
        "outer": {
          "value": 152.317
        },
        "outer2": {
          "value": 56.629
        },
        "wave": {
          "value": 1.816
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff1",
    "shader": "\n#define BALLS 10.\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *=k_rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.37
        },
        "ballSize": {
          "value": 0.13
        },
        "radius": {
          "value": 22.12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ffa",
    "shader": "void main() { \n  float stream = stream / 30.;\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv + sin(uv * cos(uv/4.) - stream)); \n  float rot = rotation * dist;\n  uv *= k_rotate2d(stream / 01. - rot); \n  float a = cos(yOuter * uv.y);\n  vec2 p = vec2(xOuter * uv.x, 0.)* a ;\n  vec3 col = k_rainbow(uv.x, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 11.481706626506025
        },
        "ballSize": {
          "value": 2.5316243222891566
        },
        "contrast": {
          "value": 0.8430481927710848
        },
        "radius": {
          "value": 80.945502090338
        },
        "yOuter": {
          "value": 2.32
        },
        "xOuter": {
          "value": 20.4
        },
        "rotation": {
          "value": 0
        },
        "wobble": {
          "value": 0.44281228863406596
        }
      },
      {
        "zoom": {
          "value": 5.1897103915662655
        },
        "ballSize": {
          "value": 2.5316243222891566
        },
        "contrast": {
          "value": 0.8430481927710848
        },
        "radius": {
          "value": 80.945502090338
        },
        "yOuter": {
          "value": 2.32
        },
        "xOuter": {
          "value": 20.4
        },
        "rotation": {
          "value": 0.05237339984939761
        },
        "wobble": {
          "value": 0.30741622740963853
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ffd",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 26.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider; // + stream/50.;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = 1.-pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.224
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01c",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 6;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/2.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n2); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,-n1); if (t>0.0) { z-=120.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(TTIME/2. - .001*length(p) -1.12*p.x/2.-atan(p.y/10.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(01. *sin(TTIME/2.+length(p/PI)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.))+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/2.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/2.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =11.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/1.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p)) + TTIME/2.10;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.667
        },
        "size": {
          "value": 5.11
        },
        "offc": {
          "value": 0
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 5.085
        },
        "_x": {
          "value": 0.425
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03c",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv - 10.*cos( .005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 21.18
        },
        "contrast": {
          "value": 0.8
        },
        "orbSize": {
          "value": 0.2
        },
        "radius": {
          "value": 6.65
        },
        "colorShift": {
          "value": 9.24
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03d",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  float div = 25.;\n  const float radius = 1000.;\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/20. - stream);\n    uv.y += cos((i+1.)*uv.x/20. + stream);\n    float t = i * PI / orbs;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/2.1);\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, 1.1, position, color, 1.2);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 30
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 0.65
        },
        "colorShift": {
          "value": 13.76
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca060",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 2.1 * uv) - stream);\n  //  uv /= sin(.01*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.45
        },
        "contrast": {
          "value": 1.71
        },
        "orbSize": {
          "value": 0.19
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.35
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca065",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= .5 * sin(.005 * dot(uv, uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 2.;\n    float x = radius * tan(dist * t + stream) * sin(dist);\n    float y = radius * cos(dist * t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 1.01
        },
        "orbSize": {
          "value": 0.2
        },
        "radius": {
          "value": 3.9
        },
        "colorShift": {
          "value": 7.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca076",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "contrast": {
          "value": 0.89
        },
        "orbSize": {
          "value": 0.66
        },
        "radius": {
          "value": 12.33
        },
        "colorShift": {
          "value": 9.55
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.7
        },
        "cosMul": {
          "value": 0.98
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.57
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0048
        },
        "yDivide": {
          "value": 4.98
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca078",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/2.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.06
        },
        "yDivider": {
          "value": 818.46
        },
        "xDivider": {
          "value": 656.67
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 2.03
        },
        "radius": {
          "value": 26.22
        },
        "yOuter": {
          "value": 0.12
        },
        "xOuter": {
          "value": 0.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07e",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      },
      {
        "zoom": {
          "value": 4.94
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 0.14
        },
        "contrast": {
          "value": 2.49
        },
        "radius": {
          "value": 0.75
        },
        "yOuter": {
          "value": 0.1
        },
        "xOuter": {
          "value": 0.21
        },
        "rotation": {
          "value": 2.52
        }
      },
      {
        "zoom": {
          "value": 43.23
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1
        },
        "contrast": {
          "value": 2.56
        },
        "radius": {
          "value": 8.11
        },
        "yOuter": {
          "value": 0.32
        },
        "xOuter": {
          "value": 0.04
        },
        "rotation": {
          "value": 3.28
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca085",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca087",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/14.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 73.49
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.98
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.72
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 16.002
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca088",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 1.7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 24.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.32
        },
        "radius": {
          "value": 4.75
        },
        "colorShift": {
          "value": 12.71
        },
        "div": {
          "value": 10
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca096",
    "shader": "\n#define orbs 40.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n  return v ? uv2 : uv;\n}\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv))/ dist + (tatumStream + beatStream)  / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < orbs; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor +=   barVolume * vec4(pow(tatumVolume ,1.5)  * orbsize / length(uv + p *(spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor= vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 1583.68
        },
        "spreadMultiplier": {
          "value": 1.913
        },
        "rotation": {
          "value": 50
        },
        "xMultiplier": {
          "value": 369.731
        },
        "yMultiplier": {
          "value": 403.636
        },
        "colorSpread": {
          "value": 0.00007
        },
        "invert": {
          "value": false
        },
        "orbsize": {
          "value": 35.636
        },
        "contrast": {
          "value": 1.258
        },
        "radius": {
          "value": 9.636
        },
        "sides": {
          "value": 7
        },
        "kaleidoscope": {
          "value": false
        },
        "aSpeed": {
          "value": -10
        },
        "bSpeed": {
          "value": 8.3
        },
        "sinMul": {
          "value": -0.109
        },
        "cosMul": {
          "value": 0.055
        },
        "rippleSpeed": {
          "value": -20
        },
        "wobbleSpeed": {
          "value": 4.145
        },
        "swirl": {
          "value": -0.5
        },
        "energy": {
          "value": 1.1
        },
        "punch": {
          "value": 1
        },
        "borderSpeed": {
          "value": 616.364
        },
        "hueShift": {
          "value": -31.964
        },
        "colorMultiplier": {
          "value": 0.0034
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a2",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 61.35
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.2
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b9",
    "shader": "#define BALLS 20.\n  \n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ca",
    "shader": "#define BALLS 5\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= primaryZoom;\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *=k_rotate2d(stream/-12. + length(cos(uv))/-1.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/.5);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/550. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 2.0) * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "shapeMultiplier": {
          "value": 125.89
        },
        "rotation": {
          "value": 0.67548
        },
        "xMultiplier": {
          "value": 51.4
        },
        "yMultiplier": {
          "value": 164.79
        },
        "colorSpread": {
          "value": 0.000081
        },
        "colorMultiplier": {
          "value": 2
        },
        "brightness": {
          "value": 3.34
        },
        "ballSize": {
          "value": 16.18
        },
        "glow": {
          "value": 1.44
        },
        "contrast": {
          "value": 1.5
        },
        "radius": {
          "value": 10.23
        },
        "invert": {
          "value": false
        },
        "primaryZoom": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 0.031
        },
        "shapeMultiplier": {
          "value": 114.61
        },
        "rotation": {
          "value": 0.67548
        },
        "xMultiplier": {
          "value": 799.82
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.000081
        },
        "colorMultiplier": {
          "value": 0.88
        },
        "brightness": {
          "value": 3.34
        },
        "ballSize": {
          "value": 9.02
        },
        "glow": {
          "value": 1.44
        },
        "contrast": {
          "value": 1.5
        },
        "radius": {
          "value": 10.23
        },
        "invert": {
          "value": false
        },
        "primaryZoom": {
          "value": 0.39
        }
      },
      {
        "zoom": {
          "value": 0.028
        },
        "shapeMultiplier": {
          "value": 590.39
        },
        "rotation": {
          "value": 2.31062
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 321.66
        },
        "colorSpread": {
          "value": 0.000043
        },
        "colorMultiplier": {
          "value": 2
        },
        "brightness": {
          "value": 1.77
        },
        "ballSize": {
          "value": 23.87
        },
        "glow": {
          "value": 1.44
        },
        "contrast": {
          "value": 2.43
        },
        "radius": {
          "value": 0.5
        },
        "invert": {
          "value": false
        },
        "primaryZoom": {
          "value": 0.46
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0da",
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.67
        },
        "yDivider": {
          "value": 0.69
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 5.86
        },
        "ballSize": {
          "value": 0.39
        },
        "contrast": {
          "value": 0.87
        },
        "radius": {
          "value": 1.14
        },
        "rotation": {
          "value": 0.22587259377776392
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0.18
        },
        "c": {
          "value": 1.61
        },
        "d": {
          "value": 3.05
        },
        "e": {
          "value": 0.34
        },
        "f": {
          "value": 0.95
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ee",
    "shader": "\n#define BALLS 10.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *=k_rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.896
        },
        "contrast": {
          "value": 1.51
        },
        "ballSize": {
          "value": 0.1211
        },
        "radius": {
          "value": 2.2
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 4.35
        },
        "sinMul": {
          "value": 2.8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca105",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/121.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    ot = M * dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .7175) * orbSize, vec2(radius*abs(tan(stream/1.3+uv.x/div)) * L * sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(-1. + 2. * vUv / resolution.xy));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.066
        },
        "iterator": {
          "value": 1.614
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.139
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 20
        },
        "L": {
          "value": 1.457
        },
        "M": {
          "value": 0.358
        },
        "colorShift": {
          "value": 1.645
        },
        "colorOffset": {
          "value": 44.956
        },
        "contrast": {
          "value": 0.965
        },
        "orbSize": {
          "value": 0.413
        },
        "div": {
          "value": 1.487
        },
        "radius": {
          "value": 7.992
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca109",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  uv *= k_rotate2d(stream/-2.);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * vUv / resolution.xy)/2.)+ stream/3.);\n  float ot = ot;\n  uv = k_kale(uv, vec2(0.), 3.);\n  uv *= k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 7763.719
        },
        "iterator": {
          "value": 0.259
        },
        "ot": {
          "value": 99.903
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.987
        },
        "K": {
          "value": 58.378
        },
        "iterations": {
          "value": 10.467
        },
        "L": {
          "value": 187.608
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 1.01
        },
        "colorOffset": {
          "value": 35.208
        },
        "contrast": {
          "value": 0.996
        },
        "orbSize": {
          "value": 0.53
        },
        "div": {
          "value": 0.564
        },
        "radius": {
          "value": 0.196
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6a",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .5);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.7;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.6)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 208050.8613461032
        },
        "ballSize": {
          "value": 46674.3601778991
        },
        "contrast": {
          "value": 0.7017193147590363
        },
        "radius": {
          "value": 333232
        },
        "yOuter": {
          "value": 684.2579981174699
        },
        "xOuter": {
          "value": 27.236858339608442
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.7860331325301209
        },
        "yMultiplier": {
          "value": 19.24
        },
        "divider": {
          "value": 4.888253012048193
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f71",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  //uv /= dot(uv, uv);\n // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter*(atan(uv.x+stream))*uv.x+radius*tan(t+xMultiplier+stream), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "ballSize": {
          "value": 0.047
        },
        "contrast": {
          "value": 4.47
        },
        "radius": {
          "value": 0.33
        },
        "yOuter": {
          "value": 12.71
        },
        "xOuter": {
          "value": 15.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.68
        },
        "yMultiplier": {
          "value": 9.62
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f74",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .7) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 64.629
        },
        "xDiv": {
          "value": 196.985
        },
        "yDiv": {
          "value": 1.915
        },
        "xDiv2": {
          "value": 2.349
        },
        "yDiv2": {
          "value": 92.714
        },
        "xDiv3": {
          "value": 89.609
        },
        "yDiv3": {
          "value": 1.918
        },
        "multiplier": {
          "value": 0.88
        },
        "ballSize": {
          "value": 3.665
        },
        "contrast": {
          "value": 2.575
        },
        "radius": {
          "value": 2.781
        },
        "rotation": {
          "value": 0.000032
        },
        "xMul": {
          "value": 1.153
        },
        "yMul": {
          "value": 7.296
        },
        "oY": {
          "value": 14.593
        },
        "oX": {
          "value": 3.208
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa4",
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 22.345463102409646
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 2.404405120481928
        },
        "x2": {
          "value": 0.8480045180722893
        },
        "y1": {
          "value": 0.41
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 6.943693524096386
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.35281795933734944
        },
        "radius": {
          "value": 1.463413027108434
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0
        },
        "x2": {
          "value": 0.07756023333999278
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 3.9954113328313263
        },
        "center": {
          "value": 9.759704442771085
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 20.516971009036148
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.6914401355421687
        },
        "radius": {
          "value": 1.0743787650602412
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.006485316265060244
        },
        "x2": {
          "value": 0.39095914909638557
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 0.29673381024096396
        },
        "center": {
          "value": 2.7102409638554223
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fae",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.79
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 2
        },
        "radius": {
          "value": 8.15
        },
        "colorShift": {
          "value": 4
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.45
        },
        "cosMul": {
          "value": 0.98
        },
        "yMul": {
          "value": 0.5
        },
        "xMul": {
          "value": 0.57
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0048
        },
        "yDivide": {
          "value": 1.13
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fbd",
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.78
        },
        "ballSize": {
          "value": 0.811
        },
        "contrast": {
          "value": 6.18
        },
        "radius": {
          "value": 0.37
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 55.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.14
        },
        "yMultiplier": {
          "value": 5.19
        },
        "divider": {
          "value": 4
        },
        "rotation": {
          "value": 0.0576
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd6",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.101);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/.5295 - t*PI), radius*tan(t - stream/.4));\n    p /= (cos(wad * cos(stream/-.83 - uv.x/x))*sin(stream/-.35- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 565165.39186
        },
        "ballSize": {
          "value": 4482.02508
        },
        "contrast": {
          "value": 2.1075
        },
        "radius": {
          "value": 21662190.72162
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 453727305.7104
        },
        "y": {
          "value": 3069728.03718
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1485.37
        },
        "sides": {
          "value": 2.09639
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 17284.96846
        },
        "div2": {
          "value": 688250.07416
        },
        "wad": {
          "value": 27.299
        },
        "woot": {
          "value": 0.18
        },
        "wat": {
          "value": 0.174
        },
        "wob": {
          "value": 43.234
        },
        "outer": {
          "value": 76.693
        },
        "outer2": {
          "value": 17.019
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 530156.163
        },
        "ballSize": {
          "value": 247.533
        },
        "contrast": {
          "value": 3.21
        },
        "radius": {
          "value": 4177483.47
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 13745054.8
        },
        "y": {
          "value": 1553415.58
        },
        "rotation": {
          "value": 0.00319
        },
        "colorOffset": {
          "value": 2099.71
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 32307.371
        },
        "div2": {
          "value": 408995.916
        },
        "wad": {
          "value": 34.823
        },
        "woot": {
          "value": 0.556
        },
        "wat": {
          "value": 0.121
        },
        "wob": {
          "value": 48.389
        },
        "outer": {
          "value": 13.813
        },
        "outer2": {
          "value": 1.099
        },
        "wave": {
          "value": 1
        },
        "aWave": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 265211.762
        },
        "ballSize": {
          "value": 222.169
        },
        "contrast": {
          "value": 3.39
        },
        "radius": {
          "value": 1787836.23
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 10007048.42
        },
        "y": {
          "value": 2998103.64
        },
        "rotation": {
          "value": 0.00323
        },
        "colorOffset": {
          "value": 2789.01
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 34777.356
        },
        "div2": {
          "value": 276101.35
        },
        "wad": {
          "value": 25.891
        },
        "woot": {
          "value": 0.773
        },
        "wat": {
          "value": 0.176
        },
        "wob": {
          "value": 48.531
        },
        "outer": {
          "value": 20.254
        },
        "outer2": {
          "value": 1.007
        },
        "wave": {
          "value": 1
        },
        "aWave": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fdf",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.101);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/.5295 - t*PI), radius*tan(t - stream/.4));\n    p /= (cos(wad * cos(stream/-.83 - uv.x/x))*sin(stream/-.35- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 189685.229
        },
        "ballSize": {
          "value": 1334.245
        },
        "contrast": {
          "value": 3.12
        },
        "radius": {
          "value": 3571727.6
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 13845195.75
        },
        "y": {
          "value": 5685594.69
        },
        "rotation": {
          "value": 0.0038
        },
        "colorOffset": {
          "value": 2110
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 12632.124
        },
        "div2": {
          "value": 116199.582
        },
        "wad": {
          "value": 8.073
        },
        "woot": {
          "value": 0.18
        },
        "wat": {
          "value": 0.174
        },
        "wob": {
          "value": 43.234
        },
        "outer": {
          "value": 76.693
        },
        "outer2": {
          "value": 17.019
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 530156.163
        },
        "ballSize": {
          "value": 247.533
        },
        "contrast": {
          "value": 3.21
        },
        "radius": {
          "value": 4177483.47
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 13745054.8
        },
        "y": {
          "value": 1553415.58
        },
        "rotation": {
          "value": 0.00319
        },
        "colorOffset": {
          "value": 2099.71
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 32307.371
        },
        "div2": {
          "value": 408995.916
        },
        "wad": {
          "value": 34.823
        },
        "woot": {
          "value": 0.556
        },
        "wat": {
          "value": 0.121
        },
        "wob": {
          "value": 48.389
        },
        "outer": {
          "value": 13.813
        },
        "outer2": {
          "value": 1.099
        },
        "wave": {
          "value": 1
        },
        "aWave": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 265211.762
        },
        "ballSize": {
          "value": 222.169
        },
        "contrast": {
          "value": 3.39
        },
        "radius": {
          "value": 1787836.23
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 10007048.42
        },
        "y": {
          "value": 2998103.64
        },
        "rotation": {
          "value": 0.00323
        },
        "colorOffset": {
          "value": 2789.01
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 34777.356
        },
        "div2": {
          "value": 276101.35
        },
        "wad": {
          "value": 25.891
        },
        "woot": {
          "value": 0.773
        },
        "wat": {
          "value": 0.176
        },
        "wob": {
          "value": 48.531
        },
        "outer": {
          "value": 20.254
        },
        "outer2": {
          "value": 1.007
        },
        "wave": {
          "value": 1
        },
        "aWave": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff3",
    "shader": "#define BALLS 10.\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= k_rotate2d(float(i));\n    //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream / 10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15) * dist * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.37
        },
        "ballSize": {
          "value": 0.13
        },
        "radius": {
          "value": 22.12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca017",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 12;\n\n#define PHI   PI - atan(1./PI, sqrt(PI))\n#define TAU   2. * PI\n#define TTIME (stream/15.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(PI,-PI,1.0));\nconst vec3 n2 = n1 * normalize(vec3(PI/2.,-PHI,PHI-1.0));\nconst vec3 n3 = n2 / normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=1.25*PI*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=PI*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=1.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=1.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.5/_z, .5*_x) * dot(z*vec3(size,0.,.2),plnormal);\n        \n  dmin = abs(dmin) - width*0.05*(0.105 + 0.05-sin(length(p) - p.y - TTIME/2.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 10.0;\n  float off = 0.7  + 0.525*(0.0625 + 3.5*cos(stream/20. - length(p) - length(.5*sin(stream/12.1-dot(p, p)/10. - stream/20.)-PI*sin(stream/4. + p))));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = ip;\n    rot(ip, TTIME/2.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(.33))), -.5);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 1.0)/r;\n  col *= vec3(1.0 - .009*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =100.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + .5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*tan(d - 0.050) - stream/10.04));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/1.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.059
        },
        "size": {
          "value": 0.8
        },
        "offc": {
          "value": 1.831
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 0.003
        },
        "_x": {
          "value": 0.003
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca028",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.54
        },
        "yDivider": {
          "value": 67.32
        },
        "xDivider": {
          "value": 0.48
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.101
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 9.38
        },
        "xOuter": {
          "value": 2.47
        },
        "yOuter": {
          "value": 0.21
        },
        "xDiv": {
          "value": 26.512
        },
        "xDiv2": {
          "value": 0.321
        },
        "warp": {
          "value": 321
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca037",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.83206
        },
        "contrast": {
          "value": 1.3
        },
        "orbSize": {
          "value": 0.67
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 9.96
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 1
        },
        "xMul": {
          "value": 4.91
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0049
        },
        "yDivide": {
          "value": 5.34
        },
        "xDivide": {
          "value": 1.73
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca036",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .00001 * dot(uv, uv) + stream/1.) * sin(.001 * dot(uv, uv)+stream/.5);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 79.62
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.61
        },
        "radius": {
          "value": 6.7
        },
        "colorShift": {
          "value": 23.39
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca043",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0003 * dot(uv, uv) - stream) * sin(.00005 * dot(uv, uv)+stream/.98378);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 67.31
        },
        "contrast": {
          "value": 1.49
        },
        "orbSize": {
          "value": 0.93
        },
        "radius": {
          "value": 3.36
        },
        "colorShift": {
          "value": 15.2
        },
        "div": {
          "value": 12.15
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca056",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i <3.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.))* k_rotate2d(stream/-10.);;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-43.+uv.x/xDiv * sin(stream/5.4-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(1.11*uv.y/yDiv2+stream/21.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 301.28439117799326
        },
        "ballSize": {
          "value": 47.95304866928653
        },
        "contrast": {
          "value": 7.721214432314219
        },
        "radius": {
          "value": 24.617146076558566
        },
        "yOuter": {
          "value": 2.617563367712016
        },
        "xOuter": {
          "value": 3.853854627494353
        },
        "xMultiplier": {
          "value": 0.04411929946347892
        },
        "yMultiplier": {
          "value": 22
        },
        "divider": {
          "value": 0.8680771425545935
        },
        "rotation": {
          "value": 2.0988518404673386
        },
        "yDiv": {
          "value": 1.882273662521179
        },
        "yDiv2": {
          "value": 0.8095045618264072
        },
        "xDiv": {
          "value": 121.48361413062824
        },
        "xDiv2": {
          "value": 231918.70456432668
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca070",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 39.53
        },
        "contrast": {
          "value": 1.07
        },
        "orbSize": {
          "value": 1.3
        },
        "radius": {
          "value": 11.24
        },
        "colorShift": {
          "value": 28.21
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 417.56
        },
        "sinMul": {
          "value": 1.52
        },
        "cosMul": {
          "value": 0.63
        },
        "yMul": {
          "value": 0.13
        },
        "xMul": {
          "value": 0.88
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.001
        },
        "yDivide": {
          "value": 3.1
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07f",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09a",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  uv = abs(uv);\n\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 620.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .162 * float(i) * cos(uv.y / yDivider - stream / 110.) + sin(uv.x / 10. - stream / 112.);\n    uv.x += .52 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider) - sin(uv.y / 10.);\n    float t = .005 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 50.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 415. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 49.16
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 10.18
        },
        "multiplier": {
          "value": 1
        },
        "ballSize": {
          "value": 6.43
        },
        "contrast": {
          "value": 2.02
        },
        "radius": {
          "value": 8.25
        },
        "rotation": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ad",
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.513
        },
        "contrast": {
          "value": 2.1
        },
        "ballSize": {
          "value": 0.0083
        },
        "radius": {
          "value": 105.45
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 1.61
        }
      },
      {
        "zoom": {
          "value": 0.478
        },
        "contrast": {
          "value": 6.22
        },
        "ballSize": {
          "value": 0.0472
        },
        "radius": {
          "value": 0.77
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 0.19
        }
      },
      {
        "zoom": {
          "value": 0.288
        },
        "contrast": {
          "value": 3.31
        },
        "ballSize": {
          "value": 0.031
        },
        "radius": {
          "value": 500
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 6.94
        },
        "sinMul": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.451
        },
        "contrast": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.0084
        },
        "radius": {
          "value": 126.91
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0
        },
        "sinMul": {
          "value": 2.6
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 5.36
        },
        "ballSize": {
          "value": 0.0409
        },
        "radius": {
          "value": 500
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 1.36
        },
        "sinMul": {
          "value": 0.81
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d2",
    "shader": "#define BALLS 15\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *=k_rotate2d(stream/-2. + length(cos(uv-stream/3.)));\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.1
        },
        "shapeMultiplier": {
          "value": 30.11
        },
        "rotation": {
          "value": 0.0195
        },
        "xMultiplier": {
          "value": 376.89
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.000114
        },
        "colorMultiplier": {
          "value": 2
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 3.34
        },
        "ballSize": {
          "value": 17.33
        },
        "glow": {
          "value": 2.39
        },
        "contrast": {
          "value": 1.5
        },
        "radius": {
          "value": 10.09
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ea",
    "shader": "#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv += sin(+((uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.777
        },
        "contrast": {
          "value": 2.28
        },
        "ballSize": {
          "value": 0.0329
        },
        "radius": {
          "value": 1
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 0.31
        },
        "tanMul": {
          "value": 10
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f9",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 66.929
        },
        "iterator": {
          "value": 1.01
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 33
        },
        "L": {
          "value": 3
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.636
        },
        "colorOffset": {
          "value": 25.259
        },
        "contrast": {
          "value": 1.999
        },
        "orbSize": {
          "value": 2.746
        },
        "div": {
          "value": 1
        },
        "radius": {
          "value": 18.203
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca104",
    "shader": "void main () {\n float stream = stream / .8; \n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.172716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}  ",
    "variants": [
      {
        "zoom": {
          "value": 4.203
        },
        "iterator": {
          "value": 1.478
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 5.27
        },
        "L": {
          "value": 1.935
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.497
        },
        "colorOffset": {
          "value": 57.701
        },
        "contrast": {
          "value": 1.434
        },
        "orbSize": {
          "value": 3.433
        },
        "div": {
          "value": 3.159
        },
        "radius": {
          "value": 16.167
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca10a",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv += (uv) * iterator - 1.;\n    uv *= rotation;\n    ot = dot(uv, uv) - tan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.0569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.2970175) * orbSize, vec2(radius*(tan(stream/-2.+uv.x/div)) * sin(stream/2. - uv.y + (-1. + 2. * vUv / resolution.xy).x), radius*cos(stream/-4.+(-1. + 2. * vUv / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 22.765
        },
        "iterator": {
          "value": 0.303
        },
        "ot": {
          "value": 29.633
        },
        "I": {
          "value": 0.698
        },
        "J": {
          "value": 0.918
        },
        "K": {
          "value": 2.848
        },
        "iterations": {
          "value": 20.511
        },
        "L": {
          "value": 4.722
        },
        "M": {
          "value": 2.962
        },
        "colorShift": {
          "value": 16.221
        },
        "colorOffset": {
          "value": 8.706
        },
        "contrast": {
          "value": 1.706
        },
        "orbSize": {
          "value": 2.042
        },
        "div": {
          "value": 9.935
        },
        "radius": {
          "value": 34.129
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f56",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * _dist * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, abs(uv), float(warpTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = abs(uv);\n  }\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 220. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.xyz += lightness;\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n  gl_FragColor.r *= r;\n  gl_FragColor.g *= g;\n  gl_FragColor.b *= b;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.3
        },
        "xMultiplier": {
          "value": 200
        },
        "yMultiplier": {
          "value": 48.06
        },
        "ballSize": {
          "value": 1.8
        },
        "colorSpread": {
          "value": 0.1
        },
        "colorMultiplier": {
          "value": 519.17
        },
        "shapeMultiplier": {
          "value": 1111
        },
        "glow": {
          "value": 10000
        },
        "contrast": {
          "value": 4.47
        },
        "rotation": {
          "value": 0.051
        },
        "brightness": {
          "value": 4872.2
        },
        "sides": {
          "value": 6
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        },
        "lightness": {
          "value": 0.63
        },
        "r": {
          "value": 0.55
        },
        "g": {
          "value": 0.03
        },
        "b": {
          "value": 0.2
        },
        "center": {
          "value": 0.04
        },
        "_dist": {
          "value": 0.0009
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f57",
    "shader": "#define BALLS 25\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv *= zoom;\n  uv *= log(dot(uv, uv));\n  uv = normalize(uv) * length(uv);\n  uv *= k_rotate2d(rotation/70.*-stream);\n  uv *= a * sin(b * dot(uv, uv) - stream);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/1.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n  uv *= k_rotate2d(rotation + (log(1./dist) - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) + stream/120.;\n    vec2 p = vec2(c * sin(e * t), c * cos(d * t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (false) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.018
        },
        "xMultiplier": {
          "value": 405.818
        },
        "yMultiplier": {
          "value": 90.078
        },
        "ballSize": {
          "value": 17.164
        },
        "colorSpread": {
          "value": 0.00464
        },
        "colorMultiplier": {
          "value": 282.111
        },
        "shapeMultiplier": {
          "value": 210
        },
        "glow": {
          "value": 9132.468
        },
        "contrast": {
          "value": 5.259
        },
        "rotation": {
          "value": -79.338
        },
        "brightness": {
          "value": 7282.753
        },
        "sides": {
          "value": 17.461
        },
        "a": {
          "value": 139.761
        },
        "b": {
          "value": 182.954
        },
        "c": {
          "value": 34.444
        },
        "d": {
          "value": 8.097
        },
        "e": {
          "value": 3.383
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f94",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  float dist = length(uv);\n  uv *= k_rotate2d(.42*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(-stream/.6);\n  uv += cos(dotMul*dot(uv + sinMul*sin(uv+stream/.241), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(cos(t-stream)-stream/2.);\n    float y = radius * cos(sin(t+stream/2.)+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, (orbSize)*volume, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.542
        },
        "contrast": {
          "value": 2.541
        },
        "orbSize": {
          "value": 1.086
        },
        "radius": {
          "value": 6.138
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 3.853
        },
        "sides": {
          "value": 8
        },
        "dotMul": {
          "value": 0.524
        },
        "sinMul": {
          "value": 3.923
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f95",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.411
        },
        "contrast": {
          "value": 2.19
        },
        "orbSize": {
          "value": 0.573
        },
        "radius": {
          "value": 2.499
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 3.248
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.388
        },
        "sinMul": {
          "value": 6.426
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9c",
    "shader": "\n#define orbs 35.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5.94
        },
        "contrast": {
          "value": 2.34
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa7",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 1.2967;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .7)*orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 26.54
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 5.39
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb2",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb3",
    "shader": "\n#define orbs 20.\n\n   \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= k_rotate2d(stream/3.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/15.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 5.87
        },
        "contrast": {
          "value": 2.25
        },
        "orbSize": {
          "value": 0.67
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 6.72
        },
        "x1": {
          "value": 0.71
        },
        "x2": {
          "value": 0.24
        },
        "y1": {
          "value": 0.23
        },
        "y2": {
          "value": 1.83
        },
        "center": {
          "value": 4.27
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd3",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(cos(sin(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv += (i+1.)/10.;\n      uv *= k_rotate2d(i+stream/4.);\n      uv.x /= abs(dist+distMul* dist*(i+1.));\n      float t = (i) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);// / cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// + sin(t-stream/1.) - cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.39
        },
        "contrast": {
          "value": 1.81
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 2.51
        },
        "colorShift": {
          "value": 9.12
        },
        "distMul": {
          "value": 0.00668
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe0",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/9.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(wat*tan(stream/1.28295 - t*PI), cos(t - stream/2.5));\n    p /= (cos(wad * cos(stream/6. - uv.x/x))*sin(stream/-.5- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 435915.092
        },
        "ballSize": {
          "value": 250.873
        },
        "contrast": {
          "value": 2.51
        },
        "radius": {
          "value": 1718856.72
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 4037425.8
        },
        "y": {
          "value": 2271711.24
        },
        "rotation": {
          "value": 0.00028
        },
        "colorOffset": {
          "value": 1525.71
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 17650.456
        },
        "div2": {
          "value": 692166.125
        },
        "wad": {
          "value": 22.423
        },
        "woot": {
          "value": 0.117
        },
        "wat": {
          "value": 0.917
        },
        "wob": {
          "value": 44.093
        },
        "outer": {
          "value": 9.645
        },
        "outer2": {
          "value": 1.282
        }
      },
      {
        "zoom": {
          "value": 530156.163
        },
        "ballSize": {
          "value": 247.533
        },
        "contrast": {
          "value": 3.21
        },
        "radius": {
          "value": 4177483.47
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 13745054.8
        },
        "y": {
          "value": 1553415.58
        },
        "rotation": {
          "value": 0.00319
        },
        "colorOffset": {
          "value": 2099.71
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 32307.371
        },
        "div2": {
          "value": 408995.916
        },
        "wad": {
          "value": 34.823
        },
        "woot": {
          "value": 0.556
        },
        "wat": {
          "value": 0.121
        },
        "wob": {
          "value": 48.389
        },
        "outer": {
          "value": 13.813
        },
        "outer2": {
          "value": 1.099
        }
      },
      {
        "zoom": {
          "value": 265211.762
        },
        "ballSize": {
          "value": 222.169
        },
        "contrast": {
          "value": 3.39
        },
        "radius": {
          "value": 1787836.23
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 10007048.42
        },
        "y": {
          "value": 2998103.64
        },
        "rotation": {
          "value": 0.00323
        },
        "colorOffset": {
          "value": 2789.01
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 34777.356
        },
        "div2": {
          "value": 276101.35
        },
        "wad": {
          "value": 25.891
        },
        "woot": {
          "value": 0.773
        },
        "wat": {
          "value": 0.176
        },
        "wob": {
          "value": 48.531
        },
        "outer": {
          "value": 20.254
        },
        "outer2": {
          "value": 1.007
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe2",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.9);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/2.5295 - t*PI), radius*tan(t - stream/.34));\n    p /= (cos(wad * cos(stream/-10.83 - uv.x/x))*sin(stream/-.835- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 4033.844
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 7666579.57
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 9489403.83
        },
        "y": {
          "value": 15865507.96
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fef",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-30.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5) * orbSize, vec2(radius*abs(tan(stream/1.3+uv.x/div)) * L * sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.104
        },
        "iterator": {
          "value": 1.31
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.139
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 20
        },
        "L": {
          "value": 1.457
        },
        "M": {
          "value": 0.358
        },
        "colorShift": {
          "value": 0.572
        },
        "colorOffset": {
          "value": 23.207
        },
        "contrast": {
          "value": 1.392
        },
        "orbSize": {
          "value": 0.647
        },
        "div": {
          "value": 0.735
        },
        "radius": {
          "value": 7.992
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca000",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.518
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca001",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.224
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca011",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = k_uv();\n  vec2 _uv = uv;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream) - sin(uv.x/xDiv - stream/3.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/20. + .01*uv))*cos(uv.x/xDiv - stream/3.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/10.- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 53.73293577243752
        },
        "yDivider": {
          "value": 2.1694277108433737
        },
        "xDivider": {
          "value": 4.430280496987952
        },
        "multiplier": {
          "value": 1.2283603162650605
        },
        "ballSize": {
          "value": 7.5453642695783145
        },
        "contrast": {
          "value": 0.6708647402108434
        },
        "radius": {
          "value": 128.25703125
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 151.80625
        },
        "xDiv2": {
          "value": 15.67018542921687
        },
        "itY": {
          "value": 0.1551346009036145
        },
        "itX": {
          "value": 0.09707172439759039
        },
        "oS": {
          "value": 0.249378765060241
        },
        "oT": {
          "value": 0.6427899096385543
        }
      },
      {
        "zoom": {
          "value": 45.72914495481928
        },
        "yDivider": {
          "value": 2.160560993975904
        },
        "xDivider": {
          "value": 5.3695877259036155
        },
        "multiplier": {
          "value": 1.7478256777108436
        },
        "ballSize": {
          "value": 14.114923757530121
        },
        "contrast": {
          "value": 1.367424698795181
        },
        "radius": {
          "value": 46.70274849397591
        },
        "rotation": {
          "value": 0.2937717432228916
        },
        "xDiv": {
          "value": 4.192112198795181
        },
        "yDiv": {
          "value": 3.116528614457832
        },
        "xDiv2": {
          "value": 1.7964278990963858
        },
        "itY": {
          "value": 0.7522778614457832
        },
        "itX": {
          "value": 0.019126506024096393
        },
        "oS": {
          "value": 1
        },
        "oT": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca041",
    "shader": "\n#define orbs 20.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 7.398509653019611
        },
        "contrast": {
          "value": 1.7564941541932788
        },
        "orbSize": {
          "value": 3
        },
        "radius": {
          "value": 2.380929656167552
        },
        "colorShift": {
          "value": 10.95
        },
        "div": {
          "value": 15.427
        },
        "div2": {
          "value": 32.974
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03e",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/41.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 20.75
        },
        "contrast": {
          "value": 0.96
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 3.65
        },
        "colorShift": {
          "value": 8.07
        },
        "div": {
          "value": 10.673
        },
        "div2": {
          "value": 16.837
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca050",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .00005 * dot(uv, uv) + stream/3.) * sin(.0001 * dot(uv, uv)-stream/6.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 91.99
        },
        "contrast": {
          "value": 1.25
        },
        "orbSize": {
          "value": 1.11
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 23.45
        },
        "div": {
          "value": 45.722
        },
        "div2": {
          "value": 63.807
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca066",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.41
        },
        "contrast": {
          "value": 1.32
        },
        "orbSize": {
          "value": 0.36
        },
        "radius": {
          "value": 4.94
        },
        "colorShift": {
          "value": 6.24
        },
        "outer": {
          "value": 2.78
        },
        "inner": {
          "value": 0.03
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08c",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * 2.*cos( .0005 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t + stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 16.43
        },
        "contrast": {
          "value": 1.05
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 2.71
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 36.913
        },
        "div2": {
          "value": 36.105
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09d",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  uv = abs(uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .12 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += 1.02 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 210. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 45. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 46.25
        },
        "yDivider": {
          "value": 244.25
        },
        "xDivider": {
          "value": 352.43
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.7
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 23.3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e0",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / .7;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream/2.))/2. + stream/5.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 1.5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream/2.), radius * sin(sinMul * t + stream/2.));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .2)/1.5 * pow(dist, 1.) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.501
        },
        "contrast": {
          "value": 1.194
        },
        "ballSize": {
          "value": 0.191
        },
        "radius": {
          "value": 2.021
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 10
        },
        "dotMultiplier": {
          "value": 2.794
        },
        "tanMul": {
          "value": 18.7
        },
        "sinMul": {
          "value": 13.724
        },
        "shift": {
          "value": 0.824
        },
        "offset": {
          "value": 1.751
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e7",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv = sin(stream*1.+(1.-log(sin(uv))));\n  // uv *= k_rotate2d(stream);\n  uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 1.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t), sinMul * sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.778
        },
        "contrast": {
          "value": 5
        },
        "ballSize": {
          "value": 0.1491
        },
        "radius": {
          "value": 2.25
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 2.17
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0.9
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e9",
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv += sin(+((uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.777
        },
        "contrast": {
          "value": 2.28
        },
        "ballSize": {
          "value": 0.0329
        },
        "radius": {
          "value": 1
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 0.31
        },
        "tanMul": {
          "value": 10
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f8",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  uv = abs(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    uv.x += .5*tan((-1. + 2. * vUv / resolution.xy).x) * iterator - 1.;\n    uv.y += sinMul * sin(stream+uv.x) * iterator + 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .82716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 122
        },
        "iterator": {
          "value": 1.01
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 33
        },
        "L": {
          "value": 3
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.636
        },
        "colorOffset": {
          "value": 25.259
        },
        "contrast": {
          "value": 1.987
        },
        "orbSize": {
          "value": 6.079
        },
        "div": {
          "value": 7.216
        },
        "radius": {
          "value": 26.903
        },
        "sinMul": {
          "value": 0.5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0fa",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  uv *= outer * sin( length(uv) * inner * dot(uv, uv) + stream / 16. );\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    gl_FragColor += k_orb(uv, orbSize, vec2(x, y),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.795
        },
        "iterator": {
          "value": 1.102
        },
        "ot": {
          "value": 97.06010404603832
        },
        "I": {
          "value": 0.839
        },
        "J": {
          "value": 0.808
        },
        "K": {
          "value": 93.01354204390226
        },
        "iterations": {
          "value": 24.216
        },
        "L": {
          "value": 9.481
        },
        "M": {
          "value": 2.446
        },
        "colorShift": {
          "value": 1.029
        },
        "colorOffset": {
          "value": 22.942
        },
        "contrast": {
          "value": 2.666
        },
        "orbSize": {
          "value": 0.706
        },
        "div": {
          "value": 1
        },
        "radius": {
          "value": 1.775
        },
        "inner": {
          "value": 0.00061
        },
        "outer": {
          "value": 1.074
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0fb",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.585
        },
        "iterator": {
          "value": 1.05
        },
        "ot": {
          "value": 65.885
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 3
        },
        "K": {
          "value": 4.685
        },
        "iterations": {
          "value": 11.987
        },
        "L": {
          "value": 28.663
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.372
        },
        "colorOffset": {
          "value": 51.908
        },
        "contrast": {
          "value": 1.873
        },
        "orbSize": {
          "value": 2.733
        },
        "div": {
          "value": 1.567
        },
        "radius": {
          "value": 7.052
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca102",
    "shader": "void main () {\n  float stream = stream / volumeDivider;\n  vec2 uv = k_uv();\nuv *= zoom;\n  uv *= k_rotate2d(stream/-3.);\n  uv = abs(uv);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * vUv / resolution.xy)/12.)+ stream/3.);\n  uv *= k_rotate2d(stream/31.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    vec2 position = vec2(x, y);\n    gl_FragColor += k_orb(uv, pow(volume, reactivity) * orbSize, position,  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.971
        },
        "iterator": {
          "value": 0.33
        },
        "ot": {
          "value": 99.903
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.987
        },
        "K": {
          "value": 58.378
        },
        "iterations": {
          "value": 3.892
        },
        "L": {
          "value": 187.608
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 0.382
        },
        "colorOffset": {
          "value": 7.804
        },
        "contrast": {
          "value": 1.503
        },
        "orbSize": {
          "value": 0.873
        },
        "div": {
          "value": 0.185
        },
        "radius": {
          "value": 0.097
        },
        "sides": {
          "value": 8
        },
        "reactivity": {
          "value": 0
        },
        "volumeDivider": {
          "value": 1.763
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca108",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/10.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - tan(length(-1. + 2. * vUv / resolution.xy) / L + stream/.0569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.0175) * orbSize, vec2(radius*(tan(stream/-2.+uv.x/div)) * sin(stream/2. - uv.y + (-1. + 2. * vUv / resolution.xy).x), radius*cos(stream/-4.+(-1. + 2. * vUv / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}     ",
    "variants": [
      {
        "zoom": {
          "value": 13
        },
        "iterator": {
          "value": 1.347
        },
        "ot": {
          "value": 70.614
        },
        "I": {
          "value": 0.416
        },
        "J": {
          "value": 0.918
        },
        "K": {
          "value": 10.77
        },
        "iterations": {
          "value": 123.282
        },
        "L": {
          "value": 5.129
        },
        "M": {
          "value": 6.292
        },
        "colorShift": {
          "value": 9.244
        },
        "colorOffset": {
          "value": 1.432
        },
        "contrast": {
          "value": 1.486
        },
        "orbSize": {
          "value": 5.173
        },
        "div": {
          "value": 9.935
        },
        "radius": {
          "value": 12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f63",
    "shader": "void main () {\n  float stream = stream / 45.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = .2 * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.15496988641210352
        },
        "xMultiplier": {
          "value": 16.201666413640403
        },
        "yMultiplier": {
          "value": 15.621596795323384
        },
        "ballSize": {
          "value": 4.67
        },
        "colorSpread": {
          "value": 5.31327548107469
        },
        "colorMultiplier": {
          "value": 159.33728218170538
        },
        "shapeMultiplier": {
          "value": 13.20382188544216
        },
        "glow": {
          "value": 18444.68
        },
        "contrast": {
          "value": 3.8245473654873408
        },
        "brightness": {
          "value": 11.161348291603918
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 42.21581365746188
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6d",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.8), radius *\ncos(.1 * dist * yOuter * uv.x / 3.5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .21)/3.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.467786754929877
        },
        "ballSize": {
          "value": 0.17738216905708776
        },
        "contrast": {
          "value": 2.8809567326924888
        },
        "radius": {
          "value": 0.4156118107071843
        },
        "yOuter": {
          "value": 17.969914545633713
        },
        "xOuter": {
          "value": 27.03570903824037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.0018560335090365
        },
        "yMultiplier": {
          "value": 5.055801225041768
        },
        "divider": {
          "value": 6.095766072100905
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6f",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x + stream)) * uv.x + radius * tan(t + xMultiplier + stream), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "ballSize": {
          "value": 0.047
        },
        "contrast": {
          "value": 4.47
        },
        "radius": {
          "value": 0.33
        },
        "yOuter": {
          "value": 12.71
        },
        "xOuter": {
          "value": 15.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.68
        },
        "yMultiplier": {
          "value": 9.62
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f89",
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.135
        },
        "iterator": {
          "value": 1.071
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 18.705
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8d",
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.199
        },
        "contrast": {
          "value": 1.262
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 0.825
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.43
        },
        "colorOffset": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.307
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 2.979
        },
        "colorShift": {
          "value": 0
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 4.12
        }
      },
      {
        "zoom": {
          "value": 0.145
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 8.789
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 1.277
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 5
        },
        "b": {
          "value": 0.19
        },
        "c": {
          "value": 1.77
        },
        "d": {
          "value": 0.47
        },
        "colorOffset": {
          "value": 2.06
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.994
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.8
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      },
      {
        "zoom": {
          "value": 0.089
        },
        "contrast": {
          "value": 0.617
        },
        "orbSize": {
          "value": 0.993
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.227
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 0
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f96",
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.831
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.685
        },
        "radius": {
          "value": 2.435
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9a",
    "shader": "#define orbs 35.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5.94
        },
        "contrast": {
          "value": 2.34
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9b",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 10
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 1.76
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9f",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .9) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.509076148343374
        },
        "orbSize": {
          "value": 0.5489348644578315
        },
        "radius": {
          "value": 4.144187123493976
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9faa",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.78
        },
        "contrast": {
          "value": 1.06
        },
        "orbSize": {
          "value": 0.36
        },
        "radius": {
          "value": 3.52
        },
        "colorShift": {
          "value": 4.45
        },
        "x1": {
          "value": 0.4
        },
        "x2": {
          "value": 0.21
        },
        "y1": {
          "value": 0.55
        },
        "y2": {
          "value": 1.62
        },
        "center": {
          "value": 11
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb9",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/30.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/50.);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 9.75
        },
        "contrast": {
          "value": 1.72
        },
        "orbSize": {
          "value": 0.54
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4
        },
        "x1": {
          "value": 0.22
        },
        "x2": {
          "value": 0.38
        },
        "y1": {
          "value": 0.22
        },
        "y2": {
          "value": 1.03
        },
        "center": {
          "value": 3.95
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fba",
    "shader": "#define orbs 20.\n\n   \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= k_rotate2d(stream/13.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 26.95
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.24
        },
        "radius": {
          "value": 11.34
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.64
        },
        "x2": {
          "value": 0.34
        },
        "y1": {
          "value": 0.41
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fbe",
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.78
        },
        "ballSize": {
          "value": 0.811
        },
        "contrast": {
          "value": 6.18
        },
        "radius": {
          "value": 0.37
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 55.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.14
        },
        "yMultiplier": {
          "value": 5.19
        },
        "divider": {
          "value": 4
        },
        "rotation": {
          "value": 0.0576
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc6",
    "shader": "#define orbs 20.\n\n  void main () {\n    float stream = stream / 10.;\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/.45));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-2.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, .8)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 5.366905120481928
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.14320511015827703
        },
        "radius": {
          "value": 5.42
        },
        "colorShift": {
          "value": 4
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00e",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / 2.5;\n  \n  vec2 uv = k_uv();\n  vec2 _uv = uv;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/1.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4.3 + .01*uv))*cos(uv.x/xDiv - stream/1.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/.812 + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/1.94+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 53.73293577243752
        },
        "yDivider": {
          "value": 2.1694277108433737
        },
        "xDivider": {
          "value": 4.430280496987952
        },
        "multiplier": {
          "value": 1.2283603162650605
        },
        "ballSize": {
          "value": 16.450013944327118
        },
        "contrast": {
          "value": 1.6010978582267232
        },
        "radius": {
          "value": 170.7015577201384
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 151.80625
        },
        "xDiv2": {
          "value": 15.67018542921687
        },
        "itY": {
          "value": 0.1551346009036145
        },
        "itX": {
          "value": 0.09707172439759039
        },
        "oS": {
          "value": 0.249378765060241
        },
        "oT": {
          "value": 0.6427899096385543
        },
        "yShape": {
          "value": 4.247590361445784
        }
      },
      {
        "zoom": {
          "value": 32.46323842243976
        },
        "yDivider": {
          "value": 2.951618975903615
        },
        "xDivider": {
          "value": 0.42119728915662663
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 21.58139118975904
        },
        "contrast": {
          "value": 1.1464503012048195
        },
        "radius": {
          "value": 165.77595067771088
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 23.026562500000004
        },
        "xDiv2": {
          "value": 33
        },
        "itY": {
          "value": 0.041319008087971405
        },
        "itX": {
          "value": 0
        },
        "oS": {
          "value": 0
        },
        "oT": {
          "value": 1.8478727409638558
        },
        "yShape": {
          "value": 25.166716867469884
        }
      },
      {
        "zoom": {
          "value": 25.434176863704824
        },
        "yDivider": {
          "value": 2.951618975903615
        },
        "xDivider": {
          "value": 0.42119728915662663
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 17.750080007530123
        },
        "contrast": {
          "value": 1.1464503012048195
        },
        "radius": {
          "value": 182.8381259412651
        },
        "rotation": {
          "value": 0.2845297439759037
        },
        "xDiv": {
          "value": 1
        },
        "yDiv": {
          "value": 0
        },
        "xDiv2": {
          "value": 33
        },
        "itY": {
          "value": 0
        },
        "itX": {
          "value": 0
        },
        "oS": {
          "value": 0
        },
        "oT": {
          "value": 0.9522213855421688
        },
        "yShape": {
          "value": 17.82530120481928
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02a",
    "shader": "#define BALLS 9.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  uv *= k_rotate2d(stream/34. + length(uv/warp));\n  uv.x += sin(uv.y/4. - stream/2.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\tuv.y += xOuter*i/50.*sin(uv.y/yDivider) + sin(uv.x/xDiv - stream/9.05);\n    uv.x += yOuter*i*cos(uv.y/xDivider) * cos(uv.x/xDiv2 - stream/-1.95);\n    float t = float(i) * PI / BALLS * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.x + stream)*cos(uv.y - stream));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.75
        },
        "yDivider": {
          "value": 4390.12
        },
        "xDivider": {
          "value": 0.44
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.03
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 2.64
        },
        "xOuter": {
          "value": 11
        },
        "yOuter": {
          "value": 0.23
        },
        "xDiv": {
          "value": 98.024
        },
        "xDiv2": {
          "value": 0.905
        },
        "warp": {
          "value": 5.826
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ffc",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.224
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca033",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * outer*cos( .00001 * dot(uv, uv) - stream/4.) + uv.x / 1110. * sin(11.01 * dot(uv, uv)-stream/1.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize * pow(volume, 3.5), position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 91.91
        },
        "contrast": {
          "value": 1.26
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 8.07
        },
        "div": {
          "value": 18.147
        },
        "div2": {
          "value": 16.837
        },
        "warp": {
          "value": false
        },
        "outer": {
          "value": 0.448
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05f",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.7
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.97
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 7.15
        },
        "outer": {
          "value": 4.79
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca064",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 20000.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.03
        },
        "contrast": {
          "value": 1.32
        },
        "orbSize": {
          "value": 0.35
        },
        "radius": {
          "value": 2.62
        },
        "colorShift": {
          "value": 10
        },
        "outer": {
          "value": 1.43
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca069",
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 6.7
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.97
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 7.15
        },
        "outer": {
          "value": 4.79
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08b",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 18.41
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 0.7
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 10.119
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08f",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * 2.*cos( .0005 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t + stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 16.43
        },
        "contrast": {
          "value": 1.05
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 2.71
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 36.913
        },
        "div2": {
          "value": 36.105
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca098",
    "shader": "\n#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n  return v ? uv2 : uv;\n}\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv))/ dist + (tatumStream + beatStream)  / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < orbs; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor +=   barVolume * vec4(pow(tatumVolume ,1.5)  * orbsize / length(uv + p *(spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor= vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 1583.68
        },
        "spreadMultiplier": {
          "value": 1.913
        },
        "rotation": {
          "value": 50
        },
        "xMultiplier": {
          "value": 369.731
        },
        "yMultiplier": {
          "value": 403.636
        },
        "colorSpread": {
          "value": 0.00007
        },
        "invert": {
          "value": false
        },
        "orbsize": {
          "value": 35.636
        },
        "contrast": {
          "value": 1.258
        },
        "radius": {
          "value": 9.636
        },
        "sides": {
          "value": 7
        },
        "kaleidoscope": {
          "value": false
        },
        "aSpeed": {
          "value": -10
        },
        "bSpeed": {
          "value": 8.3
        },
        "sinMul": {
          "value": -0.109
        },
        "cosMul": {
          "value": 0.055
        },
        "rippleSpeed": {
          "value": -20
        },
        "wobbleSpeed": {
          "value": 4.145
        },
        "swirl": {
          "value": -0.5
        },
        "energy": {
          "value": 1.1
        },
        "punch": {
          "value": 1
        },
        "borderSpeed": {
          "value": 616.364
        },
        "hueShift": {
          "value": -31.964
        },
        "colorMultiplier": {
          "value": 0.0034
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a1",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .02 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .02 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 210. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 45. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 36.26
        },
        "yDivider": {
          "value": 244.25
        },
        "xDivider": {
          "value": 352.43
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.32
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 4.74
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c1",
    "shader": "\n#define BALLS 20.\n  \n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d3",
    "shader": "#define BALLS 15\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *=k_rotate2d(stream/-3. + length(3.*cos(uv-stream/4.))/2.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.014
        },
        "shapeMultiplier": {
          "value": 259.21
        },
        "rotation": {
          "value": 0.02567
        },
        "xMultiplier": {
          "value": 734.64
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.000012
        },
        "colorMultiplier": {
          "value": 0.51
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.86
        },
        "ballSize": {
          "value": 14.39
        },
        "glow": {
          "value": 3.79
        },
        "contrast": {
          "value": 2.15
        },
        "radius": {
          "value": 19.16
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d5",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 88.11
        },
        "yDivider": {
          "value": 1
        },
        "xDivider": {
          "value": 111
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 1.69
        },
        "contrast": {
          "value": 1.66
        },
        "radius": {
          "value": 26.57
        }
      },
      {
        "zoom": {
          "value": 51
        },
        "yDivider": {
          "value": 9.97
        },
        "xDivider": {
          "value": 1.2
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 1.41
        },
        "contrast": {
          "value": 2.45
        },
        "radius": {
          "value": 13.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f0",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/(PI*20.));\n  for (float i = 1.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= factor*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 943.691
        },
        "iterator": {
          "value": 0.727
        },
        "ot": {
          "value": 91.104
        },
        "I": {
          "value": 0.886
        },
        "J": {
          "value": 0.432
        },
        "K": {
          "value": 31.922
        },
        "iterations": {
          "value": 19.474
        },
        "L": {
          "value": 95.451
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 1.015
        },
        "colorOffset": {
          "value": 4.547
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 1.663
        },
        "div": {
          "value": 1
        },
        "radius": {
          "value": 2.561
        },
        "factor": {
          "value": 1.144
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca107",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5) * orbSize,vec2(radius*tan((-1. + 2. * vUv / resolution.xy).x/J), radius*cos((-1. + 2. * vUv / resolution.xy).y/J)),  col, contrast);\n  }\n            \n}",
    "variants": [
      {
        "zoom": {
          "value": 9.029
        },
        "iterator": {
          "value": 0.885
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 5.463
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 22.6
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.84
        },
        "colorOffset": {
          "value": 2.283
        },
        "contrast": {
          "value": 1.282
        },
        "orbSize": {
          "value": 0.051
        },
        "radius": {
          "value": 0.471
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca10e",
    "shader": "\n\n#define BALLS 5\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.64
        },
        "xMultiplier": {
          "value": 86.71
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 2.25
        },
        "colorSpread": {
          "value": 3.36
        },
        "colorMultiplier": {
          "value": 115.44
        },
        "shapeMultiplier": {
          "value": 13.45
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7f",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //uv = abs(uv);\n  uv *= k_rotate2d(stream/-18.);\n\n  uv /= dot(uv, uv) * .000051;\n    uv *= k_rotate2d(stream/4.);\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, .7)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 217.11219879518077
        },
        "xDiv": {
          "value": 11.463
        },
        "yDiv": {
          "value": 122.317
        },
        "xDiv2": {
          "value": 7.522
        },
        "yDiv2": {
          "value": 61.997364457831324
        },
        "xDiv3": {
          "value": 71.2262133177484
        },
        "yDiv3": {
          "value": 172.525
        },
        "multiplier": {
          "value": 1.3139213102409641
        },
        "ballSize": {
          "value": 48.01487198795182
        },
        "contrast": {
          "value": 1.4733810240963858
        },
        "radius": {
          "value": 18.079
        },
        "rotation": {
          "value": 0.00021564382530120485
        },
        "xMul": {
          "value": 0.0721009036144579
        },
        "yMul": {
          "value": 11.059770331325304
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f87",
    "shader": "void main () {\n  float stream =time + stream  / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .75)*orbSize/2.,vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.343208772590362
        },
        "iterator": {
          "value": 1.1237387048192773
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 5.251195406626508
        },
        "iterations": {
          "value": 23.76
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        },
        "orbSize": {
          "value": 0.071
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f80",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / 9.) - cos(uv.x / xDiv2 - stream / 2.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 3.) - sin(uv.y / yDiv2 + stream / -3.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier - sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 11.) - cos(uv.y / yDiv3 - stream / 3.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .7) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 35.244
        },
        "xDiv": {
          "value": 1.575
        },
        "yDiv": {
          "value": 10.112
        },
        "xDiv2": {
          "value": 2.393
        },
        "yDiv2": {
          "value": 2.499
        },
        "xDiv3": {
          "value": 4.24
        },
        "yDiv3": {
          "value": 7.423
        },
        "multiplier": {
          "value": 6.239
        },
        "ballSize": {
          "value": 0.71
        },
        "contrast": {
          "value": 2.763
        },
        "radius": {
          "value": 2.606
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 3.212
        },
        "yMul": {
          "value": 3.85
        },
        "oY": {
          "value": 43.987
        },
        "oX": {
          "value": 7.894
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f91",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.411
        },
        "contrast": {
          "value": 2.19
        },
        "orbSize": {
          "value": 0.573
        },
        "radius": {
          "value": 2.499
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 3.248
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.388
        },
        "sinMul": {
          "value": 6.426
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa9",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 30.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 50.);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 9.75
        },
        "contrast": {
          "value": 1.72
        },
        "orbSize": {
          "value": 0.54
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4
        },
        "x1": {
          "value": 0.22
        },
        "x2": {
          "value": 0.38
        },
        "y1": {
          "value": 0.22
        },
        "y2": {
          "value": 1.03
        },
        "center": {
          "value": 3.95
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc1",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.);\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 3.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = (vUv+(o-n)*.5)/n.y,\n          m       = mouse.xy/n*2.-1.;\n          \n    for (float a = 0.; a < 100.; a++) {\n        vec3 p = r*vec3(i*.35 - m*.05, 1.);\n        p.xy  *= mat2(cos(r*m.x*.07 + vec4(0,33,11,0)));\n        p.z   += stream*.6; p = abs(fract(p)-.5);            \n        r += t = (p.x + p.y + p.z - .12)*.6;        \n    }\n    tot += mix(.7 - vec3(r*r*2e-4), \n        1.5*cos(r*(vec3(5.7, 5.76, 5.82) + length(i))), \n        exp(-r*.07) * (1.2-length(i))); \n_AA_END \n} ",
    "variants": [
      {
        "zoom": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fdd",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-.9));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2394829.316
        },
        "ballSize": {
          "value": 15935.47
        },
        "contrast": {
          "value": 3.19
        },
        "radius": {
          "value": 44172853.06
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 27903685.31
        },
        "y": {
          "value": 119133112
        },
        "rotation": {
          "value": 0.00193
        },
        "colorOffset": {
          "value": 120.05
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 18285.392
        },
        "div2": {
          "value": 12263049.143
        },
        "wad": {
          "value": 1.996
        },
        "woot": {
          "value": 0.039
        },
        "wat": {
          "value": 0.085
        },
        "wob": {
          "value": 133.457
        },
        "outer": {
          "value": 92.935
        },
        "outer2": {
          "value": 0.759
        },
        "wave": {
          "value": 8.183
        },
        "aWave": {
          "value": 0.0211
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fde",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1276364.983
        },
        "ballSize": {
          "value": 5163.717
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 40414465.06
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 41792078.09
        },
        "y": {
          "value": 19133112
        },
        "rotation": {
          "value": 0.00271
        },
        "colorOffset": {
          "value": 275.47
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 55552.306
        },
        "div2": {
          "value": 916935.078
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe9",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.5)/4. * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0015747364457831328
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 1.0034073795180722
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 13.64527014307229
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.7545274849397591
        },
        "colorOffset": {
          "value": 37.88460090361446
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.2960278614457832
        },
        "div": {
          "value": 0.03972143260542169
        },
        "radius": {
          "value": 1.8993411144578316
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6151637801204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 7.6585843373493985
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.07135316265060243
        },
        "radius": {
          "value": 2.93386671686747
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6268825301204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 8.869992469879518
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.5174934111445784
        },
        "orbSize": {
          "value": 0.732445406626506
        },
        "div": {
          "value": 0.20228308546686752
        },
        "radius": {
          "value": 2.93386671686747
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff8",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(rotation + stream / PI * abs(fract(uv.x/900.) - .5)); \n  float a = cos(uv.y/yDiv - stream / .5);\n  vec2 p = vec2(xOuter * a * uv.x, 0.);\n  vec3 col = k_rainbow(.1 / orbs, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  \n  gl_FragColor.xyz = 1.-pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 9.468664021800219
        },
        "ballSize": {
          "value": 0.3929857680722893
        },
        "contrast": {
          "value": 0.6583855421686752
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 1.0946844879518074
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 1.5671875000000002
        },
        "rotation": {
          "value": 21.33717149849398
        },
        "yDiv": {
          "value": 0.274406061746988
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ffb",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.518
        },
        "ballSize": {
          "value": 1.838
        },
        "contrast": {
          "value": 1.666
        },
        "radius": {
          "value": 0.234
        },
        "yOuter": {
          "value": 0.086
        },
        "xOuter": {
          "value": 20.4
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 0.19
        },
        "rotation": {
          "value": 0.01
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca002",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.4)/7.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.031951807228918
        },
        "ballSize": {
          "value": 0.6445783132530122
        },
        "contrast": {
          "value": 2.8809567326924888
        },
        "radius": {
          "value": 0.14869879518072293
        },
        "yOuter": {
          "value": 17.969914545633713
        },
        "xOuter": {
          "value": 27.03570903824037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.0018560335090365
        },
        "yMultiplier": {
          "value": 19.24
        },
        "divider": {
          "value": 6.095766072100905
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00d",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, 1.4)/5000.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 36.947006777108435
        },
        "ballSize": {
          "value": 4.467959337349398
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 47.4550545933735
        },
        "yOuter": {
          "value": 6.027861445783134
        },
        "xOuter": {
          "value": 117.67243975903617
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.8636577560240974
        },
        "yMultiplier": {
          "value": 1.62468561746988
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 94.5881965361446
        },
        "yDiv2": {
          "value": 112
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02b",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 6.47
        },
        "yDivider": {
          "value": 67.32
        },
        "xDivider": {
          "value": 0.48
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.101
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 9.38
        },
        "xOuter": {
          "value": 2.47
        },
        "yOuter": {
          "value": 0.21
        },
        "xDiv": {
          "value": 26.512
        },
        "xDiv2": {
          "value": 0.321
        },
        "warp": {
          "value": 321
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca032",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/1000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 25.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 3.77
        },
        "colorShift": {
          "value": 33
        },
        "div": {
          "value": 17.974
        },
        "div2": {
          "value": 27.909
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04e",
    "shader": "#define orbs 12.\n\n  \n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t-stream);\n    float y = radius * cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.43
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.63
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.95
        },
        "div": {
          "value": 10.925
        },
        "div2": {
          "value": 8.505
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca053",
    "shader": "#define BALLS 10\n n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/-80.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.054
        },
        "shapeMultiplier": {
          "value": 39.9
        },
        "rotation": {
          "value": 0.0195
        },
        "xMultiplier": {
          "value": 5.66
        },
        "yMultiplier": {
          "value": 535.74
        },
        "colorSpread": {
          "value": 0.000114
        },
        "colorMultiplier": {
          "value": 2
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.23
        },
        "ballSize": {
          "value": 42.87
        },
        "glow": {
          "value": 3.54
        },
        "contrast": {
          "value": 2.13
        },
        "radius": {
          "value": 16.47
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca068",
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * tan(dist*t+stream/20.)*sin(dist);\n    float y = t*radius * cos(dist*t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.46
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 2.32
        },
        "colorShift": {
          "value": 6.24
        },
        "outer": {
          "value": 2.78
        },
        "inner": {
          "value": 0.03
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06f",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/21.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/21.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .7)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 31.68
        },
        "contrast": {
          "value": 1.03
        },
        "orbSize": {
          "value": 2
        },
        "radius": {
          "value": 13
        },
        "colorShift": {
          "value": 7.12
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 0.94
        },
        "yMul": {
          "value": 0.14
        },
        "xMul": {
          "value": 0.05
        },
        "xSpeed": {
          "value": -0.5
        },
        "ySpeed": {
          "value": 0.5
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 3.2
        },
        "xDivide": {
          "value": 2.08
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca093",
    "shader": "precision highp float;\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 p = 2.3 / abs(vec2(.5 / shape));\n  p /= abs(tan(sin((xShape * uv.x)) * (cos(yShape * uv.y))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (colorShape - uv.x/100. - stream/6.)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y + cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.b = .960;\n  gl_FragColor.g *= .4242 + sin(uv.y/2.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.059
        },
        "xShape": {
          "value": 20
        },
        "yShape": {
          "value": 20
        },
        "colorShape": {
          "value": 0.126
        },
        "contrast": {
          "value": 0.575
        },
        "ballSize": {
          "value": 8.842
        },
        "shape": {
          "value": 0.212
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a0",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *= k_rotate2d(stream / 70.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 20) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 58.06
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.2
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a7",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t*radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0aa",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * cos(dist * t) - cos(stream) * cos(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.2
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.12
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 1.15
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b4",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.26
        },
        "contrast": {
          "value": 6.4
        },
        "ballSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.54
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0.98
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0bc",
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream*2.+abs(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.)*pow(dist, 3.)*pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.63
        },
        "contrast": {
          "value": 2.58
        },
        "ballSize": {
          "value": 0.01
        },
        "radius": {
          "value": 131.23
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c3",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.41
        },
        "contrast": {
          "value": 5.5
        },
        "ballSize": {
          "value": 0.02
        },
        "radius": {
          "value": 221.83
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c9",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.053
        },
        "shapeMultiplier": {
          "value": 223.96
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 217.723
        },
        "yMultiplier": {
          "value": 157.966
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.863
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.636
        },
        "ballSize": {
          "value": 17.795
        },
        "glow": {
          "value": 0.714
        },
        "contrast": {
          "value": 2.278
        },
        "radius": {
          "value": 15.459
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0cb",
    "shader": "#define BALLS 15\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *=k_rotate2d(stream/-3. + length(cos(uv-stream))/1.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.044
        },
        "shapeMultiplier": {
          "value": 30.11
        },
        "rotation": {
          "value": 0.0195
        },
        "xMultiplier": {
          "value": 376.89
        },
        "yMultiplier": {
          "value": 0
        },
        "colorSpread": {
          "value": 0.000114
        },
        "colorMultiplier": {
          "value": 2
        },
        "brightness": {
          "value": 3.34
        },
        "ballSize": {
          "value": 17.33
        },
        "glow": {
          "value": 2.39
        },
        "contrast": {
          "value": 1.5
        },
        "radius": {
          "value": 10.09
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d0",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "shapeMultiplier": {
          "value": 44.72
        },
        "rotation": {
          "value": 0.12
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 196.12
        },
        "colorSpread": {
          "value": 0.0008
        },
        "colorMultiplier": {
          "value": 0.78
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 7.62
        },
        "ballSize": {
          "value": 77.69
        },
        "glow": {
          "value": 0.59
        },
        "contrast": {
          "value": 3.86
        },
        "radius": {
          "value": 25.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d9",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .001 * dot(uv, uv) * sin(dot(abs(uv) * .1* sin(uv), uv)/1000.) - stream/5.) + log(uv.x / 1.);// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div + stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * tan(t-stream/16.) * cos(t+stream/22.114) ;\n    float y = radius * cos(t - stream/12.2) * cos(t-stream/PI) * tan(t+stream/13.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 3.)*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 34.88
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.66
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 10.803
        },
        "div2": {
          "value": 11.573
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0de",
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.41
        },
        "yDivider": {
          "value": 25.18
        },
        "xDivider": {
          "value": 3.99
        },
        "multiplier": {
          "value": 5.86
        },
        "ballSize": {
          "value": 0.19
        },
        "contrast": {
          "value": 0.87
        },
        "radius": {
          "value": 0.09
        },
        "rotation": {
          "value": 0.22587259377776392
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0.18
        },
        "c": {
          "value": 1.61
        },
        "d": {
          "value": 3.05
        },
        "e": {
          "value": 0.34
        },
        "f": {
          "value": 0.95
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e1",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream))/2. + stream/4.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 2.2);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream), radius * sin(sinMul * t + stream));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .25)/2.5 * pow(dist, 1.15) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.466
        },
        "contrast": {
          "value": 1.077
        },
        "ballSize": {
          "value": 0.39
        },
        "radius": {
          "value": 1.617
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": -7.539
        },
        "dotMultiplier": {
          "value": 4.4
        },
        "tanMul": {
          "value": 3.857
        },
        "sinMul": {
          "value": 1.239
        },
        "shift": {
          "value": 0.845
        },
        "offset": {
          "value": 0.808
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e4",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv = sin(stream*1.+(1.-log(sin(uv))));\n  // uv *= k_rotate2d(stream);\n  uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 1.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t), sinMul * sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.778
        },
        "contrast": {
          "value": 5
        },
        "ballSize": {
          "value": 0.1491
        },
        "radius": {
          "value": 2.25
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 2.17
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0.9
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f69",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .5);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.7;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .6)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6455.31160805723
        },
        "ballSize": {
          "value": 11076.110481927713
        },
        "contrast": {
          "value": 1.4018456312432348
        },
        "radius": {
          "value": 20278.94704856131
        },
        "yOuter": {
          "value": 2184.1534747983637
        },
        "xOuter": {
          "value": 115.20098983433736
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.2490805134600906
        },
        "yMultiplier": {
          "value": 19.24
        },
        "divider": {
          "value": 4.888253012048193
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f6b",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.1)/7.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.467786754929877
        },
        "ballSize": {
          "value": 0.31868131868131866
        },
        "contrast": {
          "value": 2.8809567326924888
        },
        "radius": {
          "value": 0.4156118107071843
        },
        "yOuter": {
          "value": 17.969914545633713
        },
        "xOuter": {
          "value": 27.03570903824037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.0018560335090365
        },
        "yMultiplier": {
          "value": 19.24
        },
        "divider": {
          "value": 6.095766072100905
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa2",
    "shader": "#define orbs 5.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 11.702141378012051
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 4.165304969879518
        },
        "x1": {
          "value": 1.3229480421686748
        },
        "x2": {
          "value": 1
        },
        "y1": {
          "value": 0.34014495481927715
        },
        "y2": {
          "value": 1.1094926581325302
        },
        "center": {
          "value": 7.340615587349399
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 6.943693524096386
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.35281795933734944
        },
        "radius": {
          "value": 1.463413027108434
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0
        },
        "x2": {
          "value": 0.07756023333999278
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 3.9954113328313263
        },
        "center": {
          "value": 9.759704442771085
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 20.516971009036148
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.6914401355421687
        },
        "radius": {
          "value": 1.0743787650602412
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.006485316265060244
        },
        "x2": {
          "value": 0.39095914909638557
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 0.29673381024096396
        },
        "center": {
          "value": 2.7102409638554223
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 15.777244917168678
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 5.551138930722892
        },
        "x1": {
          "value": 0.30045180722891573
        },
        "x2": {
          "value": 1
        },
        "y1": {
          "value": 0.5074830572289157
        },
        "y2": {
          "value": 3.37050545933735
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fca",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.96
        },
        "contrast": {
          "value": 0.85
        },
        "orbSize": {
          "value": 0.15
        },
        "radius": {
          "value": 1.15
        },
        "colorShift": {
          "value": 79.53
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fce",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(cos(sin(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv += (i + 1.) / 10.;\n    uv *= k_rotate2d(i + stream / 4.);\n    uv.x /= abs(dist + distMul * dist * (i + 1.));\n    float t = (i) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.); // / cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 2.); // + sin(t-stream/1.) - cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.39
        },
        "contrast": {
          "value": 1.81
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 2.51
        },
        "colorShift": {
          "value": 9.12
        },
        "distMul": {
          "value": 0.00668
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd2",
    "shader": "  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(cos(sin(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv += (i+1.)/10.;\n      uv *= k_rotate2d(i+stream/4.);\n      uv.x /= abs(dist+distMul* dist*(i+1.));\n      float t = (i) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);// / cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// + sin(t-stream/1.) - cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.39
        },
        "contrast": {
          "value": 1.81
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 2.51
        },
        "colorShift": {
          "value": 9.12
        },
        "distMul": {
          "value": 0.00668
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd1",
    "shader": "  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = k_kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= k_rotate2d(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.64
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe5",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.2);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .14) * _uv.y/div - stream/.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.43 - t*PI), radius*tan(t - stream/-.9));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.13- uv.y/(.7*y + .3*y*sin(stream/.7393))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.4  * float(i) / 6.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 896292.749
        },
        "ballSize": {
          "value": 14111.872
        },
        "contrast": {
          "value": 3.24
        },
        "radius": {
          "value": 82008340.58
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 155941108.62
        },
        "y": {
          "value": 10885833.37
        },
        "rotation": {
          "value": 0.00231
        },
        "colorOffset": {
          "value": 210.34
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 39960.707
        },
        "div2": {
          "value": 916935.078
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fda",
    "shader": "#define orbs 40.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / -6.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (.3 + .2*sin(6.*cos(_uv.x/div2 + stream / 1.3) * _uv.y/div - stream/2.1));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(.5*sin(t*PI), 1.5*tan(t/PI));\n    p /= sin(stream/1.+PI * sin(uv.x/x)*cos(stream+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 305.431
        },
        "ballSize": {
          "value": 0.013
        },
        "contrast": {
          "value": 2.97
        },
        "radius": {
          "value": 65.75
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 10.13
        },
        "y": {
          "value": 20.69
        },
        "rotation": {
          "value": 1
        },
        "colorOffset": {
          "value": 470.97
        },
        "sides": {
          "value": 2
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 834.574
        },
        "div2": {
          "value": 9681.278
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe1",
    "shader": "#define orbs 25.\n\nvoid main () {\n  float stream = stream / 5.3;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  // uv *= k_rotate2d(stream / -3.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= .2*sin(.237525*cos(_uv.y/-1000. + stream / -1.) - _uv.y/10000. - stream/2.49);\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(1.*sin(t - stream/-.9), 1.5*tan(t - stream/.95));\n    p /= sin(stream/1.+PI * sin(uv.x/x - stream/1.7)*cos(stream/1.8+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2823.331
        },
        "ballSize": {
          "value": 0.13
        },
        "contrast": {
          "value": 2.69
        },
        "radius": {
          "value": 222
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 90.77
        },
        "y": {
          "value": 50.54
        },
        "rotation": {
          "value": 1
        },
        "colorOffset": {
          "value": 496.96
        },
        "sides": {
          "value": 2
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff4",
    "shader": "\n#define BALLS 10.\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *=k_rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.37
        },
        "ballSize": {
          "value": 0.13
        },
        "radius": {
          "value": 22.12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff7",
    "shader": "\n// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 5.;\nconst float shell = .3;\nconst float carve = .3;\nconst float falloff = 1.8;\nconst float blend = .02;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 100.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 3.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -= time * a;\n        d = smin(d, abs(dot(sin(p),cos(p.yzx))/scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += sin(p.z*10.+time*20.)*0.002;\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n    // coordinates\n    vec2 uv = k_uv();\n    float dither = hash12(vUv);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 20.;\n    const float count = 17.;\n    for (float index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*dither;\n        pos += ray*dist;\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-time);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.283
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca007",
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(.1 * dot(uv, uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * abs(sin(time / 3.)) * (dist / .5) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / 5.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(.5 * uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 13. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.42
        },
        "ballSize": {
          "value": 447.757
        },
        "contrast": {
          "value": 0.89
        },
        "radius": {
          "value": 31.75
        },
        "yOuter": {
          "value": 353.18
        },
        "xOuter": {
          "value": 141.2
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3795.54
        },
        "yMultiplier": {
          "value": 30.28
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": -0.0024
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca010",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = k_uv();\n  vec2 _uv = uv;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/2.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4. + .01*uv))*cos(uv.x/xDiv - stream/4.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 53.73293577243752
        },
        "yDivider": {
          "value": 2.1694277108433737
        },
        "xDivider": {
          "value": 4.430280496987952
        },
        "multiplier": {
          "value": 1.2283603162650605
        },
        "ballSize": {
          "value": 7.5453642695783145
        },
        "contrast": {
          "value": 0.6708647402108434
        },
        "radius": {
          "value": 128.25703125
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 151.80625
        },
        "xDiv2": {
          "value": 15.67018542921687
        },
        "itY": {
          "value": 0.1551346009036145
        },
        "itX": {
          "value": 0.09707172439759039
        },
        "oS": {
          "value": 0.249378765060241
        },
        "oT": {
          "value": 0.6427899096385543
        },
        "yShape": {
          "value": 4.247590361445784
        }
      },
      {
        "zoom": {
          "value": 32.46323842243976
        },
        "yDivider": {
          "value": 2.951618975903615
        },
        "xDivider": {
          "value": 0.42119728915662663
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 21.58139118975904
        },
        "contrast": {
          "value": 1.1464503012048195
        },
        "radius": {
          "value": 165.77595067771088
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 23.026562500000004
        },
        "xDiv2": {
          "value": 33
        },
        "itY": {
          "value": 0.041319008087971405
        },
        "itX": {
          "value": 0
        },
        "oS": {
          "value": 0
        },
        "oT": {
          "value": 1.8478727409638558
        },
        "yShape": {
          "value": 25.166716867469884
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca019",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 6;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/10.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=100.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =11.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.982
        },
        "size": {
          "value": 2.039
        },
        "offc": {
          "value": 0
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 2.933
        },
        "_x": {
          "value": 0.517
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca026",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (17.1, 311.7)),\n\t\t\t  dot (p, vec2 (29.5, 13.3)));\n\n\treturn -1. + 1021.*fract (sin (p)*43758.5453123 * sin(stream/1000000.) * cos(stream/10000.));\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return abs(uv) * outer * sin(stream/20.) * sin(dot(uv, uv) - stream*3.);//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n} \n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length(sin(uv-34.21*stream));\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + fbm (a*uv + stream)));\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * fbm (b*uv + stream)));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc * (uv.x-log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(tan(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.57
        },
        "thickness": {
          "value": 0.0008
        },
        "haze": {
          "value": 723.56
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.007
        },
        "a": {
          "value": 4.13
        },
        "b": {
          "value": 4.01
        },
        "c": {
          "value": 38.22
        },
        "outer": {
          "value": 1.1
        },
        "inner": {
          "value": 3.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca048",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv - 10.*cos( .005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 21.18
        },
        "contrast": {
          "value": 0.8
        },
        "orbSize": {
          "value": 0.2
        },
        "radius": {
          "value": 6.65
        },
        "colorShift": {
          "value": 9.24
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04d",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.69
        },
        "contrast": {
          "value": 1.3
        },
        "orbSize": {
          "value": 0.67
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 9.96
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 1
        },
        "xMul": {
          "value": 4.91
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0049
        },
        "yDivide": {
          "value": 5.34
        },
        "xDivide": {
          "value": 1.73
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca059",
    "shader": "#define orbs 10.\n\nvoid main() {\n  float stream = stream / 4.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color =  cos( vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += pow(volume, .57) * k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.86
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 4.64
        },
        "colorShift": {
          "value": 6.24
        },
        "outer": {
          "value": 2.78
        },
        "inner": {
          "value": 0.047
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05d",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv /= sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.4
        },
        "contrast": {
          "value": 1.11
        },
        "orbSize": {
          "value": 0.08
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.35
        },
        "outer": {
          "value": 0.61
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca062",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 20.1 * uv) - stream);\n  uv /= sin(.01 * dot(uv + sin(1. * uv), 20.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.23
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 0.2
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06a",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * tan(dist*t+stream/20.)*sin(dist);\n    float y = t*radius * cos(dist*t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.41
        },
        "contrast": {
          "value": 1.32
        },
        "orbSize": {
          "value": 0.36
        },
        "radius": {
          "value": 4.94
        },
        "colorShift": {
          "value": 6.24
        },
        "outer": {
          "value": 2.78
        },
        "inner": {
          "value": 0.03
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07a",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/2.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.06
        },
        "yDivider": {
          "value": 818.46
        },
        "xDivider": {
          "value": 656.67
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 2.03
        },
        "radius": {
          "value": 26.22
        },
        "yOuter": {
          "value": 0.12
        },
        "xOuter": {
          "value": 0.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca097",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *=k_rotate2d(stream/70.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/20)*cos(uv.y/yDivider + stream/21.) + sin(uv.x/50. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider + stream/21.) * sin(uv.y/50. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 58.06
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.2
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 16.71
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.23
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 2.28
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 58.38
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 345.32
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.23
        },
        "contrast": {
          "value": 2.21
        },
        "radius": {
          "value": 13.17
        },
        "xOuter": {
          "value": 0.5
        },
        "yOuter": {
          "value": 0.5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0cf",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/-12.);\n  uv *= zoom2;\n  uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-1.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/.3) - sin(uv.y * yMultiplier + stream/-.8));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * ( 1. + uv.y/250. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.7)/3.3*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.009
        },
        "shapeMultiplier": {
          "value": 192.45
        },
        "rotation": {
          "value": 0.61129
        },
        "xMultiplier": {
          "value": 998.27
        },
        "yMultiplier": {
          "value": 41.66
        },
        "colorSpread": {
          "value": 0.00012
        },
        "colorMultiplier": {
          "value": 4.09
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.18
        },
        "ballSize": {
          "value": 41.18
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 2.06
        },
        "radius": {
          "value": 5.93
        },
        "zoom2": {
          "value": 0.2
        }
      },
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 254.58
        },
        "rotation": {
          "value": 0.61129
        },
        "xMultiplier": {
          "value": 376.84
        },
        "yMultiplier": {
          "value": 127.2
        },
        "colorSpread": {
          "value": 0.00012
        },
        "colorMultiplier": {
          "value": 4.09
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.18
        },
        "ballSize": {
          "value": 70.45
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 2.06
        },
        "radius": {
          "value": 5.93
        },
        "zoom2": {
          "value": 0.5
        }
      },
      {
        "zoom": {
          "value": 0.009
        },
        "shapeMultiplier": {
          "value": 154.35
        },
        "rotation": {
          "value": 2.62987
        },
        "xMultiplier": {
          "value": 471.96
        },
        "yMultiplier": {
          "value": 99.64
        },
        "colorSpread": {
          "value": 0.000025
        },
        "colorMultiplier": {
          "value": 5.02
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.84
        },
        "ballSize": {
          "value": 471.93
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 1.7
        },
        "radius": {
          "value": 16.37
        },
        "zoom2": {
          "value": 0.17
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f2",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 58.326
        },
        "iterator": {
          "value": 1.019
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 22.781
        },
        "L": {
          "value": 3
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.636
        },
        "colorOffset": {
          "value": 25.259
        },
        "contrast": {
          "value": 1.987
        },
        "orbSize": {
          "value": 6.079
        },
        "div": {
          "value": 7.216
        },
        "radius": {
          "value": 26.903
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0fe",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 122
        },
        "iterator": {
          "value": 1.01
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 1.434
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 33
        },
        "L": {
          "value": 3
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.636
        },
        "colorOffset": {
          "value": 25.259
        },
        "contrast": {
          "value": 1.987
        },
        "orbSize": {
          "value": 6.079
        },
        "div": {
          "value": 7.216
        },
        "radius": {
          "value": 26.903
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca115",
    "shader": "\n\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  vec2 _uv = uv;\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / 3.;\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 7.81
        },
        "colorSpread": {
          "value": 7
        },
        "colorMultiplier": {
          "value": 111.05
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5b",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 3.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 3.)); // * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i));\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.051
        },
        "shapeMultiplier": {
          "value": 200.17
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 69.59
        },
        "yMultiplier": {
          "value": 26.63
        },
        "colorSpread": {
          "value": 0.006
        },
        "colorMultiplier": {
          "value": 0.15
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.48
        },
        "ballSize": {
          "value": 2.22
        },
        "glow": {
          "value": 0.76
        },
        "contrast": {
          "value": 2.78
        },
        "radius": {
          "value": 9.97
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5c",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 10.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.xyz += lightness;\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n  gl_FragColor.r *= r;\n  gl_FragColor.g *= g;\n  gl_FragColor.b *= b;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.28
        },
        "xMultiplier": {
          "value": 39.33
        },
        "yMultiplier": {
          "value": 200
        },
        "ballSize": {
          "value": 1.04
        },
        "colorSpread": {
          "value": 0.32
        },
        "colorMultiplier": {
          "value": 519.17
        },
        "shapeMultiplier": {
          "value": 163.55
        },
        "glow": {
          "value": 1587.64
        },
        "contrast": {
          "value": 4.38
        },
        "rotation": {
          "value": 0.051
        },
        "brightness": {
          "value": 11100
        },
        "sides": {
          "value": 6
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        },
        "lightness": {
          "value": 0.29
        },
        "r": {
          "value": 0.06
        },
        "g": {
          "value": 0.61
        },
        "b": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f72",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-58.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, 1.6)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 362.832
        },
        "xDiv": {
          "value": 11.463
        },
        "yDiv": {
          "value": 122.317
        },
        "xDiv2": {
          "value": 7.522
        },
        "yDiv2": {
          "value": 2.89
        },
        "xDiv3": {
          "value": 15.832
        },
        "yDiv3": {
          "value": 172.525
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 70.762
        },
        "contrast": {
          "value": 1.714
        },
        "radius": {
          "value": 18.079
        },
        "rotation": {
          "value": 0.000054
        },
        "xMul": {
          "value": 0
        },
        "yMul": {
          "value": 13.037
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f76",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 44.43
        },
        "xDiv": {
          "value": 23.574
        },
        "yDiv": {
          "value": 1.501
        },
        "xDiv2": {
          "value": 0.615
        },
        "yDiv2": {
          "value": 5.65
        },
        "xDiv3": {
          "value": 45.225
        },
        "yDiv3": {
          "value": 1.626
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 3.182
        },
        "contrast": {
          "value": 2.483
        },
        "radius": {
          "value": 3.828
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 2.243
        },
        "yMul": {
          "value": 17.975
        },
        "oY": {
          "value": 18.724
        },
        "oX": {
          "value": 9.734
        }
      },
      {
        "zoom": {
          "value": 39.827
        },
        "xDiv": {
          "value": 18.182
        },
        "yDiv": {
          "value": 1.991
        },
        "xDiv2": {
          "value": 13.074
        },
        "yDiv2": {
          "value": 14.892
        },
        "xDiv3": {
          "value": 122.944
        },
        "yDiv3": {
          "value": 7.251
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 2.32
        },
        "contrast": {
          "value": 2.351
        },
        "radius": {
          "value": 1.948
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 12.294
        },
        "yMul": {
          "value": 4.329
        },
        "oY": {
          "value": 22.667
        },
        "oX": {
          "value": 17.056
        }
      },
      {
        "zoom": {
          "value": 65.801
        },
        "xDiv": {
          "value": 86.58
        },
        "yDiv": {
          "value": 0.779
        },
        "xDiv2": {
          "value": 3.983
        },
        "yDiv2": {
          "value": 3.463
        },
        "xDiv3": {
          "value": 100.433
        },
        "yDiv3": {
          "value": 7.416
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 1.739
        },
        "contrast": {
          "value": 1.857
        },
        "radius": {
          "value": 4.286
        },
        "rotation": {
          "value": 0.000273
        },
        "xMul": {
          "value": 2.338
        },
        "yMul": {
          "value": 5.368
        },
        "oY": {
          "value": 39.81
        },
        "oX": {
          "value": 5.455
        }
      },
      {
        "zoom": {
          "value": 43.29
        },
        "xDiv": {
          "value": 35.498
        },
        "yDiv": {
          "value": 12.121
        },
        "xDiv2": {
          "value": 0.606
        },
        "yDiv2": {
          "value": 40
        },
        "xDiv3": {
          "value": 72.727
        },
        "yDiv3": {
          "value": 5.524
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 2.639
        },
        "contrast": {
          "value": 2.506
        },
        "radius": {
          "value": 4.935
        },
        "rotation": {
          "value": 0.000429
        },
        "xMul": {
          "value": 12.294
        },
        "yMul": {
          "value": 3.636
        },
        "oY": {
          "value": 20.571
        },
        "oX": {
          "value": 5.801
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f77",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) * cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) * sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / -1.), yMul - xMul * tan(t / multiplier - stream / 12.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream /3.) - cos(uv.y / yDiv3 - stream / 3.4));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .8) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 57.137
        },
        "xDiv": {
          "value": 81.385
        },
        "yDiv": {
          "value": 7.619
        },
        "xDiv2": {
          "value": 7.359
        },
        "yDiv2": {
          "value": 4.848
        },
        "xDiv3": {
          "value": 155.844
        },
        "yDiv3": {
          "value": 11.693
        },
        "multiplier": {
          "value": 1.688
        },
        "ballSize": {
          "value": 2.814
        },
        "contrast": {
          "value": 1.669
        },
        "radius": {
          "value": 2.208
        },
        "rotation": {
          "value": 0.000046
        },
        "xMul": {
          "value": 5.281
        },
        "yMul": {
          "value": 2.597
        },
        "oY": {
          "value": 23.81
        },
        "oX": {
          "value": 16.017
        }
      },
      {
        "zoom": {
          "value": 57.137
        },
        "xDiv": {
          "value": 113.42
        },
        "yDiv": {
          "value": 0.866
        },
        "xDiv2": {
          "value": 11.775
        },
        "yDiv2": {
          "value": 24.762
        },
        "xDiv3": {
          "value": 81.385
        },
        "yDiv3": {
          "value": 2.892
        },
        "multiplier": {
          "value": 1.688
        },
        "ballSize": {
          "value": 4.978
        },
        "contrast": {
          "value": 1.597
        },
        "radius": {
          "value": 10
        },
        "rotation": {
          "value": 0.00045
        },
        "xMul": {
          "value": 1.126
        },
        "yMul": {
          "value": 1.818
        },
        "oY": {
          "value": 40.19
        },
        "oX": {
          "value": 4.762
        }
      },
      {
        "zoom": {
          "value": 47.619
        },
        "xDiv": {
          "value": 45.887
        },
        "yDiv": {
          "value": 1.299
        },
        "xDiv2": {
          "value": 1.212
        },
        "yDiv2": {
          "value": 2.251
        },
        "xDiv3": {
          "value": 195.671
        },
        "yDiv3": {
          "value": 3.303
        },
        "multiplier": {
          "value": 1.688
        },
        "ballSize": {
          "value": 3.255
        },
        "contrast": {
          "value": 1.792
        },
        "radius": {
          "value": 5
        },
        "rotation": {
          "value": 0.000046
        },
        "xMul": {
          "value": 0.779
        },
        "yMul": {
          "value": 3.636
        },
        "oY": {
          "value": 20.19
        },
        "oX": {
          "value": 15.238
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8f",
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.199
        },
        "contrast": {
          "value": 1.262
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 0.825
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.43
        },
        "colorOffset": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.307
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 2.979
        },
        "colorShift": {
          "value": 0
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 4.12
        }
      },
      {
        "zoom": {
          "value": 0.145
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 8.789
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 1.277
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 5
        },
        "b": {
          "value": 0.19
        },
        "c": {
          "value": 1.77
        },
        "d": {
          "value": 0.47
        },
        "colorOffset": {
          "value": 2.06
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.994
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.8
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      },
      {
        "zoom": {
          "value": 0.089
        },
        "contrast": {
          "value": 0.617
        },
        "orbSize": {
          "value": 0.993
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.227
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 0
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa6",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 24.7
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.204
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 2.6
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 0.394
        },
        "center": {
          "value": 13.273
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 11.101
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.003
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 4.625
        },
        "x1": {
          "value": 0.053
        },
        "x2": {
          "value": 1.82
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 3.72
        },
        "center": {
          "value": 3.859
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fee",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/(PI*10.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.049
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 4.962735316265062
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.45104942723058306
        },
        "div": {
          "value": 0.10004955760542171
        },
        "radius": {
          "value": 3.176
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ffe",
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 6.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider; // + stream/50.;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = 1.-pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.078
        },
        "ballSize": {
          "value": 2.904
        },
        "contrast": {
          "value": 1.34
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 10.2
        },
        "mirror": {
          "value": false
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01b",
    "shader": "// Ether by nimitz 2014 (twitter: @stormoid)\n// https://www.shadertoy.com/view/MsjSW3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define t stream / 5.\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\nfloat map(vec3 p){\n    p.xz*= m(t*.94);p.xy*= m(t*0.3);\n    vec3 q = p*3.+t;\n    return length(p+vec3(sin(t*1.7)))*log(length(p)+1.5) + sin(q.x+cos(q.z+sin(q.y)))*1.05 - 2.;\n}\n\nvoid main(){\t\n\tvec2 p = vUv/resolution.y - vec2(.9,.5);\n  p *= zoom;\n\n    vec3 cl = vec3(0.);\n    float d = -2.;\n    for(int i=0; i<=8; i++)\t{\n\t\tvec3 p = vec3(0,-0,5) + normalize(vec3(p,-.5))*d;\n        float rz = map(p);\n\t\tfloat f =  clamp((rz - map(p+.1))*0.5, -2.1, .5 );\n        vec3 l = vec3(0.1,0.3,.04) + vec3(-5., -.5, 3.)*f;\n        cl = cl*l + smoothstep(10.5, .0, rz)*.7*l;\n\t\td += min(rz, 2.);\n\t}\n    gl_FragColor = vec4(cl, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.822
        },
        "X": {
          "value": 30.043
        },
        "Y": {
          "value": 26.803
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca020",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.52
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca031",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 22.15
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 1.09
        },
        "radius": {
          "value": 5.14
        },
        "colorShift": {
          "value": 10.07
        },
        "div": {
          "value": 22.037
        },
        "div2": {
          "value": 19.684
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca039",
    "shader": "\n#define orbs 20.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = zoom * uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 22.15
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 1.09
        },
        "radius": {
          "value": 5.14
        },
        "colorShift": {
          "value": 10.07
        },
        "div": {
          "value": 22.037
        },
        "div2": {
          "value": 19.684
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca042",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 67.31
        },
        "contrast": {
          "value": 1.49
        },
        "orbSize": {
          "value": 1.05
        },
        "radius": {
          "value": 3.77
        },
        "colorShift": {
          "value": 23.99
        },
        "div": {
          "value": 17.974
        },
        "div2": {
          "value": 27.909
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07d",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04b",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 19.33
        },
        "contrast": {
          "value": 1.55
        },
        "orbSize": {
          "value": 1.79
        },
        "radius": {
          "value": 4.12
        },
        "colorShift": {
          "value": 16
        },
        "div": {
          "value": 11.62
        },
        "div2": {
          "value": 32.974
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a5",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "yDivider": {
          "value": 825.61
        },
        "xDivider": {
          "value": 794.72
        },
        "multiplier": {
          "value": 3.11
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.85
        },
        "yOuter": {
          "value": 0.38
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b0",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume * pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 4.99
        },
        "ballSize": {
          "value": 0.011
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b5",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume * pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.41
        },
        "contrast": {
          "value": 5.5
        },
        "ballSize": {
          "value": 0.02
        },
        "radius": {
          "value": 221.83
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c0",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.41
        },
        "contrast": {
          "value": 5.5
        },
        "ballSize": {
          "value": 0.02
        },
        "radius": {
          "value": 221.83
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c7",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.053
        },
        "shapeMultiplier": {
          "value": 223.96
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 217.723
        },
        "yMultiplier": {
          "value": 157.966
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.863
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.636
        },
        "ballSize": {
          "value": 17.795
        },
        "glow": {
          "value": 0.714
        },
        "contrast": {
          "value": 2.278
        },
        "radius": {
          "value": 15.459
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ce",
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 589.178
        },
        "rotation": {
          "value": 0.012
        },
        "xMultiplier": {
          "value": 251.592
        },
        "yMultiplier": {
          "value": 1549.9
        },
        "colorSpread": {
          "value": 0.000012
        },
        "colorMultiplier": {
          "value": 0.51
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.86
        },
        "ballSize": {
          "value": 6.194
        },
        "glow": {
          "value": 4.435
        },
        "contrast": {
          "value": 3.189
        },
        "radius": {
          "value": 10.691
        },
        "zoom2": {
          "value": 0.48
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f3",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * sin(stream - uv.y), radius*cos(stream/1.+(-1. + 2. * vUv / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 13
        },
        "iterator": {
          "value": 1.061
        },
        "ot": {
          "value": 70.614
        },
        "I": {
          "value": 0.416
        },
        "J": {
          "value": 0.918
        },
        "K": {
          "value": 11
        },
        "iterations": {
          "value": 36
        },
        "L": {
          "value": 5.129
        },
        "M": {
          "value": 6.292
        },
        "colorShift": {
          "value": 0.747
        },
        "colorOffset": {
          "value": 6.72
        },
        "contrast": {
          "value": 1.466
        },
        "orbSize": {
          "value": 0.31
        },
        "div": {
          "value": 9.935
        },
        "radius": {
          "value": 5.111
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ff",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, .1,vec2(radius*sin(stream/30.+uv.x/div), radius*cos(stream/30.+uv.y/div)),  col, contrast);\n  }\n\n\n  vec3 c = vec3(ot * I + length(uv));\n            \n}",
    "variants": [
      {
        "zoom": {
          "value": 19.027
        },
        "iterator": {
          "value": 0.935
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 1.152
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 26.455
        },
        "L": {
          "value": 3.908
        },
        "M": {
          "value": 0.149
        },
        "colorShift": {
          "value": 0.572
        },
        "colorOffset": {
          "value": 7.555
        },
        "contrast": {
          "value": 1.747
        },
        "orbSize": {
          "value": 0.645
        },
        "div": {
          "value": 0.183
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca08d",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs + stream;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 14.56
        },
        "contrast": {
          "value": 1.05
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 12.392
        },
        "div2": {
          "value": 11.325
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca112",
    "shader": "\n\n#define BALLS 5\n\n\nvoid main () {\n  vec2 uv = k_uv();\n \tuv *= zoom;\n\tfloat dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream));\n  float _grid = (cos(uv.x * xMultiplier) - sin(uv.y * yMultiplier + stream));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 4. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.18
        },
        "xMultiplier": {
          "value": 18.25
        },
        "yMultiplier": {
          "value": 93.68
        },
        "ballSize": {
          "value": 4.54
        },
        "colorSpread": {
          "value": 1.88
        },
        "colorMultiplier": {
          "value": 147.98
        },
        "shapeMultiplier": {
          "value": 68.34
        },
        "glow": {
          "value": 9407.33
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 0.00778
        },
        "brightness": {
          "value": 0.82
        },
        "sides": {
          "value": 12
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f66",
    "shader": "\n\n#define BALLS 15\n\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/10.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist * stream/2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.44
        },
        "xMultiplier": {
          "value": 39.33
        },
        "yMultiplier": {
          "value": 33.24
        },
        "ballSize": {
          "value": 1.31
        },
        "colorSpread": {
          "value": 0.27
        },
        "colorMultiplier": {
          "value": 554.68
        },
        "shapeMultiplier": {
          "value": 163.55
        },
        "glow": {
          "value": 1083.42
        },
        "contrast": {
          "value": 4.3
        },
        "rotation": {
          "value": 1.927
        },
        "brightness": {
          "value": 11100
        },
        "sides": {
          "value": 8
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f68",
    "shader": "\n\n#define BALLS 5\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tif (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist - stream/2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.14
        },
        "xMultiplier": {
          "value": 63.13
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 1.18
        },
        "colorSpread": {
          "value": 2.77
        },
        "colorMultiplier": {
          "value": 282.59
        },
        "shapeMultiplier": {
          "value": 21.93
        },
        "glow": {
          "value": 10350.68
        },
        "contrast": {
          "value": 4.57
        },
        "rotation": {
          "value": 4.072
        },
        "brightness": {
          "value": 2311.66
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f79",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 30.303
        },
        "xDiv": {
          "value": 6.061
        },
        "yDiv": {
          "value": 1.126
        },
        "xDiv2": {
          "value": 1.818
        },
        "yDiv2": {
          "value": 2.251
        },
        "xDiv3": {
          "value": 45.225
        },
        "yDiv3": {
          "value": 3.119
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 46.211
        },
        "contrast": {
          "value": 2.483
        },
        "radius": {
          "value": 15.486
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 1.595
        },
        "yMul": {
          "value": 7.948
        },
        "oY": {
          "value": 14.309
        },
        "oX": {
          "value": 10.51
        }
      },
      {
        "zoom": {
          "value": 65.801
        },
        "xDiv": {
          "value": 86.58
        },
        "yDiv": {
          "value": 0.779
        },
        "xDiv2": {
          "value": 3.983
        },
        "yDiv2": {
          "value": 3.463
        },
        "xDiv3": {
          "value": 100.433
        },
        "yDiv3": {
          "value": 7.416
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 18.615
        },
        "contrast": {
          "value": 1.857
        },
        "radius": {
          "value": 4.286
        },
        "rotation": {
          "value": 0.000273
        },
        "xMul": {
          "value": 2.338
        },
        "yMul": {
          "value": 5.368
        },
        "oY": {
          "value": 39.81
        },
        "oX": {
          "value": 5.455
        }
      },
      {
        "zoom": {
          "value": 43.29
        },
        "xDiv": {
          "value": 35.498
        },
        "yDiv": {
          "value": 12.121
        },
        "xDiv2": {
          "value": 0.606
        },
        "yDiv2": {
          "value": 40
        },
        "xDiv3": {
          "value": 72.727
        },
        "yDiv3": {
          "value": 5.524
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 44.805
        },
        "contrast": {
          "value": 2.506
        },
        "radius": {
          "value": 4.935
        },
        "rotation": {
          "value": 0.000429
        },
        "xMul": {
          "value": 12.294
        },
        "yMul": {
          "value": 3.636
        },
        "oY": {
          "value": 20.571
        },
        "oX": {
          "value": 5.801
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7c",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .4)/4. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 54.545
        },
        "xDiv": {
          "value": 110.823
        },
        "yDiv": {
          "value": 3.203
        },
        "xDiv2": {
          "value": 21.818
        },
        "yDiv2": {
          "value": 6.234
        },
        "xDiv3": {
          "value": 50.216
        },
        "yDiv3": {
          "value": 5.606
        },
        "multiplier": {
          "value": 1.779
        },
        "ballSize": {
          "value": 5.974
        },
        "contrast": {
          "value": 2.117
        },
        "radius": {
          "value": 0.952
        },
        "rotation": {
          "value": 0.000242
        },
        "xMul": {
          "value": 30
        },
        "yMul": {
          "value": 2.208
        },
        "oY": {
          "value": 19.81
        },
        "oX": {
          "value": 1.818
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f81",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 90.275
        },
        "yDivider": {
          "value": 18.646
        },
        "xDivider": {
          "value": 9.294
        },
        "multiplier": {
          "value": 1.219
        },
        "ballSize": {
          "value": 34.82
        },
        "contrast": {
          "value": 1.8
        },
        "radius": {
          "value": 76.67
        },
        "rotation": {
          "value": 14.858
        },
        "yDivide": {
          "value": 307.888
        },
        "xDivide": {
          "value": 0.408
        },
        "yShape": {
          "value": 200
        },
        "shape": {
          "value": 14.966
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f86",
    "shader": "void main () {\n  float stream =time + stream  / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .575)*orbSize/2.,vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.343208772590362
        },
        "iterator": {
          "value": 1.1237387048192773
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 5.251195406626508
        },
        "iterations": {
          "value": 23.76
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        },
        "orbSize": {
          "value": 0.071
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fac",
    "shader": "#define orbs 5.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = cos(stream + dist) - (i + 1.) * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius / tan(t - stream);\n    float y2 = radius - sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.89
        },
        "contrast": {
          "value": 1.02
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 3.75
        },
        "colorShift": {
          "value": 2.5
        },
        "center": {
          "value": 5.29
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fdb",
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 18.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 391569.402
        },
        "ballSize": {
          "value": 58607.908
        },
        "contrast": {
          "value": 3.38
        },
        "radius": {
          "value": 21822654.66
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 133300768.7
        },
        "y": {
          "value": 7915426.66
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 96.5
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 39960.707
        },
        "div2": {
          "value": 916935.078
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca018",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 10;\n\n#define PHI   .5*PI-.5*PI*sin(sqrt(PI))\n#define TAU   (PI*PI)\n#define TTIME (stream/2.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=100.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =11.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.866
        },
        "size": {
          "value": 2.687
        },
        "offc": {
          "value": 1.042
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 2.562
        },
        "_x": {
          "value": 0.266
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      },
      {
        "zoom": {
          "value": 0.538
        },
        "size": {
          "value": 3.994
        },
        "offc": {
          "value": 0.15
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 1.89
        },
        "_x": {
          "value": 0.434
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      },
      {
        "zoom": {
          "value": 1.044
        },
        "size": {
          "value": 1.75
        },
        "offc": {
          "value": 2.138
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 4.063
        },
        "_x": {
          "value": 0.63
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01e",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.52
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca021",
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(1227.1, 311.7)),\n    dot(p, vec2(269.5, 183.3)));\n\n  return -1. + 102. * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = k_uv();\n  uv *= zoom;\n  return uv; //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main() {\n  vec2 uv = mapToScreen(vUv / resolution.xy, zoom);\n  float len = length(sin(uv - stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  vec2 _uv = uv;\n  uv = abs(uv);\n\n  vec2 _warp = _uv / dot(uv, uv);\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + abs(fbm(a * uv + stream))));\n  if (warpTween) {\n    if (warp) {\n      uv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n      uv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * abs(fbm(b * uv + stream))));\n\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc / (uv.x + log(uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 50.));\n  if (warpTween) {\n    if (warp) {\n      uv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n      uv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n  col += d2 * size * abs(cos(col2 - stream / 50.));\n  col += d3 * size * col3;\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.67
        },
        "thickness": {
          "value": 0.0182
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.045
        },
        "a": {
          "value": 634.37
        },
        "b": {
          "value": 7.61
        },
        "c": {
          "value": 2.78
        },
        "warp": {
          "value": false
        },
        "warpZoom": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03f",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 25.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca040",
    "shader": "\n#define orbs 18.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2. - stream/10.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 19.33
        },
        "contrast": {
          "value": 1.55
        },
        "orbSize": {
          "value": 1.79
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 16
        },
        "div": {
          "value": 11.62
        },
        "div2": {
          "value": 32.974
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca067",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv /= sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.4
        },
        "contrast": {
          "value": 1.11
        },
        "orbSize": {
          "value": 0.08
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.35
        },
        "outer": {
          "value": 0.61
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca084",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/13.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/6000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 19.15
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 378.53
        },
        "ballSize": {
          "value": 0.87
        },
        "contrast": {
          "value": 1.77
        },
        "radius": {
          "value": 11.96
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.76
        },
        "_pow": {
          "value": 4.09
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03b",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 11.15
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b7",
    "shader": "#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.513
        },
        "contrast": {
          "value": 2.1
        },
        "ballSize": {
          "value": 0.0083
        },
        "radius": {
          "value": 105.45
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 1.61
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c4",
    "shader": "\n#define orbs 12.\n\n// COLORS  \nconst vec3 POLAR_BEAR = vec3(0.08627450980392157, 0.08627450980392157, 0.9254901960784314);\nconst vec3 LASER_LEMON = vec3(1, 0.08627450980392157, 0.10588235294117647);\nconst vec3 SEA_OF_TRANQUILITY = vec3(0.5058823529411764, 0.08627450980392157, 0.8549019607843137);\nconst vec3 FLIRT_ALERT = vec3(0.7450980392156863, 0.08627450980392157, 0.21568627450980393);\nconst vec3 JUST_A_FAIRYTALE = vec3(0.4235294117647059, 0.08627450980392157, 0.592156862745098);\nconst vec3 DIVA_GLAM = vec3(0.6980392156862745, 0.08627450980392157, 0.4627450980392157);\nconst vec3 FLAME = vec3(0.9098039215686274, 0.08627450980392157, 0.2);\nconst vec3 AZTEC_SKY = vec3(0.30196078431372547, 0.08627450980392157, 0.8431372549019608);\nconst vec3 FOUR_LEAF_CLOVER = vec3(0.7294117647058823, 0.08627450980392157, 0.6196078431372549);\nconst vec3 JOYFUL_ORANGE = vec3(0.9803921568627451, 0.08627450980392157, 0.20784313725490197);\nconst vec3 BATTLECHIP_GRAY = vec3(0.596078431372549, 0.08627450980392157, 0.5529411764705883);\nconst vec3 WISHFUL_GREEN = vec3(0.7843137254901961, 0.08627450980392157, 0.8);\nconst vec3 RIVERDALE = vec3(0.7450980392156863, 0.08627450980392157, 0.7294117647058823);\nconst vec3 BACK_TO_NATURE = vec3(0.7411764705882353, 0.08627450980392157, 0.5607843137254902);\nconst vec3 BETA_FISH = vec3(0.22745098039215686, 0.08627450980392157, 0.4);\nconst vec3 VOYAGE = vec3(0.44313725490196076, 0.08627450980392157, 0.6431372549019608); \nconst vec3 GLASS_SAPPHIRE = vec3(0.34509803921568627, 0.08627450980392157, 0.6078431372549019);\nconst vec3 WAVE_TOP = vec3(0.6862745098039216, 0.08627450980392157, 0.8274509803921568);\nconst vec3 CHARISMATIC_SKY = vec3(0.6039215686274509, 0.08627450980392157, 0.8627450980392157);\nconst vec3 ANGELICO = vec3(0.9176470588235294, 0.08627450980392157, 0.7607843137254902);\nconst vec3 FLOWERPOT = vec3(0.8470588235294118, 0.08627450980392157, 0.6274509803921569);\nconst vec3 DARK_CRIMSON = vec3(0.5176470588235295, 0.08627450980392157, 0.2549019607843137);\nconst vec3 CANYON_DUSK = vec3(0.7647058823529411, 0.08627450980392157, 0.5137254901960784);\nconst vec3 HONIED_WHITE = vec3(0.9882352941176471, 0.08627450980392157, 0.8235294117647058);\nconst vec3 SURFBOARD_YELLOW = vec3(0.9882352941176471, 0.08627450980392157, 0.5372549019607843);\n// PALETTES \nconst vec3 TEENAGE_DREAM[6] = vec3[6](SEA_OF_TRANQUILITY,WISHFUL_GREEN,CHARISMATIC_SKY,GLASS_SAPPHIRE,JUST_A_FAIRYTALE,DIVA_GLAM);\nconst vec3 NEVER_REALLY_OVER[6] = vec3[6](LASER_LEMON,JOYFUL_ORANGE,DIVA_GLAM,AZTEC_SKY,CHARISMATIC_SKY,HONIED_WHITE);\nconst vec3 WAKING_UP_IN_VEGAS[6] = vec3[6](FLIRT_ALERT,DARK_CRIMSON,ANGELICO,SURFBOARD_YELLOW,JOYFUL_ORANGE,DIVA_GLAM);\n\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n \tconst vec3 palette[6] = NEVER_REALLY_OVER;//_OVER;\n  float dist = length(uv);\n  vec2 _swirl = uv * k_rotate2d(sin(dist + stream/21.1) + rotation*stream);\n  vec2 _warp = uv / dot(uv, uv);\n\tuv = k_swap(uv, _swirl, swirl, swirlTween, swirlTweenProgress);\n  uv = k_swap(uv, _warp, warp, warpTween, warpTweenProgress);\n  //uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) { \n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-1.);\n    uv.y += cos(cosMul *  uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = palette[int(i)];\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.93
        },
        "contrast": {
          "value": 1.26
        },
        "orbSize": {
          "value": 0.59
        },
        "radius": {
          "value": 2.46
        },
        "colorShift": {
          "value": 6.88
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0.19
        },
        "cosMul": {
          "value": 0.11
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 3.12
        },
        "xSpeed": {
          "value": -0.34
        },
        "ySpeed": {
          "value": 0.26
        },
        "gloop": {
          "value": 0.0036
        },
        "yDivide": {
          "value": 2
        },
        "xDivide": {
          "value": 2
        },
        "swirl": {
          "value": false
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f5",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 64.691
        },
        "iterator": {
          "value": 0.528
        },
        "ot": {
          "value": 66.673
        },
        "I": {
          "value": 0.62
        },
        "J": {
          "value": 2.201
        },
        "K": {
          "value": 50.17
        },
        "iterations": {
          "value": 19.738
        },
        "L": {
          "value": 35.129
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 1.457
        },
        "colorOffset": {
          "value": 54.805
        },
        "contrast": {
          "value": 1.633
        },
        "orbSize": {
          "value": 1.601
        },
        "div": {
          "value": 3.113
        },
        "radius": {
          "value": 2.044
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5d",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.23
        },
        "xMultiplier": {
          "value": 29.96
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.68
        },
        "colorSpread": {
          "value": 1.79
        },
        "colorMultiplier": {
          "value": 383.24
        },
        "shapeMultiplier": {
          "value": 13.45
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 5.1
        },
        "rotation": {
          "value": 11.628
        },
        "brightness": {
          "value": 8078.46
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f64",
    "shader": "#define BALLS 20\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01*sin(shapeMultiplier*dot(uv, uv)/dist - stream/2.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/3.));\n  float _grid = (cos(uv.x * xMultiplier - stream/3.));// * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.051
        },
        "shapeMultiplier": {
          "value": 200.17
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 69.59
        },
        "yMultiplier": {
          "value": 26.63
        },
        "colorSpread": {
          "value": 0.006
        },
        "colorMultiplier": {
          "value": 0.15
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.48
        },
        "ballSize": {
          "value": 2.22
        },
        "glow": {
          "value": 0.76
        },
        "contrast": {
          "value": 2.78
        },
        "radius": {
          "value": 9.97
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f65",
    "shader": "#define BALLS 5\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "shapeMultiplier": {
          "value": 203.13
        },
        "rotation": {
          "value": 0.05
        },
        "xMultiplier": {
          "value": 59.27
        },
        "yMultiplier": {
          "value": 88
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.81
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 3.86
        },
        "ballSize": {
          "value": 36.72
        },
        "glow": {
          "value": 1.22
        },
        "contrast": {
          "value": 2.72
        },
        "radius": {
          "value": 16.24
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9faf",
    "shader": "#define orbs 20.\n\n   \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= k_rotate2d(stream/3.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/15.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t+stream/10.);\n    float y = radius * cos(t-stream/-10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 5.)*orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 21.43
        },
        "contrast": {
          "value": 1.62
        },
        "orbSize": {
          "value": 1.25
        },
        "radius": {
          "value": 7.86
        },
        "colorShift": {
          "value": 5.09
        },
        "x1": {
          "value": 0.23
        },
        "x2": {
          "value": 0.61
        },
        "y1": {
          "value": 0.27
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 6.59
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fbc",
    "shader": "\n  #define orbs 20.\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  uv = k_kale(uv, vec2(0), sides);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 40.43
        },
        "contrast": {
          "value": 1.65
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 14.08
        },
        "colorShift": {
          "value": 7.65
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 50
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 3
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.4
        },
        "xSpeed": {
          "value": -22
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 5.89
        },
        "xDivide": {
          "value": 5.89
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fcc",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = k_kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= k_rotate2d(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < 20.; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.64
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fcf",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 2.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress);\n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv *= k_rotate2d(stream / 1.);\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x *= abs(dist + .001 * dist * (i) * (uv.x));\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 1.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.64
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd0",
    "shader": "  #define orbs 013.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = -4. + 8.* vUv / resolution.xy;\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/8.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = k_kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\t//uv *= k_rotate2d(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 1.06
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 50
        },
        "colorShift": {
          "value": 8.14
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca008",
    "shader": "void main() {\n  float t = stream;\n  vec2 r = resolution.xy;\n  vec2 uv = vUv - r;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 10.);\n\n  uv = vec2(length(uv) / r.y - 0.05, atan(uv.x, uv.y));\n  uv *= twist;\n  vec3 s = cos(1.0 * vec3(0, 1, 2) + t + uv.y / 2. + sin(uv.y / yMul) * cos(t)) / 5.0;\n  vec3 e = s.zxy;\n  vec3 f = min(uv.x - s, e - uv.x);\n  gl_FragColor.rgb = dot(clamp(f * r.y, 0., 1.), 50. * (s - e)) * (s - .1) + f;\n  gl_FragColor = k_hue(gl_FragColor, stream / 100.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0932335
        },
        "twist": {
          "value": 2.5
        },
        "kale1": {
          "value": 1
        },
        "kale2": {
          "value": 1
        },
        "yMul": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca009",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(-rotation*(dist/5.)+stream/4.+float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter*(atan(uv.x-stream/.1))*uv.x+radius*tan(t+xMultiplier) * 20.*cos(uv.x + sin(uv.y/100.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.03
        },
        "ballSize": {
          "value": 52.577
        },
        "contrast": {
          "value": 4.44
        },
        "radius": {
          "value": 1.23
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 24
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 100
        },
        "yMultiplier": {
          "value": 72.3
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca013",
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 5.;\nconst float shell = .3;\nconst float carve = .3;\nconst float falloff = 1.8;\nconst float blend = .02;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 100.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 3.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -= stream * a;\n        d = smin(d, abs(dot(sin(p),cos(p.yzx))/scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += sin(p.z*10.+stream*20.)*0.002;\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n    // coordinates\n    vec2 uv = k_uv();\n    float dither = hash12(vUv);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 20.;\n    const float count = 17.;\n    for (float index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*dither;\n        pos += ray*dist;\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-stream);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.283
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca03a",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 19.33
        },
        "contrast": {
          "value": 1.55
        },
        "orbSize": {
          "value": 1.79
        },
        "radius": {
          "value": 4.12
        },
        "colorShift": {
          "value": 16
        },
        "div": {
          "value": 11.62
        },
        "div2": {
          "value": 32.974
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04c",
    "shader": "#define orbs 20.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = zoom * uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 22.15
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 1.09
        },
        "radius": {
          "value": 5.14
        },
        "colorShift": {
          "value": 10.07
        },
        "div": {
          "value": 22.037
        },
        "div2": {
          "value": 19.684
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca046",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * outer*cos( .00001 * dot(uv, uv) - stream/4.) + uv.x / 1110. * sin(11.01 * dot(uv, uv)-stream/1.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize * pow(volume, 3.5), position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 91.91
        },
        "contrast": {
          "value": 1.26
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 8.07
        },
        "div": {
          "value": 18.147
        },
        "div2": {
          "value": 16.837
        },
        "warp": {
          "value": false
        },
        "outer": {
          "value": 0.448
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05e",
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.14 * dot(uv, 20.1 * uv) - stream);\n  uv /= sin(.005 * dot(uv + sin(1. * uv), 20.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t) * sin(dist);\n    float y = t * radius * cos(dist * t - stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.23
        },
        "contrast": {
          "value": 1.11
        },
        "orbSize": {
          "value": 0.08
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca074",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 42.58
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 2.35
        },
        "radius": {
          "value": 22.85
        },
        "colorShift": {
          "value": 8.85
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0.67
        },
        "cosMul": {
          "value": 1.64
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09f",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 65.91
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a3",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n//  uv = abs(uv);\n//  uv /= dot(uv, uv);\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/2)*cos(uv.y/yDivider + stream/201.) + sin(uv.x/10. - stream/20.);\n    uv.x += yOuter*float(i/1)*sin(uv.x/xDivider + stream/201.) * sin(uv.y/20. + stream/30.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/20.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 35.05
        },
        "yDivider": {
          "value": 1001
        },
        "xDivider": {
          "value": 320.51
        },
        "multiplier": {
          "value": 5.87
        },
        "ballSize": {
          "value": 0.17
        },
        "contrast": {
          "value": 1.63
        },
        "radius": {
          "value": 13.43
        },
        "xOuter": {
          "value": 0.83
        },
        "yOuter": {
          "value": 0.52
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b1",
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d1",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/-80.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.054
        },
        "shapeMultiplier": {
          "value": 39.9
        },
        "rotation": {
          "value": 0.0195
        },
        "xMultiplier": {
          "value": 5.66
        },
        "yMultiplier": {
          "value": 535.74
        },
        "colorSpread": {
          "value": 0.000114
        },
        "colorMultiplier": {
          "value": 2
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.23
        },
        "ballSize": {
          "value": 42.87
        },
        "glow": {
          "value": 3.54
        },
        "contrast": {
          "value": 2.13
        },
        "radius": {
          "value": 16.47
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e2",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream))/2. + stream/4.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 2.5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream), radius * sin(sinMul * t + stream));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .5)/3.5 * pow(dist, 1.15) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.466
        },
        "contrast": {
          "value": 1.421
        },
        "ballSize": {
          "value": 0.509
        },
        "radius": {
          "value": 3.976
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": -7.539
        },
        "dotMultiplier": {
          "value": 4.4
        },
        "tanMul": {
          "value": 3.857
        },
        "sinMul": {
          "value": 0.653
        },
        "shift": {
          "value": 0.845
        },
        "offset": {
          "value": 0.808
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ec",
    "shader": "#define BALLS 10.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *=k_rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.896
        },
        "contrast": {
          "value": 1.51
        },
        "ballSize": {
          "value": 0.1211
        },
        "radius": {
          "value": 2.2
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 4.35
        },
        "sinMul": {
          "value": 2.8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f7",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, .1,vec2(radius*sin(stream/30.+(-1. + 2. * vUv / resolution.xy).x/div), radius*cos(stream/30.+(-1. + 2. * vUv / resolution.xy).y/div)),  col, contrast);\n  }\n\n\n  vec3 c = vec3(ot * I + length(uv));\n            \n}",
    "variants": [
      {
        "zoom": {
          "value": 21
        },
        "iterator": {
          "value": 1.04
        },
        "ot": {
          "value": 99.773
        },
        "I": {
          "value": 1.152
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 26.455
        },
        "L": {
          "value": 7.436
        },
        "M": {
          "value": 4.34
        },
        "colorShift": {
          "value": 0.911
        },
        "colorOffset": {
          "value": 3.651
        },
        "contrast": {
          "value": 1.413
        },
        "orbSize": {
          "value": 0.259
        },
        "div": {
          "value": 0.676
        },
        "radius": {
          "value": 0.384
        }
      }
    ]
  },

  {
    "_id": "66d11670577f4e8cedfca10f",
    "shader": "\n\n\n\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  vec2 _uv = uv;\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / 3.;\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 7.81
        },
        "colorSpread": {
          "value": 7
        },
        "colorMultiplier": {
          "value": 111.05
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca111",
    "shader": "#define BALLS 3\n\nvoid main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 15.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream / .1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  uv = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 20.));\n  float _grid = (cos(uv.x * xMultiplier - stream / .5) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = (uv.x / 10.);\n  float t = float(i) * PI / float(BALLS);\n  vec2 p = vec2(sin(t), cos(t));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n  gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.94
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 8.09
        },
        "colorSpread": {
          "value": 7
        },
        "colorMultiplier": {
          "value": 111.05
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5a",
    "shader": "#define orbs 5.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x3 = radius * sin(t - stream);\n    float y3 = radius * tan(t + stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    if (warp2Tween) {\n      if (warp2) {\n        x = mix(x1, x3, warp2TweenProgress);\n        y = mix(y1, y3, warp2TweenProgress);\n      } else {\n        x = mix(x3, x1, warp2TweenProgress);\n        y = mix(y3, y1, warp2TweenProgress);\n      }\n    } else if (warp2) {\n      x = x3;\n      y = y3;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 0.88
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.87
        },
        "colorShift": {
          "value": 2.5
        },
        "center": {
          "value": 1.73
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        },
        "warp2": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5e",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 10.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.44
        },
        "xMultiplier": {
          "value": 39.33
        },
        "yMultiplier": {
          "value": 33.24
        },
        "ballSize": {
          "value": 1.31
        },
        "colorSpread": {
          "value": 0.27
        },
        "colorMultiplier": {
          "value": 554.68
        },
        "shapeMultiplier": {
          "value": 163.55
        },
        "glow": {
          "value": 1083.42
        },
        "contrast": {
          "value": 4.3
        },
        "rotation": {
          "value": 1.927
        },
        "brightness": {
          "value": 11100
        },
        "sides": {
          "value": 8
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f7b",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, .6) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 275.018
        },
        "xDiv": {
          "value": 11.484
        },
        "yDiv": {
          "value": 151.304
        },
        "xDiv2": {
          "value": 29.942
        },
        "yDiv2": {
          "value": 3.656
        },
        "xDiv3": {
          "value": 11.46
        },
        "yDiv3": {
          "value": 123.108
        },
        "multiplier": {
          "value": 0.738
        },
        "ballSize": {
          "value": 25.963
        },
        "contrast": {
          "value": 1.714
        },
        "radius": {
          "value": 10.804
        },
        "rotation": {
          "value": 0.00011
        },
        "xMul": {
          "value": 6.025
        },
        "yMul": {
          "value": 1.936
        },
        "oY": {
          "value": 3.738
        },
        "oX": {
          "value": 0.927
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f85",
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.5;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/3.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 4.);\n    vec2 p = radius * vec2(xMul * cos(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .6)/5. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 558.036
        },
        "xDiv": {
          "value": 13.393
        },
        "yDiv": {
          "value": 1848.214
        },
        "xDiv2": {
          "value": 108.036
        },
        "yDiv2": {
          "value": 90.179
        },
        "xDiv3": {
          "value": 26.786
        },
        "yDiv3": {
          "value": 419.643
        },
        "multiplier": {
          "value": 17.768
        },
        "ballSize": {
          "value": 100
        },
        "contrast": {
          "value": 2.089
        },
        "radius": {
          "value": 74.777
        },
        "rotation": {
          "value": 0.049107
        },
        "xMul": {
          "value": 4.911
        },
        "yMul": {
          "value": 2.946
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f8a",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/2. + sin(i+stream/10.));\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume*I,vec2(sin(uv.x), cos(uv.y)),  col, contrast);\n  }         \n}",
    "variants": [
      {
        "zoom": {
          "value": 0.855
        },
        "iterator": {
          "value": 1.156
        },
        "ot": {
          "value": 92.023
        },
        "I": {
          "value": 0.056
        },
        "J": {
          "value": 2.267
        },
        "K": {
          "value": 7.852
        },
        "iterations": {
          "value": 23.555
        },
        "L": {
          "value": 0.795
        },
        "M": {
          "value": 6.933
        },
        "colorShift": {
          "value": 0.756
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f9e",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb0",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 1.2967;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .7)*orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 26.54
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 5.39
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb5",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream/3.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb7",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 26.54
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 5.39
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fbb",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream/3.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= x1*sin(x2*uv.y);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 6.)*orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 17.35
        },
        "contrast": {
          "value": 1.47
        },
        "orbSize": {
          "value": 0.98
        },
        "radius": {
          "value": 5.52
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.09
        },
        "x2": {
          "value": 0.42
        },
        "y1": {
          "value": 0.24
        },
        "y2": {
          "value": 2.22
        },
        "center": {
          "value": 11
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fcb",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 4.89
        },
        "contrast": {
          "value": 0.85
        },
        "orbSize": {
          "value": 0.15
        },
        "radius": {
          "value": 1.15
        },
        "colorShift": {
          "value": 79.53
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa1",
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = 2. * time + stream  /2.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.509076148343374
        },
        "orbSize": {
          "value": 0.5489348644578315
        },
        "radius": {
          "value": 4.144187123493976
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd8",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .3) * _uv.y/div - stream/-.8));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/1. - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 947824.569
        },
        "ballSize": {
          "value": 7592.894
        },
        "contrast": {
          "value": 2
        },
        "radius": {
          "value": 12686504.54
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 108522415.87
        },
        "y": {
          "value": 14648788.88
        },
        "rotation": {
          "value": 0.00066
        },
        "colorOffset": {
          "value": 95.3
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 28453.413
        },
        "div2": {
          "value": 889304.153
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fdc",
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 10.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 2.2);\n  vec2 _uv = uv;\n  float a = woot * cos(_uv.x / div2 + stream / .14);\n  float b = w00t * sin(a * _uv.y / div - stream / .2);\n  uv *= (outer + outer2 * b);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / orbs * (2. + 1.);\n    float a = radius * tan(stream / .43 - t * PI);\n    float b = radius * tan(t - stream/-.9);\n    vec2 p = vec2(a, b);\n    float c = cos(wad * cos(stream / .3 - uv.x / x));\n    float d = .3 * y *sin(stream / .37393);\n    float e = .85*cos(stream / -.13 - uv.y / (.7 * y + d));\n    p /= (e * c);\n    p /=  (c - (c - e));\n    vec3 base = vec3(0, 1, -1) * PI * 2. / 3.;\n    float offset = (brightness  * float(i) / 6.) * 0.5;\n    vec3 col = cos(colorOffset + base + PI * offset + 0.5);\n    float size = float(i) * ballSize / length(uv  - p * 0.9);\n    gl_FragColor += vec4(intensity * size * col, contrast);\n  }\n  vec3 inverted = .5 * log(abs(gl_FragColor.xyz));\n  gl_FragColor.xyz = pow(1.-inverted, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 606351.071
        },
        "ballSize": {
          "value": 27876.048
        },
        "contrast": {
          "value": 2.22
        },
        "radius": {
          "value": 1065459.5
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 64084773.64
        },
        "y": {
          "value": 18031783.24
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1102.3
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 22692.642
        },
        "div2": {
          "value": 18649.316
        },
        "wad": {
          "value": 14.664
        },
        "woot": {
          "value": 0.11
        },
        "wat": {
          "value": 0.091
        },
        "wob": {
          "value": 18.085
        },
        "outer": {
          "value": 130.069
        },
        "outer2": {
          "value": 0
        },
        "wave": {
          "value": 0.947
        },
        "aWave": {
          "value": 0.2746
        },
        "intensity": {
          "value": 38.944
        },
        "brightness": {
          "value": 1.345
        },
        "w00t": {
          "value": 4.201
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        },
        "intensity": {
          "value": 1
        },
        "brightness": {
          "value": 1
        },
        "w00t": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe7",
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00987
        },
        "iterator": {
          "value": 4.63524
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.98477
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.24399
        },
        "colorOffset": {
          "value": 12.50333
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.46552
        },
        "div": {
          "value": 0.02173
        },
        "radius": {
          "value": 1.57716
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fec",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / -6.;\n  mat2 rotation = k_rotate2d(stream/(PI*2.));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.720) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.049
        },
        "iterator": {
          "value": 1.989
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 4.962735316265062
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.5863422439759036
        },
        "colorOffset": {
          "value": 9.61846762048193
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.2960278614457832
        },
        "div": {
          "value": 0.12494399472891568
        },
        "radius": {
          "value": 1.8993411144578316
        }
      },
      {
        "zoom": {
          "value": 0.019743034638554223
        },
        "iterator": {
          "value": 1.6151637801204821
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 7.6585843373493985
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.9093279367469881
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.9242046310240968
        },
        "orbSize": {
          "value": 0.31844879518072294
        },
        "div": {
          "value": 0.07135316265060243
        },
        "radius": {
          "value": 2.93386671686747
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00a",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 36.947006777108435
        },
        "ballSize": {
          "value": 58.014457831325316
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 136.74698795180726
        },
        "yOuter": {
          "value": 6.027861445783134
        },
        "xOuter": {
          "value": 117.67243975903617
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.8636577560240974
        },
        "yMultiplier": {
          "value": 1.62468561746988
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 94.5881965361446
        },
        "yDiv2": {
          "value": 112
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00c",
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, 1.4)/5000.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 36.947006777108435
        },
        "ballSize": {
          "value": 4.467959337349398
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 47.4550545933735
        },
        "yOuter": {
          "value": 6.027861445783134
        },
        "xOuter": {
          "value": 117.67243975903617
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.8636577560240974
        },
        "yMultiplier": {
          "value": 1.62468561746988
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 94.5881965361446
        },
        "yDiv2": {
          "value": 112
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01f",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.52
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      },
      {
        "zoom": {
          "value": 2
        },
        "thickness": {
          "value": 0.0009
        },
        "haze": {
          "value": 107.21
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.006
        },
        "a": {
          "value": 1.12
        },
        "b": {
          "value": 3.33
        },
        "c": {
          "value": 3.05
        }
      },
      {
        "zoom": {
          "value": 0.69
        },
        "thickness": {
          "value": 0.0009
        },
        "haze": {
          "value": 486.2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.003
        },
        "a": {
          "value": 9.65
        },
        "b": {
          "value": 3.33
        },
        "c": {
          "value": 3.05
        }
      },
      {
        "zoom": {
          "value": 0.9
        },
        "thickness": {
          "value": 0.0241
        },
        "haze": {
          "value": 1.57
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.016
        },
        "a": {
          "value": 0.45
        },
        "b": {
          "value": 8.16
        },
        "c": {
          "value": 3.24
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01a",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 2;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/10.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n2); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,-n1); if (t>0.0) { z-=120.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(01. *sin(stream/10.+length(p/PI)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =11.*(q - 0.5) * zoom;\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.667
        },
        "size": {
          "value": 5.11
        },
        "offc": {
          "value": 0
        },
        "width": {
          "value": 0
        },
        "_z": {
          "value": 5.085
        },
        "_x": {
          "value": 0.425
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca024",
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(17.1, 311.7)),\n    dot(p, vec2(29.5, 13.3)));\n\n  return -1. + 1021. * fract(sin(p) * 43758.5453123 * sin(stream / 1000000.) * cos(stream / 10000.));\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = k_uv();\n  uv *= zoom;\n  return uv; //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main()\n{\n  vec2 uv = mapToScreen(vUv / resolution.xy, zoom);\n  float len = length(sin(uv - stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + fbm(a * uv + stream)));\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * fbm(b * uv + stream)));\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc / (uv.x + (uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 20.));\n  col += d2 * size * abs(tan(col2 - stream / 20.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "thickness": {
          "value": 0.0021
        },
        "haze": {
          "value": 366.96
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.012
        },
        "a": {
          "value": 2.87
        },
        "b": {
          "value": 1.94
        },
        "c": {
          "value": 1.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca029",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream /3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  uv *= k_rotate2d(stream/2. + length(uv/warp));\n  uv.x += sin(uv.y/4. - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/50)*sin(uv.y/yDivider) + sin(uv.x/xDiv - stream/4.05);\n    uv.x += yOuter*float(i/1)*cos(uv.y/xDivider) * cos(uv.x/xDiv2 - stream/-11.95);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.x/1. + stream/3.)*cos(uv.y/4. - stream));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.1)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.75
        },
        "yDivider": {
          "value": 4390.12
        },
        "xDivider": {
          "value": 0.44
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.089
        },
        "contrast": {
          "value": 1.08
        },
        "radius": {
          "value": 12
        },
        "xOuter": {
          "value": 1.84
        },
        "yOuter": {
          "value": 0.23
        },
        "xDiv": {
          "value": 98.024
        },
        "xDiv2": {
          "value": 0.905
        },
        "warp": {
          "value": 3.571
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca02f",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  float div = 25.;\n  const float radius = 1000.;\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/20. - stream);\n    uv.y += cos((i+1.)*uv.x/20. + stream);\n    float t = i * PI / orbs;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/2.1);\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, 1.1, position, color, 1.2);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 30
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 0.65
        },
        "colorShift": {
          "value": 13.76
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca003",
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/1.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.24)/5.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.031951807228918
        },
        "ballSize": {
          "value": 0.6445783132530122
        },
        "contrast": {
          "value": 2.8809567326924888
        },
        "radius": {
          "value": 0.14869879518072293
        },
        "yOuter": {
          "value": 17.969914545633713
        },
        "xOuter": {
          "value": 27.03570903824037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.0018560335090365
        },
        "yMultiplier": {
          "value": 19.24
        },
        "divider": {
          "value": 6.095766072100905
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca044",
    "shader": "\n#define orbs 20.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 41
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 1.09
        },
        "radius": {
          "value": 3.98
        },
        "colorShift": {
          "value": 10.07
        },
        "div": {
          "value": 10.273
        },
        "div2": {
          "value": 45.223
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca075",
    "shader": "  #define orbs 10.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n\t    uv.x += .15*sin(uv.y+stream) + .1*cos(uv.x);\n      uv.y -= .9*cos(uv.x-stream) - .1*sin(uv.y);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 2.*sin(t-stream/2.);\n      float y = radius * cos(t+stream) + 2.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n\t\tgl_FragColor = k_hue(gl_FragColor, stream/3.);\t\n    for (float i = 0.; i < orbs; i++) {\n      uv.x += .05*sin(.1*uv.y+stream/2.) + .01*(uv.x);\n      uv.y += .2*cos(.1*uv.x-stream/2.) - .01*sin(uv.y);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.) + 10.*tan(t-stream/12.);\n      float y = radius * cos(t+stream/5.) + 1.*cos(t-stream/12.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor -=k_orb(uv, orbSize*.75, position, color, contrast);\n    }\n    gl_FragColor = k_hue(gl_FragColor, stream/5.);\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 3.4
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.79
        },
        "radius": {
          "value": 2.13
        },
        "colorShift": {
          "value": 7.31
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07b",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 13.61
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.4
        },
        "radius": {
          "value": 2.38
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.04
        },
        "sinMul": {
          "value": 0.25
        },
        "cosMul": {
          "value": 0.2
        },
        "yMul": {
          "value": 0.9
        },
        "xMul": {
          "value": 1.27
        },
        "xSpeed": {
          "value": -0.71
        },
        "ySpeed": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca082",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/13.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/6000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 19.15
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 378.53
        },
        "ballSize": {
          "value": 0.87
        },
        "contrast": {
          "value": 1.77
        },
        "radius": {
          "value": 11.96
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.76
        },
        "_pow": {
          "value": 4.09
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca09b",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c2",
    "shader": "\n#define BALLS 20.\n  \n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0df",
    "shader": "#define BALLS 12\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / 1.5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/15.);\n  uv = abs(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += itY *float(i)*cos(uv.y/yDivider - stream) - 2.*sin(uv.x/xDiv - stream/3.);\n    uv.x += itX *float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider - stream /4.) - sin(uv.y/yDiv-stream/2.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t- uv.x/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 30.19243806475904
        },
        "yDivider": {
          "value": 3.157021837349398
        },
        "xDivider": {
          "value": 13.953981551204821
        },
        "multiplier": {
          "value": 0.23878953313253018
        },
        "ballSize": {
          "value": 33
        },
        "contrast": {
          "value": 0.7774875753012048
        },
        "radius": {
          "value": 99.06938064759036
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 16.12448230421687
        },
        "yDiv": {
          "value": 29.392187500000006
        },
        "xDiv2": {
          "value": 60.20790662650604
        },
        "itY": {
          "value": 0.0981174698795181
        },
        "itX": {
          "value": 0.18025790662650606
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e6",
    "shader": "\n\n#define BALLS 15\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *=k_rotate2d(rotation * (dist - stream/200.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.21
        },
        "xMultiplier": {
          "value": 49.77
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 1.37
        },
        "colorSpread": {
          "value": 1.21
        },
        "colorMultiplier": {
          "value": 500
        },
        "shapeMultiplier": {
          "value": 17.27
        },
        "glow": {
          "value": 2080.32
        },
        "contrast": {
          "value": 4.53
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 6430.09
        },
        "sides": {
          "value": 9
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 1.1
        },
        "xMultiplier": {
          "value": 200
        },
        "yMultiplier": {
          "value": 167.38
        },
        "ballSize": {
          "value": 0.6
        },
        "colorSpread": {
          "value": 0.27
        },
        "colorMultiplier": {
          "value": 256.75
        },
        "shapeMultiplier": {
          "value": 65.06
        },
        "glow": {
          "value": 8509.81
        },
        "contrast": {
          "value": 4.52
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 5636
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 1.09
        },
        "xMultiplier": {
          "value": 63.13
        },
        "yMultiplier": {
          "value": 77.92
        },
        "ballSize": {
          "value": 0.52
        },
        "colorSpread": {
          "value": 1.71
        },
        "colorMultiplier": {
          "value": 256.75
        },
        "shapeMultiplier": {
          "value": 65.06
        },
        "glow": {
          "value": 8509.81
        },
        "contrast": {
          "value": 4.52
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 5636
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.45
        },
        "xMultiplier": {
          "value": 24.23
        },
        "yMultiplier": {
          "value": 13.15
        },
        "ballSize": {
          "value": 0.6
        },
        "colorSpread": {
          "value": 1.71
        },
        "colorMultiplier": {
          "value": 256.75
        },
        "shapeMultiplier": {
          "value": 65.06
        },
        "glow": {
          "value": 8509.81
        },
        "contrast": {
          "value": 4.52
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 5636
        },
        "sides": {
          "value": 10
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f70",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x + stream)) * uv.x + radius * sin(t + xMultiplier + stream), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.08
        },
        "ballSize": {
          "value": 0.099
        },
        "contrast": {
          "value": 4.47
        },
        "radius": {
          "value": 1.91
        },
        "yOuter": {
          "value": 45.35
        },
        "xOuter": {
          "value": 15.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.68
        },
        "yMultiplier": {
          "value": 9.62
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f73",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 30.12751317771085
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 0.7
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 11.5300734186747
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f92",
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.831
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.685
        },
        "radius": {
          "value": 2.435
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa5",
    "shader": "#define orbs 10.\n\n   \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= k_rotate2d(stream/13.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 22.345463102409646
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.64
        },
        "x2": {
          "value": 0.34
        },
        "y1": {
          "value": 0.41
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb1",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream/3.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc8",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = k_kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= k_rotate2d(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 2.64
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 4.35
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 30.99
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fcd",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x *= abs(dist + .009 * dist * (i + 1.) * (uv.x));\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 3.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.88
        },
        "contrast": {
          "value": 1.75
        },
        "orbSize": {
          "value": 0.55
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 8.84
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fa3",
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 22.345463102409646
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 2.404405120481928
        },
        "x2": {
          "value": 0.8480045180722893
        },
        "y1": {
          "value": 0.41
        },
        "y2": {
          "value": 1.06
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 6.943693524096386
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.35281795933734944
        },
        "radius": {
          "value": 1.463413027108434
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0
        },
        "x2": {
          "value": 0.07756023333999278
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 3.9954113328313263
        },
        "center": {
          "value": 9.759704442771085
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 20.516971009036148
        },
        "contrast": {
          "value": 1.6040850903614459
        },
        "orbSize": {
          "value": 0.6914401355421687
        },
        "radius": {
          "value": 1.0743787650602412
        },
        "colorShift": {
          "value": 7.42
        },
        "x1": {
          "value": 0.006485316265060244
        },
        "x2": {
          "value": 0.39095914909638557
        },
        "y1": {
          "value": 0.5479049740494154
        },
        "y2": {
          "value": 0.29673381024096396
        },
        "center": {
          "value": 2.7102409638554223
        },
        "sides": {
          "value": 5
        }
      },
      {
        "zoom": {
          "value": 15.777244917168678
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 1.1566663215361448
        },
        "radius": {
          "value": 4.044220632530121
        },
        "colorShift": {
          "value": 5.551138930722892
        },
        "x1": {
          "value": 0.30045180722891573
        },
        "x2": {
          "value": 1
        },
        "y1": {
          "value": 0.5074830572289157
        },
        "y2": {
          "value": 3.37050545933735
        },
        "center": {
          "value": 7.7
        },
        "sides": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fd5",
    "shader": "  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.009* dist*(i+1.) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 1.88
        },
        "contrast": {
          "value": 1.75
        },
        "orbSize": {
          "value": 0.55
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 8.84
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00b",
    "shader": "void main () {\n  float stream = stream/1. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/1.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/3.14)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 33.30431099397591
        },
        "ballSize": {
          "value": 4.467959337349398
        },
        "contrast": {
          "value": 2.5764307228915664
        },
        "radius": {
          "value": 47.4550545933735
        },
        "yOuter": {
          "value": 6.027861445783134
        },
        "xOuter": {
          "value": 117.67243975903617
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.8636577560240974
        },
        "yMultiplier": {
          "value": 1.62468561746988
        },
        "divider": {
          "value": 1.2380176957831328
        },
        "rotation": {
          "value": 0
        },
        "yDiv": {
          "value": 94.5881965361446
        },
        "yDiv2": {
          "value": 112
        },
        "xDiv": {
          "value": 5.729734563253014
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca00f",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = k_uv();\n  vec2 _uv = uv;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/2.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4. + .01*uv))*cos(uv.x/xDiv - stream/4.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 53.73293577243752
        },
        "yDivider": {
          "value": 2.1694277108433737
        },
        "xDivider": {
          "value": 4.430280496987952
        },
        "multiplier": {
          "value": 1.2283603162650605
        },
        "ballSize": {
          "value": 7.5453642695783145
        },
        "contrast": {
          "value": 0.6708647402108434
        },
        "radius": {
          "value": 128.25703125
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 151.80625
        },
        "xDiv2": {
          "value": 15.67018542921687
        },
        "itY": {
          "value": 0.1551346009036145
        },
        "itX": {
          "value": 0.09707172439759039
        },
        "oS": {
          "value": 0.249378765060241
        },
        "oT": {
          "value": 0.6427899096385543
        },
        "yShape": {
          "value": 4.247590361445784
        }
      },
      {
        "zoom": {
          "value": 32.46323842243976
        },
        "yDivider": {
          "value": 2.951618975903615
        },
        "xDivider": {
          "value": 0.42119728915662663
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 21.58139118975904
        },
        "contrast": {
          "value": 1.1464503012048195
        },
        "radius": {
          "value": 165.77595067771088
        },
        "rotation": {
          "value": 0.12331758283132532
        },
        "xDiv": {
          "value": 29.762142319277114
        },
        "yDiv": {
          "value": 23.026562500000004
        },
        "xDiv2": {
          "value": 33
        },
        "itY": {
          "value": 0.041319008087971405
        },
        "itX": {
          "value": 0
        },
        "oS": {
          "value": 0
        },
        "oT": {
          "value": 1.8478727409638558
        },
        "yShape": {
          "value": 25.166716867469884
        }
      },
      {
        "zoom": {
          "value": 25.434176863704824
        },
        "yDivider": {
          "value": 2.951618975903615
        },
        "xDivider": {
          "value": 0.42119728915662663
        },
        "multiplier": {
          "value": 2
        },
        "ballSize": {
          "value": 17.750080007530123
        },
        "contrast": {
          "value": 1.1464503012048195
        },
        "radius": {
          "value": 182.8381259412651
        },
        "rotation": {
          "value": 0.2845297439759037
        },
        "xDiv": {
          "value": 1
        },
        "yDiv": {
          "value": 0
        },
        "xDiv2": {
          "value": 33
        },
        "itY": {
          "value": 0
        },
        "itX": {
          "value": 0
        },
        "oS": {
          "value": 0
        },
        "oT": {
          "value": 0.9522213855421688
        },
        "yShape": {
          "value": 17.82530120481928
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca015",
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 13 ;\n\n#define PHI   ((1./sqrt(PI)))\n#define TAU   (1.0*PI)\n#define TTIME (TAU*stream)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*0.5*(0.05 + 0.05*sin(1.0*length(p) - 0.5*p.y + TTIME/2.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = k_uv();\n  vec2 p =1.6*(q - 0.5);\n  ;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.871
        },
        "size": {
          "value": 3.76
        },
        "offc": {
          "value": 0.135
        },
        "width": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca01d",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.84553
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca022",
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(17.1, 311.7)),\n    dot(p, vec2(29.5, 13.3)));\n\n  return -1. + 1021. * fract(sin(p) * 43758.5453123 * sin(stream / 1000000.) * cos(stream / 10000.));\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = k_uv();\n  uv *= zoom;\n  return abs(uv);\n  return abs(uv) * outer * sin(stream / 20.) * sin(dot(uv, uv) - stream * 3.); //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main()\n{\n  vec2 uv = mapToScreen(vUv / resolution.xy, zoom);\n  float len = length(sin(uv - 34.21 * stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + fbm(a * uv + stream)));\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * fbm(b * uv + stream)));\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc * (uv.x - log(uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 20.));\n  col += d2 * size * abs(tan(col2 - stream / 20.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.36
        },
        "thickness": {
          "value": 0.0391
        },
        "haze": {
          "value": 1100
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.007
        },
        "a": {
          "value": 31.29
        },
        "b": {
          "value": 4.01
        },
        "c": {
          "value": 1.14
        },
        "outer": {
          "value": 2.62
        },
        "inner": {
          "value": 3.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca035",
    "shader": "\n#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .00005 * dot(uv, uv) + stream/3.) * sin(.0001 * dot(uv, uv)-stream/6.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 91.99
        },
        "contrast": {
          "value": 1.25
        },
        "orbSize": {
          "value": 1.11
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 23.45
        },
        "div": {
          "value": 45.722
        },
        "div2": {
          "value": 63.807
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca049",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 25.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05a",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv / dot(uv, uv), warpTweenProgress);\n    } else {\n      uv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n    uv /= dot(uv, uv);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / .5 * PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10. / dist) / t * radius * sin(stream / 3. + dist * t) * cos(uv.y * dist - stream) * sin(dist - stream / 2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.47
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 5.46
        },
        "colorShift": {
          "value": 7.8
        },
        "center": {
          "value": 2.76
        },
        "sides": {
          "value": 15
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca05b",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 19.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv / dot(uv, uv), warpTweenProgress);\n    } else {\n      uv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n    uv /= dot(uv, uv);\n  }\n  vec2 kale_ = sin(k_kale(uv, vec2(center), sides) - stream);\n  if (kkkTween) {\n    if (kkk) {\n      uv = mix(uv, (kale_), kkkTweenProgress);\n    } else {\n      uv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n    uv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / .5 * PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base / dist) / t * radius * sin(stream / 3. + dist * t) * cos(uv.y * dist - stream) * sin(dist - stream / 2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.33
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 6.4
        },
        "colorShift": {
          "value": 5.57
        },
        "center": {
          "value": 2.71
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        },
        "kkk": {
          "value": false
        },
        "base": {
          "value": 7.16
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06e",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "contrast": {
          "value": 0.89
        },
        "orbSize": {
          "value": 0.66
        },
        "radius": {
          "value": 12.33
        },
        "colorShift": {
          "value": 9.55
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.7
        },
        "cosMul": {
          "value": 0.98
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.57
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0048
        },
        "yDivide": {
          "value": 4.98
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca099",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n  float dist = length(uv);\n  //  uv *= sin(uv.y/20.)+k_rotate2d(dist/10.-stream/20.);\n\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .362 * float(i) * cos(uv.y / yDivider - stream / 111.) + sin(uv.x / 21. - stream / 112.);\n    uv.x += .152 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 111.) - sin(uv.y / 210. + stream / 112.);\n    float t = .005 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 415. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 52.32
        },
        "yDivider": {
          "value": 472.4
        },
        "xDivider": {
          "value": 377.14
        },
        "multiplier": {
          "value": 58.37
        },
        "ballSize": {
          "value": 0.57
        },
        "contrast": {
          "value": 1.78
        },
        "radius": {
          "value": 7.86
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a6",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.22
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.203
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ab",
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ae",
    "shader": "\n#define BALLS 20.\n  \n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.79
        },
        "contrast": {
          "value": 3.03
        },
        "ballSize": {
          "value": 0.016
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 1.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0bd",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 4.99
        },
        "ballSize": {
          "value": 0.011
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c5",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream * 2. + abs(uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow(dist, 3.) * pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.63
        },
        "contrast": {
          "value": 2.58
        },
        "ballSize": {
          "value": 0.01
        },
        "radius": {
          "value": 131.23
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c6",
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 589.178
        },
        "rotation": {
          "value": 0.012
        },
        "xMultiplier": {
          "value": 251.592
        },
        "yMultiplier": {
          "value": 1549.9
        },
        "colorSpread": {
          "value": 0.000012
        },
        "colorMultiplier": {
          "value": 0.51
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.86
        },
        "ballSize": {
          "value": 6.194
        },
        "glow": {
          "value": 4.435
        },
        "contrast": {
          "value": 3.189
        },
        "radius": {
          "value": 10.691
        },
        "zoom2": {
          "value": 0.48
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0c8",
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 589.178
        },
        "rotation": {
          "value": 0.012
        },
        "xMultiplier": {
          "value": 251.592
        },
        "yMultiplier": {
          "value": 1549.9
        },
        "colorSpread": {
          "value": 0.000012
        },
        "colorMultiplier": {
          "value": 0.51
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.86
        },
        "ballSize": {
          "value": 6.194
        },
        "glow": {
          "value": 4.435
        },
        "contrast": {
          "value": 3.189
        },
        "radius": {
          "value": 10.691
        },
        "zoom2": {
          "value": 0.48
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0dd",
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/15.);  \n\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider + stream / -2.) + cos(uv.x/c + stream/-3.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * tan(uv.y/300.)*cos(uv.y/106.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, 2.04)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.44
        },
        "yDivider": {
          "value": 3.95
        },
        "xDivider": {
          "value": 0.43
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.56
        },
        "contrast": {
          "value": 1.64
        },
        "radius": {
          "value": 1.54
        },
        "rotation": {
          "value": 0.19
        },
        "a": {
          "value": 0.03
        },
        "b": {
          "value": 0.13
        },
        "c": {
          "value": 2.23
        },
        "d": {
          "value": 2.2
        },
        "e": {
          "value": 0.34
        },
        "f": {
          "value": 0.95
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0e3",
    "shader": "\n#define BALLS 10.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *=k_rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.896
        },
        "contrast": {
          "value": 1.51
        },
        "ballSize": {
          "value": 0.1211
        },
        "radius": {
          "value": 2.2
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 5
        },
        "dotMultiplier": {
          "value": 1
        },
        "tanMul": {
          "value": 4.35
        },
        "sinMul": {
          "value": 2.8
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca113",
    "shader": "#define BALLS 5\n\nvoid main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 15.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream / .1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  uv = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 20.));\n  float _grid = (cos(uv.x * xMultiplier - stream / .5) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.06
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.25
        },
        "colorSpread": {
          "value": 3.36
        },
        "colorMultiplier": {
          "value": 114.55
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f78",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 176.593
        },
        "xDiv": {
          "value": 192.407
        },
        "yDiv": {
          "value": 4.196
        },
        "xDiv2": {
          "value": 1.126
        },
        "yDiv2": {
          "value": 5.65
        },
        "xDiv3": {
          "value": 45.225
        },
        "yDiv3": {
          "value": 3.119
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 46.211
        },
        "contrast": {
          "value": 2.483
        },
        "radius": {
          "value": 15.486
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 1.595
        },
        "yMul": {
          "value": 7.948
        },
        "oY": {
          "value": 14.309
        },
        "oX": {
          "value": 10.51
        }
      },
      {
        "zoom": {
          "value": 39.827
        },
        "xDiv": {
          "value": 135.065
        },
        "yDiv": {
          "value": 4.069
        },
        "xDiv2": {
          "value": 3.117
        },
        "yDiv2": {
          "value": 4.848
        },
        "xDiv3": {
          "value": 335.931
        },
        "yDiv3": {
          "value": 11.775
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 22.294
        },
        "contrast": {
          "value": 2.468
        },
        "radius": {
          "value": 3.377
        },
        "rotation": {
          "value": 0.001
        },
        "xMul": {
          "value": 12.641
        },
        "yMul": {
          "value": 3.55
        },
        "oY": {
          "value": 38.286
        },
        "oX": {
          "value": 1.905
        }
      },
      {
        "zoom": {
          "value": 65.801
        },
        "xDiv": {
          "value": 86.58
        },
        "yDiv": {
          "value": 0.779
        },
        "xDiv2": {
          "value": 3.983
        },
        "yDiv2": {
          "value": 3.463
        },
        "xDiv3": {
          "value": 100.433
        },
        "yDiv3": {
          "value": 7.416
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 18.615
        },
        "contrast": {
          "value": 1.857
        },
        "radius": {
          "value": 4.286
        },
        "rotation": {
          "value": 0.000273
        },
        "xMul": {
          "value": 2.338
        },
        "yMul": {
          "value": 5.368
        },
        "oY": {
          "value": 39.81
        },
        "oX": {
          "value": 5.455
        }
      },
      {
        "zoom": {
          "value": 43.29
        },
        "xDiv": {
          "value": 35.498
        },
        "yDiv": {
          "value": 12.121
        },
        "xDiv2": {
          "value": 0.606
        },
        "yDiv2": {
          "value": 40
        },
        "xDiv3": {
          "value": 72.727
        },
        "yDiv3": {
          "value": 5.524
        },
        "multiplier": {
          "value": 1.065
        },
        "ballSize": {
          "value": 44.805
        },
        "contrast": {
          "value": 2.506
        },
        "radius": {
          "value": 4.935
        },
        "rotation": {
          "value": 0.000429
        },
        "xMul": {
          "value": 12.294
        },
        "yMul": {
          "value": 3.636
        },
        "oY": {
          "value": 20.571
        },
        "oX": {
          "value": 5.801
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f82",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  vec2 mirrored = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _dotted = uv * sin(.0001 * dot(uv, uv) - stream / 10.);\n  if (mirrorTween) {\n    if (dotted) {\n      uv = mix(uv, mirrored, dottedTweenProgress);\n    } else {\n      uv = mix(mirrored, uv, dottedTweenProgress);\n    }\n  } else if (mirror) {\n    uv = mirrored;\n  }\n  if (dottedTween) {\n    if (dotted) {\n      uv = mix(uv, _dotted, dottedTweenProgress);\n    } else {\n      uv = mix(_dotted, uv, dottedTweenProgress);\n    }\n  } else if (dotted) {\n    uv = _dotted;\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 116.00066318094458
        },
        "yDivider": {
          "value": 2.0108340560372664
        },
        "xDivider": {
          "value": 19.66732405775273
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 26.2977033459619
        },
        "contrast": {
          "value": 3.1896125184039077
        },
        "radius": {
          "value": 51.601894147360014
        },
        "rotation": {
          "value": 10.745
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 1.485310136543849
        },
        "yShape": {
          "value": 14.65960528313752
        },
        "shape": {
          "value": 71.5548653767282
        },
        "dotted": {
          "value": false
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 113.869
        },
        "yDivider": {
          "value": 0.648
        },
        "xDivider": {
          "value": 4.401
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 18.522
        },
        "contrast": {
          "value": 3.132
        },
        "radius": {
          "value": 28.094
        },
        "rotation": {
          "value": 10.745
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 0.788
        },
        "yShape": {
          "value": 4.193
        },
        "shape": {
          "value": 142.16
        },
        "dotted": {
          "value": false
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f60",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 30.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 200.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 20.) - sin(uv.y * yMultiplier + stream / 15.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.21
        },
        "xMultiplier": {
          "value": 49.77
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 1.37
        },
        "colorSpread": {
          "value": 1.21
        },
        "colorMultiplier": {
          "value": 500
        },
        "shapeMultiplier": {
          "value": 17.27
        },
        "glow": {
          "value": 2080.32
        },
        "contrast": {
          "value": 4.53
        },
        "rotation": {
          "value": 5
        },
        "brightness": {
          "value": 6430.09
        },
        "sides": {
          "value": 9
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fb8",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/30.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/50.);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 9.75
        },
        "contrast": {
          "value": 1.72
        },
        "orbSize": {
          "value": 0.54
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4
        },
        "x1": {
          "value": 0.22
        },
        "x2": {
          "value": 0.38
        },
        "y1": {
          "value": 0.22
        },
        "y2": {
          "value": 1.03
        },
        "center": {
          "value": 3.95
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc9",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.96
        },
        "contrast": {
          "value": 0.85
        },
        "orbSize": {
          "value": 0.15
        },
        "radius": {
          "value": 1.15
        },
        "colorShift": {
          "value": 79.53
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fe6",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-60.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,1.1) * orbSize, vec2(radius*abs(tan(stream/11.3+uv.x/div)) * L *\n                                                              sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)), \n                          col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.03338
        },
        "iterator": {
          "value": 1.42433
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.139
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 20
        },
        "L": {
          "value": 1.457
        },
        "M": {
          "value": 0.358
        },
        "colorShift": {
          "value": 0.572
        },
        "colorOffset": {
          "value": 23.207
        },
        "contrast": {
          "value": 1.392
        },
        "orbSize": {
          "value": 0.647
        },
        "div": {
          "value": 0.16863
        },
        "radius": {
          "value": 7.992
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca025",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main () {\n  vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n  float len = length (sin(uv-stream));\n  float thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n  vec2 _uv = uv;\n   uv = abs(uv);\n\n  vec2 _warp = _uv / dot(uv, uv);\n  float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n  if (warpTween) {\n   \tif (warp) {\n    \tuv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n\t\t\tuv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\n  float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n\n  float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n  vec3 col = vec3 (.0);\n  col += d1*size*abs(sin(col1-stream/50.));\n if (warpTween) {\n   \tif (warp) {\n    \tuv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n\t\t\tuv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\tcol += d2*size*abs(cos(col2-stream/50.));\n\tcol += d3*size*col3;\n  gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.67
        },
        "thickness": {
          "value": 0.0182
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.8, 0.2, 0.6]
        },
        "col2": {
          "value": [0.8, 0.2, 0.6]
        },
        "col3": {
          "value": [0.8, 0.2, 0.6]
        },
        "size": {
          "value": 0.045
        },
        "a": {
          "value": 634.37
        },
        "b": {
          "value": 7.61
        },
        "c": {
          "value": 2.78
        },
        "warp": {
          "value": false
        },
        "warpZoom": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca030",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 11.15
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca057",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n\n  for (float i = 0.; i <5.; i++) {\n    uv += uv * k_rotate2d(rotation / (i + 1.))* k_rotate2d(.001*stream/(PI/.125/(i+1.)));;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(radius*cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-31. + uv.x/xDiv * sin(stream/31.24-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(10.11*uv.y*yDiv2+stream/-12.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. \n                   + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * .8) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 1646.1309740181432
        },
        "ballSize": {
          "value": 163.83789158097235
        },
        "contrast": {
          "value": 31.105512504118035
        },
        "radius": {
          "value": 0.7008733769042019
        },
        "yOuter": {
          "value": 1.8334986675216494
        },
        "xOuter": {
          "value": 19.315167898155124
        },
        "xMultiplier": {
          "value": 0.03616945565464986
        },
        "yMultiplier": {
          "value": 7.551691396322596
        },
        "divider": {
          "value": 0.76852540165545
        },
        "rotation": {
          "value": 5.062753576255707
        },
        "yDiv": {
          "value": 88.92895783573749
        },
        "yDiv2": {
          "value": 0.40368724271475553
        },
        "xDiv": {
          "value": 108.5551214011319
        },
        "xDiv2": {
          "value": 30197.249208942096
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca052",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .00001 * dot(uv, uv) + stream/1.) * sin(.001 * dot(uv, uv)+stream/.5);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 79.62
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.61
        },
        "radius": {
          "value": 6.7
        },
        "colorShift": {
          "value": 23.39
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca073",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 31.68
        },
        "contrast": {
          "value": 1.03
        },
        "orbSize": {
          "value": 2
        },
        "radius": {
          "value": 13
        },
        "colorShift": {
          "value": 7.12
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 0.94
        },
        "yMul": {
          "value": 0.14
        },
        "xMul": {
          "value": 0.05
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 3.2
        },
        "xDivide": {
          "value": 2.08
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca077",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.1
        },
        "yDivider": {
          "value": 332.97
        },
        "xDivider": {
          "value": 377.39
        },
        "multiplier": {
          "value": 61.62
        },
        "ballSize": {
          "value": 0.12
        },
        "contrast": {
          "value": 3.52
        },
        "radius": {
          "value": 31.84
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca07c",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca094",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0a9",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.22
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.203
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0af",
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.513
        },
        "contrast": {
          "value": 2.1
        },
        "ballSize": {
          "value": 0.0083
        },
        "radius": {
          "value": 105.45
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 1.61
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b2",
    "shader": "#define BALLS 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (abs(uv)));\n  uv *= sin(dotMultiplier * (dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(20. * dist * rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul * tan(t), sinMul * sin(t));\n    // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.513
        },
        "contrast": {
          "value": 2.1
        },
        "ballSize": {
          "value": 0.0083
        },
        "radius": {
          "value": 105.45
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        },
        "dotMultiplier": {
          "value": 2.24
        },
        "tanMul": {
          "value": 3.12
        },
        "sinMul": {
          "value": 1.61
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b8",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream*2.+abs(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.)*pow(dist, 3.)*pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.63
        },
        "contrast": {
          "value": 2.58
        },
        "ballSize": {
          "value": 0.01
        },
        "radius": {
          "value": 131.23
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0dc",
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/130.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 40. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, 1.)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.67
        },
        "yDivider": {
          "value": 81.88
        },
        "xDivider": {
          "value": 1.01
        },
        "multiplier": {
          "value": 5.86
        },
        "ballSize": {
          "value": 0.77
        },
        "contrast": {
          "value": 0.87
        },
        "radius": {
          "value": 1.73
        },
        "rotation": {
          "value": 0.22587259377776392
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0.18
        },
        "c": {
          "value": 1.61
        },
        "d": {
          "value": 3.05
        },
        "e": {
          "value": 0.34
        },
        "f": {
          "value": 0.95
        }
      },
      {
        "zoom": {
          "value": 8.61354989366002
        },
        "yDivider": {
          "value": 1.9712829910422611
        },
        "xDivider": {
          "value": 5.017385253372832
        },
        "multiplier": {
          "value": 10528.643868617806
        },
        "ballSize": {
          "value": 1.0898527291689468
        },
        "contrast": {
          "value": 1.8993169481920358
        },
        "radius": {
          "value": 3.461095054074759
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.0640341525903982
        },
        "b": {
          "value": 0.061613661036159284
        },
        "c": {
          "value": 1.4230565591203275
        },
        "d": {
          "value": 6.6857779104421
        },
        "e": {
          "value": 1.8910778800592485
        },
        "f": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 17.54
        },
        "yDivider": {
          "value": 10.19
        },
        "xDivider": {
          "value": 2.85
        },
        "multiplier": {
          "value": 11094.65
        },
        "ballSize": {
          "value": 0.36
        },
        "contrast": {
          "value": 1.98
        },
        "radius": {
          "value": 0
        },
        "rotation": {
          "value": 0.38
        },
        "a": {
          "value": 0.05
        },
        "b": {
          "value": 0.5
        },
        "c": {
          "value": 1.44
        },
        "d": {
          "value": 7.09
        },
        "e": {
          "value": 2
        },
        "f": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ef",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/100. * PI);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i * iterations, colorShift, colorOffset);\n    uv -= .621*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 44.466
        },
        "iterator": {
          "value": 0.737
        },
        "ot": {
          "value": 66.673
        },
        "I": {
          "value": 2.876
        },
        "J": {
          "value": 2.574
        },
        "K": {
          "value": 41.562
        },
        "iterations": {
          "value": 16.81
        },
        "L": {
          "value": 91.488
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 0.831
        },
        "colorOffset": {
          "value": 66.971
        },
        "contrast": {
          "value": 1.09
        },
        "orbSize": {
          "value": 5.062
        },
        "div": {
          "value": 2.042
        },
        "radius": {
          "value": 3.651
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f1",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= .61*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 247.892
        },
        "iterator": {
          "value": 0.319
        },
        "ot": {
          "value": 66.673
        },
        "I": {
          "value": 2.876
        },
        "J": {
          "value": 2.574
        },
        "K": {
          "value": 41.562
        },
        "iterations": {
          "value": 4.305
        },
        "L": {
          "value": 91.488
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 0.383
        },
        "colorOffset": {
          "value": 71.375
        },
        "contrast": {
          "value": 1.09
        },
        "orbSize": {
          "value": 2.838
        },
        "div": {
          "value": 1.906
        },
        "radius": {
          "value": 1.054
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f4",
    "shader": "void main () {\n  float stream = stream / volumeDivider;\n  vec2 uv = k_uv();\nuv *= zoom;\n  uv *= k_rotate2d(stream/-1.);\n\n  mat2 rotation = k_rotate2d(length((-1. + 2. * vUv / resolution.xy)/12.)+ stream/3.);\n  uv *= k_rotate2d(stream/21.);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - .2;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    vec2 position = vec2(x, y);\n    gl_FragColor += k_orb(uv, 1./length(uv) * pow(volume, reactivity)/6. * orbSize * gl_FragCoord.z, position,  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 321.999
        },
        "iterator": {
          "value": 0.432
        },
        "ot": {
          "value": 151
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.987
        },
        "K": {
          "value": 58.378
        },
        "iterations": {
          "value": 7
        },
        "L": {
          "value": 117.24
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 0.813
        },
        "colorOffset": {
          "value": 2.629
        },
        "contrast": {
          "value": 0.644
        },
        "orbSize": {
          "value": 2
        },
        "div": {
          "value": 0.364
        },
        "radius": {
          "value": 0.678
        },
        "sides": {
          "value": 8
        },
        "reactivity": {
          "value": 1.188
        },
        "volumeDivider": {
          "value": 8.243
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca089",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs + stream;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 14.56
        },
        "contrast": {
          "value": 1.05
        },
        "orbSize": {
          "value": 0.38
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 12.392
        },
        "div2": {
          "value": 11.325
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f59",
    "shader": "#define BALLS 25\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv *= zoom;\n  uv *= log(dot(uv, uv));\n  uv = normalize(uv) * length(uv);\n  uv *= k_rotate2d(-rotation/30.*-stream/3.);\n  uv *= a * (.15 + .525 * sin(b * dot(uv, uv) - stream/7.));\n  float dist = length(uv * log(abs(uv)));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n  uv *= k_rotate2d(rotation + (log(1./dist) - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) + stream/1651.;\n    vec2 p = vec2(c * sin(e + t), c * cos(d * t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (false) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.134
        },
        "xMultiplier": {
          "value": 412.109
        },
        "yMultiplier": {
          "value": 435.908
        },
        "ballSize": {
          "value": 22.031
        },
        "colorSpread": {
          "value": 0.002
        },
        "colorMultiplier": {
          "value": 1250.438
        },
        "shapeMultiplier": {
          "value": 496.378
        },
        "glow": {
          "value": 9132.468
        },
        "contrast": {
          "value": 4.843
        },
        "rotation": {
          "value": -2.824
        },
        "brightness": {
          "value": 3916.284
        },
        "sides": {
          "value": 22.551
        },
        "a": {
          "value": 0.093
        },
        "b": {
          "value": 0.911
        },
        "c": {
          "value": 20.433
        },
        "d": {
          "value": 22.362
        },
        "e": {
          "value": 3.479
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1c",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(cul * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 0.168
        },
        "orbSize": {
          "value": 2.97
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 9.54
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0.1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.93
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 1.31
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": -1
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.47
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "cul": {
          "value": 0.08
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f1d",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 59900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 5.33
        },
        "radius": {
          "value": 36.25
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 4.89
        },
        "xDivide": {
          "value": 7.14
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f62",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  float dist = distance(sin(uv), vec2(0));\n  float thing = 1. / dist * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  vec2 _kale = k_kale(uv, vec2(0.), 6.);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x / .5 * xMultiplier - stream / 1.) * sin(uv.y * yMultiplier + stream / 150.));\n  uv /= (colorSpread * thing * _grid) - abs(_kale);\n  uv /= 20.01 * sin(dist);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) - stream / 4.;\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.87
        },
        "shapeMultiplier": {
          "value": 38.43
        },
        "rotation": {
          "value": 0.14
        },
        "xMultiplier": {
          "value": 10
        },
        "yMultiplier": {
          "value": 23.62
        },
        "colorSpread": {
          "value": 0.884
        },
        "colorMultiplier": {
          "value": 0.2
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 0.19
        },
        "ballSize": {
          "value": 0.01
        },
        "glow": {
          "value": 0.01
        },
        "contrast": {
          "value": 3.69
        },
        "radius": {
          "value": 0.18
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f67",
    "shader": "#define BALLS 20\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01*sin(shapeMultiplier*dot(uv, uv)/dist - stream/2.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/3.));\n  float _grid = (cos(uv.x * xMultiplier - stream/3.));// * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.051
        },
        "shapeMultiplier": {
          "value": 200.17
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 69.59
        },
        "yMultiplier": {
          "value": 26.63
        },
        "colorSpread": {
          "value": 0.006
        },
        "colorMultiplier": {
          "value": 0.15
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.48
        },
        "ballSize": {
          "value": 2.22
        },
        "glow": {
          "value": 0.76
        },
        "contrast": {
          "value": 2.78
        },
        "radius": {
          "value": 9.97
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f98",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/23.);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream/5.), uv));\n  uv *= k_rotate2d(stream/-21.);\n  uv /= dot(tan(uv), cos(uv));\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/5.)-stream/9.);\n    float y = radius * cos(sin(t+stream/5.)+stream)/4.;\n    vec2 position = vec2(x, y);\n    vec3 color = col + cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 7.95
        },
        "contrast": {
          "value": 2.93
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 7.05
        },
        "center": {
          "value": 2.13
        },
        "sides": {
          "value": 8
        },
        "dotMul": {
          "value": 0.2
        },
        "sinMul": {
          "value": 10
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9f5f",
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.14
        },
        "xMultiplier": {
          "value": 63.13
        },
        "yMultiplier": {
          "value": 0
        },
        "ballSize": {
          "value": 1.18
        },
        "colorSpread": {
          "value": 2.77
        },
        "colorMultiplier": {
          "value": 282.59
        },
        "shapeMultiplier": {
          "value": 21.93
        },
        "glow": {
          "value": 10350.68
        },
        "contrast": {
          "value": 4.57
        },
        "rotation": {
          "value": 4.072
        },
        "brightness": {
          "value": 2311.66
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fad",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc2",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = k_uv();\n          i *= zoom;\n\n    i *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      {
        "zoom": {
          "value": 0.033
        },
        "mul": {
          "value": 0.46
        },
        "rot": {
          "value": 489.87
        },
        "sub": {
          "value": 42.73
        },
        "A": {
          "value": 2.34
        },
        "B": {
          "value": 5.57
        },
        "C": {
          "value": 10.18
        },
        "D": {
          "value": 3.59
        },
        "dep": {
          "value": 0.11
        },
        "wap": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9fc4",
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/3.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 7.14
        },
        "contrast": {
          "value": 1.51
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 2.37
        },
        "colorShift": {
          "value": 6.05
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 30.99
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfc9ff0",
    "shader": "#define BALLS 10.\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream / 2.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= k_rotate2d(float(i));\n    //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream / 10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15) * dist * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.37
        },
        "ballSize": {
          "value": 0.13
        },
        "radius": {
          "value": 22.12
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca004",
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.8), radius *\ncos(.1 * dist * yOuter * uv.x / 3.5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .21)/3.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.467786754929877
        },
        "ballSize": {
          "value": 0.17738216905708776
        },
        "contrast": {
          "value": 2.8809567326924888
        },
        "radius": {
          "value": 0.4156118107071843
        },
        "yOuter": {
          "value": 17.969914545633713
        },
        "xOuter": {
          "value": 27.03570903824037
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.0018560335090365
        },
        "yMultiplier": {
          "value": 5.055801225041768
        },
        "divider": {
          "value": 6.095766072100905
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca005",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * (dist / 5.) + stream / 4. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.03
        },
        "ballSize": {
          "value": 52.577
        },
        "contrast": {
          "value": 4.44
        },
        "radius": {
          "value": 1.23
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 24
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 100
        },
        "yMultiplier": {
          "value": 72.3
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca006",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.1 * (dist / 5.) + stream / 4. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2
        },
        "ballSize": {
          "value": 2.829
        },
        "contrast": {
          "value": 2.16
        },
        "radius": {
          "value": 0.02
        },
        "yOuter": {
          "value": 715.01
        },
        "xOuter": {
          "value": 22.38
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 111
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca034",
    "shader": "\n#define orbs 12.\n\n  \n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t-stream);\n    float y = radius * cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.43
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.63
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.95
        },
        "div": {
          "value": 10.925
        },
        "div2": {
          "value": 8.505
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca04a",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/1000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 25.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.3
        },
        "radius": {
          "value": 3.77
        },
        "colorShift": {
          "value": 33
        },
        "div": {
          "value": 17.974
        },
        "div2": {
          "value": 27.909
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca061",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= .5 * sin(.005 * dot(uv + sin(2. * uv), 9.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 2.;\n    float x = radius * tan(dist * t + stream) * sin(dist);\n    float y = radius * cos(dist * t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 1.01
        },
        "orbSize": {
          "value": 0.2
        },
        "radius": {
          "value": 2.58
        },
        "colorShift": {
          "value": 7.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca063",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 2.1 * uv) - stream);\n  //  uv /= sin(.01*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.45
        },
        "contrast": {
          "value": 1.71
        },
        "orbSize": {
          "value": 0.19
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.35
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06b",
    "shader": "\n#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 6.7
        },
        "contrast": {
          "value": 1.53
        },
        "orbSize": {
          "value": 0.97
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 7.15
        },
        "outer": {
          "value": 4.79
        },
        "inner": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca06d",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 1.);\n    float y = radius * cos(t + stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 42.58
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 2.35
        },
        "radius": {
          "value": 22.85
        },
        "colorShift": {
          "value": 8.85
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0.67
        },
        "cosMul": {
          "value": 1.64
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca072",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 29.27
        },
        "contrast": {
          "value": 1.44
        },
        "orbSize": {
          "value": 2.57
        },
        "radius": {
          "value": 25.16
        },
        "colorShift": {
          "value": 8.53
        },
        "sides": {
          "value": 2
        },
        "rotation": {
          "value": 0.4
        },
        "sinMul": {
          "value": 1.03
        },
        "cosMul": {
          "value": 2.31
        },
        "yMul": {
          "value": 0.36
        },
        "xMul": {
          "value": 0.16
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0092
        },
        "yDivide": {
          "value": 9.77
        },
        "xDivide": {
          "value": 1.52
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca079",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 42.58
        },
        "contrast": {
          "value": 1.08
        },
        "orbSize": {
          "value": 2.35
        },
        "radius": {
          "value": 22.85
        },
        "colorShift": {
          "value": 8.85
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0.67
        },
        "cosMul": {
          "value": 1.64
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca086",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 1.7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 24.95
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.32
        },
        "radius": {
          "value": 4.75
        },
        "colorShift": {
          "value": 12.71
        },
        "div": {
          "value": 10
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca090",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 18.41
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 0.7
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 10.119
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca091",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.74772
        },
        "contrast": {
          "value": 0.82
        },
        "orbSize": {
          "value": 0.32
        },
        "radius": {
          "value": 4.75
        },
        "colorShift": {
          "value": 22.22298
        },
        "div": {
          "value": 10
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b3",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.19
        },
        "contrast": {
          "value": 4.95
        },
        "ballSize": {
          "value": 0.08
        },
        "radius": {
          "value": 1
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0b6",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 4.99
        },
        "ballSize": {
          "value": 0.011
        },
        "radius": {
          "value": 45.33
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0ba",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream/2.);\n  uv *=k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius*tan(t), radius*sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.26
        },
        "contrast": {
          "value": 6.4
        },
        "ballSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.54
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0.98
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0cc",
    "shader": "#define BALLS 10\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *=k_rotate2d(stream/-12.);\n  uv *= zoom2;\n  uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-1.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/.3) - sin(uv.y * yMultiplier + stream/-.8));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * ( 100. + uv.y/2505. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)/3.3*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.009
        },
        "shapeMultiplier": {
          "value": 192.45
        },
        "rotation": {
          "value": 0.61129
        },
        "xMultiplier": {
          "value": 998.27
        },
        "yMultiplier": {
          "value": 41.66
        },
        "colorSpread": {
          "value": 0.00012
        },
        "colorMultiplier": {
          "value": 4.09
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.18
        },
        "ballSize": {
          "value": 70.45
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 2.06
        },
        "radius": {
          "value": 5.93
        },
        "zoom2": {
          "value": 0.2
        }
      },
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 254.58
        },
        "rotation": {
          "value": 0.61129
        },
        "xMultiplier": {
          "value": 376.84
        },
        "yMultiplier": {
          "value": 127.2
        },
        "colorSpread": {
          "value": 0.00012
        },
        "colorMultiplier": {
          "value": 4.09
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 2.18
        },
        "ballSize": {
          "value": 70.45
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 2.06
        },
        "radius": {
          "value": 5.93
        },
        "zoom2": {
          "value": 0.5
        }
      },
      {
        "zoom": {
          "value": 0.009
        },
        "shapeMultiplier": {
          "value": 154.35
        },
        "rotation": {
          "value": 2.62987
        },
        "xMultiplier": {
          "value": 471.96
        },
        "yMultiplier": {
          "value": 99.64
        },
        "colorSpread": {
          "value": 0.000025
        },
        "colorMultiplier": {
          "value": 5.02
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.84
        },
        "ballSize": {
          "value": 471.93
        },
        "glow": {
          "value": 1.16
        },
        "contrast": {
          "value": 1.7
        },
        "radius": {
          "value": 16.37
        },
        "zoom2": {
          "value": 0.17
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0d7",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 64.73
        },
        "contrast": {
          "value": 1.42
        },
        "orbSize": {
          "value": 1.05
        },
        "radius": {
          "value": 4.58
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 17.328
        },
        "div2": {
          "value": 14.483
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca0f6",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\nuv *= zoom;\n  uv *= k_rotate2d(stream/-2.);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * vUv / resolution.xy)/2.)+ stream/3.);\n  float ot = ot;\n  uv = k_kale(uv, vec2(0.), 12.);\n  uv *= k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .792716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 7763.719
        },
        "iterator": {
          "value": 0.259
        },
        "ot": {
          "value": 99.903
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.987
        },
        "K": {
          "value": 58.378
        },
        "iterations": {
          "value": 17.327
        },
        "L": {
          "value": 187.608
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 1.01
        },
        "colorOffset": {
          "value": 35.208
        },
        "contrast": {
          "value": 1.687
        },
        "orbSize": {
          "value": 0.53
        },
        "div": {
          "value": 0.564
        },
        "radius": {
          "value": 0.055
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca103",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/10.);\n  uv = abs(uv);\n  for (float i = 1.; i < 20.; i++) {\n    uv *= rotation;\n    uv =(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= factor*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.924
        },
        "iterator": {
          "value": 0.319
        },
        "ot": {
          "value": 151
        },
        "I": {
          "value": 0.886
        },
        "J": {
          "value": 0.432
        },
        "K": {
          "value": 31.922
        },
        "iterations": {
          "value": 3.054
        },
        "L": {
          "value": 95.451
        },
        "M": {
          "value": 5.211
        },
        "colorShift": {
          "value": 1.912
        },
        "colorOffset": {
          "value": 0.873
        },
        "contrast": {
          "value": 1.361
        },
        "orbSize": {
          "value": 2
        },
        "div": {
          "value": 0.275
        },
        "radius": {
          "value": 0.436
        },
        "factor": {
          "value": 0.539
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca10b",
    "shader": "\n\n#define BALLS 5\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.06
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.25
        },
        "colorSpread": {
          "value": 3.36
        },
        "colorMultiplier": {
          "value": 114.55
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14c",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca150",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation + stream / 8.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.02 * uv.y - stream / 2.)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 5.) * (.4201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(color * log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.1
        },
        "ballSize": {
          "value": 590.219
        },
        "contrast": {
          "value": 1.08
        },
        "radius": {
          "value": 527.24
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 73.89
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca119",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(1. - uv) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv -= .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.24
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.62
        },
        "radius": {
          "value": 4.92
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11c",
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / .02;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/90.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*orbSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.141
        },
        "contrast": {
          "value": 1.22
        },
        "orbSize": {
          "value": 1.25
        },
        "radius": {
          "value": 5.247
        },
        "colorShift": {
          "value": 19.007
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.381
        },
        "x": {
          "value": 10.75
        },
        "y": {
          "value": 7.11
        },
        "colorOffset": {
          "value": 1
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca144",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 35.88
        },
        "yDivider": {
          "value": 818.46
        },
        "xDivider": {
          "value": 656.67
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 1.15
        },
        "radius": {
          "value": 26.22
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca122",
    "shader": "#define orbs 10.\n\nvoid main() {\n  float stream = stream / .1;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream / 100.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 1.1 * sin(t + stream / 100.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 50. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 300. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(1. - log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 29.17
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12b",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (.004 / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n    }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.334
        },
        "iterator": {
          "value": 4.787
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 1
        },
        "L": {
          "value": 1.372
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.077
        },
        "colorOffset": {
          "value": 14.399
        },
        "contrast": {
          "value": 1.57
        },
        "orbSize": {
          "value": 0.891
        },
        "div": {
          "value": 0.112
        },
        "radius": {
          "value": 3.567
        }
      },
      {
        "zoom": {
          "value": 0.032
        },
        "iterator": {
          "value": 1.405
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 6
        },
        "L": {
          "value": 1.358
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.689
        },
        "colorOffset": {
          "value": 13.519
        },
        "contrast": {
          "value": 1.736
        },
        "orbSize": {
          "value": 0.546
        },
        "div": {
          "value": 0.307
        },
        "radius": {
          "value": 4.767
        }
      },
      {
        "zoom": {
          "value": 0.574
        },
        "iterator": {
          "value": 1.144
        },
        "ot": {
          "value": 107.664
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 10.753
        },
        "iterations": {
          "value": 13
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.54
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.372
        },
        "orbSize": {
          "value": 0.443
        },
        "div": {
          "value": 0.135
        },
        "radius": {
          "value": 3.176
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca146",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *=k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 69.87
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 3.01
        },
        "radius": {
          "value": 20.48
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca124",
    "shader": "#define orbs 5.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = test-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "ballSize": {
          "value": 11.1
        },
        "contrast": {
          "value": 2.21
        },
        "radius": {
          "value": 93.39
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 23.47
        },
        "y": {
          "value": 15.14
        },
        "rotation": {
          "value": 0.1
        },
        "colorOffset": {
          "value": 4.57
        },
        "test": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca134",
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.50;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .6)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 406.25
        },
        "xDiv": {
          "value": 370.536
        },
        "yDiv": {
          "value": 348.214
        },
        "xDiv2": {
          "value": 31.25
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 44.643
        },
        "yDiv3": {
          "value": 62.5
        },
        "multiplier": {
          "value": 17.768
        },
        "ballSize": {
          "value": 25.446
        },
        "contrast": {
          "value": 1.554
        },
        "radius": {
          "value": 99.33
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 1.875
        },
        "yMul": {
          "value": 2.411
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca135",
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.5;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 2.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 11.) * cos(uv.y / yDiv3 - stream / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (11125. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, 1.19)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 513.393
        },
        "xDiv": {
          "value": 370.536
        },
        "yDiv": {
          "value": 348.214
        },
        "xDiv2": {
          "value": 31.25
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 44.643
        },
        "yDiv3": {
          "value": 62.5
        },
        "multiplier": {
          "value": 17.768
        },
        "ballSize": {
          "value": 38.839
        },
        "contrast": {
          "value": 2.268
        },
        "radius": {
          "value": 65.848
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 12.054
        },
        "yMul": {
          "value": 2.411
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca139",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *=k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 69.87
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 3.01
        },
        "radius": {
          "value": 20.48
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12d",
    "shader": "#define orbs 20.\n\n  void main () {\n    float stream = stream / 1.24;\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv = abs(uv);\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n   \n      uv.x *= tan(dist+.000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5 + uv.x/40.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.5) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "contrast": {
          "value": 2.09
        },
        "orbSize": {
          "value": 0.68
        },
        "radius": {
          "value": 2.9
        },
        "colorShift": {
          "value": 5.26
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca130",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= tan(dist+.0000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5;\n      float x = radius * tan(t);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, .009/dist*pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.004
        },
        "contrast": {
          "value": 2.53
        },
        "orbSize": {
          "value": 616.6
        },
        "radius": {
          "value": 5.76
        },
        "colorShift": {
          "value": 6.49
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13d",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 55.34
        },
        "contrast": {
          "value": 0.89
        },
        "orbSize": {
          "value": 2
        },
        "radius": {
          "value": 34.66
        },
        "colorShift": {
          "value": 9.55
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.7
        },
        "cosMul": {
          "value": 0.98
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.57
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.0048
        },
        "yDivide": {
          "value": 4.98
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca141",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.5
        },
        "yDivider": {
          "value": 332.97
        },
        "xDivider": {
          "value": 377.39
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.08
        },
        "contrast": {
          "value": 4.82
        },
        "radius": {
          "value": 12.6
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 0.47
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14b",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11a",
    "shader": "  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x -= dist+.009* dist*(i+1.) * (uv.y);\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 11
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.23
        },
        "radius": {
          "value": 3.68
        },
        "colorShift": {
          "value": 7.05
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca120",
    "shader": "\n#define orbs 5.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = test-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "ballSize": {
          "value": 11.1
        },
        "contrast": {
          "value": 2.21
        },
        "radius": {
          "value": 93.39
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 23.47
        },
        "y": {
          "value": 15.14
        },
        "rotation": {
          "value": 0.1
        },
        "colorOffset": {
          "value": 4.57
        },
        "test": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12c",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  mat2 rotation = k_rotate2d(stream/ (PI*12.));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .9) * orbSize, vec2(radius*abs(cos(stream/-1.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/-1.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.112
        },
        "iterator": {
          "value": 1.371
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 7
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.689
        },
        "colorOffset": {
          "value": 37.77
        },
        "contrast": {
          "value": 1.83
        },
        "orbSize": {
          "value": 0.564
        },
        "div": {
          "value": 1
        },
        "radius": {
          "value": 4.731
        }
      },
      {
        "zoom": {
          "value": 0.032
        },
        "iterator": {
          "value": 1.405
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 6
        },
        "L": {
          "value": 1.358
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.689
        },
        "colorOffset": {
          "value": 13.519
        },
        "contrast": {
          "value": 1.736
        },
        "orbSize": {
          "value": 0.546
        },
        "div": {
          "value": 0.307
        },
        "radius": {
          "value": 4.767
        }
      },
      {
        "zoom": {
          "value": 0.574
        },
        "iterator": {
          "value": 1.144
        },
        "ot": {
          "value": 107.664
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 10.753
        },
        "iterations": {
          "value": 13
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.54
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.372
        },
        "orbSize": {
          "value": 0.443
        },
        "div": {
          "value": 0.135
        },
        "radius": {
          "value": 3.176
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13a",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  uv = abs(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = 1. / dist * .1 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x / .5 * xMultiplier - stream / 1.) * sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i));\n    float t = float(i) * PI / float(BALLS) - stream / 4.;\n    vec2 p = vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.66
        },
        "shapeMultiplier": {
          "value": 301.19
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 27.57
        },
        "yMultiplier": {
          "value": 23.65
        },
        "colorSpread": {
          "value": 0.02
        },
        "colorMultiplier": {
          "value": 0.08
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 0.19
        },
        "ballSize": {
          "value": 0.16
        },
        "glow": {
          "value": 0.29
        },
        "contrast": {
          "value": 2.78
        },
        "radius": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14d",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca152",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(20.1*(.001*dot(uv, uv)));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(.001*length(uv)-rotation*(dist)+stream/5.+float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream/-50.;\n    vec2 p = vec2(xOuter*(atan(uv.x))*5.*uv.x+radius*tan(t+xMultiplier) * 5.*cos(uv.x + sin(uv.y/100.-stream/-50.-dist/10.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 43.33
        },
        "ballSize": {
          "value": 503.852
        },
        "contrast": {
          "value": 5.07
        },
        "radius": {
          "value": 1051.65
        },
        "yOuter": {
          "value": 401.47
        },
        "xOuter": {
          "value": 347.95
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 10111
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": -0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11d",
    "shader": "#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv)) / dist + (tatumStream + beatStream) / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < 20.; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor += barVolume * vec4(pow(tatumVolume, 1.5) * orbsize / length(uv + p * (spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor = vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.032
        },
        "shapeMultiplier": {
          "value": 124.545
        },
        "spreadMultiplier": {
          "value": 2.494
        },
        "rotation": {
          "value": 103.636
        },
        "xMultiplier": {
          "value": 113.422
        },
        "yMultiplier": {
          "value": -208
        },
        "colorSpread": {
          "value": 0.000197800000000001
        },
        "invert": {
          "value": false
        },
        "orbsize": {
          "value": 585.455
        },
        "contrast": {
          "value": 1.12136
        },
        "radius": {
          "value": 26
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "aSpeed": {
          "value": -15
        },
        "bSpeed": {
          "value": -5
        },
        "sinMul": {
          "value": 0.102
        },
        "cosMul": {
          "value": 0.312
        },
        "rippleSpeed": {
          "value": -20
        },
        "wobbleSpeed": {
          "value": -200
        },
        "swirl": {
          "value": 0.121
        },
        "energy": {
          "value": 1.1
        },
        "punch": {
          "value": 1
        },
        "borderSpeed": {
          "value": 2000
        },
        "hueShift": {
          "value": -97.745
        },
        "colorMultiplier": {
          "value": 0.0034
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca127",
    "shader": "#define orbs 5.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "ballSize": {
          "value": 11.1
        },
        "contrast": {
          "value": 2.21
        },
        "radius": {
          "value": 93.39
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 18.76
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0.1
        },
        "colorOffset": {
          "value": 4.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca138",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 13.61
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.4
        },
        "radius": {
          "value": 2.38
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.04
        },
        "sinMul": {
          "value": 0.25
        },
        "cosMul": {
          "value": 0.2
        },
        "yMul": {
          "value": 0.9
        },
        "xMul": {
          "value": 1.27
        },
        "xSpeed": {
          "value": -0.71
        },
        "ySpeed": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca145",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *=k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 69.87
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 3.01
        },
        "radius": {
          "value": 20.48
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca151",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) {  \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.9
        },
        "ballSize": {
          "value": 193.249
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 151.82
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca154",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.9
        },
        "ballSize": {
          "value": 193.249
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 151.82
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca155",
    "shader": "\n#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist*t+radius * (i/div) * tan(dist*t-stream/2.)*mul*sin(dist+stream/15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 6.52
        },
        "contrast": {
          "value": 0.55
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.08
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 2.86
        },
        "mul": {
          "value": 5.19
        },
        "div": {
          "value": 7.42
        }
      },
      {
        "zoom": {
          "value": 6.52
        },
        "contrast": {
          "value": 0.77
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 2
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 2.39
        },
        "mul": {
          "value": 0
        },
        "div": {
          "value": 30
        }
      },
      {
        "zoom": {
          "value": 9.36
        },
        "contrast": {
          "value": 0.8
        },
        "orbSize": {
          "value": 0.11
        },
        "radius": {
          "value": 2
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 7.69
        },
        "mul": {
          "value": 0.17
        },
        "div": {
          "value": 0.6
        }
      },
      {
        "zoom": {
          "value": 2
        },
        "contrast": {
          "value": 0.81
        },
        "orbSize": {
          "value": 0.02
        },
        "radius": {
          "value": 0.1
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 7.69
        },
        "mul": {
          "value": 15
        },
        "div": {
          "value": 5.03
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca117",
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv.x -= -14.;\n  float dist = length(sin(cos(uv + stream) + stream / .28));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x -= dist + dis * dist * (i + 1.) * (uv.y);\n    float t = (i + 1.) * PI / orbs * 4.;\n    float x = radius * tan(t + stream / .6);// * cos(t-stream/1.) * sin(t);\n    float y = radius * sin(t - stream / 2.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.313
        },
        "contrast": {
          "value": 1.277
        },
        "orbSize": {
          "value": 0.656
        },
        "radius": {
          "value": 6.407
        },
        "colorShift": {
          "value": 15.791
        },
        "dis": {
          "value": 0.001
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca133",
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.0;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .9)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 513.393
        },
        "xDiv": {
          "value": 370.536
        },
        "yDiv": {
          "value": 348.214
        },
        "xDiv2": {
          "value": 31.25
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 44.643
        },
        "yDiv3": {
          "value": 62.5
        },
        "multiplier": {
          "value": 17.768
        },
        "ballSize": {
          "value": 72.768
        },
        "contrast": {
          "value": 1.554
        },
        "radius": {
          "value": 36.83
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 12.054
        },
        "yMul": {
          "value": 2.411
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca129",
    "shader": "#define orbs 10.\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12a",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (wob / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n  gl_FragColor.g *= .2;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6347062999362257
        },
        "iterator": {
          "value": 9.545699904913453
        },
        "ot": {
          "value": 63.45670382482259
        },
        "I": {
          "value": 2.004611658162746
        },
        "J": {
          "value": 0.9292826277731768
        },
        "K": {
          "value": 1.7887850816908168
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 1.1279381425603259
        },
        "M": {
          "value": 0.43865731802863905
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 4.816923703081921
        },
        "contrast": {
          "value": 2.172935900983824
        },
        "orbSize": {
          "value": 1.3638092748249202
        },
        "div": {
          "value": 0.18712700275218697
        },
        "radius": {
          "value": 4.478964174125304
        },
        "wob": {
          "value": 0.027189022299892483
        }
      },
      {
        "zoom": {
          "value": 0.252383
        },
        "iterator": {
          "value": 7.569259349233938
        },
        "ot": {
          "value": 77.22702061398316
        },
        "I": {
          "value": 2.5421969305949066
        },
        "J": {
          "value": 2.3204582724811766
        },
        "K": {
          "value": 10.66774605644863
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.4078496791886295
        },
        "M": {
          "value": 0.49353160809578367
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 5.7879599494522385
        },
        "contrast": {
          "value": 1.72852776965142
        },
        "orbSize": {
          "value": 2
        },
        "div": {
          "value": 0.08027884559708552
        },
        "radius": {
          "value": 3.306594
        },
        "wob": {
          "value": 0.09822452407689686
        }
      },
      {
        "zoom": {
          "value": 0.5518645466466255
        },
        "iterator": {
          "value": 9.345306061754322
        },
        "ot": {
          "value": 76.95672847031916
        },
        "I": {
          "value": 2.0299764684706196
        },
        "J": {
          "value": 0.5775865735935444
        },
        "K": {
          "value": 4.5782725349372235
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.5327226221179027
        },
        "M": {
          "value": 0.9855923008127525
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 7.124793907730577
        },
        "contrast": {
          "value": 1.8673261085401902
        },
        "orbSize": {
          "value": 1.6922743948115222
        },
        "div": {
          "value": 0.06848968434306733
        },
        "radius": {
          "value": 3.145716
        },
        "wob": {
          "value": 0.003
        }
      },
      {
        "zoom": {
          "value": 0.380322
        },
        "iterator": {
          "value": 9.218471677489154
        },
        "ot": {
          "value": 131.63249519716393
        },
        "I": {
          "value": 1.3802125534214826
        },
        "J": {
          "value": 1.395041179704047
        },
        "K": {
          "value": 2.951226237343881
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.974272682393624
        },
        "M": {
          "value": 0.8482203936410846
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 8.985077800486769
        },
        "contrast": {
          "value": 1.87270215686231
        },
        "orbSize": {
          "value": 0.8984214901639822
        },
        "div": {
          "value": 0.07098858854079364
        },
        "radius": {
          "value": 7.968495755292857
        },
        "wob": {
          "value": 0.012046381298866725
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13b",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= abs(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 10.77
        },
        "contrast": {
          "value": 1.39
        },
        "orbSize": {
          "value": 3.81
        },
        "radius": {
          "value": 33.43
        },
        "colorShift": {
          "value": 7.65
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 50
        },
        "sinMul": {
          "value": 2.23
        },
        "cosMul": {
          "value": 1.53
        },
        "yMul": {
          "value": 0.11
        },
        "xMul": {
          "value": 0.29
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 19
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca140",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 5.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) * sin(uv.y / 3. + stream / 7.);\n    // uv *= k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius * -1. * tan(t - multiplier), radius * sin(t - multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 69.87
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 3.01
        },
        "radius": {
          "value": 20.48
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca132",
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.67950;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .58)/4. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 334.821
        },
        "xDiv": {
          "value": 218.75
        },
        "yDiv": {
          "value": 1205.357
        },
        "xDiv2": {
          "value": 129.464
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 26.786
        },
        "yDiv3": {
          "value": 26.786
        },
        "multiplier": {
          "value": 5.982
        },
        "ballSize": {
          "value": 50.446
        },
        "contrast": {
          "value": 1.304
        },
        "radius": {
          "value": 50.223
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 3.482
        },
        "yMul": {
          "value": 4.196
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca147",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.49
        },
        "yDivider": {
          "value": 210.95
        },
        "xDivider": {
          "value": 144.58
        },
        "multiplier": {
          "value": 0.34
        },
        "ballSize": {
          "value": 0.06
        },
        "contrast": {
          "value": 1.23
        },
        "radius": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca118",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x -= dist + .009 * dist * (i + 1.) * (uv.y);\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 3.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 11
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.23
        },
        "radius": {
          "value": 3.68
        },
        "colorShift": {
          "value": 7.05
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11e",
    "shader": "#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv)) / dist + (tatumStream + beatStream) / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < 20.; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor += barVolume * vec4(pow(tatumVolume, 1.5) * orbsize / length(uv + p * (spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor = vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "shapeMultiplier": {
          "value": 1583.68
        },
        "spreadMultiplier": {
          "value": 1.913
        },
        "rotation": {
          "value": 50
        },
        "xMultiplier": {
          "value": 369.731
        },
        "yMultiplier": {
          "value": 403.636
        },
        "colorSpread": {
          "value": 0.00007
        },
        "invert": {
          "value": false
        },
        "orbsize": {
          "value": 35.636
        },
        "contrast": {
          "value": 1.258
        },
        "radius": {
          "value": 9.636
        },
        "sides": {
          "value": 7
        },
        "kaleidoscope": {
          "value": false
        },
        "aSpeed": {
          "value": -10
        },
        "bSpeed": {
          "value": 8.3
        },
        "sinMul": {
          "value": -0.109
        },
        "cosMul": {
          "value": 0.055
        },
        "rippleSpeed": {
          "value": -20
        },
        "wobbleSpeed": {
          "value": 4.145
        },
        "swirl": {
          "value": -0.5
        },
        "energy": {
          "value": 1.1
        },
        "punch": {
          "value": 1
        },
        "borderSpeed": {
          "value": 616.364
        },
        "hueShift": {
          "value": -31.964
        },
        "colorMultiplier": {
          "value": 0.0034
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11f",
    "shader": "#define orbs 10.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 29.17
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.014
        },
        "ballSize": {
          "value": 15.51
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0.102
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.026
        },
        "ballSize": {
          "value": 15.51
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0.102
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14a",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x -= sin(uv.x / xDivider - stream / 8.) * sin(uv.y / 3. + stream / 2.);\n\n    float t = dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x - stream / 2.);\n    vec2 p = radius * vec2(-1. * cos(t * multiplier - stream / 5.), 1. * sin(t / multiplier + stream));\n    p -= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12e",
    "shader": "#define orbs 30.\n\n  void main () {\n    float stream = stream / 1.24;\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv = abs(uv);\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n   \n      uv.x *= tan(dist+.0000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5 + uv.x/40.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*20.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "contrast": {
          "value": 2.09
        },
        "orbSize": {
          "value": 0.42
        },
        "radius": {
          "value": 2.9
        },
        "colorShift": {
          "value": 4.96
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca12f",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (.005 / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.301
        },
        "iterator": {
          "value": 2.105
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 4
        },
        "L": {
          "value": 1.372
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 1.006
        },
        "colorOffset": {
          "value": 7.654
        },
        "contrast": {
          "value": 2.083
        },
        "orbSize": {
          "value": 0.753
        },
        "div": {
          "value": 0.214
        },
        "radius": {
          "value": 0.639
        }
      },
      {
        "zoom": {
          "value": 0.032
        },
        "iterator": {
          "value": 1.405
        },
        "ot": {
          "value": 39.026
        },
        "I": {
          "value": 0.259
        },
        "J": {
          "value": 0.36
        },
        "K": {
          "value": 1.669
        },
        "iterations": {
          "value": 6
        },
        "L": {
          "value": 1.358
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.689
        },
        "colorOffset": {
          "value": 13.519
        },
        "contrast": {
          "value": 1.736
        },
        "orbSize": {
          "value": 0.546
        },
        "div": {
          "value": 0.307
        },
        "radius": {
          "value": 4.767
        }
      },
      {
        "zoom": {
          "value": 0.574
        },
        "iterator": {
          "value": 1.144
        },
        "ot": {
          "value": 107.664
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 10.753
        },
        "iterations": {
          "value": 13
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.54
        },
        "colorOffset": {
          "value": 26.661
        },
        "contrast": {
          "value": 1.372
        },
        "orbSize": {
          "value": 0.443
        },
        "div": {
          "value": 0.135
        },
        "radius": {
          "value": 3.176
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca136",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *=k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 69.87
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 2.98
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 3.01
        },
        "radius": {
          "value": 20.48
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 10.75
        },
        "yDivider": {
          "value": 60.01
        },
        "xDivider": {
          "value": 53.56
        },
        "multiplier": {
          "value": 3.06
        },
        "ballSize": {
          "value": 0.11
        },
        "contrast": {
          "value": 1.58
        },
        "radius": {
          "value": 14.86
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 82.81
        },
        "yDivider": {
          "value": 60.01
        },
        "xDivider": {
          "value": 53.56
        },
        "multiplier": {
          "value": 3.06
        },
        "ballSize": {
          "value": 0.29
        },
        "contrast": {
          "value": 4.67
        },
        "radius": {
          "value": 45.97
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 17.6
        },
        "yDivider": {
          "value": 60.01
        },
        "xDivider": {
          "value": 53.56
        },
        "multiplier": {
          "value": 3.06
        },
        "ballSize": {
          "value": 0.08
        },
        "contrast": {
          "value": 1.69
        },
        "radius": {
          "value": 13.89
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.51
        },
        "yDivider": {
          "value": 60.01
        },
        "xDivider": {
          "value": 360.08
        },
        "multiplier": {
          "value": 3.06
        },
        "ballSize": {
          "value": 0.14
        },
        "contrast": {
          "value": 5.62
        },
        "radius": {
          "value": 18.25
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13e",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += (sinMul * sin(stream / 5. + uv.y * yMul)); // + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream / 10. + uv.x * xMul)); // + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 20.) + sin(t);\n    float y = radius * cos(t + stream / 20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.61
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.4
        },
        "radius": {
          "value": 2.38
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.04
        },
        "sinMul": {
          "value": 0.25
        },
        "cosMul": {
          "value": 0.2
        },
        "yMul": {
          "value": 0.9
        },
        "xMul": {
          "value": 1.27
        },
        "xSpeed": {
          "value": -0.71
        },
        "ySpeed": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13f",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.06
        },
        "yDivider": {
          "value": 818.46
        },
        "xDivider": {
          "value": 656.67
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 2.03
        },
        "radius": {
          "value": 26.22
        },
        "yOuter": {
          "value": 0.12
        },
        "xOuter": {
          "value": 0.29
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca142",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 1.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.1
        },
        "yDivider": {
          "value": 332.97
        },
        "xDivider": {
          "value": 377.39
        },
        "multiplier": {
          "value": 61.62
        },
        "ballSize": {
          "value": 0.12
        },
        "contrast": {
          "value": 3.52
        },
        "radius": {
          "value": 31.84
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca149",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x -= sin(uv.x / xDivider - stream / 8.) * sin(uv.y / 3. + stream / 2.);\n\n    float t = dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x - stream / 2.);\n    vec2 p = radius * vec2(-1. * cos(t * multiplier - stream / 5.), 1. * sin(t / multiplier + stream));\n    p -= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14f",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.9
        },
        "ballSize": {
          "value": 193.249
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 151.82
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      },
      {
        "zoom": {
          "value": 2.33
        },
        "ballSize": {
          "value": 99.135
        },
        "contrast": {
          "value": 3.3
        },
        "radius": {
          "value": 50.08
        },
        "yOuter": {
          "value": 30.31
        },
        "xOuter": {
          "value": 8.89
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 12.61
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0.0002
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      },
      {
        "zoom": {
          "value": 3.51
        },
        "ballSize": {
          "value": 642.44
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 539.23
        },
        "yOuter": {
          "value": 12
        },
        "xOuter": {
          "value": 86.53
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 12.61
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      },
      {
        "zoom": {
          "value": 2.2
        },
        "ballSize": {
          "value": 642.44
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 34.39
        },
        "yOuter": {
          "value": 64.48
        },
        "xOuter": {
          "value": 100
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca121",
    "shader": "\n#define orbs 10.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 29.17
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca125",
    "shader": "\n#define orbs 10.\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca14e",
    "shader": "#define BALLS 50.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  uv.x +=11.1*sin(uv.y/yDivider) + sinMul*sin(uv.x*x1 - stream/1.);\n  uv.y *= xMul*cos(stream)+(uv.y/yDivider + 11.*sin(x2*uv.x-stream));\n  uv.x += xMul2*sin(.1*uv.y);\n  uv.y += yMul2*cos(.1*uv.x);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*s in(t)*xMul, i * uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 23.14
        },
        "contrast": {
          "value": 1.85
        },
        "ballSize": {
          "value": 2.29
        },
        "x1": {
          "value": 0.45
        },
        "x2": {
          "value": 0.74
        },
        "ballMul": {
          "value": 3.59
        },
        "xMul": {
          "value": 18.24
        },
        "yDivider": {
          "value": 1.06
        },
        "sinMul": {
          "value": 7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca153",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.9
        },
        "ballSize": {
          "value": 193.249
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 151.82
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca116",
    "shader": "\n\n#define BALLS 5\n\n\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.06
        },
        "xMultiplier": {
          "value": 35.99
        },
        "yMultiplier": {
          "value": 49.25
        },
        "ballSize": {
          "value": 1.25
        },
        "colorSpread": {
          "value": 3.36
        },
        "colorMultiplier": {
          "value": 114.55
        },
        "shapeMultiplier": {
          "value": 13.46
        },
        "glow": {
          "value": 1862.09
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 11.471
        },
        "brightness": {
          "value": 1
        },
        "sides": {
          "value": 11
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca148",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "yDivider": {
          "value": 4.3
        },
        "xDivider": {
          "value": 117.73
        },
        "multiplier": {
          "value": 0.51
        },
        "ballSize": {
          "value": 0.1
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca11b",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x -= dist+.009* dist*(i+1.) * (uv.y);\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 11
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.23
        },
        "radius": {
          "value": 3.68
        },
        "colorShift": {
          "value": 7.05
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca128",
    "shader": "#define orbs 10.\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/1.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.016
        },
        "ballSize": {
          "value": 11.57
        },
        "contrast": {
          "value": 4.53
        },
        "radius": {
          "value": 93.39
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 50
        },
        "rotation": {
          "value": 0.055
        },
        "colorOffset": {
          "value": 4.7
        },
        "sides": {
          "value": 5
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca131",
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= tan(dist+.0000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * .5;\n      float x = radius * tan(t);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, .03/dist*pow(volume, 1.2) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 0.01
        },
        "contrast": {
          "value": 1.84
        },
        "orbSize": {
          "value": 5.37
        },
        "radius": {
          "value": 12
        },
        "colorShift": {
          "value": 5.58
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca137",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 13.61
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.4
        },
        "radius": {
          "value": 2.38
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.04
        },
        "sinMul": {
          "value": 0.25
        },
        "cosMul": {
          "value": 0.2
        },
        "yMul": {
          "value": 0.9
        },
        "xMul": {
          "value": 1.27
        },
        "xSpeed": {
          "value": -0.71
        },
        "ySpeed": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 34.22
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 1.29
        },
        "radius": {
          "value": 8.17
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.01
        },
        "sinMul": {
          "value": 0.04
        },
        "cosMul": {
          "value": 1
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.81
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 3.14
        },
        "contrast": {
          "value": 1.24
        },
        "orbSize": {
          "value": 0.57
        },
        "radius": {
          "value": 1.73
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.04
        },
        "sinMul": {
          "value": 0.25
        },
        "cosMul": {
          "value": 0.41
        },
        "yMul": {
          "value": 0.9
        },
        "xMul": {
          "value": 1.27
        },
        "xSpeed": {
          "value": -0.71
        },
        "ySpeed": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 71.22
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 3.65
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 4.72
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.01
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 1
        },
        "yMul": {
          "value": 0.35
        },
        "xMul": {
          "value": 1.19
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 46.57
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 3.65
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.01
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0.62
        },
        "xMul": {
          "value": 1.19
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca13c",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 3.);\n    float y = radius * cos(t + stream / 3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 71.67
        },
        "contrast": {
          "value": 1.49
        },
        "orbSize": {
          "value": 4.57
        },
        "radius": {
          "value": 25.16
        },
        "colorShift": {
          "value": 8.53
        },
        "sides": {
          "value": 2
        },
        "rotation": {
          "value": 0.4
        },
        "sinMul": {
          "value": 0.3
        },
        "cosMul": {
          "value": 1.88
        },
        "yMul": {
          "value": 0.36
        },
        "xMul": {
          "value": 0.16
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0057
        },
        "yDivide": {
          "value": 4.98
        },
        "xDivide": {
          "value": 7.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca143",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 3.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 33.59
        },
        "yDivider": {
          "value": 332.97
        },
        "xDivider": {
          "value": 377.39
        },
        "multiplier": {
          "value": 48.3
        },
        "ballSize": {
          "value": 0.16
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 15.87
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca123",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream / 100.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 1.1 * sin(t + stream / 100.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 50. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(1. - log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 29.17
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca126",
    "shader": "\n#define orbs 10.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.034
        },
        "ballSize": {
          "value": 7.06
        },
        "contrast": {
          "value": 2.05
        },
        "radius": {
          "value": 51.36
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 50
        },
        "y": {
          "value": 29.17
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 1.91
        },
        "sides": {
          "value": 4
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca171",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(.15*stream-dist/rotateDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/50.) * tan(dist*t-stream/8.7)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.52
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 0.005
        },
        "radius": {
          "value": 2.21
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.53
        },
        "rotateDiv": {
          "value": 1.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca174",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t*radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17e",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(-stream/2.5);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/4.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t+stream/.769195)*shape*sin(dist+stream/.69045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 7.23
        },
        "contrast": {
          "value": 0.66
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.2
        },
        "colorShift": {
          "value": 4.38
        },
        "sides": {
          "value": 13
        },
        "shape": {
          "value": 29.41
        },
        "distDiv": {
          "value": 14.05
        },
        "mul": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17f",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.06
        },
        "contrast": {
          "value": 1.59
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 18.4
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.62
        },
        "contrast": {
          "value": 1.5
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 10.4
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0059
        },
        "yDivide": {
          "value": 0.43
        },
        "xDivide": {
          "value": 12.45
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 1.68
        },
        "orbSize": {
          "value": 6.95
        },
        "radius": {
          "value": 55.15
        },
        "colorShift": {
          "value": 7.11
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18d",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15d",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca166",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape + sin(dist + stream / .25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.84
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.17
        },
        "colorShift": {
          "value": 4.89
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.53
        },
        "distDiv": {
          "value": 4.36
        },
        "mul": {
          "value": 4.47
        },
        "rotateSpeed": {
          "value": 0.34
        },
        "center": {
          "value": 2.72
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca100",
    "shader": "void main () {\n  float stream = stream / 1.5;\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/3.);\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec2 position = vec2(radius*abs(tan(stream/2.+uv.x/div)) * L * (sin(stream - uv.y)), radius*-(cos(stream/21.10+uv.y/div)));\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .96175) * orbSize, position,  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 32.989
        },
        "iterator": {
          "value": 1.019
        },
        "I": {
          "value": 167.101
        },
        "J": {
          "value": 6.434
        },
        "K": {
          "value": 60.598
        },
        "iterations": {
          "value": 24.216
        },
        "L": {
          "value": 22.901
        },
        "M": {
          "value": 3.077
        },
        "colorShift": {
          "value": 0.466
        },
        "colorOffset": {
          "value": 56.543
        },
        "contrast": {
          "value": 1.747
        },
        "orbSize": {
          "value": 0.886
        },
        "div": {
          "value": 238.717
        },
        "radius": {
          "value": 1.642
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca187",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 0.168
        },
        "orbSize": {
          "value": 4.15
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10.64
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0.1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.93
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.46
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": -1
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.01
        },
        "xDivide": {
          "value": 6.97
        },
        "mirror": {
          "value": false
        },
        "col": {
          "value": 0.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18c",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca157",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv *= k_rotate2d(-stream);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = dist + pow(volume, 6.) * t * radius * cos(dist * t - stream / .29195) * shape + sin(dist + stream / -1.25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 6.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.26
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.014
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 8.02
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.42
        },
        "distDiv": {
          "value": 19.55
        },
        "mul": {
          "value": 3.12
        },
        "rotateSpeed": {
          "value": 0
        },
        "center": {
          "value": 0.19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca172",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);;\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul - shape;\n    float x = t*radius * cos(dist*t+stream/2.69195)*shape*sin(dist+stream/.9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.43
        },
        "contrast": {
          "value": 0.87
        },
        "orbSize": {
          "value": 0.012
        },
        "radius": {
          "value": 0.36
        },
        "colorShift": {
          "value": 4.82
        },
        "sides": {
          "value": 9
        },
        "shape": {
          "value": 2.82
        },
        "distDiv": {
          "value": 111
        },
        "mul": {
          "value": 11
        },
        "center": {
          "value": 2.78
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca175",
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length((uv));\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius * cos(dist*t)*cos(uv.x*dist-stream)*sin(dist-stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.19
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.12
        },
        "radius": {
          "value": 2.64
        },
        "colorShift": {
          "value": 4.54
        },
        "center": {
          "value": 2.76
        },
        "sides": {
          "value": 10
        },
        "shape": {
          "value": 0.25
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca185",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 1.);\n    float y = radius * cos(t + stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 21.66
        },
        "colorShift": {
          "value": 8.85
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca188",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 18900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.058
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 2.38
        },
        "radius": {
          "value": 6.38
        },
        "colorShift": {
          "value": 5.43
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": -1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.08
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -1.5
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 3.56
        },
        "xDivide": {
          "value": 5
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18e",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .12;\n  float b = stream * .5;\n  float ot =.1;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 10; i++) {\n    p *= rot;\n    p = (abs(p) * 1.5 - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  ot = max(0., .1 - ot) / .1; //orbit trap \n  if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * 4. + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * .25, color, 2.); // saturation adjustment\n  color *= 1. - pow(l * .1, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/11. * sin(.01*length(-1. + 2. * vUv / resolution.xy)/1.1));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.366
        },
        "A": {
          "value": 1
        },
        "B": {
          "value": 3
        },
        "C": {
          "value": 0.6359954038787592
        },
        "D": {
          "value": 0.41622989513690534
        },
        "E": {
          "value": 0.4048123309829358
        },
        "F": {
          "value": 0.5604462168821562
        },
        "G": {
          "value": 0.1933471163590238
        },
        "H": {
          "value": 0.7424808632786761
        },
        "I": {
          "value": 0.8936912598741336
        },
        "J": {
          "value": 3.3570565776680446
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca165",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  uv *= k_rotate2d(0. * 115. * stream - (length(uv)) / rotateDiv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 1.;\n    float x = dist * t + radius * (i / iDiv) * tan(dist * t - i * stream / tanSpeed) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, volume * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.48
        },
        "contrast": {
          "value": 1.06
        },
        "orbSize": {
          "value": 0.005
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 13.19
        },
        "rotateDiv": {
          "value": 9.89
        },
        "tanSpeed": {
          "value": 66.61
        },
        "iDiv": {
          "value": 57.88
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16d",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * 1. * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.21
        },
        "contrast": {
          "value": 0.8
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "center": {
          "value": 0.81
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.36
        },
        "distDiv": {
          "value": 30
        },
        "mul": {
          "value": 8.45
        },
        "rotateSpeed": {
          "value": 0.34
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16e",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center * dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t * radius * cos(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca170",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist*t+radius * (i/10.) * tan(dist*t-stream/2.7)*1.*sin(dist-stream/5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist*orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.44
        },
        "contrast": {
          "value": 1.24
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 6.91
        },
        "center": {
          "value": 3.65
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca182",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca162",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 2.5);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t + stream / .769195) * shape * sin(dist + stream / .69045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.23
        },
        "contrast": {
          "value": 0.66
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.2
        },
        "colorShift": {
          "value": 4.38
        },
        "sides": {
          "value": 13
        },
        "shape": {
          "value": 29.41
        },
        "distDiv": {
          "value": 14.05
        },
        "mul": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16b",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 10.) * tan(dist * t - stream / 1.7) * 1. * sin(dist + stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.62
        },
        "contrast": {
          "value": 0.9
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 1.58
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca180",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.234
        },
        "orbSize": {
          "value": 2.298
        },
        "radius": {
          "value": 20.95
        },
        "colorShift": {
          "value": 5.41
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.56
        },
        "cosMul": {
          "value": 0.88
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.56
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.65
        },
        "xDivide": {
          "value": 32.82
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca186",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 5.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca159",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(.15 * stream - dist / rotateDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist * t + radius * (i / 50.) * tan(dist * t - stream / 8.7) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.53
        },
        "contrast": {
          "value": 0.7
        },
        "orbSize": {
          "value": 0.005
        },
        "radius": {
          "value": 2.21
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 1
        },
        "rotateDiv": {
          "value": 3.88
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15e",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * cos(dist * t) * cos(uv.x * dist - stream) * sin(dist - stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.19
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.12
        },
        "radius": {
          "value": 2.64
        },
        "colorShift": {
          "value": 4.54
        },
        "center": {
          "value": 2.76
        },
        "sides": {
          "value": 10
        },
        "shape": {
          "value": 0.25
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca160",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.84
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 3
        },
        "colorShift": {
          "value": 7.96
        },
        "center": {
          "value": 2.46
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca169",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * .8 * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.75
        },
        "contrast": {
          "value": 0.95
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "center": {
          "value": 0.81
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.36
        },
        "distDiv": {
          "value": 9.86
        },
        "mul": {
          "value": 8.45
        },
        "rotateSpeed": {
          "value": 0.34
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca184",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream * gloop);\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.25
        },
        "contrast": {
          "value": 1.3
        },
        "orbSize": {
          "value": 1.03
        },
        "radius": {
          "value": 4.74
        },
        "colorShift": {
          "value": 5.2
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0.23
        },
        "yMul": {
          "value": 1.33
        },
        "xMul": {
          "value": 2.44
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 0.5
        },
        "gloop": {
          "value": 0.001
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15a",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 1.5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 112.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .69195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.44
        },
        "contrast": {
          "value": 0.91
        },
        "orbSize": {
          "value": 0.05
        },
        "radius": {
          "value": 4.17
        },
        "colorShift": {
          "value": 4.89
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.31
        },
        "distDiv": {
          "value": 9.79
        },
        "mul": {
          "value": 10.7
        },
        "rotateSpeed": {
          "value": 0.34
        },
        "center": {
          "value": 2.72
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca176",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed*stream-dist/distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t-stream/.9195)*.8*sin(dist+stream/.5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.75
        },
        "contrast": {
          "value": 0.95
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "center": {
          "value": 0.81
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.36
        },
        "distDiv": {
          "value": 9.86
        },
        "mul": {
          "value": 8.45
        },
        "rotateSpeed": {
          "value": 0.34
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca177",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t+radius * cos(dist*t-stream/1.5)*1.*sin(dist+stream/3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.61
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca191",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * vUv / resolution.xy).y + uv.x);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.4850717148852155
        },
        "A": {
          "value": 0.5003307097927256
        },
        "B": {
          "value": 0.7402404991801865
        },
        "C": {
          "value": 0.6891870954341921
        },
        "D": {
          "value": 0.8314592178758453
        },
        "E": {
          "value": 0.34211315865608305
        },
        "F": {
          "value": 0.3259375489172806
        },
        "G": {
          "value": 0.7566317119359389
        },
        "H": {
          "value": 0.39430978186333754
        },
        "I": {
          "value": 4.712730014375358
        },
        "J": {
          "value": 1.764128620477062
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca164",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.15
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.95
        },
        "distDiv": {
          "value": 15.64
        },
        "mul": {
          "value": 10.7
        },
        "rotateSpeed": {
          "value": 0.34
        },
        "center": {
          "value": 2.72
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca167",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 2.) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.52
        },
        "contrast": {
          "value": 0.55
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.08
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 2.86
        },
        "mul": {
          "value": 5.19
        },
        "div": {
          "value": 7.42
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16f",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 1.5) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.48
        },
        "contrast": {
          "value": 0.91
        },
        "orbSize": {
          "value": 0.02
        },
        "radius": {
          "value": 0.1
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.87
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 1.55
        },
        "mul": {
          "value": 2.24
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17a",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius - .7 * atan(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.37
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca183",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "3": {
          "value": [0.8, 0.2, 0.6]
        },
        "zoom": {
          "value": 5.9
        },
        "ballSize": {
          "value": 193.249
        },
        "contrast": {
          "value": 2.55
        },
        "radius": {
          "value": 151.82
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca194",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.5349397590361449
        },
        "contrast": {
          "value": 1.4188433734939763
        },
        "ballSize": {
          "value": 0.8915662650602411
        },
        "radius": {
          "value": 9.612144578313256
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca156",
    "shader": "\n#define orbs 10.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist*t+radius * (i/div) * tan(dist*t-stream/2.)*mul*sin(dist+stream/15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 6.52
        },
        "contrast": {
          "value": 0.55
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.08
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 2.86
        },
        "mul": {
          "value": 5.19
        },
        "div": {
          "value": 7.42
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16a",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 2.) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.37
        },
        "contrast": {
          "value": 0.47
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.1
        },
        "colorShift": {
          "value": 6.04
        },
        "center": {
          "value": 2.92
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 20
        },
        "mul": {
          "value": 3.41
        },
        "div": {
          "value": 9.59
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca179",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed*stream/12.2-dist/distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t-stream/.9195)*shape*sin(dist+stream/.5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.15
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.95
        },
        "distDiv": {
          "value": 15.64
        },
        "mul": {
          "value": 10.7
        },
        "rotateSpeed": {
          "value": 0.34
        },
        "center": {
          "value": 2.72
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17b",
    "shader": "\n#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\tuv = abs(uv);\n  uv *= k_rotate2d(stream);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed*stream/12.2-dist/distDiv);\n  uv *= k_rotate2d(-stream);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = dist + pow(volume, 6.) * t*radius * cos(dist*t-stream/.29195)*shape+sin(dist+stream/-1.25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, 6.)*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.26
        },
        "contrast": {
          "value": 0.99
        },
        "orbSize": {
          "value": 0.014
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 8.02
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.42
        },
        "distDiv": {
          "value": 19.55
        },
        "mul": {
          "value": 3.12
        },
        "rotateSpeed": {
          "value": 0
        },
        "center": {
          "value": 0.19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca190",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .12;\n  float b = stream * 1.5;\n  float ot =.1;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 10; i++) {\n    p *= rot;\n    p = (abs(p) * 1.5 - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  ot = max(0., .1 - ot) / .1; //orbit trap \n  if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * 4. + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * .25, color, 2.); // saturation adjustment\n  color *= 1. - pow(l * .1, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. * sin(.01*length(-1. + 2. * vUv / resolution.xy)/1.1));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.142
        },
        "A": {
          "value": 1
        },
        "B": {
          "value": 3
        },
        "C": {
          "value": 0.6359954038787592
        },
        "D": {
          "value": 0.41622989513690534
        },
        "E": {
          "value": 0.4048123309829358
        },
        "F": {
          "value": 0.5604462168821562
        },
        "G": {
          "value": 0.1933471163590238
        },
        "H": {
          "value": 0.7424808632786761
        },
        "I": {
          "value": 0.8936912598741336
        },
        "J": {
          "value": 3.3570565776680446
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca168",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 2.5);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t + stream / 2.69195) * shape * sin(dist + stream / .9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.93
        },
        "contrast": {
          "value": 0.79
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.1
        },
        "colorShift": {
          "value": 4.38
        },
        "sides": {
          "value": 11
        },
        "shape": {
          "value": 10.27
        },
        "distDiv": {
          "value": 101.37
        },
        "mul": {
          "value": 13.8
        },
        "center": {
          "value": 0.65
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18f",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, C);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 4) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 8; i++) {\n    p *= (rot);\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * F) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - D * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, E); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(col-color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/1. - sin(length(-1. + 2. * vUv / resolution.xy)/4.));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.395
        },
        "A": {
          "value": 0.244
        },
        "B": {
          "value": 0.599
        },
        "C": {
          "value": 8
        },
        "D": {
          "value": -0.553
        },
        "E": {
          "value": 0.106
        },
        "F": {
          "value": 9.958
        },
        "G": {
          "value": 0.38
        },
        "H": {
          "value": 0.369
        },
        "I": {
          "value": 15.777
        },
        "J": {
          "value": 1.523
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15c",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 10.) * tan(dist * t - stream / 2.7) * 1. * sin(dist - stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.44
        },
        "contrast": {
          "value": 1.24
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 6.91
        },
        "center": {
          "value": 3.65
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca189",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.234
        },
        "orbSize": {
          "value": 2.298
        },
        "radius": {
          "value": 20.95
        },
        "colorShift": {
          "value": 5.41
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.56
        },
        "cosMul": {
          "value": 0.88
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.56
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.65
        },
        "xDivide": {
          "value": 32.82
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca158",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(.15 * stream - dist / rotateDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist * t + radius * (i / 50.) * tan(dist * t - stream / 8.7) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.52
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 0.005
        },
        "radius": {
          "value": 2.21
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 0.53
        },
        "rotateDiv": {
          "value": 1.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15b",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);;\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul - shape;\n    float x = t * radius * cos(dist * t + stream / 2.69195) * shape * sin(dist + stream / .9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.43
        },
        "contrast": {
          "value": 0.87
        },
        "orbSize": {
          "value": 0.012
        },
        "radius": {
          "value": 0.36
        },
        "colorShift": {
          "value": 4.82
        },
        "sides": {
          "value": 9
        },
        "shape": {
          "value": 2.82
        },
        "distDiv": {
          "value": 111
        },
        "mul": {
          "value": 11
        },
        "center": {
          "value": 2.78
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca163",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.78
        },
        "contrast": {
          "value": 1.26
        },
        "orbSize": {
          "value": 0.06
        },
        "radius": {
          "value": 1.52
        },
        "colorShift": {
          "value": 4.89
        },
        "sides": {
          "value": 10
        },
        "shape": {
          "value": 0.95
        },
        "distDiv": {
          "value": 15.64
        },
        "mul": {
          "value": 10.7
        },
        "rotateSpeed": {
          "value": 0.34
        },
        "center": {
          "value": 2.72
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca173",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius *sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist*hue(k_orb(uv, orbSize, position, color, contrast), stream/2.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.84
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 3
        },
        "colorShift": {
          "value": 7.96
        },
        "center": {
          "value": 2.46
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca178",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  uv *= k_rotate2d(0.*15.*stream-(length(uv))/rotateDiv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/iDiv) * tan(dist*t-i*stream/tanSpeed)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.48
        },
        "contrast": {
          "value": 1.06
        },
        "orbSize": {
          "value": 0.005
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 13.19
        },
        "rotateDiv": {
          "value": 9.89
        },
        "tanSpeed": {
          "value": 66.61
        },
        "iDiv": {
          "value": 57.88
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17c",
    "shader": "\n#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t+radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18a",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 10. + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.07
        },
        "contrast": {
          "value": 0.59
        },
        "orbSize": {
          "value": 13.88
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 8.01
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0.31
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.14
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.44
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.08
        },
        "xDivide": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca192",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.5349397590361449
        },
        "contrast": {
          "value": 1.4188433734939763
        },
        "ballSize": {
          "value": 0.4361445783132531
        },
        "radius": {
          "value": 9.612144578313256
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca15f",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius - .7 * atan(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.37
        },
        "contrast": {
          "value": 1.13
        },
        "orbSize": {
          "value": 0.09
        },
        "radius": {
          "value": 1.45
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca17d",
    "shader": "\n#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist*t+radius * (i/6.) * cos(dist*t-stream/1.7)*1.*sin(dist+stream/5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.07
        },
        "contrast": {
          "value": 1.03
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 1.58
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca18b",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 21.66
        },
        "colorShift": {
          "value": 8.85
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca195",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(0.*15.*stream-(length(uv))/rotateDiv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/iDiv) * tan(dist*t-i*stream/tanSpeed)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.7746965361445785
        },
        "contrast": {
          "value": 0.9976212349397593
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 2
        },
        "colorShift": {
          "value": 5.13
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 2
        },
        "shape": {
          "value": 13.19
        },
        "rotateDiv": {
          "value": 9.89
        },
        "tanSpeed": {
          "value": 66.61
        },
        "iDiv": {
          "value": 57.88
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca161",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 20.) * tan(dist * t + stream / 2.7) * 3. * sin(dist - stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.11
        },
        "orbSize": {
          "value": 0.04
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 6.91
        },
        "center": {
          "value": 1.58
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca16c",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 6.) * cos(dist * t - stream / 1.7) * 1. * sin(dist + stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.07
        },
        "contrast": {
          "value": 1.03
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 1.58
        },
        "sides": {
          "value": 3
        },
        "shape": {
          "value": 0.13
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca193",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.5349397590361449
        },
        "contrast": {
          "value": 1.4188433734939763
        },
        "ballSize": {
          "value": 0.4361445783132531
        },
        "radius": {
          "value": 9.612144578313256
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a3",
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(1.);\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.0;\n    float t = (shape + (i * 2.) * PI / orbs + rotation) + sin(stream / 10.);\n    float x = (radius * tan(t - stream) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * sin(t) - tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_hue(k_orb(uv, orbSize * 3., position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 0.153
        },
        "radius": {
          "value": 1.51
        },
        "colorShift": {
          "value": 17.69
        },
        "rotation": {
          "value": 188.09
        },
        "shape": {
          "value": 94.51
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1aa",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);// + .5*sin(1.1*uv.x-stream/5.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);// + cos(.01*uv.y+stream/6.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 93.83
        },
        "yDivider": {
          "value": 628.39
        },
        "xDivider": {
          "value": 679.91
        },
        "multiplier": {
          "value": 79.47
        },
        "ballSize": {
          "value": 0.09
        },
        "contrast": {
          "value": 1.43
        },
        "radius": {
          "value": 21.73
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c4",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 90.275
        },
        "yDivider": {
          "value": 18.646
        },
        "xDivider": {
          "value": 9.294
        },
        "multiplier": {
          "value": 1.219
        },
        "ballSize": {
          "value": 34.82
        },
        "contrast": {
          "value": 1.8
        },
        "radius": {
          "value": 76.67
        },
        "rotation": {
          "value": 14.858
        },
        "yDivide": {
          "value": 307.888
        },
        "xDivide": {
          "value": 0.408
        },
        "yShape": {
          "value": 200
        },
        "shape": {
          "value": 14.966
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d5",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/4.) * .09*cos(uv.y/yShape + stream/2.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t);// + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 166.94
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 24.95
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e3",
    "shader": "  #define orbs 15.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(uv);\n    uv *= 1.1*sin(.01*dot(uv, uv) - stream/5.);\n    uv /= abs(fract(uv) - .5); \n    for (float i = 0.; i < orbs; i++) {\n      uv *= k_rotate2d(i);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream);\n      float y = radius * cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 6.92
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e4",
    "shader": "  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(sin(uv+stream) + tan(cos(uv-stream) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 7.4
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.99
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 9.77
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca213",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.005 * sin(uv + stream), cos(shape * uv + stream)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.85
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 997.79
        },
        "ballSize": {
          "value": 2.45
        },
        "contrast": {
          "value": 1.86
        },
        "radius": {
          "value": 66.39
        },
        "yOuter": {
          "value": 2
        },
        "xOuter": {
          "value": 2
        },
        "rotation": {
          "value": 13.26
        },
        "shape": {
          "value": 1.63
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca215",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20. * (uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002 * sin(uv + stream / 5.), 2. * cos(shape * uv + stream / 5.)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 2.69
        },
        "contrast": {
          "value": 3.6
        },
        "radius": {
          "value": 28.41
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22d",
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n // uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19d",
    "shader": "\n#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.73
        },
        "contrast": {
          "value": 1.36
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 3.21
        },
        "colorShift": {
          "value": 4
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 5.26
        },
        "contrast": {
          "value": 1.78
        },
        "orbSize": {
          "value": 0.31
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 12.03
        },
        "center": {
          "value": 2.02
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 6.31
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.26
        },
        "radius": {
          "value": 3.01
        },
        "colorShift": {
          "value": 12.03
        },
        "center": {
          "value": 1.28
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 2.27
        },
        "contrast": {
          "value": 2.1
        },
        "orbSize": {
          "value": 0.38281263306543034
        },
        "radius": {
          "value": 2.538399385459133
        },
        "colorShift": {
          "value": 16.71
        },
        "center": {
          "value": 1.7565130473989226
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a0",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress);\n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.); // * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress);\n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n      uv = glooped;\n    }\n  }\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i - stream / 500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 100.);\n    float y = radius * cos(t - stream / 100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.73
        },
        "contrast": {
          "value": 1.36
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 3.21
        },
        "colorShift": {
          "value": 4
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b3",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .005 * dot(uv + 1. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 10.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "contrast": {
          "value": 0.12
        },
        "orbSize": {
          "value": 17.09
        },
        "radius": {
          "value": 10.09
        },
        "colorShift": {
          "value": 7.95
        },
        "sides": {
          "value": 12
        },
        "rotation": {
          "value": 0.6
        },
        "sinMul": {
          "value": 4
        },
        "cosMul": {
          "value": 3.16
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b9",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n//  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.005*dot(uv + 1.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/10.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "contrast": {
          "value": 0.12
        },
        "orbSize": {
          "value": 17.09
        },
        "radius": {
          "value": 10.09
        },
        "colorShift": {
          "value": 7.95
        },
        "sides": {
          "value": 12
        },
        "rotation": {
          "value": 0.6
        },
        "sinMul": {
          "value": 4
        },
        "cosMul": {
          "value": 3.16
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c2",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x); //-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream) * cosMul * cos(uv.x / yShape + stream / 3.) * cosMul * sin(stream / 10.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t) + stream / 100.;\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, 6.) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 363.69
        },
        "yDivider": {
          "value": 665.49
        },
        "xDivider": {
          "value": 9.32
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 55.94
        },
        "contrast": {
          "value": 3.57
        },
        "radius": {
          "value": 26.89
        },
        "rotation": {
          "value": 0
        },
        "yDivide": {
          "value": 1000
        },
        "xDivide": {
          "value": 0.05
        },
        "yShape": {
          "value": 16.92
        },
        "shape": {
          "value": 14.28
        },
        "cosMul": {
          "value": 0.21
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c8",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = tan(t - stream / 42.); // + stream/100.);\n    float y = sin(t / multiplier + stream / 7.); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 500
        },
        "yDivider": {
          "value": 177.2
        },
        "xDivider": {
          "value": 70.49
        },
        "multiplier": {
          "value": 2.0479
        },
        "ballSize": {
          "value": 78.79
        },
        "contrast": {
          "value": 2.18
        },
        "radius": {
          "value": 35.96
        },
        "rotation": {
          "value": 55.39
        },
        "yDivide": {
          "value": 401.76
        },
        "xDivide": {
          "value": 0.57
        },
        "yShape": {
          "value": 69.29
        },
        "shape": {
          "value": 100
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d4",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *=k_rotate2d(stream/10.);\n  vec2 _dotted = uv * sin(.0001*dot(uv, uv) - stream/10.);\n  if (dottedTween) {\n    \n  }\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/2.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/5.) * .4229*cos(uv.y/yShape + stream/1.5);\n    float t = 1.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/90.;\n    float x = -1.*tan(t-stream/10.);// + stream/100.);\n    float y = sin(t*multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02*float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 92.31
        },
        "yDivider": {
          "value": 2.02
        },
        "xDivider": {
          "value": 19.77
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 26.35
        },
        "contrast": {
          "value": 3.19
        },
        "radius": {
          "value": 25.88
        },
        "rotation": {
          "value": 89.48
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 1.49
        },
        "yShape": {
          "value": 14.73
        },
        "shape": {
          "value": 71.08
        },
        "dotted": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f3",
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv.x += sin(stream / 4.) * 11.1 * sin(stream) + uv.y / .2 + 20. * sin(uv.x * x1 - stream / 1.);\n  uv.y *= .1 * cos(stream) + (uv.y / .2 + 11. * sin(x2 * uv.x - stream));\n  uv.x += .1 * sin(.1 * uv.y);\n  uv.y += .1 * cos(.1 * uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.35
        },
        "contrast": {
          "value": 0.48
        },
        "ballSize": {
          "value": 607.64
        },
        "x1": {
          "value": 0.41
        },
        "x2": {
          "value": 0
        },
        "ballMul": {
          "value": 35.51
        },
        "xMul": {
          "value": 110
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca201",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(atan(dist/uv.x+stream))*uv.x+radius*sin(t+xMultiplier), radius*sin(dist*yOuter*uv.x/.5+t+yMultiplier+3.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.46
        },
        "ballSize": {
          "value": 0.004
        },
        "contrast": {
          "value": 4.47
        },
        "radius": {
          "value": 0.12
        },
        "yOuter": {
          "value": 29.89
        },
        "xOuter": {
          "value": 0.88
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.82
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21f",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n // uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca223",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.41
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 1.15
        },
        "contrast": {
          "value": 3
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23f",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50. * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream / 52.;\n    vec2 p = vec2(xOuter * uv.y * 2.1 / uv.x * 3. + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.24
        },
        "ballSize": {
          "value": 1111
        },
        "contrast": {
          "value": 1.53
        },
        "radius": {
          "value": 224.63
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 39.66
        },
        "yMultiplier": {
          "value": 41.44
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca240",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 30.)) * (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50000.;\n    float x = xOuter * (tan(.01 * uv.x * -20. - stream)) * uv.y + radius * cos(t + xMultiplier + stream / 1.) * 100. / cos(.1 * uv.y + tan(stream / 50. + uv.x / 10.) - stream / 50.);\n    float y = radius * cos((.01 * cos(.001 * uv.y + uv.x) / t + yMultiplier) + stream / 30.);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.06
        },
        "ballSize": {
          "value": 1111
        },
        "contrast": {
          "value": 10.27
        },
        "radius": {
          "value": 81.48
        },
        "yOuter": {
          "value": 114.28
        },
        "xOuter": {
          "value": 1320.01
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 10.34
        },
        "yMultiplier": {
          "value": 39.83
        },
        "divider": {
          "value": 10
        },
        "rotation": {
          "value": 0.0066
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca251",
    "shader": "\nvoid main() {\n  vec2 uv = -1.0 + 2.0 * vUv / resolution.xy;\n  \n  uv *= zoom;\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv = abs(fract(uv) - .5) * 2.1;\n  uv = abs(fract(uv) - .5) * .1;\n  uv *= 2. * atan(uv.x / 50. + stream / 1.) - .1;\n  vec4 result = vec4(0, 0, 0, 1);\n  float t = 1.8;\n  float base = 1000. * length(uv);\n  for (int p = 0; p < 3; p++) {\n    float a = cos((t * base) - stream / 1.);\n    float b = cos(shape * uv.x / .25 - stream /2.);\n    result[p] = 2.52 * a + 1.7 * b + base / 1000.;\n    t += 2.6;\n  }\n  result.xyz *= brightness * result.x;\n  result.xyz = (result.xyz);\n  result.xy *= abs(tan(uv.x*multiplier));\n  gl_FragColor = 1. + log(abs(result));\n  gl_FragColor.r *= red;\n  gl_FragColor.g *= green;\n  gl_FragColor.b *= blue;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.0039
        },
        "brightness": {
          "value": 41.76
        },
        "red": {
          "value": 0.6
        },
        "green": {
          "value": 0.17
        },
        "blue": {
          "value": 0.17
        },
        "shape": {
          "value": 765.37
        },
        "multiplier": {
          "value": 51.58
        },
        "kaleidoscope": {
          "value": false
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19a",
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream) + 2. * sin(t - stream / 2.);\n    float y = radius * cos(t + stream) + 2. * cos(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream) + 1. * tan(t - stream / 2.);\n    float y = radius * cos(t + stream) + 1. * cos(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_orb(uv, orbSize * .5, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.48
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.43
        },
        "radius": {
          "value": 1.03
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a6",
    "shader": "#define BALLS 20\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * 2. * PI / float(BALLS);\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(color * PI * (float(i) / PI)); //* 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "ballSize": {
          "value": 0.004
        },
        "contrast": {
          "value": 0.39
        },
        "radius": {
          "value": 0.1
        },
        "mirror": {
          "value": false
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b1",
    "shader": "\n#define BALLS 30\n  \nmat2k_rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius*tan(t * multiplier + stream);\n    float y = radius*sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.11
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 0.05
        },
        "contrast": {
          "value": 2.73
        },
        "radius": {
          "value": 1
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b6",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.32
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1bb",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n//  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 5.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.13
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 1.88
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 12.27
        },
        "sides": {
          "value": 6
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d6",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/4.) * .09*cos(uv.y/yShape + stream/2.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t);// + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 166.94
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 24.95
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f6",
    "shader": "#define orbs 25.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 5.*uv.x+radius * tan(t+stream);\n    float y = .1*sin(uv.y/.01) * uv.x*sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 1.73
        },
        "orbSize": {
          "value": 0.24
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 6.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f8",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*tan(t*xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t*yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.3
        },
        "ballSize": {
          "value": 0.076
        },
        "contrast": {
          "value": 4.36
        },
        "radius": {
          "value": 1.44
        },
        "yOuter": {
          "value": 0.71
        },
        "xOuter": {
          "value": 4.15
        },
        "rotation": {
          "value": 0.46
        },
        "shape": {
          "value": 5.17
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.38
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1fe",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*cos(t+xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t+yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.27
        },
        "ballSize": {
          "value": 0.021
        },
        "contrast": {
          "value": 3.98
        },
        "radius": {
          "value": 0.97
        },
        "yOuter": {
          "value": 1.98
        },
        "xOuter": {
          "value": 20
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.39
        },
        "yMultiplier": {
          "value": 3.46
        },
        "divider": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca209",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.602
        },
        "radius": {
          "value": 1.82
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 7.68
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 2.982958668830698
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 1.535
        },
        "radius": {
          "value": 5.629
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 5.341
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 1.211
        },
        "yDot": {
          "value": 0.554
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 6.332
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21b",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * sin(uv) + stream / .5)) * 20.1 * tan(uv + stream);\n  uv *= k_rotate2d(rotation * stream / .8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 1.) / 1. * sin(uv.x / 1. - stream / 1.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 1.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier + stream / 5.), 2. * radius * sin(t * multiplier - stream / 5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.56
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 0.1
        },
        "ballSize": {
          "value": 3.68
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 32.48
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        },
        "rotation": {
          "value": 0.55
        },
        "shape": {
          "value": 5.39
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca226",
    "shader": "\n#define BALLS 20\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.01
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 4.53
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 40.55
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca233",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(20.1 * (.001 * dot(uv, uv)));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.001 * length(uv) - rotation * (dist) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -50.;\n    vec2 p = vec2(xOuter * (atan(uv.x)) * 5. * uv.x + radius * tan(t + xMultiplier) * 5. * cos(uv.x + sin(uv.y / 100. - stream / -50. - dist / 10.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 43.33
        },
        "ballSize": {
          "value": 503.852
        },
        "contrast": {
          "value": 5.07
        },
        "radius": {
          "value": 1051.65
        },
        "yOuter": {
          "value": 401.47
        },
        "xOuter": {
          "value": 347.95
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 10111
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": -0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca242",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*3.1+radius*cos(t+xMultiplier+stream/1.) * 20./cos(uv.x + sin(uv.y/100.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.3
        },
        "ballSize": {
          "value": 696.957
        },
        "contrast": {
          "value": 9.7
        },
        "radius": {
          "value": 21.61
        },
        "yOuter": {
          "value": 21.57
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 9.99
        },
        "yMultiplier": {
          "value": 36.27
        },
        "divider": {
          "value": 2
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a4",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * uv.y + radius * cos(t + xMultiplier + stream), radius * sin(yOuter * uv.x / .1 + t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.27
        },
        "ballSize": {
          "value": 0.021
        },
        "contrast": {
          "value": 3.98
        },
        "radius": {
          "value": 0.97
        },
        "yOuter": {
          "value": 1.98
        },
        "xOuter": {
          "value": 20
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.39
        },
        "yMultiplier": {
          "value": 3.46
        },
        "divider": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ac",
    "shader": "#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.73
        },
        "contrast": {
          "value": 1.36
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 3.21
        },
        "colorShift": {
          "value": 4
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b4",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .05 * dot(uv + 5. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.13
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 1.88
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 12.27
        },
        "sides": {
          "value": 6
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b8",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n//  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 5.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.13
        },
        "contrast": {
          "value": 0.14
        },
        "orbSize": {
          "value": 1.88
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 12.27
        },
        "sides": {
          "value": 6
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1bc",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .05 * dot(uv + 20. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.32
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c9",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00003 * dot(uv, uv) - stream / 20.);\n  //uv *= k_rotate2d(stream/50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 116.02
        },
        "yDivider": {
          "value": 24.7
        },
        "xDivider": {
          "value": 7.47
        },
        "multiplier": {
          "value": 2.9612
        },
        "ballSize": {
          "value": 20
        },
        "contrast": {
          "value": 2.01
        },
        "radius": {
          "value": 40.23
        },
        "rotation": {
          "value": 2.22
        },
        "yDivide": {
          "value": 555
        },
        "xDivide": {
          "value": 0.99
        },
        "yShape": {
          "value": 6.54
        },
        "shape": {
          "value": 24.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d9",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/30.);\n  uv *=k_rotate2d(stream/120.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/6.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/5.) * .251*cos(uv.y/yShape + stream/12.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/1000.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/10.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 349.41
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 51.31
        },
        "shape": {
          "value": 62.39
        }
      },
      {
        "zoom": {
          "value": 125.177
        },
        "yDivider": {
          "value": 1.109
        },
        "xDivider": {
          "value": 6.08
        },
        "multiplier": {
          "value": 5.96
        },
        "ballSize": {
          "value": 6.972
        },
        "contrast": {
          "value": 1.763
        },
        "radius": {
          "value": 17.255
        },
        "rotation": {
          "value": 1.789
        },
        "yDivide": {
          "value": 367.524
        },
        "xDivide": {
          "value": 2.36
        },
        "yShape": {
          "value": 1.929
        },
        "shape": {
          "value": 24.409
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1da",
    "shader": "#define orbs 5.\n\nvoid main() {\n  float stream = stream / 30.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream / 2.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 10.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.);\n    float y = radius * cos(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  gl_FragColor.b -= -.2;\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.452
        },
        "contrast": {
          "value": 2.93
        },
        "orbSize": {
          "value": 2.953
        },
        "radius": {
          "value": 6.786
        },
        "colorShift": {
          "value": 0.0573
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca203",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.602
        },
        "radius": {
          "value": 1.82
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 7.68
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 2.982958668830698
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 1.535
        },
        "radius": {
          "value": 5.629
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 5.341
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 1.211
        },
        "yDot": {
          "value": 0.554
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 6.332
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21d",
    "shader": "#define BALLS 20\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.01
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 4.53
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 40.55
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19c",
    "shader": "/**\n * Defining some constants. \n * You can't power for loops using uniform variables, hence the `orbs` definition.\n */\n#define orbs 99.\n\n/** \n * Stolen utility function. Warps domain space (ask me what that is) into a kaleidoscope.\n * To make a six-sided kaleidoscope with zero center offset:\n *\n * uv = k_kale(uv, vec2(0.), 6.); \n */\n\n\n/**\n * Stolen utility function... looped k_hue shifting. Shifts all colors by k_hue simultaneously. \n * \n * gl_FragColor = k_hue(gl_FragColor, stream);\n */\n\n/*\n * Stolen from neon balls sketch creates a glowing orb. To create a red orb at the center of the screen:\n *\n * gl_FragColor += k_orb(uv, .1, vec2(0., 0.), vec3(1., 0., 0.), 1.);\n */\n/*\n * Rotate the plane (2D).\n *\n * uv *= k_rotate2d(stream);\n */\n/*\n * Main shader function. Decides the color of a single pixel, given the position on the screen.\n */\nvoid main() {\n  // The x/y position on the screen, normalized so that 0,0 is in the center of the viewport, which is from -1 to 1.\n  // vUv is specific to three.js don't worry about it.\n  vec2 uv = k_uv();\n\n  // This adjusts the domain per the aspect ratio of the screen.\n  \n\n  // Adjust zoom level simply by assigning uv to itself multiplied by any float.\n  uv *= zoom;\n  uv *= k_rotate2d(stream);\n\n  // The distance between the current pixel and the center of the screen.\n  float dist = length(uv);\n\n  // Uncomment the next line to warp domain space into a kaleidoscope.\n  // Try creating a uniform called \"sides\" instead of hard coding the 6. Same for the center offset (0.).\n  //uv = k_kale(uv, vec2(center), sides);\n\n  // I have no idea what a dot product is, but it can do nifty things. Uncomment at will.\n  uv *= atan(dot(uv, uv) - stream);\n  uv /= dot(uv, uv);\n\n  // Create our orbs!\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * -1. * tan(t + stream); // Try `cos` and `tan`. Or comment out and use the next line.\n    //float x = radius * sin(t + stream) * tan(uv.y - stream);\n    float y = radius * tan(t * stream);\n    vec2 position = vec2(x, y);\n    uv *= k_rotate2d(i * 100.);\n\n    // Stolen from the neon balls sketch on ShaderToy. No fucking idea, but we have a rainbow.\n    vec3 color = cos(vec3(-1, 8, 1) * PI * 2. / 8. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n\n    // We're *adding* to gl_FragColor, iteratively, for each orb.\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.149
        },
        "contrast": {
          "value": 1.724
        },
        "orbSize": {
          "value": 0.131
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10.345
        },
        "sides": {
          "value": 0
        },
        "center": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca234",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(20.1 * (.001 * dot(uv, uv)));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.001 * length(uv) - rotation * (dist) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -50.;\n    vec2 p = vec2(xOuter * (atan(uv.x)) * 20. * uv.x + radius * tan(t + xMultiplier) * 10. * cos(uv.x + sin(uv.y / 100. + stream)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 13. + float(i * 2) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 45.14
        },
        "ballSize": {
          "value": 447.327
        },
        "contrast": {
          "value": 5.07
        },
        "radius": {
          "value": 353.04
        },
        "yOuter": {
          "value": 401.47
        },
        "xOuter": {
          "value": 112.32
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": -0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23e",
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 10.)) * (dist / .5) + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / 50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.33
        },
        "ballSize": {
          "value": 1111
        },
        "contrast": {
          "value": 4.78
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 1000
        },
        "xOuter": {
          "value": 226.31
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.43
        },
        "yMultiplier": {
          "value": 32.67
        },
        "divider": {
          "value": 10
        },
        "rotation": {
          "value": -0.0024
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca253",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize((uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 25.38
        },
        "yDivider": {
          "value": 27.34
        },
        "xDivider": {
          "value": 10.17
        },
        "multiplier": {
          "value": 287.12
        },
        "ballSize": {
          "value": 1.72
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 11
        },
        "yOuter": {
          "value": 0.3
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca199",
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / 50.);\n    uv *= 1.05;\n    float t = ((.1 * shape) + i * PI / orbs + rotation) * sin(stream / 10.);\n    float x = (radius * cos(t - stream / 10.) * sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * sin(t); // - tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = _uv * k_rotate2d(stream / 1.);\n  uv = k_kale(uv, vec2(1.2), 1.);\n\n  uv *= .2;\n  uv *= abs(dot(uv, uv));\n  uv *= k_rotate2d(dist);\n\n  for (float i = 0.; i < 20. / 4.; i++) {\n    uv = abs(uv);\n    float radius = .15;\n    float t = i * PI / orbs + sin(rotation * stream / 1.);\n    float x = (radius * sin(t - stream / 200.) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.3
        },
        "contrast": {
          "value": 1.59
        },
        "orbSize": {
          "value": 0.032
        },
        "radius": {
          "value": 2
        },
        "colorShift": {
          "value": 4.41
        },
        "rotation": {
          "value": 22
        },
        "shape": {
          "value": 16.75
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19b",
    "shader": "\n#define BALLS 5.\n}\n\nvoid main () {\n  float stream = stream  /2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv *= sin(11./length(uv)*.001*dot(outer2*sin(uv) + uv, uv)-stream/1.5);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation*sin(PI*rotation*dist/9.+stream/29.*dist/100000.));\n    float t = float(i) * PI / BALLS / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(float(i)*dist-1.01*uv.x+sin(PI*1.)))*uv.x/dist*PI+radius*sin(t) * 405.01*cos(uv.x + sin(uv.y/1.1)), radius*cos(dist+yOuter*uv.x/12.5+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/20.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.  / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 41.69
        },
        "ballSize": {
          "value": 8.197
        },
        "contrast": {
          "value": 2.15
        },
        "radius": {
          "value": 4
        },
        "yOuter": {
          "value": 10
        },
        "xOuter": {
          "value": 1.84
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.68
        },
        "yMultiplier": {
          "value": 0.62
        },
        "divider": {
          "value": 28
        },
        "rotation": {
          "value": 0.0591
        },
        "outer2": {
          "value": 0.765
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c0",
    "shader": "\n#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/15.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 1.; i < orbs; i++) {\n    uv *= k_rotate2d(i*tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t*radius *sin(shape*dist+stream);\n    float y = i/80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist*hue(k_orb(uv, orbSize, position, color, contrast), stream/2.);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.92
        },
        "contrast": {
          "value": 0.94
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 3.55
        },
        "colorShift": {
          "value": 4.02
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 3.92
        },
        "shape2": {
          "value": 1.42
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c3",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001 * dot(uv, uv) - stream / 52.);\n\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 200. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 30. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 234.54
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.4155
        },
        "ballSize": {
          "value": 27.72
        },
        "contrast": {
          "value": 2.17
        },
        "radius": {
          "value": 44.22
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 943.61
        },
        "xDivide": {
          "value": 1.57
        },
        "yShape": {
          "value": 61.01
        },
        "shape": {
          "value": 24.77
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ca",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / -2.);\n  uv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 2.) * .229 * cos(uv.y / yShape + stream / 2.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 33.47
        },
        "contrast": {
          "value": 4.16
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 496.23
        },
        "xDivide": {
          "value": 0.2
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 100
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1cc",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 8000.);\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 814.87
        },
        "yDivider": {
          "value": 174.84
        },
        "xDivider": {
          "value": 99.1
        },
        "multiplier": {
          "value": 0.5526
        },
        "ballSize": {
          "value": 56.73
        },
        "contrast": {
          "value": 1.85
        },
        "radius": {
          "value": 30.56
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d8",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/20.);\n  uv *=k_rotate2d(stream/120.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/14.) * .251*cos(uv.y/yShape + stream/6.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/1000.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/10.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 349.41
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 51.31
        },
        "shape": {
          "value": 62.39
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f0",
    "shader": "#define BALLS 40.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  //  uv = abs(uv);\n  uv.x += outerX * sin(stream) + uv.y / .2 + loops * sin(uv.x * x1 - stream / 1.);\n  uv.y *= outerY * cos(stream) + (uv.y / .2 + loopSize * sin(x2 * uv.x - stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.) * ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.87
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 38.45
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f2",
    "shader": "#define BALLS 25\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / 1.;\n    vec2 p = length(uv) * outer * vec2(uv.x / uv.y * xMul * uv.y + radius * tan(t * xMultiplier - stream), radius * sin(yMul * uv.x + t * yMultiplier + stream / .2));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.36
        },
        "ballSize": {
          "value": 0.009
        },
        "contrast": {
          "value": 4.57
        },
        "radius": {
          "value": 0.38
        },
        "rotation": {
          "value": 0
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 5.15
        },
        "yMultiplier": {
          "value": 10
        },
        "xMul": {
          "value": 2.3
        },
        "yMul": {
          "value": 20.73
        },
        "outer": {
          "value": 0.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f7",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\tuv = abs(uv);\n  float dist = length(uv);\n  uv *= sin(uv.x/10.)+k_rotate2d(dist/10.-stream/20.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += .162*float(i)*cos(uv.y/yDivider - stream/111.) + sin(uv.x/21. - stream/112.);\n    uv.x += .52*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider - stream/111.) - sin(uv.y/210. + stream/112.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/100.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 4105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.r *= .5;\n}",
    "variants": [
      {
        "zoom": {
          "value": 22.43
        },
        "yDivider": {
          "value": 408.69
        },
        "xDivider": {
          "value": 574.25
        },
        "multiplier": {
          "value": 4.47
        },
        "ballSize": {
          "value": 0.84
        },
        "contrast": {
          "value": 3
        },
        "radius": {
          "value": 23.44
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20d",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(uv, vec2(1.), 8.);\n  uv *= 5.15 * sin(.01 * dot(uv, uv) - stream);\n  uv.x = dist * abs(fract(uv.y) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i + stream / 10.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8
        },
        "contrast": {
          "value": 2.1
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 4.88
        },
        "colorShift": {
          "value": 8.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca211",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 501
        },
        "yDivider": {
          "value": 1
        },
        "xDivider": {
          "value": 111
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 1.69
        },
        "contrast": {
          "value": 1.66
        },
        "radius": {
          "value": 26.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca218",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), cos(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.58
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 0.93
        },
        "contrast": {
          "value": 2.85
        },
        "radius": {
          "value": 11.78
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 0.92
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca222",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca225",
    "shader": "#define BALLS 5\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/30.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .1*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/1.);\n  uv *=k_rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x/.5 * xMultiplier - stream/1.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += log(abs(sin(stream/3. + float(i) * PI)));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.26
        },
        "shapeMultiplier": {
          "value": 13.4
        },
        "rotation": {
          "value": 0.53
        },
        "xMultiplier": {
          "value": 6.77
        },
        "yMultiplier": {
          "value": 16.44
        },
        "colorSpread": {
          "value": 67.44
        },
        "colorMultiplier": {
          "value": 0.12
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 39.9
        },
        "ballSize": {
          "value": 0.01
        },
        "glow": {
          "value": 2.9
        },
        "contrast": {
          "value": 3.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24d",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*length(uv)/((stream/20.))/(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.87
        },
        "ballSize": {
          "value": 194.683
        },
        "contrast": {
          "value": 3.34
        },
        "radius": {
          "value": 105.97
        },
        "yOuter": {
          "value": 457.26
        },
        "xOuter": {
          "value": 1392.53
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 8.32
        },
        "yMultiplier": {
          "value": 12.9
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": 0.0049
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca250",
    "shader": "\n\nvoid main() {\n  vec2 uv = -1.0 + 2.0 * vUv / resolution.xy;\n  \n  uv *= zoom;\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv = abs(fract(uv) - .5) * 2.1;\n  uv = abs(fract(uv) - .5) * .1;\n  uv *= 2. * atan(uv.x / 50. + stream / 1.) - .1;\n  vec4 result = vec4(0, 0, 0, 1);\n  float t = 1.8;\n  float base = 1000. * length(uv);\n  for (int p = 0; p < 3; p++) {\n    float a = cos((t * base) - stream / 1.);\n    float b = cos(shape * uv.x / .25 - stream /2.);\n    result[p] = 2.52 * a + 1.7 * b + base / 1000.;\n    t += 2.6;\n  }\n  result.xyz *= brightness * result.x;\n  result.xyz = (result.xyz);\n  result.xy *= abs(tan(uv.x*multiplier));\n  gl_FragColor = 1. + log(abs(result));\n  gl_FragColor.r *= red;\n  gl_FragColor.g *= green;\n  gl_FragColor.b *= blue;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.0039
        },
        "brightness": {
          "value": 41.76
        },
        "red": {
          "value": 0.6
        },
        "green": {
          "value": 0.17
        },
        "blue": {
          "value": 0.17
        },
        "shape": {
          "value": 765.37
        },
        "multiplier": {
          "value": 51.58
        },
        "kaleidoscope": {
          "value": false
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1af",
    "shader": "\n#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.73
        },
        "contrast": {
          "value": 1.36
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 3.21
        },
        "colorShift": {
          "value": 4
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1cd",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 10000.);\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 518.74
        },
        "yDivider": {
          "value": 509.34
        },
        "xDivider": {
          "value": 107.89
        },
        "multiplier": {
          "value": 0.5526
        },
        "ballSize": {
          "value": 60.31
        },
        "contrast": {
          "value": 3.03
        },
        "radius": {
          "value": 40.75
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d1",
    "shader": "#define BALLS 20\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotation * stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = tan(t - stream / 42.); // + stream/100.);\n    float y = sin(t / multiplier + stream / 7.); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 376.98
        },
        "yDivider": {
          "value": 177.2
        },
        "xDivider": {
          "value": 70.49
        },
        "multiplier": {
          "value": 2.0479
        },
        "ballSize": {
          "value": 67.06
        },
        "contrast": {
          "value": 2.45
        },
        "radius": {
          "value": 55.1
        },
        "rotation": {
          "value": 1
        },
        "yDivide": {
          "value": 401.76
        },
        "xDivide": {
          "value": 0.57
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 62.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1df",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= 1.1 * sin(.01 * dot(uv, uv) - stream / 5.);\n  uv /= abs(fract(uv) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.92
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca220",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.), 2.*cos(shape*uv+stream/5.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 2.69
        },
        "contrast": {
          "value": 3.6
        },
        "radius": {
          "value": 28.41
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca237",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 11.)) * (dist / .5) + stream / 10.);\n    float t = PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * (abs(cos(.06 * uv.y - stream))) * uv.x * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.61
        },
        "ballSize": {
          "value": 807.57
        },
        "contrast": {
          "value": 1.54
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 715.65
        },
        "xOuter": {
          "value": 389.02
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23d",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream / 52. - float(i) / 10.;\n    vec2 p = vec2(xOuter * uv.y * 2.1 / uv.x * 6. + radius * cos(t + xMultiplier + stream / 5.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + 2.1 * stream) / stream / 5.);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1. / dist * length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 37.46
        },
        "ballSize": {
          "value": 6567.026
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 126.63
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 814.53
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 29.31
        },
        "yMultiplier": {
          "value": 41.44
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0059
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b2",
    "shader": "\n  #define orbs 10.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 2.*sin(t-stream/2.);\n      float y = radius * cos(t+stream) + 2.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 1.*tan(t-stream/2.);\n      float y = radius * cos(t+stream) + 1.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor -=k_orb(uv, orbSize*.5, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 4.48
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.43
        },
        "radius": {
          "value": 1.03
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1bf",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 15.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 1.; i < 20.; i++) {\n    uv *= k_rotate2d(i * tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t * radius * sin(shape * dist + stream);\n    float y = i / 80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.92
        },
        "contrast": {
          "value": 0.94
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 3.55
        },
        "colorShift": {
          "value": 4.02
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 3.92
        },
        "shape2": {
          "value": 1.42
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1dd",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(uv) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.93
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.62
        },
        "radius": {
          "value": 4.92
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e5",
    "shader": "  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 26.24
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.62
        },
        "radius": {
          "value": 4.92
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1eb",
    "shader": "\n  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 26.24
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.62
        },
        "radius": {
          "value": 4.92
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ee",
    "shader": "  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv)-sin(uv) - stream/3.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.);\n      float y = radius * sin(t-stream/10.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 6.15
        },
        "contrast": {
          "value": 2.03
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 3.28
        },
        "colorShift": {
          "value": 8.91
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca210",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50
        },
        "yDivider": {
          "value": 0.73
        },
        "xDivider": {
          "value": 9.13
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.23
        },
        "contrast": {
          "value": 1.61
        },
        "radius": {
          "value": 38.96
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20f",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 88.11
        },
        "yDivider": {
          "value": 1
        },
        "xDivider": {
          "value": 111
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 1.69
        },
        "contrast": {
          "value": 1.66
        },
        "radius": {
          "value": 26.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21e",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n  uv *=k_rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.63
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 3
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 20.28
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca228",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), cos(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.58
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 0.93
        },
        "contrast": {
          "value": 2.85
        },
        "radius": {
          "value": 11.78
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 0.92
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22b",
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.41
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 1.15
        },
        "contrast": {
          "value": 3
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22e",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.), 2.*cos(shape*uv+stream/5.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 2.69
        },
        "contrast": {
          "value": 3.6
        },
        "radius": {
          "value": 28.41
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22f",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.01*sin(uv+stream), 2.*cos(shape*uv+stream))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.74
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 784.55
        },
        "ballSize": {
          "value": 1.36
        },
        "contrast": {
          "value": 2.66
        },
        "radius": {
          "value": 43.22
        },
        "yOuter": {
          "value": 0.82
        },
        "xOuter": {
          "value": 0.92
        },
        "rotation": {
          "value": 1215
        },
        "shape": {
          "value": 0.75
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca239",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * (dist / 5.) + stream / 10. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.22
        },
        "ballSize": {
          "value": 8.028
        },
        "contrast": {
          "value": 0.48
        },
        "radius": {
          "value": 5
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 24
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 1.35
        },
        "yMultiplier": {
          "value": 8.46
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": -0.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca196",
    "shader": "\n#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.73
        },
        "contrast": {
          "value": 1.36
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 3.21
        },
        "colorShift": {
          "value": 4
        },
        "center": {
          "value": 0
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 4.68
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0.001
        },
        "gloop": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a2",
    "shader": "#define orbs 50.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 1.; i < 20.; i++) {\n    uv *= 1.005;\n    float t = i * PI / orbs + rotation * sin(stream / 10.);\n    float x = radius * tan(t - stream) * sin(t - stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.41
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 0.06
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 12.95
        },
        "rotation": {
          "value": 9.14
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a8",
    "shader": "#define BALLS 30\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius * tan(t * multiplier + stream);\n    float y = radius * sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.11
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 0.05
        },
        "contrast": {
          "value": 2.73
        },
        "radius": {
          "value": 1
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ae",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*cos(t+xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t+yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.27
        },
        "ballSize": {
          "value": 0.021
        },
        "contrast": {
          "value": 3.98
        },
        "radius": {
          "value": 0.97
        },
        "yOuter": {
          "value": 1.98
        },
        "xOuter": {
          "value": 20
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 6.39
        },
        "yMultiplier": {
          "value": 3.46
        },
        "divider": {
          "value": 2
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b7",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n//  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.005*dot(uv + 1.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/10.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.006
        },
        "contrast": {
          "value": 0.12
        },
        "orbSize": {
          "value": 17.09
        },
        "radius": {
          "value": 10.09
        },
        "colorShift": {
          "value": 7.95
        },
        "sides": {
          "value": 12
        },
        "rotation": {
          "value": 0.6
        },
        "sinMul": {
          "value": 4
        },
        "cosMul": {
          "value": 3.16
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        },
        "base": {
          "value": 0.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c6",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x); //-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream) * cosMul * cos(uv.y / yShape + stream / 3.) * cosMul * sin(stream / 10.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 469.65
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 105.78
        },
        "contrast": {
          "value": 3.32
        },
        "radius": {
          "value": 115
        },
        "rotation": {
          "value": 0
        },
        "yDivide": {
          "value": 897.27
        },
        "xDivide": {
          "value": 0.18
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 100
        },
        "cosMul": {
          "value": 0.86
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d2",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _dotted = uv * sin(.0001 * dot(uv, uv) - stream / 10.);\n  if (dottedTween) {\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 92.31
        },
        "yDivider": {
          "value": 2.02
        },
        "xDivider": {
          "value": 19.77
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 26.35
        },
        "contrast": {
          "value": 3.19
        },
        "radius": {
          "value": 25.88
        },
        "rotation": {
          "value": 89.48
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 1.49
        },
        "yShape": {
          "value": 14.73
        },
        "shape": {
          "value": 71.08
        },
        "dotted": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1fd",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*tan(t*xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t*yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.3
        },
        "ballSize": {
          "value": 0.076
        },
        "contrast": {
          "value": 4.36
        },
        "radius": {
          "value": 1.44
        },
        "yOuter": {
          "value": 0.71
        },
        "xOuter": {
          "value": 4.15
        },
        "rotation": {
          "value": 0.46
        },
        "shape": {
          "value": 5.17
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.38
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca231",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 20000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.22
        },
        "ballSize": {
          "value": 2071.834
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 68.36
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        },
        "xOuter": {
          "value": 2783.51
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca249",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) *k_rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.23
        },
        "ballSize": {
          "value": 183.349
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 237.72
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 100
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0.0002
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca255",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.3*(uv + sin(5.*uv))-stream/10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/2. - stream/21.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius*tan(t*multiplier), _radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.84
        },
        "yDivider": {
          "value": 232
        },
        "xDivider": {
          "value": 77.31
        },
        "multiplier": {
          "value": 69.13
        },
        "ballSize": {
          "value": 2.31
        },
        "contrast": {
          "value": 1.79
        },
        "radius": {
          "value": 57.1
        },
        "yOuter": {
          "value": 0.73
        },
        "xOuter": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1bd",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(20. * uv.y);\n    float y = .1 * sin(uv.y / 2.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 50.28
        },
        "contrast": {
          "value": 2.43
        },
        "orbSize": {
          "value": 0.36
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 6.68
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e1",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\tvec2 _uv = uv;\n  uv /= abs(fract(sin(uv)) - .5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv = _uv;\n    uv /= 1.*sin(dist*dot(uv + sin(uv), uv)+(i*.15));\n    float t = i * PI / orbs + rotation * sin(stream/10.);\n    float x = radius * cos(t-stream) * sin(t-stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.06
        },
        "contrast": {
          "value": 1.81
        },
        "orbSize": {
          "value": 0.28
        },
        "radius": {
          "value": 3.95
        },
        "colorShift": {
          "value": 18.43
        },
        "rotation": {
          "value": 36.65
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f1",
    "shader": "#define BALLS 40.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX * sin(stream) + uv.y / .2 + loops * sin(uv.x * x1 - stream / 1.);\n  uv.y *= outerY * cos(stream) + (uv.y / .2 + loopSize * sin(x2 * uv.x - stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 55.86
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 101
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20b",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(uv, vec2(1.), 8.);\n  uv *= 5.15 * cos(.01 * dot(uv + shape * sin(uv + stream), uv + fuck * cos(uv - stream)) - stream);\n  uv.x = dist * abs(fract(uv.y) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i + stream / 10.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8
        },
        "contrast": {
          "value": 2.1
        },
        "orbSize": {
          "value": 1.01
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 8.7
        },
        "shape": {
          "value": 0
        },
        "fuck": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20e",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 92.286572
        },
        "yDivider": {
          "value": 0.73
        },
        "xDivider": {
          "value": 9.13
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.23
        },
        "contrast": {
          "value": 1.61
        },
        "radius": {
          "value": 38.96
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21a",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.41
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 1.15
        },
        "contrast": {
          "value": 3
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22a",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n  uv *=k_rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.63
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 3
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 20.28
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca238",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation + stream / 8.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.02 * uv.y - stream / 2.)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 5.) * (.4201 * uv.x + sin(uv.y / .1)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(color * log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.37
        },
        "ballSize": {
          "value": 590.219
        },
        "contrast": {
          "value": 1.63
        },
        "radius": {
          "value": 527.24
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 73.89
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 101
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0.0004
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca245",
    "shader": "#define BALLS 3\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*length(uv)/((stream/2.))*(dist/.5)+stream/9.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*1.1+radius*cos(t+xMultiplier+stream/20.) * .1/cos(.1*uv.x + sin(uv.x/1.)), radius*cos((.01*uv.y*t+yMultiplier)+1.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.561
        },
        "ballSize": {
          "value": 2006.924
        },
        "contrast": {
          "value": 1.349
        },
        "radius": {
          "value": 0.135
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 2523.313
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 3.843
        },
        "yMultiplier": {
          "value": 4.397
        },
        "divider": {
          "value": 842.935
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a5",
    "shader": "#define orbs 40.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.05;\n    float radius = 10.;\n    float t = (i * PI / orbs + rotation) * sin(stream / 10.);\n    float x = (radius * tan(t - stream) * sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = k_kale(uv, vec2(.2), 5.);\n  uv *= k_rotate2d(tan(stream));\n\n  uv *= k_rotate2d(dist);\n\n  for (float i = 1.; i < 20.; i++) {\n    float t = i * PI / orbs + rotation * sin(stream / 10.);\n    float x = (radius * tan(t - stream) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 2.05
        },
        "orbSize": {
          "value": 0.073
        },
        "radius": {
          "value": 0.06
        },
        "colorShift": {
          "value": 8.93
        },
        "rotation": {
          "value": 17
        },
        "shape": {
          "value": 110
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a9",
    "shader": "#define orbs 5.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t-stream);\n    float y1 = radius * sin(t+stream);\n    float x2 = radius * tan(t-stream);\n    float y2 = radius * sin(t-stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n\t\t  \tx = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n     \tx = x2; \n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 0.88
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.87
        },
        "colorShift": {
          "value": 2.5
        },
        "center": {
          "value": 1.73
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1b0",
    "shader": "\n#define BALLS 20\n  \nmat2k_rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * 2. * PI / float(BALLS);\n    float x = radius*tan(t + stream);\n    float y = radius*cos(t + stream);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(color * PI * (float(i) / PI));//* 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "ballSize": {
          "value": 0.004
        },
        "contrast": {
          "value": 0.39
        },
        "radius": {
          "value": 0.1
        },
        "mirror": {
          "value": false
        },
        "color": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ce",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 12000.);\n    uv.y -= float(i) / 50. * cos(uv.y / yDivider + stream / 18.) + sin(uv.x / 100. - stream / 13.);\n    uv.x += float(i) / 2. * sin(uv.x / xDivider + stream / 18.) - cos(uv.y / 1000. + stream / 13.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 41.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1276.85
        },
        "yDivider": {
          "value": 414.6
        },
        "xDivider": {
          "value": 40.9
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 176
        },
        "contrast": {
          "value": 2.26
        },
        "radius": {
          "value": 82.95
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1cf",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 2.) * .229 * cos(uv.y / yShape + stream / 2.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 182.83
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 496.23
        },
        "xDivide": {
          "value": 0.2
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 100
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1fa",
    "shader": "#define BALLS 40.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 55.86
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 101
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca207",
    "shader": "\n#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n\tuv *= k_rotate2d(stream/10.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .001/dist * uv + yDot*cos(uv))-stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, 4.*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.68
        },
        "contrast": {
          "value": 1.67
        },
        "orbSize": {
          "value": 0.07
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.96
        },
        "center": {
          "value": 1.15
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 10
        },
        "yDot": {
          "value": 0.63
        },
        "dotMul": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca217",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * uv + stream / 2.)) * 21.1 * tan(uv);\n  uv *= k_rotate2d(rotation * stream / .8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.63
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 3
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 20.28
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23c",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.92
        },
        "ballSize": {
          "value": 696.957
        },
        "contrast": {
          "value": 1.54
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca246",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*length(uv)/((stream/20.))/(dist/-222.2)+stream/dist/10000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(11./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.22
        },
        "ballSize": {
          "value": 204.295
        },
        "contrast": {
          "value": 0.84
        },
        "radius": {
          "value": 148.3
        },
        "yOuter": {
          "value": 994.06
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 73.02
        },
        "yMultiplier": {
          "value": 71.21
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24f",
    "shader": "void main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(fract(uv) - .5) * 2.1;\n  uv = abs(fract(uv) - .5) * .1;\n  uv *= 2. * atan(uv.x / 50. + stream / 1.) - .1;\n  vec4 result = vec4(0, 0, 0, 1);\n  float t = 1.8;\n  float base = 1000. * length(uv);\n  for (int p = 0; p < 3; p++) {\n    float a = cos((t * base) - stream / 1.);\n    float b = cos(shape * uv.x / .25 - stream / 2.);\n    result[p] = 2.52 * a + 1.7 * b + base / 1000.;\n    t += 2.6;\n  }\n  result.xyz *= brightness * result.x;\n  result.xyz = (result.xyz);\n  result.xy *= abs(tan(uv.x * multiplier));\n  gl_FragColor = 1. + log(abs(result));\n  gl_FragColor.r *= red;\n  gl_FragColor.g *= green;\n  gl_FragColor.b *= blue;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0039
        },
        "brightness": {
          "value": 58.03
        },
        "red": {
          "value": 0.2
        },
        "green": {
          "value": 0.17
        },
        "blue": {
          "value": 0.81
        },
        "shape": {
          "value": 765.37
        },
        "multiplier": {
          "value": 17.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19e",
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  vec2 _uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.05;\n    float radius = 3.;\n    float t = (shape * i * PI / orbs + rotation) * sin(stream / 20.);\n    float x = (radius * tan(t - stream / 20.) * sin(t - stream / 5.));\n    float y = radius * tan(t) * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = _uv * k_rotate2d(stream / 1.);\n  uv = k_kale(uv, vec2(dist), 1.);\n\n  uv += dot(uv, uv);\n  //  uv *= k_rotate2d(dist);\n\n  for (float i = 0.; i < 20. / 2.; i++) {\n    uv = abs(uv);\n    float radius = .0;\n    float t = i * PI / orbs + rotation + tan(stream / 50.);\n    float x = (radius / sin(t) * sin(t - stream / 20.)) + (.1 * sin(uv.x));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.11
        },
        "contrast": {
          "value": 1.2
        },
        "orbSize": {
          "value": 0.076
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 4.41
        },
        "rotation": {
          "value": 9.58
        },
        "shape": {
          "value": 3.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d7",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x);//-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider+stream) * cosMul*cos(uv.x/yShape+stream/3.) * cosMul*sin(stream/10.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/10.;\n    float x = -1.*tan(t) + stream/100.;\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, 6.)*pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 363.69
        },
        "yDivider": {
          "value": 665.49
        },
        "xDivider": {
          "value": 9.32
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 55.94
        },
        "contrast": {
          "value": 3.57
        },
        "radius": {
          "value": 26.89
        },
        "rotation": {
          "value": 0
        },
        "yDivide": {
          "value": 1000
        },
        "xDivide": {
          "value": 0.05
        },
        "yShape": {
          "value": 16.92
        },
        "shape": {
          "value": 14.28
        },
        "cosMul": {
          "value": 0.21
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e7",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n  uv += sin(.01*dot(tan(uv+stream/20.), (uv)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1. + stream/3.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 22.28
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 0.1
        },
        "ballSize": {
          "value": 0.54
        },
        "contrast": {
          "value": 1.63
        },
        "radius": {
          "value": 29.51
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f4",
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  vec2 dotted = uv / dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  if (dottedTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(float(i) + stream / 200.);\n    uv.x += uv.y / yDivider;\n    uv.y -= uv.x / xDivider;\n    float t = twist * dist * (i) * PI / (orbs) * (5. + 1.);\n    vec2 p = radius * vec2(cosMul * cos(t - stream / 30.), 2.5 * sin(t + stream / 31.));\n    p *= pMul * sin(stream / 44. + cos(uv.y / 2. + stream / 50.) * sin(t + uv.x / x3) * cos(t - stream / 44. + uv.y / y3));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + (i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((-5. + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 111
        },
        "ballSize": {
          "value": 15
        },
        "contrast": {
          "value": 1.77
        },
        "radius": {
          "value": 15
        },
        "y3": {
          "value": 50
        },
        "mirror": {
          "value": false
        },
        "x3": {
          "value": 11.48
        },
        "twist": {
          "value": 0.00132
        },
        "pMul": {
          "value": 1.19
        },
        "cosMul": {
          "value": 24.09
        },
        "kaleidoscope": {
          "value": false
        },
        "dotted": {
          "value": false
        },
        "sides": {
          "value": 10
        },
        "yDivider": {
          "value": 42.2
        },
        "xDivider": {
          "value": 46.07
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f9",
    "shader": "#define BALLS 40.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n//  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.)*ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 34.87
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 38.45
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca227",
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24b",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) *k_rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.23
        },
        "ballSize": {
          "value": 183.349
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 237.72
        },
        "yOuter": {
          "value": 100
        },
        "xOuter": {
          "value": 100
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0.0002
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24c",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) { \n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) *k_rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.06
        },
        "ballSize": {
          "value": 183.349
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 237.72
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 18.72
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca198",
    "shader": "#define orbs 5.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 0.88
        },
        "orbSize": {
          "value": 0.01
        },
        "radius": {
          "value": 0.87
        },
        "colorShift": {
          "value": 2.5
        },
        "center": {
          "value": 1.73
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1db",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(uv) - sin(uv) - stream / 3.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 5.);\n    float y = radius * sin(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.15
        },
        "contrast": {
          "value": 2.03
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 3.28
        },
        "colorShift": {
          "value": 8.91
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e6",
    "shader": "  #define orbs 15.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(uv);\n    uv *= 5.1*sin(.1*dot(uv, uv) - stream/5.);\n    uv /= abs(fract(uv) - .5) / .5/dist*k_rotate2d(stream/4.); \n    for (float i = 0.; i < orbs; i++) {\n      uv *= k_rotate2d(.001*stream/(i+1.));\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t);\n      float y = radius * cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 0.87
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 1.81
        },
        "colorShift": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e9",
    "shader": "  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n\n    uv /= dot(uv, uv);\n    uv *= k_rotate2d(stream/2.);\n    float dist = length(tan(cos(uv-stream) - stream/1.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/6.);\n      float y = radius * sin(t-stream/1.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 2.93
        },
        "orbSize": {
          "value": 3
        },
        "radius": {
          "value": 21.13
        },
        "colorShift": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ea",
    "shader": "  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv+stream) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .001* dist*i * (uv + sin(uv-stream));\n      uv.x += .2*sin(uv.y);\n      uv.y += 1.2*cos(uv.x+stream);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 18.16
        },
        "contrast": {
          "value": 1.43
        },
        "orbSize": {
          "value": 0.75
        },
        "radius": {
          "value": 4.58
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ec",
    "shader": "\n  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv)-sin(uv) - stream/3.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.);\n      float y = radius * sin(t-stream/10.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 6.15
        },
        "contrast": {
          "value": 2.03
        },
        "orbSize": {
          "value": 0.84
        },
        "radius": {
          "value": 3.28
        },
        "colorShift": {
          "value": 8.91
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ef",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / 2.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 6.);\n    float y = radius * sin(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.41
        },
        "contrast": {
          "value": 2.58
        },
        "orbSize": {
          "value": 1.71
        },
        "radius": {
          "value": 14.42
        },
        "colorShift": {
          "value": 8.19
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1fc",
    "shader": "\n#define orbs 25.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 5.*uv.x+radius * tan(t+stream);\n    float y = .1*sin(uv.y/.01) * uv.x*sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 1.73
        },
        "orbSize": {
          "value": 0.24
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 6.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca200",
    "shader": "#define BALLS 40.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n//  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.)*ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 34.87
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 38.45
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca202",
    "shader": "#define BALLS 40.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      {
        "zoom": {
          "value": 55.86
        },
        "contrast": {
          "value": 2.57
        },
        "ballSize": {
          "value": 101
        },
        "x1": {
          "value": 0.14
        },
        "x0": {
          "value": 0
        },
        "y0": {
          "value": 0.85
        },
        "ballMul": {
          "value": 9.04
        },
        "xMul": {
          "value": 100.56
        },
        "yMul": {
          "value": 1.68
        },
        "wave1": {
          "value": 44.32
        },
        "wave2": {
          "value": 1.62
        },
        "loops": {
          "value": 67.96
        },
        "outerX": {
          "value": 19.6
        },
        "outerY": {
          "value": 33.32
        },
        "loopSize": {
          "value": 0
        },
        "x2": {
          "value": 64.85
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca206",
    "shader": "#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n\tuv *= k_rotate2d(stream/20.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/30.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.35
        },
        "radius": {
          "value": 1.82
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 7.68
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 2.982958668830698
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca214",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20. * (uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * uv + stream / 2.)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.01
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 4.53
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 40.55
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca221",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*sin(uv)+stream/.5))*21.1*tan(uv);\n  uv *=k_rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/1.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/1.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier+stream/5.), 2.*radius*sin(t*multiplier-stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.88
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 0.1
        },
        "ballSize": {
          "value": 3.24
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 18.53
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        },
        "rotation": {
          "value": 0.55
        },
        "shape": {
          "value": 10
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca235",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.01 * uv.x + sin(uv.x / 1.)), vec2(10.) * k_rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.06
        },
        "ballSize": {
          "value": 183.349
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 237.72
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 18.72
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23a",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * length(uv) / ((stream / 20.)) / (dist / -222.2) + stream / dist / 10000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 20.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(11. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.22
        },
        "ballSize": {
          "value": 204.295
        },
        "contrast": {
          "value": 0.84
        },
        "radius": {
          "value": 148.3
        },
        "yOuter": {
          "value": 994.06
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 73.02
        },
        "yMultiplier": {
          "value": 71.21
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": 0.02
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca243",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*length(uv)/((stream/20.))/(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.87
        },
        "ballSize": {
          "value": 194.683
        },
        "contrast": {
          "value": 3.34
        },
        "radius": {
          "value": 105.97
        },
        "yOuter": {
          "value": 457.26
        },
        "xOuter": {
          "value": 1392.53
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 8.32
        },
        "yMultiplier": {
          "value": 12.9
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": 0.0049
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24e",
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n\n  uv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*tan(uv.x)*atan(dist/-2212.2)-stream/100. -dist/1000.);\n    float t = (PI / float(BALLS) * float(BALLS) / divider) - stream/15.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x/-2.-stream/20.))*uv.y+radius*cos(t+xMultiplier+stream/2.) * cos(sin(uv.y)*uv.y + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/100. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(.01*length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02
        },
        "ballSize": {
          "value": 518.629
        },
        "contrast": {
          "value": 5.13
        },
        "radius": {
          "value": 0
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 2401
        },
        "xMultiplier": {
          "value": 33.1
        },
        "yMultiplier": {
          "value": 24.92
        },
        "divider": {
          "value": 188
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ba",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.08
        },
        "contrast": {
          "value": 0.13
        },
        "orbSize": {
          "value": 6.32
        },
        "radius": {
          "value": 11
        },
        "colorShift": {
          "value": 10.32
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 1
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.28
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0
        },
        "xSpeed": {
          "value": 0
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.003
        },
        "yDivide": {
          "value": 11
        },
        "xDivide": {
          "value": 15
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1f5",
    "shader": "#define BALLS 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv.x += sin(stream / 4.) * 11.1 * sin(stream) + uv.y / 1.2 + xMul2 * sin(uv.x * x1 - stream / 1.);\n  uv.y *= .1 * cos(stream) + (uv.y / .2 + 1. * sin(x2 * uv.x - stream));\n  uv.x += .1 * sin(.1 * uv.y);\n  uv.y += .1 * cos(.1 * uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(sin(t + i) * xMul, uv.x + cos(uv.y - stream + i) * sin(uv.x + stream + i));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.35
        },
        "contrast": {
          "value": 0.48
        },
        "ballSize": {
          "value": 607.64
        },
        "x1": {
          "value": 0.41
        },
        "x2": {
          "value": 0
        },
        "ballMul": {
          "value": 35.51
        },
        "xMul": {
          "value": 110
        },
        "size": {
          "value": 15870.35
        },
        "xMul2": {
          "value": 61.45
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20a",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001 * dot(uv, uv) - stream / 40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. / stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 10.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t + multiplier + stream / 50.), radius * sin(t - multiplier + stream / 30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 88.11
        },
        "yDivider": {
          "value": 1
        },
        "xDivider": {
          "value": 111
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 1.69
        },
        "contrast": {
          "value": 1.66
        },
        "radius": {
          "value": 26.57
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca224",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.01
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 4.53
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 40.55
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca232",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * length(uv) / ((stream / 20.)) / (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 20.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.87
        },
        "ballSize": {
          "value": 194.683
        },
        "contrast": {
          "value": 3.34
        },
        "radius": {
          "value": 105.97
        },
        "yOuter": {
          "value": 457.26
        },
        "xOuter": {
          "value": 1392.53
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 8.32
        },
        "yMultiplier": {
          "value": 12.9
        },
        "divider": {
          "value": 8
        },
        "rotation": {
          "value": 0.0049
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca244",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50.*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(stream/20.4567);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.1234) * 20./cos(.1*uv.x + sin(uv.x/100.+stream/20.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.11 + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.2
        },
        "ballSize": {
          "value": 3397.579
        },
        "contrast": {
          "value": 2.19
        },
        "radius": {
          "value": 2007.3
        },
        "yOuter": {
          "value": 557.08
        },
        "xOuter": {
          "value": 1451.1
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 23.06
        },
        "yMultiplier": {
          "value": 91.45
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 0.0303
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca197",
    "shader": "/**\n * Defining some constants. \n * You can't power for loops using uniform variables, hence the `orbs` definition.\n */\n\n#define orbs 99.\n\n/** \n * Stolen utility function. Warps domain space (ask me what that is) into a kaleidoscope.\n * To make a six-sided kaleidoscope with zero center offset:\n *\n * uv = k_kale(uv, vec2(0.), 6.); \n */\n\n\n/**\n * Stolen utility function... looped k_hue shifting. Shifts all colors by k_hue simultaneously. \n * \n * gl_FragColor = k_hue(gl_FragColor, stream);\n */\n\n\n/*\n * Stolen from neon balls sketch creates a glowing orb. To create a red orb at the center of the screen:\n *\n * gl_FragColor +=k_orb(uv, .1, vec2(0., 0.), vec3(1., 0., 0.), 1.);\n */\nvec4k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n/*\n * Rotate the plane (2D).\n *\n * uv *= k_rotate2d(stream);\n */\nmat2 k_rotate2d(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n/*\n * Main shader function. Decides the color of a single pixel, given the position on the screen.\n */\nvoid main() {\n  // The x/y position on the screen, normalized so that 0,0 is in the center of the viewport, which is from -1 to 1.\n  // vUv is specific to three.js don't worry about it.\n  vec2 uv = k_uv();\n  \n\n  // This adjusts the domain per the aspect ratio of the screen.\n  \n\n  // Adjust zoom level simply by assigning uv to itself multiplied by any float.\n  uv *= zoom;\n  uv *= k_rotate2d(stream);\n\n  // The distance between the current pixel and the center of the screen.\n  float dist = length(uv);\n  \n  // Uncomment the next line to warp domain space into a kaleidoscope.\n\t// Try creating a uniform called \"sides\" instead of hard coding the 6. Same for the center offset (0.).\n  //uv = k_kale(uv, vec2(center), sides); \n\n  // I have no idea what a dot product is, but it can do nifty things. Uncomment at will.\n  uv *= atan(dot(uv, uv) - stream);\n  uv /= dot(uv, uv);\n  \n  \n\n  // Create our orbs!\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * -1.*tan(t + stream); // Try `cos` and `tan`. Or comment out and use the next line.\n    //float x = radius * sin(t + stream) * tan(uv.y - stream);\n    float y = radius * tan(t * stream); \n    vec2 position = vec2(x, y);\n    uv *= k_rotate2d(i*100.);\n\n    // Stolen from the neon balls sketch on ShaderToy. No fucking idea, but we have a rainbow.\n    vec3 color = cos(vec3(-1, 8, 1) * PI * 2. / 8. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n\n    // We're *adding* to gl_FragColor, iteratively, for each orb. \n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    \n  }\n  \n}",
    "variants": [
      {
        "zoom": {
          "value": 1.149
        },
        "contrast": {
          "value": 1.724
        },
        "orbSize": {
          "value": 0.131
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 10.345
        },
        "sides": {
          "value": 0
        },
        "center": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca19f",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.125
        },
        "radius": {
          "value": 2.5
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a7",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * uv.y + radius * tan(t * xMultiplier + stream), radius * sin(yOuter * uv.x / .1 + t * yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.3
        },
        "ballSize": {
          "value": 0.076
        },
        "contrast": {
          "value": 4.36
        },
        "radius": {
          "value": 1.44
        },
        "yOuter": {
          "value": 0.71
        },
        "xOuter": {
          "value": 4.15
        },
        "rotation": {
          "value": 0.46
        },
        "shape": {
          "value": 5.17
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.38
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1cb",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 12000.);\n    uv.y -= float(i) / 50. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 2. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1110
        },
        "yDivider": {
          "value": 300.86
        },
        "xDivider": {
          "value": 35.63
        },
        "multiplier": {
          "value": 1.3445
        },
        "ballSize": {
          "value": 108.3
        },
        "contrast": {
          "value": 2.26
        },
        "radius": {
          "value": 54.64
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d3",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/52.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/14.) * .251*cos(uv.y/yShape + stream/6.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/200.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/30. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 234.54
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.4155
        },
        "ballSize": {
          "value": 27.72
        },
        "contrast": {
          "value": 2.17
        },
        "radius": {
          "value": 44.22
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 943.61
        },
        "xDivide": {
          "value": 1.57
        },
        "yShape": {
          "value": 61.01
        },
        "shape": {
          "value": 24.77
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1dc",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= 5.1 * sin(.1 * dot(uv, uv) - stream / 5.);\n  uv /= abs(fract(uv) - .5) / .5 / dist * k_rotate2d(stream / 4.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(.001 * stream / (i + 1.));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.87
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 1.81
        },
        "colorShift": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1de",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / 5.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 6.);\n    float y = radius * sin(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42
        },
        "contrast": {
          "value": 1.26
        },
        "orbSize": {
          "value": 1.36
        },
        "radius": {
          "value": 6.32
        },
        "colorShift": {
          "value": 4.3
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e0",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(sin(uv + stream) + tan(cos(uv - stream) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.4
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.99
        },
        "radius": {
          "value": 15
        },
        "colorShift": {
          "value": 9.77
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1fb",
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(atan(dist/uv.x+stream))*uv.x+radius*sin(t+xMultiplier), radius*sin(dist*yOuter*uv.x/.5+t+yMultiplier+3.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.46
        },
        "ballSize": {
          "value": 0.004
        },
        "contrast": {
          "value": 4.47
        },
        "radius": {
          "value": 0.12
        },
        "yOuter": {
          "value": 29.89
        },
        "xOuter": {
          "value": 0.88
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 2.82
        },
        "yMultiplier": {
          "value": 0
        },
        "divider": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca205",
    "shader": "#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n\tuv *= k_rotate2d(stream/10.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .001/dist * uv + yDot*cos(uv))-stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, 4.*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 3.68
        },
        "contrast": {
          "value": 1.67
        },
        "orbSize": {
          "value": 0.07
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.96
        },
        "center": {
          "value": 1.15
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 10
        },
        "yDot": {
          "value": 0.63
        },
        "dotMul": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca208",
    "shader": "\n#define orbs 20.\n\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n\tuv *= k_rotate2d(stream/20.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/30.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 15
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.35
        },
        "radius": {
          "value": 1.82
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 7.68
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 2.982958668830698
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca212",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca216",
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  // uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.83
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 476.91
        },
        "ballSize": {
          "value": 2.5
        },
        "contrast": {
          "value": 2.63
        },
        "radius": {
          "value": 12.73
        },
        "yOuter": {
          "value": 1
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        },
        "shape": {
          "value": 0.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca22c",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.01
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 4.53
        },
        "contrast": {
          "value": 4.42
        },
        "radius": {
          "value": 40.55
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca241",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.92
        },
        "ballSize": {
          "value": 696.957
        },
        "contrast": {
          "value": 1.54
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca247",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) { \n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(stream/100.+rotation*(dist));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), 100.*cos(dist-stream/100.));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1
        },
        "ballSize": {
          "value": 155.087
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 237.72
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 18.72
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 0
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca24a",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50.*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(stream/20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.24
        },
        "ballSize": {
          "value": 1111
        },
        "contrast": {
          "value": 1.53
        },
        "radius": {
          "value": 224.63
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 39.66
        },
        "yMultiplier": {
          "value": 41.44
        },
        "divider": {
          "value": 7
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca254",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.36
        },
        "yDivider": {
          "value": 27.34
        },
        "xDivider": {
          "value": 10.17
        },
        "multiplier": {
          "value": 287.12
        },
        "ballSize": {
          "value": 1.13
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 11
        },
        "yOuter": {
          "value": 0.3
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca101",
    "shader": "void main () {\n  vec2 uv = k_uv();\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      {
        "zoom": {
          "value": 34.766
        },
        "iterator": {
          "value": 1.071
        },
        "ot": {
          "value": 124.993
        },
        "I": {
          "value": 1.184
        },
        "J": {
          "value": 2.139
        },
        "K": {
          "value": 38.004
        },
        "iterations": {
          "value": 12.332
        },
        "L": {
          "value": 3
        },
        "M": {
          "value": 3.192
        },
        "colorShift": {
          "value": 0.967
        },
        "colorOffset": {
          "value": 29.314
        },
        "contrast": {
          "value": 1.977
        },
        "orbSize": {
          "value": 4.654
        },
        "div": {
          "value": 1.838
        },
        "radius": {
          "value": 23.923
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ab",
    "shader": "  #define orbs 15.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * sin(t+stream);\n      float y = radius * cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 4
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.125
        },
        "radius": {
          "value": 2.5
        },
        "colorShift": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c5",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 349.41
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 51.31
        },
        "shape": {
          "value": 62.39
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1d0",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 20.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t - stream / 5.); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 212.73
        },
        "yDivider": {
          "value": 177.2
        },
        "xDivider": {
          "value": 70.49
        },
        "multiplier": {
          "value": 2.1035
        },
        "ballSize": {
          "value": 38.6
        },
        "contrast": {
          "value": 2.68
        },
        "radius": {
          "value": 39.41
        },
        "rotation": {
          "value": 25.63
        },
        "yDivide": {
          "value": 309.81
        },
        "xDivide": {
          "value": 0.57
        },
        "yShape": {
          "value": 24.51
        },
        "shape": {
          "value": 61.37
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e2",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n\tvec2 _uv = uv;\n  uv /= abs(fract(sin(uv)) - .5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv = _uv;\n    uv /= 1.*sin(dist*dot(uv + sin(uv), uv)+(i*.15));\n    float t = i * PI / orbs + rotation * sin(stream/10.);\n    float x = radius * tan(t-stream) * sin(t-stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.18
        },
        "contrast": {
          "value": 1.92
        },
        "orbSize": {
          "value": 0.74
        },
        "radius": {
          "value": 5
        },
        "colorShift": {
          "value": 18.43
        },
        "rotation": {
          "value": 36.65
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1e8",
    "shader": "  #define orbs 25.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 8.93
        },
        "contrast": {
          "value": 1
        },
        "orbSize": {
          "value": 0.62
        },
        "radius": {
          "value": 4.92
        },
        "colorShift": {
          "value": 6.06
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ed",
    "shader": "\n  #define orbs 20.\n\n    vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n    \n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n\n    uv /= dot(uv, uv);\n    uv *= k_rotate2d(stream/2.);\n    float dist = length(tan(cos(uv-stream) - stream/1.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/6.);\n      float y = radius * sin(t-stream/1.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 2.93
        },
        "orbSize": {
          "value": 3
        },
        "radius": {
          "value": 21.13
        },
        "colorShift": {
          "value": 4
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ff",
    "shader": "#define BALLS 10.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv.x += sin(stream/4.)*11.1*sin(stream)+uv.y/.2 + 20.*sin(uv.x*x1 - stream/1.);\n  uv.y *= .1*cos(stream)+(uv.y/.2 + 11.*sin(x2*uv.x-stream));\n  uv.x += .1*sin(.1*uv.y);\n  uv.y += .1*cos(.1*uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.35
        },
        "contrast": {
          "value": 0.48
        },
        "ballSize": {
          "value": 607.64
        },
        "x1": {
          "value": 0.41
        },
        "x2": {
          "value": 0
        },
        "ballMul": {
          "value": 35.51
        },
        "xMul": {
          "value": 110
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca204",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 10.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .001 / dist * uv + yDot * cos(uv)) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 4. * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.68
        },
        "contrast": {
          "value": 1.67
        },
        "orbSize": {
          "value": 0.07
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 4.96
        },
        "center": {
          "value": 1.15
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 10
        },
        "yDot": {
          "value": 0.63
        },
        "dotMul": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca181",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.234
        },
        "orbSize": {
          "value": 2.298
        },
        "radius": {
          "value": 20.95
        },
        "colorShift": {
          "value": 5.41
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.56
        },
        "cosMul": {
          "value": 0.88
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.56
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.65
        },
        "xDivide": {
          "value": 32.82
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca21c",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.01 * sin(uv + stream), 2. * cos(shape * uv + stream)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t * multiplier), 1. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.74
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 784.55
        },
        "ballSize": {
          "value": 1.36
        },
        "contrast": {
          "value": 2.66
        },
        "radius": {
          "value": 43.22
        },
        "yOuter": {
          "value": 0.82
        },
        "xOuter": {
          "value": 0.92
        },
        "rotation": {
          "value": 1215
        },
        "shape": {
          "value": 0.75
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca248",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/25.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*(cos(.0*uv.x*-20.-stream))*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.85
        },
        "ballSize": {
          "value": 646.744
        },
        "contrast": {
          "value": 1.54
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1a1",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 11.1 * tan(t + stream / 11.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 5. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0311
        },
        "ballSize": {
          "value": 0.66
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 1.64
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 81.64
        },
        "y": {
          "value": 128.04
        },
        "rotation": {
          "value": 0.5
        },
        "colorOffset": {
          "value": 0.77
        },
        "sides": {
          "value": 5
        },
        "kaleidoscope": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1ad",
    "shader": "#define BALLS 30\n  \nmat2k_rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius*tan(t * multiplier + stream);\n    float y = radius*sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.11
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 352.09
        },
        "ballSize": {
          "value": 0.05
        },
        "contrast": {
          "value": 2.73
        },
        "radius": {
          "value": 1
        },
        "yOuter": {
          "value": 1.16
        },
        "xOuter": {
          "value": 0.91
        },
        "rotation": {
          "value": 0.07
        },
        "shape": {
          "value": 1.54
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1be",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i * tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t * radius * sin(shape * dist + stream);\n    float y = i / 80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5
        },
        "contrast": {
          "value": 1.1
        },
        "orbSize": {
          "value": 0.03
        },
        "radius": {
          "value": 2.1
        },
        "colorShift": {
          "value": 4.35
        },
        "center": {
          "value": 2.78
        },
        "sides": {
          "value": 1
        },
        "shape": {
          "value": 5.5
        },
        "shape2": {
          "value": 1.42
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c1",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 4.) * .09 * cos(uv.y / yShape + stream / 2.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 166.94
        },
        "yDivider": {
          "value": 885.36
        },
        "xDivider": {
          "value": 74.88
        },
        "multiplier": {
          "value": 3.5795
        },
        "ballSize": {
          "value": 27.44
        },
        "contrast": {
          "value": 1.88
        },
        "radius": {
          "value": 27.16
        },
        "rotation": {
          "value": 2.6
        },
        "yDivide": {
          "value": 520.47
        },
        "xDivide": {
          "value": 0.56
        },
        "yShape": {
          "value": 100
        },
        "shape": {
          "value": 24.95
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca1c7",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / .5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t - stream / 5.); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 161.64
        },
        "yDivider": {
          "value": 945.89
        },
        "xDivider": {
          "value": 19.77
        },
        "multiplier": {
          "value": 1.4242
        },
        "ballSize": {
          "value": 39.93
        },
        "contrast": {
          "value": 2.87
        },
        "radius": {
          "value": 31.79
        },
        "rotation": {
          "value": 89.48
        },
        "yDivide": {
          "value": 81.9
        },
        "xDivide": {
          "value": 0.41
        },
        "yShape": {
          "value": 14.73
        },
        "shape": {
          "value": 71.08
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca219",
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.1 * ((uv)) - stream / 10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 2. - stream / 21.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.); // + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius * tan(t * multiplier), _radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.01
        },
        "yDivider": {
          "value": 232
        },
        "xDivider": {
          "value": 77.31
        },
        "multiplier": {
          "value": 69.13
        },
        "ballSize": {
          "value": 1.56
        },
        "contrast": {
          "value": 3.98
        },
        "radius": {
          "value": 57.1
        },
        "yOuter": {
          "value": 0.73
        },
        "xOuter": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca230",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 25.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider - stream / 52.;\n    vec2 p = vec2(xOuter * (cos(.0 * uv.x * -20. - stream)) * uv.y * 2.1 / uv.x * 3. + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.85
        },
        "ballSize": {
          "value": 646.744
        },
        "contrast": {
          "value": 1.54
        },
        "radius": {
          "value": 115
        },
        "yOuter": {
          "value": 295.45
        },
        "xOuter": {
          "value": 2401
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 74.08
        },
        "yMultiplier": {
          "value": 52.27
        },
        "divider": {
          "value": 3
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca236",
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.72
        },
        "ballSize": {
          "value": 155.087
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 363.58
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 21.98
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 27.87
        },
        "yMultiplier": {
          "value": 33.47
        },
        "divider": {
          "value": 5
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca23b",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05
        },
        "ballSize": {
          "value": 835.689
        },
        "contrast": {
          "value": 2.79
        },
        "radius": {
          "value": 172.51
        },
        "yOuter": {
          "value": 27.3
        },
        "xOuter": {
          "value": 97.47
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 27.87
        },
        "yMultiplier": {
          "value": 79.96
        },
        "divider": {
          "value": 0
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca252",
    "shader": "void main() {\n  vec2 uv = -1.0 + 2.0 * vUv / resolution.xy;\n  \n  uv *= zoom;\n  uv = abs(fract(uv) - .5) * 2.1;\n  uv = abs(fract(uv) - .5) * .1;\n  uv *= 2. * atan(uv.x / 50. + stream / 1.) - .1;\n  vec4 result = vec4(0, 0, 0, 1);\n  float t = 1.8;\n  float base = 1000. * length(uv);\n  for (int p = 0; p < 3; p++) {\n    float a = cos((t * base) - stream / 1.);\n    float b = cos(shape * uv.x / .25 - stream /2.);\n    result[p] = 2.52 * a + 1.7 * b + base / 1000.;\n    t += 2.6;\n  }\n  result.xyz *= brightness * result.x;\n  result.xyz = (result.xyz);\n  result.xy *= abs(tan(uv.x*multiplier));\n  gl_FragColor = 1. + log(abs(result));\n  gl_FragColor.r *= red;\n  gl_FragColor.g *= green;\n  gl_FragColor.b *= blue;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.0039
        },
        "brightness": {
          "value": 58.03
        },
        "red": {
          "value": 0.2
        },
        "green": {
          "value": 0.17
        },
        "blue": {
          "value": 0.81
        },
        "shape": {
          "value": 765.37
        },
        "multiplier": {
          "value": 17.79
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca20c",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. / stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 10.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t + multiplier), radius * sin(t - multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50
        },
        "yDivider": {
          "value": 0.73
        },
        "xDivider": {
          "value": 9.13
        },
        "multiplier": {
          "value": 111
        },
        "ballSize": {
          "value": 0.23
        },
        "contrast": {
          "value": 1.61
        },
        "radius": {
          "value": 38.96
        }
      }
    ]
  },
  {
    "_id": "66dcff64bf713fefd607ef27",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02716
        },
        "shapeMultiplier": {
          "value": 35.24037
        },
        "rotation": {
          "value": 0.1
        },
        "xMultiplier": {
          "value": 605.52337
        },
        "yMultiplier": {
          "value": 396.72118
        },
        "colorSpread": {
          "value": 0.00243
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dcff77bf713fefd607f759",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00692
        },
        "shapeMultiplier": {
          "value": 1043.21
        },
        "rotation": {
          "value": 0.1
        },
        "xMultiplier": {
          "value": 605.52337
        },
        "yMultiplier": {
          "value": 396.72118
        },
        "colorSpread": {
          "value": 0.00243
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dcfd1389eb98559dc7219f",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd0078bd48cb9e42ad74f2",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca262",
    "shader": "  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n//  uv *= k_rotate2d(-stream/10.);\n//  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.39
        },
        "orbSize": {
          "value": 3
        },
        "radius": {
          "value": 20.95
        },
        "colorShift": {
          "value": 5.41
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.56
        },
        "cosMul": {
          "value": 0.88
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.56
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.65
        },
        "xDivide": {
          "value": 32.82
        }
      }
    ]
  },
  {
    "_id": "66dcffb5bf713fefd607f75d",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dcffe4bf713fefd607f75f",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02007
        },
        "shapeMultiplier": {
          "value": 1296.93278
        },
        "rotation": {
          "value": 0.04008
        },
        "xMultiplier": {
          "value": 1500
        },
        "yMultiplier": {
          "value": 1000
        },
        "colorSpread": {
          "value": 0.00165
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd008762b27cec843af06c",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25e",
    "shader": "#define orbs 5.\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  uv *= outer * sin(inner * dot(uv, uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n        y = mix(y1, y2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n        y = mix(y2, y1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n      y = y2;\n    }\n    float dist = length(uv);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_orb(uv, dist * orbSize, position, log(color), contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.58
        },
        "contrast": {
          "value": 0.88
        },
        "orbSize": {
          "value": 0.0011
        },
        "radius": {
          "value": 0.44
        },
        "colorShift": {
          "value": 2.5
        },
        "center": {
          "value": 1.73
        },
        "sides": {
          "value": 7
        },
        "warp": {
          "value": false
        },
        "inner": {
          "value": 5.19
        },
        "outer": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca229",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*sin(uv)+stream/.5))*21.1*tan(uv);\n  uv *=k_rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/1.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/1.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier+stream/5.), 2.*radius*sin(t*multiplier-stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.88
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 1000
        },
        "multiplier": {
          "value": 0.1
        },
        "ballSize": {
          "value": 3.24
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 18.53
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 0
        },
        "rotation": {
          "value": 0.55
        },
        "shape": {
          "value": 10
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25b",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10./dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.47
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 5.46
        },
        "colorShift": {
          "value": 7.8
        },
        "center": {
          "value": 2.76
        },
        "sides": {
          "value": 15
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca260",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.11
        },
        "yDivider": {
          "value": 825.61
        },
        "xDivider": {
          "value": 794.72
        },
        "multiplier": {
          "value": 6.36
        },
        "ballSize": {
          "value": 0.46
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.94
        },
        "xOuter": {
          "value": 0.16
        },
        "yOuter": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66dcff99bf713fefd607f75b",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd02ef227f7b820e8aa374",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00346
        },
        "shapeMultiplier": {
          "value": 119.04997
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 1022.62345
        },
        "yMultiplier": {
          "value": 885.86978
        },
        "colorSpread": {
          "value": 0.00103
        },
        "colorMultiplier": {
          "value": 0.78876
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca259",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1. / length(uv) * 20. * uv) - stream / 3.)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv + stream), cos(uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 1.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.); // + stream/5000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.36
        },
        "yDivider": {
          "value": 27.34
        },
        "xDivider": {
          "value": 10.17
        },
        "multiplier": {
          "value": 287.12
        },
        "ballSize": {
          "value": 1.13
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 11
        },
        "yOuter": {
          "value": 0.3
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dd0307227f7b820e8aabb2",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00271
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 1022.62345
        },
        "yMultiplier": {
          "value": 1
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.78876
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca257",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.3*(uv + sin(5.*uv))-stream/10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/2. - stream/21.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius*tan(t*multiplier), _radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.84
        },
        "yDivider": {
          "value": 232
        },
        "xDivider": {
          "value": 77.31
        },
        "multiplier": {
          "value": 69.13
        },
        "ballSize": {
          "value": 2.31
        },
        "contrast": {
          "value": 1.79
        },
        "radius": {
          "value": 57.1
        },
        "yOuter": {
          "value": 0.73
        },
        "xOuter": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25a",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/19.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(k_kale(uv, vec2(center), sides)-stream);\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.21
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 6.4
        },
        "colorShift": {
          "value": 5.57
        },
        "center": {
          "value": 2.71
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        },
        "kkk": {
          "value": false
        },
        "base": {
          "value": 7.16
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25d",
    "shader": "\n#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10./dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 2.47
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.51
        },
        "radius": {
          "value": 5.46
        },
        "colorShift": {
          "value": 7.8
        },
        "center": {
          "value": 2.76
        },
        "sides": {
          "value": 15
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66dd01e9227f7b820e8a7224",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02603
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.01861
        },
        "xMultiplier": {
          "value": 613.11725
        },
        "yMultiplier": {
          "value": 238.0321
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.68553
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.00144
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66dd03e3227f7b820e8ad4f6",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00271
        },
        "shapeMultiplier": {
          "value": 11198.13317
        },
        "rotation": {
          "value": 0.0093
        },
        "xMultiplier": {
          "value": 1076.67056
        },
        "yMultiplier": {
          "value": 166.57476
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.09682
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 1.25843
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 9.85346
        },
        "col": {
          "value": 0.1838
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25c",
    "shader": "\n#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/19.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(k_kale(uv, vec2(center), sides)-stream);\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 4.33
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 6.4
        },
        "colorShift": {
          "value": 5.57
        },
        "center": {
          "value": 2.71
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        },
        "kkk": {
          "value": false
        },
        "base": {
          "value": 7.16
        }
      }
    ]
  },
  {
    "_id": "66dd0261227f7b820e8a8290",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0048
        },
        "shapeMultiplier": {
          "value": 16.45342
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 163.59483
        },
        "yMultiplier": {
          "value": 885.86978
        },
        "colorSpread": {
          "value": 0.00103
        },
        "colorMultiplier": {
          "value": 0.78876
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66dd0384227f7b820e8ac472",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00271
        },
        "shapeMultiplier": {
          "value": 11198.13317
        },
        "rotation": {
          "value": 0.0093
        },
        "xMultiplier": {
          "value": 1076.67056
        },
        "yMultiplier": {
          "value": 166.57476
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.09682
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 1.25843
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 9.85346
        },
        "col": {
          "value": 1.45043
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca256",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation+stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.18
        },
        "yDivider": {
          "value": 1000
        },
        "xDivider": {
          "value": 915.81
        },
        "multiplier": {
          "value": 90.94
        },
        "ballSize": {
          "value": 0.73
        },
        "contrast": {
          "value": 1.62
        },
        "radius": {
          "value": 14.78
        },
        "yOuter": {
          "value": 0.31
        },
        "xOuter": {
          "value": 0.33
        },
        "rotation": {
          "value": 3.83
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca258",
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.36
        },
        "yDivider": {
          "value": 27.34
        },
        "xDivider": {
          "value": 10.17
        },
        "multiplier": {
          "value": 287.12
        },
        "ballSize": {
          "value": 1.13
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 11
        },
        "yOuter": {
          "value": 0.3
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dcfe9849312c93e1e4e112",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dcff2cbf713fefd607e6f7",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd02a6227f7b820e8a9300",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00853
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 1022.62345
        },
        "yMultiplier": {
          "value": 885.86978
        },
        "colorSpread": {
          "value": 0.00103
        },
        "colorMultiplier": {
          "value": 0.78876
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66dd0444227f7b820e8af1e1",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 2.653
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca25f",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  gl_FragColor = vec4(1);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -=k_orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      {
        "zoom": {
          "value": 77.16
        },
        "contrast": {
          "value": 2.16
        },
        "orbSize": {
          "value": 3.57
        },
        "radius": {
          "value": 43.35
        },
        "colorShift": {
          "value": 4.81
        },
        "x1": {
          "value": 2.03
        },
        "x2": {
          "value": 0.25
        },
        "y1": {
          "value": 1
        },
        "y2": {
          "value": 0.33
        },
        "center": {
          "value": 43.26
        },
        "sides": {
          "value": 7
        },
        "col": {
          "value": [0.8, 0.2, 0.6]
        }
      }
    ]
  },
  {
    "_id": "66dd0033bf713fefd607ff90",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd0100227f7b820e8a5156",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00675
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66d11670577f4e8cedfca261",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.03
        },
        "yDivider": {
          "value": 825.61
        },
        "xDivider": {
          "value": 794.72
        },
        "multiplier": {
          "value": 6.36
        },
        "ballSize": {
          "value": 0.37
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 2.4
        },
        "xOuter": {
          "value": 0.16
        },
        "yOuter": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66dd00f74e7cc2277772bfd9",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02969
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd013d227f7b820e8a598a",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.02539
        },
        "shapeMultiplier": {
          "value": 357.50588
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 163.59483
        },
        "yMultiplier": {
          "value": 885.86978
        },
        "colorSpread": {
          "value": 0.00103
        },
        "colorMultiplier": {
          "value": 0.78876
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 35.43942
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 19.60172
        },
        "col": {
          "value": 0.12518
        }
      }
    ]
  },
  {
    "_id": "66dd0329227f7b820e8ab3f2",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00271
        },
        "shapeMultiplier": {
          "value": 11198.13317
        },
        "rotation": {
          "value": 0.0093
        },
        "xMultiplier": {
          "value": 1076.67056
        },
        "yMultiplier": {
          "value": 166.57476
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.09682
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.75866
        },
        "ballSize": {
          "value": 1.25843
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.61461
        },
        "radius": {
          "value": 9.85346
        },
        "col": {
          "value": 0.71116
        }
      }
    ]
  },
  {
    "_id": "66dcff72bf713fefd607f757",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00692
        },
        "shapeMultiplier": {
          "value": 1043.21
        },
        "rotation": {
          "value": 0.1
        },
        "xMultiplier": {
          "value": 605.52337
        },
        "yMultiplier": {
          "value": 396.72118
        },
        "colorSpread": {
          "value": 0.00243
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.22730139307228922
        }
      }
    ]
  },
  {
    "_id": "66dd048c227f7b820e8b0ed3",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01296
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66dfce23d8fb699c09593de1",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.1 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 3. * PI);\n    float t = i / PI / orbs * 2.;\n    float a = (base / dist) / t * radius;\n    float b = dist - t + uv.y / yDiv;\n    float c = cos(uv.y / 1.215 - stream / .5);\n    float d = cos(uv.x / 22.5 * dist / 1.125 - stream);\n    float x = a / sin(stream / - 11.5 + b) + c - d;\n    float y = 10. - x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.07337
        },
        "contrast": {
          "value": 1.58057
        },
        "orbSize": {
          "value": 1.65542
        },
        "radius": {
          "value": 0.04126
        },
        "colorShift": {
          "value": 10.65137
        },
        "base": {
          "value": 195.45747
        },
        "yDiv": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dd12ff227f7b820e8b6e89",
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -5.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / .5);\n    float b = radius * sin(uv.y + stream / -1.);\n    float c = radius * wave * sin(split * uv.x - stream /11.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.42716
        },
        "iterator": {
          "value": 1.88938
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 1.24012
        },
        "orbSize": {
          "value": 0.37995
        },
        "div": {
          "value": 7.54191
        },
        "radius": {
          "value": 5.73635
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      }
    ]
  },
  {
    "_id": "66dfab77d8fb699c0958dd13",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.99628
        },
        "contrast": {
          "value": 2.45377
        },
        "orbSize": {
          "value": 1.83289
        },
        "radius": {
          "value": 23.19695
        },
        "colorShift": {
          "value": 10.73398
        },
        "base": {
          "value": 1.07505
        },
        "yDiv": {
          "value": 1.00273
        }
      },
      {
        "zoom": {
          "value": 22.13005
        },
        "contrast": {
          "value": 2.59269
        },
        "orbSize": {
          "value": 1.33992
        },
        "radius": {
          "value": 0.67056
        },
        "colorShift": {
          "value": 11.14
        },
        "base": {
          "value": 26.14888
        },
        "yDiv": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dfdf39d8fb699c09594667",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.99162
        },
        "contrast": {
          "value": 1.90539
        },
        "orbSize": {
          "value": 2.46341
        },
        "radius": {
          "value": 0.39591
        },
        "colorShift": {
          "value": 7.70505
        },
        "base": {
          "value": 12.81943
        },
        "yDiv": {
          "value": 0.99897
        }
      }
    ]
  },
  {
    "_id": "66dd049e227f7b820e8b0ed7",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00285
        },
        "shapeMultiplier": {
          "value": 2000
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 1500
        },
        "yMultiplier": {
          "value": 973.9949
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 8.116722760819773
        },
        "col": {
          "value": 0.25801
        }
      }
    ]
  },
  {
    "_id": "66dd0b28227f7b820e8b40bd",
    "shader": "\n\nvoid main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.00405
        },
        "iterator": {
          "value": 4.01438
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.98477
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.07321
        },
        "colorOffset": {
          "value": 3.28169
        },
        "contrast": {
          "value": 1.5999623493975905
        },
        "orbSize": {
          "value": 0.54407
        },
        "div": {
          "value": 0.02688
        },
        "radius": {
          "value": 2.54727
        }
      }
    ]
  },
  {
    "_id": "66df8ccfd8fb699c0958bfaa",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/4.);\n  uv /= dot(uv, uv); \n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.+dist-t + uv.x/1.5)-(cos(uv.x/11.1*dist-stream/2.)*sin(uv.y*dist/11.-stream));\n    float y = 1.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.18736
        },
        "contrast": {
          "value": 2.48958
        },
        "orbSize": {
          "value": 4.29365
        },
        "radius": {
          "value": 2.95825
        },
        "colorShift": {
          "value": 4.36198
        },
        "base": {
          "value": 44.43269
        }
      }
    ]
  },
  {
    "_id": "66dfd65ad8fb699c09594663",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.2 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 1.2 * PI);\n    float t = i / PI / orbs * .5;\n    float a = radius * (base / dist/2.) / t;\n    float b = dist * fatness + t + uv.y/.5 / yDiv;\n    float c = cos(uv.y * yDiv2 - stream / .5);\n    float d = (c - a / b) - (a * b) - c;\n    float x = b / sin(stream - b) - d;\n    float y = offset - x;\n    vec2 position = vec2(x, y);\n    vec3 base = vec3(-2, 0, -1);\n    vec3 shift = cos(base * PI * 2. / 3. + PI * float(i) / colorShift);\n    vec3 color = shift * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 31.98232
        },
        "contrast": {
          "value": 2.22911
        },
        "orbSize": {
          "value": 11.05142
        },
        "radius": {
          "value": 0.10555
        },
        "colorShift": {
          "value": 10.0169
        },
        "base": {
          "value": 255.09985
        },
        "yDiv": {
          "value": 25
        },
        "yDiv2": {
          "value": 5.3423
        },
        "yDiv3": {
          "value": 31.33395
        },
        "offset": {
          "value": 16.65481
        },
        "fatness": {
          "value": 0.35498
        }
      }
    ]
  },
  {
    "_id": "66dfbd71d8fb699c09592053",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-.5 - uv.y/dist*uv.y/yDiv)-(cos(uv.x/20.15+dist-stream/2.5)*cos(uv.x/zoom*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.1146
        },
        "contrast": {
          "value": 1.88453
        },
        "orbSize": {
          "value": 1.64892
        },
        "radius": {
          "value": 0.23628
        },
        "colorShift": {
          "value": 9.99002
        },
        "base": {
          "value": 83.54579
        },
        "yDiv": {
          "value": 0.55807
        }
      }
    ]
  },
  {
    "_id": "66dd1656227f7b820e8b72bf",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}  ",
    "variants": [
      {
        "zoom": {
          "value": 3.53768
        },
        "yDivider": {
          "value": 67.32
        },
        "xDivider": {
          "value": 0.48
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.101
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 9.38
        },
        "xOuter": {
          "value": 2.47
        },
        "yOuter": {
          "value": 0.21
        },
        "xDiv": {
          "value": 26.512
        },
        "xDiv2": {
          "value": 0.321
        },
        "warp": {
          "value": 321
        }
      }
    ]
  },
  {
    "_id": "66dfcb47d8fb699c09593569",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/10.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.07471
        },
        "contrast": {
          "value": 2.45323
        },
        "orbSize": {
          "value": 2.20514
        },
        "radius": {
          "value": 0.02982
        },
        "colorShift": {
          "value": 6.28168
        },
        "base": {
          "value": 149.73706
        },
        "yDiv": {
          "value": 0.71914
        }
      }
    ]
  },
  {
    "_id": "66dd058e227f7b820e8b1f7b",
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.05976
        },
        "iterator": {
          "value": 3.15546
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.27344
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.24399
        },
        "colorOffset": {
          "value": 3.29047
        },
        "contrast": {
          "value": 1.85237
        },
        "orbSize": {
          "value": 0.21935
        },
        "div": {
          "value": 0.08058
        },
        "radius": {
          "value": 1.75561
        }
      }
    ]
  },
  {
    "_id": "66df8568d8fb699c095891ac",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-60.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,1.1) * orbSize, vec2(radius*abs(tan(stream/11.3+uv.x/div)) * L *\n                                                              sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)), \n                          col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.19552
        },
        "iterator": {
          "value": 1.07394
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 2.139
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 19.56624
        },
        "L": {
          "value": 1.457
        },
        "M": {
          "value": 0.358
        },
        "colorShift": {
          "value": 0.572
        },
        "colorOffset": {
          "value": 23.207
        },
        "contrast": {
          "value": 1.392
        },
        "orbSize": {
          "value": 0.60462
        },
        "div": {
          "value": 0.04509
        },
        "radius": {
          "value": 12
        }
      }
    ]
  },
  {
    "_id": "66e0a560e2bae2208f72bc32",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.14333
        },
        "contrast": {
          "value": 2.38222
        },
        "orbSize": {
          "value": 3.82232
        },
        "radius": {
          "value": 0.64054
        },
        "colorShift": {
          "value": 0.72369
        },
        "base": {
          "value": 6.34386
        },
        "yDiv": {
          "value": 0.79904
        }
      }
    ]
  },
  {
    "_id": "66dd164c227f7b820e8b72bb",
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.38671
        },
        "yDivider": {
          "value": 67.32
        },
        "xDivider": {
          "value": 0.48
        },
        "multiplier": {
          "value": 0.57
        },
        "ballSize": {
          "value": 0.101
        },
        "contrast": {
          "value": 0.7
        },
        "radius": {
          "value": 9.38
        },
        "xOuter": {
          "value": 2.47
        },
        "yOuter": {
          "value": 0.21
        },
        "xDiv": {
          "value": 26.512
        },
        "xDiv2": {
          "value": 0.321
        },
        "warp": {
          "value": 321
        }
      }
    ]
  },
  {
    "_id": "66df9fa4d8fb699c0958bfb4",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 22.13005
        },
        "contrast": {
          "value": 1.98004
        },
        "orbSize": {
          "value": 2.38453
        },
        "radius": {
          "value": 1.139
        },
        "colorShift": {
          "value": 7.39311
        },
        "base": {
          "value": 23.31462
        },
        "yDiv": {
          "value": 0.97397
        }
      }
    ]
  },
  {
    "_id": "66dfd23dd8fb699c09593de7",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.1 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 3. * PI);\n    float t = i / PI / orbs * 2.;\n    float a = (base / dist) / t * radius;\n    float b = dist - t + uv.y / yDiv;\n    float c = cos(uv.y / yDiv2 - stream / .5);\n    float d = cos(uv.x / yDiv3 * dist / 1.125 - stream);\n    float x = a / sin(stream / - .5 + b) + c - d;\n    float y = offset - x;\n    vec2 position = vec2(x, y);\n    vec3 base = vec3(-2, 0, -1);\n    vec3 shift = cos(base * PI * 2. / 3. + PI * float(i) / colorShift);\n    vec3 color = shift * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.29254
        },
        "contrast": {
          "value": 1.84949
        },
        "orbSize": {
          "value": 2.60649
        },
        "radius": {
          "value": 0.03695
        },
        "colorShift": {
          "value": 9.61595
        },
        "base": {
          "value": 298.50033
        },
        "yDiv": {
          "value": 4.13837
        },
        "yDiv2": {
          "value": 3.82661
        },
        "yDiv3": {
          "value": 59.96575
        },
        "offset": {
          "value": 10.99357
        }
      }
    ]
  },
  {
    "_id": "66dd052c227f7b820e8b1725",
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0004
        },
        "iterator": {
          "value": 4.99078
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.27344
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.24399
        },
        "colorOffset": {
          "value": 3.29047
        },
        "contrast": {
          "value": 1.85237
        },
        "orbSize": {
          "value": 0.3119
        },
        "div": {
          "value": 0.01
        },
        "radius": {
          "value": 1.83748
        }
      }
    ]
  },
  {
    "_id": "66dd125b227f7b820e8b6e83",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.00619
        },
        "iterator": {
          "value": 0.99762
        },
        "iterations": {
          "value": 12.294084149096387
        },
        "colorShift": {
          "value": 111
        },
        "colorOffset": {
          "value": 18.446018448795183
        },
        "contrast": {
          "value": 1.16299
        },
        "orbSize": {
          "value": 171.06751223644582
        },
        "div": {
          "value": 77.40551
        },
        "radius": {
          "value": 73.36788403614459
        },
        "wave": {
          "value": 1333
        },
        "split": {
          "value": 4.41711
        }
      }
    ]
  },
  {
    "_id": "66dd0557227f7b820e8b172d",
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.0649
        },
        "iterator": {
          "value": 1.90885
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.27344
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.24399
        },
        "colorOffset": {
          "value": 3.29047
        },
        "contrast": {
          "value": 1.85237
        },
        "orbSize": {
          "value": 0.59197
        },
        "div": {
          "value": 0.01
        },
        "radius": {
          "value": 1.40083
        }
      }
    ]
  },
  {
    "_id": "66df9f38d8fb699c0958bfb0",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/1.)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 23.71705
        },
        "contrast": {
          "value": 2.36005
        },
        "orbSize": {
          "value": 2.78708
        },
        "radius": {
          "value": 0.89578
        },
        "colorShift": {
          "value": 7.39311
        },
        "base": {
          "value": 30.09417
        }
      }
    ]
  },
  {
    "_id": "66dfe570d8fb699c09597955",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-12.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.+dist+t +uv.x/yDiv)-(cos(uv.x/.215+dist/2.-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 32.21172
        },
        "contrast": {
          "value": 1.62484
        },
        "orbSize": {
          "value": 2.69787
        },
        "radius": {
          "value": 0.21512
        },
        "colorShift": {
          "value": 10.07638
        },
        "base": {
          "value": 114.66802
        },
        "yDiv": {
          "value": 0.91146
        }
      }
    ]
  },
  {
    "_id": "66dd052f227f7b820e8b1729",
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.010728
        },
        "iterator": {
          "value": 4.99078
        },
        "ot": {
          "value": 38.302
        },
        "I": {
          "value": 3
        },
        "J": {
          "value": 0.994
        },
        "K": {
          "value": 0.9497646837349399
        },
        "iterations": {
          "value": 0.27344
        },
        "L": {
          "value": 2
        },
        "M": {
          "value": 0.209
        },
        "colorShift": {
          "value": 0.24399
        },
        "colorOffset": {
          "value": 3.29047
        },
        "contrast": {
          "value": 1.85237
        },
        "orbSize": {
          "value": 0.3119
        },
        "div": {
          "value": 0.01
        },
        "radius": {
          "value": 1.83748
        }
      }
    ]
  },
  {
    "_id": "66dfbc1ed8fb699c095917e1",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.83412
        },
        "contrast": {
          "value": 2.91649
        },
        "orbSize": {
          "value": 2.25636
        },
        "radius": {
          "value": 0.55085
        },
        "colorShift": {
          "value": 7.53763
        },
        "base": {
          "value": 6.41897
        },
        "yDiv": {
          "value": 0.83058
        }
      },
      {
        "zoom": {
          "value": 22.13005
        },
        "contrast": {
          "value": 2.59269
        },
        "orbSize": {
          "value": 1.33992
        },
        "radius": {
          "value": 0.67056
        },
        "colorShift": {
          "value": 11.14
        },
        "base": {
          "value": 26.14888
        },
        "yDiv": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dfbd11d8fb699c095917e5",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-.5 - uv.y/dist*uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 23.75759
        },
        "contrast": {
          "value": 1.98593
        },
        "orbSize": {
          "value": 2.08202
        },
        "radius": {
          "value": 0.79469
        },
        "colorShift": {
          "value": 9.99002
        },
        "base": {
          "value": 19.23353
        },
        "yDiv": {
          "value": 0.82445
        }
      },
      {
        "zoom": {
          "value": 22.13005
        },
        "contrast": {
          "value": 2.59269
        },
        "orbSize": {
          "value": 1.33992
        },
        "radius": {
          "value": 0.67056
        },
        "colorShift": {
          "value": 11.14
        },
        "base": {
          "value": 26.14888
        },
        "yDiv": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dfcb43d8fb699c09593565",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  // uv *= k_rotate2d(stream/-2.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.07471
        },
        "contrast": {
          "value": 2.45323
        },
        "orbSize": {
          "value": 2.20514
        },
        "radius": {
          "value": 0.02982
        },
        "colorShift": {
          "value": 6.28168
        },
        "base": {
          "value": 149.73706
        },
        "yDiv": {
          "value": 0.71914
        }
      },
      {
        "zoom": {
          "value": 22.13005
        },
        "contrast": {
          "value": 2.59269
        },
        "orbSize": {
          "value": 1.33992
        },
        "radius": {
          "value": 0.67056
        },
        "colorShift": {
          "value": 11.14
        },
        "base": {
          "value": 26.14888
        },
        "yDiv": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66dfcbf2d8fb699c09593ddd",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  // uv *= k_rotate2d(stream/-2.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.282)) * abs(fract(1.00112901*(abs(.2*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.43789
        },
        "contrast": {
          "value": 2.0819
        },
        "orbSize": {
          "value": 2.66444
        },
        "radius": {
          "value": 0.01444
        },
        "colorShift": {
          "value": 8.34327
        },
        "base": {
          "value": 223.62236
        },
        "yDiv": {
          "value": 1.16459
        }
      }
    ]
  },
  {
    "_id": "66dd1391227f7b820e8b72b7",
    "shader": "\n\n#define BALLS 5\n\n\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 1.33675
        },
        "xMultiplier": {
          "value": 117.55271
        },
        "yMultiplier": {
          "value": 98.5
        },
        "ballSize": {
          "value": 1.25
        },
        "colorSpread": {
          "value": 3.47754
        },
        "colorMultiplier": {
          "value": 42.32055
        },
        "shapeMultiplier": {
          "value": 26.92
        },
        "glow": {
          "value": 730.07686
        },
        "contrast": {
          "value": 3.17
        },
        "rotation": {
          "value": 7.7042
        },
        "brightness": {
          "value": 0.96284
        },
        "sides": {
          "value": 12
        },
        "warp": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "invert": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66dfaa95d8fb699c0958dd0f",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 23.85746
        },
        "contrast": {
          "value": 1.98004
        },
        "orbSize": {
          "value": 2.38453
        },
        "radius": {
          "value": 1.139
        },
        "colorShift": {
          "value": 7.39311
        },
        "base": {
          "value": 23.31462
        },
        "yDiv": {
          "value": 0.97397
        }
      }
    ]
  },
  {
    "_id": "66dfe00bd8fb699c09594ee5",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 17.34629
        },
        "contrast": {
          "value": 2.38222
        },
        "orbSize": {
          "value": 1.95408
        },
        "radius": {
          "value": 0.1056
        },
        "colorShift": {
          "value": 9.79726
        },
        "base": {
          "value": 11.12041
        },
        "yDiv": {
          "value": 0.79904
        }
      }
    ]
  },
  {
    "_id": "66e0a541e2bae2208f72b3b2",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 48.26468
        },
        "contrast": {
          "value": 2.79106
        },
        "orbSize": {
          "value": 4.66013
        },
        "radius": {
          "value": 0.43578
        },
        "colorShift": {
          "value": 9.79726
        },
        "base": {
          "value": 149.46048
        },
        "yDiv": {
          "value": 0.79904
        }
      }
    ]
  },
  {
    "_id": "66e0ef2a0a18140c4826f7c2",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * vUv / resolution.xy).y + uv.x);\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.02347
        },
        "A": {
          "value": 0.10871
        },
        "B": {
          "value": 0.1038
        },
        "C": {
          "value": 0.24285
        },
        "D": {
          "value": 0.34975
        },
        "E": {
          "value": 0.38016
        },
        "F": {
          "value": 0.56808
        },
        "G": {
          "value": 0.17096
        },
        "H": {
          "value": 0.3471
        },
        "I": {
          "value": 4.712730014375358
        },
        "J": {
          "value": 1.74224
        },
        "col": {
          "value": [0, 1, 0.8823529411764706]
        }
      }
    ]
  },
  {
    "_id": "66e0ef4cd20ebe14f1041a14",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * vUv / resolution.xy).y + uv.x);\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.02347
        },
        "A": {
          "value": 0.10871
        },
        "B": {
          "value": 0.1038
        },
        "C": {
          "value": 0.24285
        },
        "D": {
          "value": 0.34975
        },
        "E": {
          "value": 0.38016
        },
        "F": {
          "value": 0.56808
        },
        "G": {
          "value": 0.17096
        },
        "H": {
          "value": 0.3471
        },
        "I": {
          "value": 4.712730014375358
        },
        "J": {
          "value": 1.74224
        },
        "col": {
          "value": [0, 1, 0.8823529411764706]
        }
      }
    ]
  },
  {
    "_id": "66e0ef66e4f663ca90417674",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * vUv / resolution.xy).y + uv.x);\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.02347
        },
        "A": {
          "value": 0.10871
        },
        "B": {
          "value": 0.1038
        },
        "C": {
          "value": 0.24285
        },
        "D": {
          "value": 0.34975
        },
        "E": {
          "value": 0.38016
        },
        "F": {
          "value": 0.56808
        },
        "G": {
          "value": 0.17096
        },
        "H": {
          "value": 0.3471
        },
        "I": {
          "value": 4.712730014375358
        },
        "J": {
          "value": 1.74224
        },
        "col": {
          "value": [0, 1, 0.8823529411764706]
        }
      }
    ]
  },
  {
    "_id": "66e0ef836d68c45da02089bb",
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = k_uv();\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * vUv / resolution.xy).y + uv.x);\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.02347
        },
        "A": {
          "value": 0.10871
        },
        "B": {
          "value": 0.1038
        },
        "C": {
          "value": 0.24285
        },
        "D": {
          "value": 0.34975
        },
        "E": {
          "value": 0.38016
        },
        "F": {
          "value": 0.56808
        },
        "G": {
          "value": 0.17096
        },
        "H": {
          "value": 0.3471
        },
        "I": {
          "value": 4.712730014375358
        },
        "J": {
          "value": 1.74224
        },
        "col": {
          "value": [0, 1, 0.8823529411764706]
        }
      }
    ]
  },
  {
    "_id": "66e0fcd40b9954748f6ad665",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/10.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.5125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 16.07471
        },
        "contrast": {
          "value": 1.79259
        },
        "orbSize": {
          "value": 5.52968
        },
        "radius": {
          "value": 0.06771
        },
        "colorShift": {
          "value": 2.88353
        },
        "base": {
          "value": 149.73706
        },
        "yDiv": {
          "value": 0.71914
        }
      }
    ]
  },
  {
    "_id": "66e0ffd30b9954748f6ad668",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-8.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.5*PI);\n    float t = i / PI / orbs * 3.;\n    float x = (base/dist)/t*radius * sin(stream/-1.+dist+t +uv.y/1.)*(cos(uv.y/1.-stream/1.5)-cos(uv.x/.5*dist/2.125-stream));\n    float y = 12.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .25) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.55236
        },
        "contrast": {
          "value": 3.54193
        },
        "orbSize": {
          "value": 4.81571
        },
        "radius": {
          "value": 0.44976
        },
        "colorShift": {
          "value": 1.42293
        },
        "base": {
          "value": 31.42344
        }
      }
    ]
  },
  {
    "_id": "66e1020f0b9954748f6ad66b",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-8.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/1.5*PI);\n    float t = i / PI / orbs * 3.;\n    float x = (base/dist)/t*radius * sin(stream/-.5+dist/11.2+t +uv.y)*(cos(uv.x/.5-dist/.2-stream/1.5)-cos(uv.x/1.5*dist/-1.25-stream));\n    float y = 1.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.5128
        },
        "contrast": {
          "value": 1.34118
        },
        "orbSize": {
          "value": 0.3264
        },
        "radius": {
          "value": 1.83638
        },
        "colorShift": {
          "value": 1.56524
        },
        "base": {
          "value": 3.62785
        }
      }
    ]
  },
  {
    "_id": "66e1091fd850b2ae7ea7db42",
    "shader": "void main () {\n  float stream =stream * 1.6;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66e128a40b9954748f6ad686",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/8.*sin(-uv.y/-.29 - t)-(length(uv/.2))/t*radius * sin(stream/-.9+dist/1.5+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/1.125));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 3.86675
        },
        "orbSize": {
          "value": 3.84757
        },
        "radius": {
          "value": 0.01948
        },
        "colorShift": {
          "value": 4.8625
        },
        "base": {
          "value": 1.25086
        },
        "rad": {
          "value": 0.60245
        }
      }
    ]
  },
  {
    "_id": "66e129660b9954748f6ad689",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 3.86675
        },
        "orbSize": {
          "value": 3.84757
        },
        "radius": {
          "value": 0.01948
        },
        "colorShift": {
          "value": 4.8625
        },
        "base": {
          "value": 1.25086
        },
        "rad": {
          "value": 0.60245
        },
        "yDiv": {
          "value": 2
        },
        "uvDiv": {
          "value": 0.07987
        },
        "dDiv": {
          "value": 1.73928
        },
        "dDiv2": {
          "value": 2.33453
        },
        "dDiv3": {
          "value": 0.03192
        }
      },
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 2.9722
        },
        "orbSize": {
          "value": 3.89975
        },
        "radius": {
          "value": 0.0016
        },
        "colorShift": {
          "value": 1.14953
        },
        "base": {
          "value": 0.60715
        },
        "rad": {
          "value": 0.66992
        },
        "yDiv": {
          "value": 2
        },
        "uvDiv": {
          "value": 0.07987
        },
        "dDiv": {
          "value": 1.73928
        },
        "dDiv2": {
          "value": 2.33453
        },
        "dDiv3": {
          "value": 0.03192
        }
      }
    ]
  },
  {
    "_id": "66e12ba90b9954748f6ad68c",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 2.95647
        },
        "contrast": {
          "value": 1.99725
        },
        "orbSize": {
          "value": 2.09813
        },
        "radius": {
          "value": 0.0719
        },
        "colorShift": {
          "value": 1.18016
        },
        "base": {
          "value": 0.35383
        },
        "rad": {
          "value": 0.1215
        },
        "yDiv": {
          "value": 0.01062
        },
        "uvDiv": {
          "value": 0.04953
        },
        "dDiv": {
          "value": 0.32136
        },
        "dDiv2": {
          "value": 1.03526
        },
        "dDiv3": {
          "value": 0.10821
        }
      },
      {
        "zoom": {
          "value": 7.30516
        },
        "contrast": {
          "value": 2.59893
        },
        "orbSize": {
          "value": 2.30734
        },
        "radius": {
          "value": 0.19831
        },
        "colorShift": {
          "value": 2.85401
        },
        "base": {
          "value": 0.27172
        },
        "rad": {
          "value": 0.10469
        },
        "yDiv": {
          "value": 0.02143
        },
        "uvDiv": {
          "value": 0.89904
        },
        "dDiv": {
          "value": 0.90367
        },
        "dDiv2": {
          "value": 0.47482
        },
        "dDiv3": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 2.9722
        },
        "orbSize": {
          "value": 3.89975
        },
        "radius": {
          "value": 0.0016
        },
        "colorShift": {
          "value": 2.72359
        },
        "base": {
          "value": 0.60715
        },
        "rad": {
          "value": 0.66992
        },
        "yDiv": {
          "value": 2
        },
        "uvDiv": {
          "value": 0.07987
        },
        "dDiv": {
          "value": 1.73928
        },
        "dDiv2": {
          "value": 2.33453
        },
        "dDiv3": {
          "value": 0.03192
        }
      }
    ]
  },
  {
    "_id": "66e12c8a0b9954748f6ad68f",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 7.30516
        },
        "contrast": {
          "value": 2.59893
        },
        "orbSize": {
          "value": 2.30734
        },
        "radius": {
          "value": 0.19831
        },
        "colorShift": {
          "value": 2.85401
        },
        "base": {
          "value": 0.27172
        },
        "rad": {
          "value": 0.10469
        },
        "yDiv": {
          "value": 0.02143
        },
        "uvDiv": {
          "value": 0.89904
        },
        "dDiv": {
          "value": 0.90367
        },
        "dDiv2": {
          "value": 0.47482
        },
        "dDiv3": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 2.9722
        },
        "orbSize": {
          "value": 3.89975
        },
        "radius": {
          "value": 0.0016
        },
        "colorShift": {
          "value": 2.72359
        },
        "base": {
          "value": 0.60715
        },
        "rad": {
          "value": 0.66992
        },
        "yDiv": {
          "value": 2
        },
        "uvDiv": {
          "value": 0.07987
        },
        "dDiv": {
          "value": 1.73928
        },
        "dDiv2": {
          "value": 2.33453
        },
        "dDiv3": {
          "value": 0.03192
        }
      },
      {
        "zoom": {
          "value": 6.08598
        },
        "contrast": {
          "value": 2.66725
        },
        "orbSize": {
          "value": 2.79358
        },
        "radius": {
          "value": 0.18184
        },
        "colorShift": {
          "value": 2.72425
        },
        "base": {
          "value": 1.40101
        },
        "rad": {
          "value": 0.27049
        },
        "yDiv": {
          "value": 0.1632
        },
        "uvDiv": {
          "value": 0.13463
        },
        "dDiv": {
          "value": 8.06158
        },
        "dDiv2": {
          "value": 1.25279
        },
        "dDiv3": {
          "value": 1.12041
        }
      },
      {
        "zoom": {
          "value": 21.32517
        },
        "contrast": {
          "value": 2.34362
        },
        "orbSize": {
          "value": 3.14346
        },
        "radius": {
          "value": 0.01887
        },
        "colorShift": {
          "value": 4.69639
        },
        "base": {
          "value": 0.96003
        },
        "rad": {
          "value": 1.14201
        },
        "yDiv": {
          "value": 0.59891
        },
        "uvDiv": {
          "value": 0.13794
        },
        "dDiv": {
          "value": 1.15985
        },
        "dDiv2": {
          "value": 4.23992
        },
        "dDiv3": {
          "value": 0.63733
        }
      }
    ]
  },
  {
    "_id": "66e2184d2db3aaaad31a3fe8",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/8.*sin(-uv.y/-.29 - t)-(length(uv/.2))/t*radius * sin(stream/-.9+dist/1.5+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/1.125));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 13.54836
        },
        "contrast": {
          "value": 3.86675
        },
        "orbSize": {
          "value": 3.84757
        },
        "radius": {
          "value": 0.01948
        },
        "colorShift": {
          "value": 4.8625
        },
        "base": {
          "value": 1.25086
        },
        "rad": {
          "value": 0.60245
        }
      }
    ]
  },
  {
    "_id": "66e21b342db3aaaad31a3fed",
    "shader": "void main () {\n  float stream =stream * 1.8;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 8.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66e24a368f9935c9566330c4",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (float i = 1.; i < 10.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 18.717
        },
        "iterator": {
          "value": 0.843
        },
        "iterations": {
          "value": 91.395
        },
        "colorShift": {
          "value": 8.102
        },
        "colorOffset": {
          "value": 189.512
        },
        "contrast": {
          "value": 1.221
        },
        "orbSize": {
          "value": 1049.592
        },
        "div": {
          "value": 1.698
        },
        "radius": {
          "value": 185.206
        },
        "wave": {
          "value": 3073.92
        },
        "split": {
          "value": 52.499
        }
      }
    ]
  },
  {
    "_id": "66e24abc8f9935c9566330c7",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.255
        },
        "iterator": {
          "value": 0.673
        },
        "iterations": {
          "value": 109.617
        },
        "colorShift": {
          "value": 17.822
        },
        "colorOffset": {
          "value": 189.512
        },
        "contrast": {
          "value": 1.221
        },
        "orbSize": {
          "value": 1907.207
        },
        "div": {
          "value": 8.839
        },
        "radius": {
          "value": 196.658
        },
        "wave": {
          "value": 7183.313
        },
        "split": {
          "value": 316.917
        }
      }
    ]
  },
  {
    "_id": "66e24adc8f9935c9566330ca",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.69
        },
        "iterator": {
          "value": 0.515
        },
        "iterations": {
          "value": 109.617
        },
        "colorShift": {
          "value": 17.822
        },
        "colorOffset": {
          "value": 189.512
        },
        "contrast": {
          "value": 1.221
        },
        "orbSize": {
          "value": 1907.207
        },
        "div": {
          "value": 8.839
        },
        "radius": {
          "value": 196.658
        },
        "wave": {
          "value": 7183.313
        },
        "split": {
          "value": 316.917
        }
      }
    ]
  },
  {
    "_id": "66e24e378f9935c9566330cd",
    "shader": "void main () {\n  float stream = stream / 1.9;\n  vec2 uv = k_uv();\n   uv *= k_rotate2d(stream/5.);\n  uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n  uv *= (i/10. + (i/20.*cos(dot(uv, .005*uv) - stream/5.)));\n    uv *= k_rotate2d(stream/(i*PI/1.5));\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -11.5);\n    float b = radius * sin(uv.y  + stream / 1.);\n    float c = wave * sin(split * uv.x / div - stream / 3.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.591
        },
        "iterator": {
          "value": 0.918
        },
        "iterations": {
          "value": 109.617
        },
        "colorShift": {
          "value": 17.822
        },
        "colorOffset": {
          "value": 189.512
        },
        "contrast": {
          "value": 1.049
        },
        "orbSize": {
          "value": 84.707
        },
        "div": {
          "value": 11.203
        },
        "radius": {
          "value": 141.641
        },
        "wave": {
          "value": 2453.274
        },
        "split": {
          "value": 340
        }
      }
    ]
  },
  {
    "_id": "66e24e6d0b9954748f6ad6c0",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/29.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(stream/1. + k_kale(uv, vec2(center), sides));\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/1.5*PI);\n    float t = i / PI / orbs * 2. - stream/20.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist)*sin(dist-stream/11.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.33
        },
        "contrast": {
          "value": 1.96
        },
        "orbSize": {
          "value": 0.58
        },
        "radius": {
          "value": 6.4
        },
        "colorShift": {
          "value": 5.57
        },
        "center": {
          "value": 2.71
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.18
        },
        "warp": {
          "value": false
        },
        "kkk": {
          "value": false
        },
        "base": {
          "value": 7.16
        }
      },
      {
        "zoom": {
          "value": 1.52231
        },
        "contrast": {
          "value": 2.14609
        },
        "orbSize": {
          "value": 0.40594
        },
        "radius": {
          "value": 3.77112
        },
        "colorShift": {
          "value": 10.55752
        },
        "center": {
          "value": 2.71
        },
        "sides": {
          "value": 5
        },
        "shape": {
          "value": 0.17086
        },
        "warp": {
          "value": true
        },
        "kkk": {
          "value": false
        },
        "base": {
          "value": 14.32
        }
      }
    ]
  },
  {
    "_id": "66e24f4d718b0f48d56bd730",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/-15.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 15.255
        },
        "iterator": {
          "value": 0.673
        },
        "iterations": {
          "value": 109.617
        },
        "colorShift": {
          "value": 17.822
        },
        "colorOffset": {
          "value": 189.512
        },
        "contrast": {
          "value": 1.221
        },
        "orbSize": {
          "value": 1907.207
        },
        "div": {
          "value": 8.839
        },
        "radius": {
          "value": 196.658
        },
        "wave": {
          "value": 7183.313
        },
        "split": {
          "value": 316.917
        }
      }
    ]
  },
  {
    "_id": "66e37f066a0cab26c3d8d3f2",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.113
        },
        "contrast": {
          "value": 1.923
        },
        "orbSize": {
          "value": 0.237
        },
        "radius": {
          "value": 2.646
        },
        "colorShift": {
          "value": 7.787
        },
        "base": {
          "value": 21.135
        },
        "blob": {
          "value": 3.344
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 0.091
        },
        "yDiv2": {
          "value": 0.075
        },
        "xDiv": {
          "value": 0.15
        },
        "distDiv": {
          "value": 1.524
        }
      },
      {
        "zoom": {
          "value": 3.58
        },
        "contrast": {
          "value": 2.917
        },
        "orbSize": {
          "value": 0.168
        },
        "radius": {
          "value": 0.445
        },
        "colorShift": {
          "value": 7.787
        },
        "base": {
          "value": 21.135
        },
        "blob": {
          "value": 3.344
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 0.133
        },
        "yDiv2": {
          "value": 0.21
        },
        "xDiv": {
          "value": 0.116
        },
        "distDiv": {
          "value": 0.804
        }
      }
    ]
  },
  {
    "_id": "66e380c86a0cab26c3d8d3f7",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.245
        },
        "contrast": {
          "value": 3.273
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1.137
        },
        "colorShift": {
          "value": 4.599
        },
        "base": {
          "value": 17.544
        },
        "blob": {
          "value": 2.452
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 1.777
        },
        "yDiv2": {
          "value": 0.013
        },
        "xDiv": {
          "value": 2
        },
        "distDiv": {
          "value": 0.697
        }
      }
    ]
  },
  {
    "_id": "66e381386a0cab26c3d8d3fa",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.245
        },
        "contrast": {
          "value": 3.273
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1.137
        },
        "colorShift": {
          "value": 4.599
        },
        "base": {
          "value": 17.544
        },
        "blob": {
          "value": 2.452
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 1.777
        },
        "yDiv2": {
          "value": 0.013
        },
        "xDiv": {
          "value": 2
        },
        "distDiv": {
          "value": 0.697
        }
      },
      {
        "zoom": {
          "value": 5.245
        },
        "contrast": {
          "value": 3.689
        },
        "orbSize": {
          "value": 0.17
        },
        "radius": {
          "value": 1.526
        },
        "colorShift": {
          "value": 4.599
        },
        "base": {
          "value": 6.043
        },
        "blob": {
          "value": 3.425
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 0.01
        },
        "yDiv2": {
          "value": 0.244
        },
        "xDiv": {
          "value": 0.499
        },
        "distDiv": {
          "value": 2.549
        }
      }
    ]
  },
  {
    "_id": "66e381886a0cab26c3d8d3fd",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 8.218
        },
        "contrast": {
          "value": 3.92
        },
        "orbSize": {
          "value": 0.212
        },
        "radius": {
          "value": 1.34
        },
        "colorShift": {
          "value": 4.599
        },
        "base": {
          "value": 8.398
        },
        "blob": {
          "value": 3.18
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 0.011
        },
        "yDiv2": {
          "value": 0.337
        },
        "xDiv": {
          "value": 1.912
        },
        "distDiv": {
          "value": 1.561
        }
      }
    ]
  },
  {
    "_id": "66e382016a0cab26c3d8d400",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 11.009
        },
        "contrast": {
          "value": 3.92
        },
        "orbSize": {
          "value": 0.451
        },
        "radius": {
          "value": 1.344
        },
        "colorShift": {
          "value": 4.599
        },
        "base": {
          "value": 80.442
        },
        "blob": {
          "value": 7.829
        },
        "mul": {
          "value": 0
        },
        "yDiv": {
          "value": 0.027
        },
        "yDiv2": {
          "value": 8.475
        },
        "xDiv": {
          "value": 0.767
        },
        "distDiv": {
          "value": 11.512
        }
      }
    ]
  },
  {
    "_id": "66e90037a98b47d3ec6e4636",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -14.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 6.);\n    float b = radius * sin(uv.y + stream / -3.);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.937
        },
        "iterator": {
          "value": 0.853
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.942
        },
        "orbSize": {
          "value": 0.033
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 1.583
        },
        "split": {
          "value": 3.07
        }
      }
    ]
  },
  {
    "_id": "66e9e690e5a883e152ada227",
    "shader": "void main () {\n  float stream =stream * 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -9.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.153
        },
        "iterator": {
          "value": 0.916
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.899
        },
        "orbSize": {
          "value": 0.095
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 6.051
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66e9e8b4e5a883e152ada22d",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.601
        },
        "iterator": {
          "value": 1.067
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.218
        },
        "orbSize": {
          "value": 15
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 14.725
        },
        "wave": {
          "value": 4.695
        },
        "split": {
          "value": 53.778
        }
      }
    ]
  },
  {
    "_id": "66eb1478e5a883e152ada287",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - (stream / -12.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 12.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.976
        },
        "iterator": {
          "value": 1.045
        },
        "iterations": {
          "value": 13.242
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 19.115
        },
        "contrast": {
          "value": 1.566
        },
        "orbSize": {
          "value": 0.885
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 3.933
        },
        "wave": {
          "value": 1.494
        },
        "split": {
          "value": 45.275
        }
      }
    ]
  },
  {
    "_id": "66eb147ce5a883e152ada28a",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - (stream / -12.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 12.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.976
        },
        "iterator": {
          "value": 1.045
        },
        "iterations": {
          "value": 13.242
        },
        "colorShift": {
          "value": 0.352
        },
        "colorOffset": {
          "value": 19.115
        },
        "contrast": {
          "value": 1.566
        },
        "orbSize": {
          "value": 0.885
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 3.933
        },
        "wave": {
          "value": 1.494
        },
        "split": {
          "value": 45.275
        }
      }
    ]
  },
  {
    "_id": "66eb65fdab07251a8c3a4917",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.601
        },
        "iterator": {
          "value": 1.067
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.218
        },
        "orbSize": {
          "value": 15
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 14.725
        },
        "wave": {
          "value": 4.695
        },
        "split": {
          "value": 53.778
        }
      }
    ]
  },
  {
    "_id": "66eb6602ab07251a8c3a491b",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.601
        },
        "iterator": {
          "value": 1.067
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.218
        },
        "orbSize": {
          "value": 15
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 14.725
        },
        "wave": {
          "value": 4.695
        },
        "split": {
          "value": 53.778
        }
      }
    ]
  },
  {
    "_id": "66eb660eab07251a8c3a491e",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.601
        },
        "iterator": {
          "value": 1.067
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.218
        },
        "orbSize": {
          "value": 15
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 14.725
        },
        "wave": {
          "value": 4.695
        },
        "split": {
          "value": 53.778
        }
      }
    ]
  },
  {
    "_id": "66eb67e1ab07251a8c3a4d8a",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.768
        },
        "iterator": {
          "value": 0.931
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.116
        },
        "orbSize": {
          "value": 11.147
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 28.317
        },
        "wave": {
          "value": 8.749
        },
        "split": {
          "value": 36.831
        }
      }
    ]
  },
  {
    "_id": "66eb68b3ab07251a8c3a4d8d",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.881
        },
        "iterator": {
          "value": 1.048
        },
        "iterations": {
          "value": 1.872
        },
        "colorShift": {
          "value": 0.073
        },
        "colorOffset": {
          "value": 16.222
        },
        "contrast": {
          "value": 1.233
        },
        "orbSize": {
          "value": 91.667
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 27.637
        },
        "wave": {
          "value": 7.194
        },
        "split": {
          "value": 30.011
        }
      }
    ]
  },
  {
    "_id": "66eb6b62ab07251a8c3a4da2",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.695
        },
        "iterator": {
          "value": 1.064
        },
        "iterations": {
          "value": 1.872
        },
        "colorShift": {
          "value": 0.073
        },
        "colorOffset": {
          "value": 16.222
        },
        "contrast": {
          "value": 1.233
        },
        "orbSize": {
          "value": 12.993
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 27.637
        },
        "wave": {
          "value": 7.194
        },
        "split": {
          "value": 30.011
        }
      }
    ]
  },
  {
    "_id": "66eb71e2ab07251a8c3a4dc3",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.881
        },
        "iterator": {
          "value": 1.048
        },
        "iterations": {
          "value": 1.872
        },
        "colorShift": {
          "value": 0.073
        },
        "colorOffset": {
          "value": 16.222
        },
        "contrast": {
          "value": 1.233
        },
        "orbSize": {
          "value": 91.667
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 27.637
        },
        "wave": {
          "value": 7.194
        },
        "split": {
          "value": 30.011
        }
      }
    ]
  },
  {
    "_id": "66ef50679f75d84dba139ccf",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.103
        },
        "iterator": {
          "value": 1.267
        },
        "iterations": {
          "value": 2.857
        },
        "colorShift": {
          "value": 0.118
        },
        "colorOffset": {
          "value": 21.236
        },
        "contrast": {
          "value": 0.846
        },
        "orbSize": {
          "value": 11.503
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 6
        },
        "wave": {
          "value": 2.759
        },
        "split": {
          "value": 4.937
        }
      }
    ]
  },
  {
    "_id": "66ef582b9f75d84dba139cd2",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n    uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(wave *uv.y + stream / 4.);\n    float b = radius * sin(wave *uv.y + stream / -5.26);\n    float c = radius *  sin(split * uv.x - (stream / -2.8255));\n    float d = radius * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c * d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(0,x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, length(uv)/2. + stream/20.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007
        },
        "iterator": {
          "value": 0.987
        },
        "iterations": {
          "value": 33
        },
        "colorShift": {
          "value": 1.429
        },
        "colorOffset": {
          "value": 5.414
        },
        "contrast": {
          "value": 0.859
        },
        "orbSize": {
          "value": 9.488
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 1.894
        },
        "wave": {
          "value": 0.655
        },
        "split": {
          "value": 265.051
        }
      }
    ]
  },
  {
    "_id": "66ef59f79f75d84dba139cd5",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n\n  uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.074
        },
        "iterator": {
          "value": 0.961
        },
        "iterations": {
          "value": 2.857
        },
        "colorShift": {
          "value": 0.118
        },
        "colorOffset": {
          "value": 21.236
        },
        "contrast": {
          "value": 1.179
        },
        "orbSize": {
          "value": 6.809
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 5.926
        },
        "wave": {
          "value": 0.473
        },
        "split": {
          "value": 33.849
        }
      }
    ]
  },
  {
    "_id": "66ef61949f75d84dba139cd8",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n\n  // uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.682
        },
        "iterator": {
          "value": 1.195
        },
        "iterations": {
          "value": 3.518
        },
        "colorShift": {
          "value": 0.104
        },
        "colorOffset": {
          "value": 25.291
        },
        "contrast": {
          "value": 0.978
        },
        "orbSize": {
          "value": 0.128
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 2.405
        },
        "wave": {
          "value": 0.118
        },
        "split": {
          "value": 12.832
        }
      }
    ]
  },
  {
    "_id": "66ef631b9f75d84dba139cdb",
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n\n  uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(sin(i/5.)*stream / 10. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.);\n    float b = radius * sin(uv.y + stream / -1.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / .75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.113
        },
        "iterator": {
          "value": 1.6
        },
        "iterations": {
          "value": 9.419
        },
        "colorShift": {
          "value": 1.402
        },
        "colorOffset": {
          "value": 8.55
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 20.769
        },
        "div": {
          "value": 2.117
        },
        "radius": {
          "value": 6
        },
        "wave": {
          "value": 0.208
        },
        "split": {
          "value": 6.324
        }
      }
    ]
  },
  {
    "_id": "66ef88e51191881f16ade01b",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 683.015
        },
        "rotation": {
          "value": 0.032
        },
        "xMultiplier": {
          "value": 460.913
        },
        "yMultiplier": {
          "value": 479.344
        },
        "colorSpread": {
          "value": 0.003
        },
        "colorMultiplier": {
          "value": 0.737
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 5.586078689759038
        },
        "ballSize": {
          "value": 9.584360881024098
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 10.43147590361446
        },
        "col": {
          "value": 0.7912348800524701
        }
      }
    ]
  },
  {
    "_id": "66ef8a061191881f16ade01e",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.01
        },
        "shapeMultiplier": {
          "value": 1062.076
        },
        "rotation": {
          "value": 1.969
        },
        "xMultiplier": {
          "value": 196.314
        },
        "yMultiplier": {
          "value": 426.424
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.405
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.417
        },
        "ballSize": {
          "value": 17.331
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 3.202
        },
        "radius": {
          "value": 20
        },
        "col": {
          "value": 2.192
        }
      }
    ]
  },
  {
    "_id": "66ef8a291191881f16ade023",
    "shader": "void main() {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/10.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.16);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1606359186746988
        },
        "xMultiplier": {
          "value": 40.74
        },
        "yMultiplier": {
          "value": 14.908
        },
        "ballSize": {
          "value": 44.899672910391565
        },
        "colorSpread": {
          "value": 0.012
        },
        "colorMultiplier": {
          "value": 508.183
        },
        "shapeMultiplier": {
          "value": 69.613
        },
        "glow": {
          "value": 10250.044
        },
        "contrast": {
          "value": 3.103421498493976
        },
        "brightness": {
          "value": 11.57032793674699
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 8.024077560240965
        },
        "radius": {
          "value": 5.128962725903616
        },
        "sapphire": {
          "value": [0.8, 0.2, 0.6]
        },
        "shape": {
          "value": 0.005611351656626507
        },
        "xDiv": {
          "value": 1118.053765060241
        }
      }
    ]
  },
  {
    "_id": "66ef8ac61191881f16ade028",
    "shader": "void main() {\n  float stream = stream / 8.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  // uv *= k_rotate2d(-stream);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.3);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i - stream));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.029
        },
        "xMultiplier": {
          "value": 91.9
        },
        "yMultiplier": {
          "value": 7.118
        },
        "ballSize": {
          "value": 39.407
        },
        "colorSpread": {
          "value": 0.008
        },
        "colorMultiplier": {
          "value": 357.132
        },
        "shapeMultiplier": {
          "value": 22.878
        },
        "glow": {
          "value": 4623.298
        },
        "contrast": {
          "value": 2.52
        },
        "brightness": {
          "value": 6.556
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 11.918
        },
        "radius": {
          "value": 9.757
        },
        "sapphire": {
          "value": [0.7450980392156863, 0.23529411764705882, 0.4549019607843137]
        },
        "shape": {
          "value": 0.005
        },
        "xDiv": {
          "value": 965.246
        }
      }
    ]
  },
  {
    "_id": "66ef8bce1191881f16ade031",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 6.455
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66ef8bda1191881f16ade036",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.007140436746987954
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 6.455
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66ef8be71191881f16ade039",
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 606.1652861445783
        },
        "rotation": {
          "value": 0.0590643825301205
        },
        "xMultiplier": {
          "value": 287.50470632530124
        },
        "yMultiplier": {
          "value": 253.25677710843374
        },
        "colorSpread": {
          "value": 0.003169728915662651
        },
        "colorMultiplier": {
          "value": 1.1984186746987953
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 6.455
        },
        "ballSize": {
          "value": 7.444983057228917
        },
        "glow": {
          "value": 4
        },
        "contrast": {
          "value": 5
        },
        "radius": {
          "value": 7.704536897590362
        },
        "col": {
          "value": 1.6711219879518073
        }
      }
    ]
  },
  {
    "_id": "66ef94771191881f16ade03d",
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/4.);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.71));\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/1.);\n    float b = radius * sin(uv.y - stream);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.032
        },
        "iterator": {
          "value": 0.87
        },
        "iterations": {
          "value": 5.98
        },
        "colorShift": {
          "value": 0.158
        },
        "colorOffset": {
          "value": 20.786
        },
        "contrast": {
          "value": 1.393
        },
        "orbSize": {
          "value": 42.605
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 17.743
        },
        "wave": {
          "value": 6.791
        },
        "split": {
          "value": 40.315
        },
        "inner": {
          "value": 1039.61
        },
        "outer": {
          "value": 36.225
        }
      }
    ]
  },
  {
    "_id": "66ef97d01191881f16ade040",
    "shader": "void main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.135
        },
        "iterator": {
          "value": 1.135
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.117
        },
        "orbSize": {
          "value": 6.165
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 11.846
        },
        "wave": {
          "value": 4.026
        },
        "split": {
          "value": 15.271
        },
        "inner": {
          "value": 21.846
        },
        "outer": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66ef98501191881f16ade045",
    "shader": "void main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.135
        },
        "iterator": {
          "value": 1.135
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 20.017
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 25.847
        },
        "wave": {
          "value": 4.026
        },
        "split": {
          "value": 5.371
        },
        "inner": {
          "value": 21.846
        },
        "outer": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66efaaca1191881f16ade048",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.159
        },
        "iterator": {
          "value": 1.213
        },
        "iterations": {
          "value": 5.98
        },
        "colorShift": {
          "value": 0.288
        },
        "colorOffset": {
          "value": 20.786
        },
        "contrast": {
          "value": 1.406
        },
        "orbSize": {
          "value": 22.638
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 9.24
        },
        "wave": {
          "value": 2.933
        },
        "split": {
          "value": 8.013
        },
        "inner": {
          "value": 49082863.243
        },
        "outer": {
          "value": 35608.658
        },
        "mul": {
          "value": 0.332
        }
      }
    ]
  },
  {
    "_id": "66efaad31191881f16ade04b",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "iterator": {
          "value": 1.213
        },
        "iterations": {
          "value": 5.98
        },
        "colorShift": {
          "value": 0.288
        },
        "colorOffset": {
          "value": 20.786
        },
        "contrast": {
          "value": 1.406
        },
        "orbSize": {
          "value": 22.638
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 9.24
        },
        "wave": {
          "value": 2.933
        },
        "split": {
          "value": 8.013
        },
        "inner": {
          "value": 49082863.243
        },
        "outer": {
          "value": 35608.658
        },
        "mul": {
          "value": 0.332
        }
      }
    ]
  },
  {
    "_id": "66efac771191881f16ade04e",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09
        },
        "iterator": {
          "value": 1.162
        },
        "iterations": {
          "value": 16.702
        },
        "colorShift": {
          "value": 1.245
        },
        "colorOffset": {
          "value": 17.566
        },
        "contrast": {
          "value": 1.313
        },
        "orbSize": {
          "value": 99.656
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 16.083
        },
        "wave": {
          "value": 6.035
        },
        "split": {
          "value": 8.473
        },
        "inner": {
          "value": 93223150
        },
        "outer": {
          "value": 47124.698
        },
        "mul": {
          "value": 0.332
        }
      }
    ]
  },
  {
    "_id": "66efac821191881f16ade051",
    "shader": "void main () {\n  float stream = stream / 13.;\n  vec2 uv = k_uv();\n   uv *= zoom / 300.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.09
        },
        "iterator": {
          "value": 1.162
        },
        "iterations": {
          "value": 16.702
        },
        "colorShift": {
          "value": 1.245
        },
        "colorOffset": {
          "value": 17.566
        },
        "contrast": {
          "value": 1.313
        },
        "orbSize": {
          "value": 99.656
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 16.083
        },
        "wave": {
          "value": 6.035
        },
        "split": {
          "value": 8.473
        },
        "inner": {
          "value": 93223150
        },
        "outer": {
          "value": 47124.698
        },
        "mul": {
          "value": 0.332
        }
      }
    ]
  },
  {
    "_id": "66efafdd1191881f16ade05c",
    "shader": "void main () {\n  float stream = stream / 13.;\n  vec2 uv = k_uv();\n   uv *= zoom / 300.;\n  uv *= k_rotate2d(stream/.25 - abs(uv.x));\n  // uv *= mul * abs(length(uv/.00001));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.2425));\n  for (float i = 2.; i < 10.; i++) {\n  // uv *= k_rotate2d(float(int(i)) + PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.022
        },
        "iterator": {
          "value": 0.736
        },
        "iterations": {
          "value": 16.702
        },
        "colorShift": {
          "value": 1.094
        },
        "colorOffset": {
          "value": 22.86
        },
        "contrast": {
          "value": 1.088
        },
        "orbSize": {
          "value": 55.585
        },
        "div": {
          "value": 4.623
        },
        "radius": {
          "value": 2.911
        },
        "wave": {
          "value": 2.057
        },
        "split": {
          "value": 12.991
        },
        "inner": {
          "value": 93223150
        },
        "outer": {
          "value": 101338.936
        },
        "mul": {
          "value": 13.443
        }
      }
    ]
  },
  {
    "_id": "66efb3ca1191881f16ade05f",
    "shader": "void main () {\n  float stream = stream / 10.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1000.;\n  uv *= k_rotate2d(stream/.75 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * sin(inner *length(uv) - stream/.423);\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.4);\n    float b = radius * sin(uv.y - stream/.5117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.31855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .3195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.001
        },
        "iterator": {
          "value": 1.108
        },
        "iterations": {
          "value": 2.608
        },
        "colorShift": {
          "value": 0.25
        },
        "colorOffset": {
          "value": 19.086
        },
        "contrast": {
          "value": 1.364
        },
        "orbSize": {
          "value": 799511.488
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 205.593
        },
        "wave": {
          "value": 40.198
        },
        "split": {
          "value": 52.417
        },
        "inner": {
          "value": {
            "$numberLong": "9112232150"
          }
        },
        "outer": {
          "value": 2753625353.334
        },
        "mul": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66efbc701191881f16ade062",
    "shader": "void main () {\n  float stream = stream / 20.;\n  vec2 uv = k_uv();\n   uv *= zoom / 23200.;\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  uv *= k_rotate2d(stream/.25);\n  for (float i = 2.; i < 15.; i++) {\n  // uv *= zoom*length(uv);\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  uv *= k_rotate2d(stream/5.  + float(int(i))/20. + PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.331
        },
        "iterator": {
          "value": 0.736
        },
        "iterations": {
          "value": 12.664
        },
        "colorShift": {
          "value": 0.362
        },
        "colorOffset": {
          "value": 17.251
        },
        "contrast": {
          "value": 2.313
        },
        "orbSize": {
          "value": 420
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 122.832
        },
        "wave": {
          "value": 6.322
        },
        "split": {
          "value": 6.435
        },
        "inner": {
          "value": 156372.005
        },
        "outer": {
          "value": 525199.083
        },
        "mul": {
          "value": 0.091
        }
      }
    ]
  },
  {
    "_id": "66efbd011191881f16ade067",
    "shader": "void main () {\n  float stream = stream / 50.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.135
        },
        "iterator": {
          "value": 1.135
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 20.017
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 25.847
        },
        "wave": {
          "value": 4.026
        },
        "split": {
          "value": 5.371
        },
        "inner": {
          "value": 21.846
        },
        "outer": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66efbfd41191881f16ade06c",
    "shader": "void main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv();\n   uv *= zoom / 200.;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 2.; i < 12.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.771
        },
        "iterator": {
          "value": 1.165
        },
        "iterations": {
          "value": 23.693
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 15.535
        },
        "contrast": {
          "value": 1.292
        },
        "orbSize": {
          "value": 23.38
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 12.705
        },
        "wave": {
          "value": 4.719
        },
        "split": {
          "value": 23.17
        },
        "inner": {
          "value": 20739.465
        },
        "outer": {
          "value": 80.884
        }
      }
    ]
  },
  {
    "_id": "66efc0f11191881f16ade06f",
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.013
        },
        "iterator": {
          "value": 1.116
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.406
        },
        "colorOffset": {
          "value": 28.653
        },
        "contrast": {
          "value": 1.217
        },
        "orbSize": {
          "value": 1387.16
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 27.036
        },
        "wave": {
          "value": 20
        },
        "split": {
          "value": 1.208
        },
        "inner": {
          "value": 5015.722
        },
        "outer": {
          "value": 272.905
        }
      }
    ]
  },
  {
    "_id": "66efc1401191881f16ade074",
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-.75);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.012
        },
        "iterator": {
          "value": 1.111
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.384
        },
        "colorOffset": {
          "value": 18.713
        },
        "contrast": {
          "value": 1.303
        },
        "orbSize": {
          "value": 1217.276
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 27.036
        },
        "wave": {
          "value": 20
        },
        "split": {
          "value": 1.208
        },
        "inner": {
          "value": 5015.722
        },
        "outer": {
          "value": 272.905
        }
      }
    ]
  },
  {
    "_id": "66efd4dc1191881f16ade07f",
    "shader": "void main () {\n  float stream = stream / 7.;\n  vec2 uv = k_uv();\n   uv *= zoom / 5000.;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.5)));\n  uv *= k_rotate2d(stream/-.75);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/1.15);\n    float b = radius * sin(uv.y+stream/1.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.2));\n    float d = radius * wave * cos(split * uv.y  - (stream / .2));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.25)* orbSize, vec2(x, log(abs(x))),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.722
        },
        "iterator": {
          "value": 1.202
        },
        "iterations": {
          "value": 18.883
        },
        "colorShift": {
          "value": 0.53
        },
        "colorOffset": {
          "value": 18.732
        },
        "contrast": {
          "value": 1.237
        },
        "orbSize": {
          "value": 8.891
        },
        "div": {
          "value": 6.149
        },
        "radius": {
          "value": 47.569
        },
        "wave": {
          "value": 10.251
        },
        "split": {
          "value": 20
        },
        "inner": {
          "value": 7491644.749
        },
        "outer": {
          "value": 520.517
        }
      }
    ]
  },
  {
    "_id": "66efe69f1191881f16ade098",
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.135
        },
        "iterator": {
          "value": 1.135
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 20.017
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 25.847
        },
        "wave": {
          "value": 4.026
        },
        "split": {
          "value": 5.371
        },
        "inner": {
          "value": 21.846
        },
        "outer": {
          "value": 10
        }
      }
    ]
  },
  {
    "_id": "66eff0b21191881f16ade09c",
    "shader": "void main () {\n  float stream = stream / 222.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1000.;\n  uv *= k_rotate2d(stream/12.1/PI/2.);\n  uv /= sin(stream + abs(outer * cos(stream/.5 - sin(inner*dot(uv, uv) - stream/1.))));\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/30.1/PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/3.1745);\n    float b = radius * sin(uv.y+stream/1.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -.074255));\n    float d = radius * wave * cos(split * uv.y  - (stream / .3175));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.76
        },
        "iterator": {
          "value": 0.953
        },
        "iterations": {
          "value": 18.13
        },
        "colorShift": {
          "value": 0.793
        },
        "colorOffset": {
          "value": 17.129
        },
        "contrast": {
          "value": 2.338
        },
        "orbSize": {
          "value": 579.482
        },
        "div": {
          "value": 2.977
        },
        "radius": {
          "value": 170
        },
        "wave": {
          "value": 835.683
        },
        "split": {
          "value": 3078.899
        },
        "inner": {
          "value": 349658.518
        },
        "outer": {
          "value": 223.574
        }
      }
    ]
  },
  {
    "_id": "66efff7e1191881f16ade0a0",
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.023
        },
        "iterator": {
          "value": 1.15
        },
        "iterations": {
          "value": 9.869
        },
        "colorShift": {
          "value": 0.659
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 20.017
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 25.847
        },
        "wave": {
          "value": 8.265
        },
        "split": {
          "value": 26.298
        },
        "inner": {
          "value": 54.435
        },
        "outer": {
          "value": 9.7
        }
      }
    ]
  },
  {
    "_id": "66f00afa1191881f16ade0a5",
    "shader": "void main () {\n  float stream = stream / 250.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1000.;\n  uv *= cos(outer * sin(inner*(abs(dot(uv, uv))) - stream/-1.59953) - stream/2.29953);//+3.25*cos(uv.x/11.1-stream/16.) ;//* .1/k_rotate2d(stream + length(uv)/.000000005);\n  uv *= k_rotate2d(stream/-.120123);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.5);\n    float b = radius * sin(uv.y+stream/1.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.155));\n    float d = radius * wave * cos(split * uv.y  - (stream / .015));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.074
        },
        "iterator": {
          "value": 1.07
        },
        "iterations": {
          "value": 11.104
        },
        "colorShift": {
          "value": 0.416
        },
        "colorOffset": {
          "value": 28.009
        },
        "contrast": {
          "value": 1.51
        },
        "orbSize": {
          "value": 3807.526
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 26.777
        },
        "wave": {
          "value": 251
        },
        "split": {
          "value": 33255
        },
        "inner": {
          "value": 3221200
        },
        "outer": {
          "value": 95.984
        }
      }
    ]
  },
  {
    "_id": "66f00b521191881f16ade0a8",
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "iterator": {
          "value": 1.202
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 12.541
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 11.461
        },
        "split": {
          "value": 3.2
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f00d581191881f16ade0ab",
    "shader": "void main () {\n  float stream = stream / 9.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/.93));\n  uv *= k_rotate2d(stream/-.5);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/2.15);\n    float b = radius * sin(uv.y+stream/2.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002
        },
        "iterator": {
          "value": 1.271
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.72
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 347.359
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 5.62
        },
        "wave": {
          "value": 6.193
        },
        "split": {
          "value": 107.363
        },
        "inner": {
          "value": 164441.438
        },
        "outer": {
          "value": 0.519
        }
      }
    ]
  },
  {
    "_id": "66f00ed31191881f16ade0ae",
    "shader": "void main () {\n  float stream = stream / 19.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/.3));\n  uv *= k_rotate2d(stream/-.452435);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.6);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / .25));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.002
        },
        "iterator": {
          "value": 1.134
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.72
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.067
        },
        "orbSize": {
          "value": 2909.578
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 9.971
        },
        "wave": {
          "value": 1.763
        },
        "split": {
          "value": 31.157
        },
        "inner": {
          "value": 88321.454
        },
        "outer": {
          "value": 44.76
        }
      }
    ]
  },
  {
    "_id": "66f0108f1191881f16ade0b1",
    "shader": "void main () {\n  float stream = stream / 19.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1000.;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/1.01));\n  uv *= k_rotate2d(stream/-.2452435);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.16);\n    float b = radius * sin(uv.y+stream/.15);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / .25));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.345
        },
        "iterator": {
          "value": 0.979
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.72
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.512
        },
        "orbSize": {
          "value": 52.622
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 15
        },
        "wave": {
          "value": 8.009
        },
        "split": {
          "value": 66.608
        },
        "inner": {
          "value": 2485681.402
        },
        "outer": {
          "value": 254.776
        }
      }
    ]
  },
  {
    "_id": "66f013141191881f16ade0b4",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.141
        },
        "iterator": {
          "value": 1.04
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 12.541
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 2.005
        },
        "split": {
          "value": 50.385
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f0137d1191881f16ade0b7",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.056
        },
        "iterator": {
          "value": 1.201
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.157
        },
        "orbSize": {
          "value": 19.277
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 1.775
        },
        "split": {
          "value": 36.146
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f013981191881f16ade0ba",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.087
        },
        "iterator": {
          "value": 1.18
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.157
        },
        "orbSize": {
          "value": 19.277
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 1.775
        },
        "split": {
          "value": 36.146
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f015811191881f16ade0bd",
    "shader": "void main () {\n  float stream = stream / 20.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-.45);\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.2)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.2415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.087
        },
        "iterator": {
          "value": 1.18
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.157
        },
        "orbSize": {
          "value": 19.277
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 1.775
        },
        "split": {
          "value": 36.146
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f045091191881f16ade0e1",
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.0726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.12);\n    float c = radius * wave * sin(split * uv.x - (stream / -.055));\n    float d = radius * wave * cos(split * uv.y  - (stream / .05));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.345
        },
        "iterator": {
          "value": 1.095
        },
        "iterations": {
          "value": 2.594
        },
        "colorShift": {
          "value": 0.085
        },
        "colorOffset": {
          "value": 19.294
        },
        "contrast": {
          "value": 1.945
        },
        "orbSize": {
          "value": 0.075
        },
        "div": {
          "value": 3.891
        },
        "radius": {
          "value": 2.251
        },
        "wave": {
          "value": 1.124
        },
        "split": {
          "value": 454.723
        },
        "inner": {
          "value": 11512120
        },
        "outer": {
          "value": 36.225
        }
      }
    ]
  },
  {
    "_id": "66f0c0921191881f16ade0fc",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.7)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.141
        },
        "iterator": {
          "value": 1.04
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 12.541
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 2.005
        },
        "split": {
          "value": 50.385
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f0c0eb1191881f16ade100",
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.141
        },
        "iterator": {
          "value": 1.04
        },
        "iterations": {
          "value": 10.504
        },
        "colorShift": {
          "value": 0.506
        },
        "colorOffset": {
          "value": 29.656
        },
        "contrast": {
          "value": 1.095
        },
        "orbSize": {
          "value": 12.541
        },
        "div": {
          "value": 10.566
        },
        "radius": {
          "value": 8.423
        },
        "wave": {
          "value": 2.005
        },
        "split": {
          "value": 50.385
        },
        "inner": {
          "value": 100
        },
        "outer": {
          "value": 4.547
        }
      }
    ]
  },
  {
    "_id": "66f0c3dc1191881f16ade112",
    "shader": "void main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / -7.5);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.75);\n    float b = radius * sin(uv.y + stream / -3.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.49
        },
        "iterator": {
          "value": 1.067
        },
        "iterations": {
          "value": 6.162
        },
        "colorShift": {
          "value": 0.172
        },
        "colorOffset": {
          "value": 22.793
        },
        "contrast": {
          "value": 1.218
        },
        "orbSize": {
          "value": 15
        },
        "div": {
          "value": 10.462
        },
        "radius": {
          "value": 14.725
        },
        "wave": {
          "value": 4.695
        },
        "split": {
          "value": 53.778
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8c9",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float stream = stream / 1.2;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/15.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 26.54
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 5.39
        },
        "sides": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 53.08
        },
        "contrast": {
          "value": 1.475624
        },
        "orbSize": {
          "value": 1.812746
        },
        "radius": {
          "value": 6.592458
        },
        "colorShift": {
          "value": 6.478777
        },
        "x1": {
          "value": 0
        },
        "x2": {
          "value": 0.26894
        },
        "y1": {
          "value": 1.26
        },
        "y2": {
          "value": 2.372751
        },
        "center": {
          "value": 30.572182
        },
        "sides": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 69.63853
        },
        "contrast": {
          "value": 2.119733
        },
        "orbSize": {
          "value": 6.244888
        },
        "radius": {
          "value": 10.580402
        },
        "colorShift": {
          "value": 6.478777
        },
        "x1": {
          "value": 0.84439
        },
        "x2": {
          "value": 1.006902
        },
        "y1": {
          "value": 1.525242
        },
        "y2": {
          "value": 0.179639
        },
        "center": {
          "value": 6.533354
        },
        "sides": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 30.635108
        },
        "contrast": {
          "value": 2.38993
        },
        "orbSize": {
          "value": 3.662296
        },
        "radius": {
          "value": 10.669814
        },
        "colorShift": {
          "value": 2.920201
        },
        "x1": {
          "value": 0
        },
        "x2": {
          "value": 5.370659
        },
        "y1": {
          "value": 4.792634
        },
        "y2": {
          "value": 1.211102
        },
        "center": {
          "value": 6.533354
        },
        "sides": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8cc",
    "shader": "#define BALLS 15.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  // uv *=outer*sin(inner / 500.*dot(uv, uv) - stream/24.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/2.75);\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/-5.*PI/20.);\n    float t = float(i) * PI / BALLS * (2. + 1.);\n    float x = xOuter * sin(xInner * t - stream);\n    float y = yOuter * cos(yOuter * t - stream/1.7);\n    vec2 p = vec2(radius*x, radius*y);\n    p /= pDiv * sin(PI * sin(uv.x/shape - stream/2.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume,.5)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 763.232826
        },
        "ballSize": {
          "value": 90.045199
        },
        "contrast": {
          "value": 1.865348
        },
        "radius": {
          "value": 4945.528285
        },
        "shape": {
          "value": 114.095092
        },
        "sides": {
          "value": 3
        },
        "center": {
          "value": 817.995185
        },
        "xOuter": {
          "value": 0.323888
        },
        "xInner": {
          "value": 0.198128
        },
        "yInner": {
          "value": 1.408218
        },
        "yOuter": {
          "value": 1.670995
        },
        "pDiv": {
          "value": 22
        },
        "inner": {
          "value": 0.001367
        },
        "outer": {
          "value": 17.325566
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8cd",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= abs(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/6.);\n    float y = radius * sin(t+stream/8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 9.741
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 4.346
        },
        "radius": {
          "value": 39.769
        },
        "colorShift": {
          "value": 7.65
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 50
        },
        "sinMul": {
          "value": 2.23
        },
        "cosMul": {
          "value": 1.53
        },
        "yMul": {
          "value": 0.11
        },
        "xMul": {
          "value": 0.29
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 19
        },
        "xDivide": {
          "value": 19
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ce",
    "shader": "#define orbs 20.\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  uv = k_kale(uv, vec2(0), sides);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .8) * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 40.43
        },
        "contrast": {
          "value": 1.202
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 14.079999999999998
        },
        "colorShift": {
          "value": 7.65
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 50
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 3
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.4
        },
        "xSpeed": {
          "value": -22
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 5.89
        },
        "xDivide": {
          "value": 5.89
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8cf",
    "shader": "#define orbs 20.\n\n  \n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\n  float stream = stream / .532;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = k_swap(uv, warped, warp, warpTween, warpTweenProgress);\n  uv *= k_rotate2d(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream/2.);\n    uv.y += cos((i+1.)*uv.x/div2 + stream/2.);\n    float t = i * PI / orbs * 20.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .79)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.1
        },
        "contrast": {
          "value": 1.55
        },
        "orbSize": {
          "value": 1.79
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 10.95
        },
        "div": {
          "value": 15.427
        },
        "div2": {
          "value": 32.974
        },
        "warp": {
          "value": true
        }
      },
      {
        "zoom": {
          "value": 10.56
        },
        "contrast": {
          "value": 1.55
        },
        "orbSize": {
          "value": 0.94
        },
        "radius": {
          "value": 1
        },
        "colorShift": {
          "value": 8.11
        },
        "div": {
          "value": 90.8
        },
        "div2": {
          "value": 16.276
        },
        "warp": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.43
        },
        "contrast": {
          "value": 1.24
        },
        "orbSize": {
          "value": 1.17
        },
        "radius": {
          "value": 14
        },
        "colorShift": {
          "value": 10.95
        },
        "div": {
          "value": 96.668
        },
        "div2": {
          "value": 66.266
        },
        "warp": {
          "value": true
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d0",
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize((uv) + sin(abs(1./length(uv)*20.*uv)-stream/2.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation + stream/15.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/2.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(stream + uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .8) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 25.38
        },
        "yDivider": {
          "value": 27.34
        },
        "xDivider": {
          "value": 10.17
        },
        "multiplier": {
          "value": 287.12
        },
        "ballSize": {
          "value": 1.72
        },
        "contrast": {
          "value": 1.41
        },
        "radius": {
          "value": 11
        },
        "yOuter": {
          "value": 0.3
        },
        "xOuter": {
          "value": 1
        },
        "rotation": {
          "value": 5
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d1",
    "shader": "#define orbs 20.\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(dist/rotation + stream/20.);\n  //uv /= dot(uv, uv);\n  uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/1.7);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 33.367
        },
        "contrast": {
          "value": 1.242
        },
        "orbSize": {
          "value": 1.418
        },
        "radius": {
          "value": 8.08
        },
        "colorShift": {
          "value": 7.65
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 12.74
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 2.22
        },
        "yMul": {
          "value": 0.25
        },
        "xMul": {
          "value": 0.42
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 0
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 2.04
        },
        "xDivide": {
          "value": 16.34
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d2",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  uv *= k_rotate2d(stream/40.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/4.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/7.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/4.);\n    float y = radius * sin(t+stream/4.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .8)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 47.434
        },
        "contrast": {
          "value": 1.167
        },
        "orbSize": {
          "value": 2.594
        },
        "radius": {
          "value": 10.291
        },
        "colorShift": {
          "value": 7.12
        },
        "sides": {
          "value": 4
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 2
        },
        "cosMul": {
          "value": 0.94
        },
        "yMul": {
          "value": 0.14
        },
        "xMul": {
          "value": 0.05
        },
        "xSpeed": {
          "value": -0.5
        },
        "ySpeed": {
          "value": 0.5
        },
        "gloop": {
          "value": 0.006
        },
        "yDivide": {
          "value": 3.2
        },
        "xDivide": {
          "value": 2.08
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d3",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv *= k_rotate2d(stream/20.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += radius * sin((i+1.)*uv.y/yDiv - stream);\n    uv.y += radius * cos((i+1.)*uv.x/xDiv + stream);\n    float t = i * PI / orbs;\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.882917
        },
        "contrast": {
          "value": 1.21
        },
        "orbSize": {
          "value": 0.071563
        },
        "colorShift": {
          "value": 15
        },
        "warp": {
          "value": true
        },
        "radius": {
          "value": 0.103421
        },
        "yDiv": {
          "value": 0.754
        },
        "xDiv": {
          "value": 2.235
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d4",
    "shader": "precision highp float;\n\n\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv *=k_rotate2d(1. + stream/35.);\n  vec2 p = shape2 / abs(vec2(.5 / shape));\n  p /= abs(tan(sin(xShape * uv.x-stream) * (cos(yShape * uv.y - stream))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (time / 3.23 + colorShape * uv.x)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y - cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * (pow(1./volume, -.6)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.b *= .42;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.443
        },
        "xShape": {
          "value": 7.238
        },
        "yShape": {
          "value": 7.275
        },
        "colorShape": {
          "value": 11
        },
        "contrast": {
          "value": 0.376
        },
        "ballSize": {
          "value": 3.948
        },
        "shape": {
          "value": 1.34
        },
        "shape2": {
          "value": 0.284
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d5",
    "shader": "#define orbs 30.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.);\n    float y = radius * cos(t - stream/6.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, pow(volume, .7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 11.15
        },
        "contrast": {
          "value": 1.094
        },
        "orbSize": {
          "value": 1.055
        },
        "radius": {
          "value": 12.89
        },
        "colorShift": {
          "value": 10.54
        },
        "div": {
          "value": 40
        },
        "div2": {
          "value": 40
        },
        "warp": {
          "value": true
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d6",
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 52.612
        },
        "contrast": {
          "value": 0.931
        },
        "orbSize": {
          "value": 0.617
        },
        "radius": {
          "value": 22.221
        },
        "colorShift": {
          "value": 11.52
        },
        "div": {
          "value": 17.328
        },
        "div2": {
          "value": 14.483
        },
        "warp": {
          "value": true
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d7",
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n  \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 24.95
        },
        "contrast": {
          "value": 0.902
        },
        "orbSize": {
          "value": 0.682
        },
        "radius": {
          "value": 8.159
        },
        "colorShift": {
          "value": 12.71
        },
        "div": {
          "value": 10
        },
        "div2": {
          "value": 10
        },
        "warp": {
          "value": true
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d8",
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n    uv *= k_rotate2d(stream/2.);\n  uv = sin(stream * 1. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / .8);\n  uv *= k_rotate2d(rotation * dist + stream / 1.7);\n  for (float i = 0.; i < BALLS; i++) {\n    // uv.x /= cos(log(abs(uv.x*.1)-float(i+2.)));\n    float t = stream / 7. + float(i) * PI / BALLS;\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(2.7/dist * pow(volume, .9)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .6) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.559
        },
        "contrast": {
          "value": 2.733
        },
        "ballSize": {
          "value": 0.034
        },
        "radius": {
          "value": 0.53
        },
        "col": {
          "value": [0.37254901960784315, 0.6509803921568628, 0.9490196078431372]
        },
        "rotation": {
          "value": 0.225
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8d9",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv += sin(stream*1.+(1.-log(sin(uv))));\n  uv *= k_rotate2d(stream/3.);\n  // uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 11.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 5; i < BALLS; i++) {\n    // uv.x -= .01*cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t - stream/2.), sinMul * sin(t + stream/4.));\n    p += radius * tan(stream + float(i) - PI) * sin(t - stream);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 55. + float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.153
        },
        "contrast": {
          "value": 1.831
        },
        "ballSize": {
          "value": 0.507
        },
        "radius": {
          "value": 6.699
        },
        "col": {
          "value": [0.37254901960784315, 0.6509803921568628, 0.9490196078431372]
        },
        "rotation": {
          "value": 2.17
        },
        "dotMultiplier": {
          "value": 5
        },
        "tanMul": {
          "value": 0.9
        },
        "sinMul": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8da",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .45;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 10.) + a * sin(uv.x / 100. - stream / 12.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider - stream / 15.) - b * cos(uv.y / 100. + stream / 10.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-11. * tan(t + stream/10.), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 100.) * cos(uv.y / 40.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 239.782
        },
        "yDivider": {
          "value": 23.215
        },
        "xDivider": {
          "value": 520.181
        },
        "multiplier": {
          "value": 1.895
        },
        "ballSize": {
          "value": 50.485
        },
        "contrast": {
          "value": 3.054
        },
        "radius": {
          "value": 23.28
        },
        "a": {
          "value": 1.91
        },
        "b": {
          "value": 8.04
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ca",
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/9.);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t * radius * cos(dist*t-stream/1.5)*1.-sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.34
        },
        "contrast": {
          "value": 1.344
        },
        "orbSize": {
          "value": 0.132
        },
        "radius": {
          "value": 2.239
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.94
        },
        "sides": {
          "value": 8
        },
        "shape": {
          "value": 0.36
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8dc",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": true
        }
      },
      {
        "zoom": {
          "value": 50.47
        },
        "yDivider": {
          "value": 397.41
        },
        "xDivider": {
          "value": 815.27
        },
        "multiplier": {
          "value": 4.29
        },
        "ballSize": {
          "value": 0.22
        },
        "contrast": {
          "value": 1.96
        },
        "radius": {
          "value": 9.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8de",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 21.09
        },
        "contrast": {
          "value": 1.37
        },
        "orbSize": {
          "value": 1.39
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 5.37
        },
        "x1": {
          "value": 0.57
        },
        "x2": {
          "value": 0.3
        },
        "y1": {
          "value": 0.63
        },
        "y2": {
          "value": 0.53
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 6
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8cb",
    "shader": "#define BALLS 5\n\nvoid main () {\n  vec2 uv = k_uv();\n   gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *=k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *=k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.062
        },
        "shapeMultiplier": {
          "value": 203.13
        },
        "rotation": {
          "value": 0.05
        },
        "xMultiplier": {
          "value": 59.27
        },
        "yMultiplier": {
          "value": 88
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.81
        },
        "invert": {
          "value": true
        },
        "brightness": {
          "value": 3.86
        },
        "ballSize": {
          "value": 36.72
        },
        "glow": {
          "value": 1.22
        },
        "contrast": {
          "value": 2.72
        },
        "radius": {
          "value": 16.24
        }
      },
      {
        "zoom": {
          "value": 0.02
        },
        "shapeMultiplier": {
          "value": 203.13
        },
        "rotation": {
          "value": 0.05
        },
        "xMultiplier": {
          "value": 59.27
        },
        "yMultiplier": {
          "value": 88
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.81
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 3.86
        },
        "ballSize": {
          "value": 36.72
        },
        "glow": {
          "value": 1.22
        },
        "contrast": {
          "value": 2.72
        },
        "radius": {
          "value": 22.046
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8df",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 90.275
        },
        "yDivider": {
          "value": 18.646
        },
        "xDivider": {
          "value": 9.294
        },
        "multiplier": {
          "value": 1.219
        },
        "ballSize": {
          "value": 34.82
        },
        "contrast": {
          "value": 1.8
        },
        "radius": {
          "value": 76.67
        },
        "rotation": {
          "value": 14.858
        },
        "yDivide": {
          "value": 307.888
        },
        "xDivide": {
          "value": 0.408
        },
        "yShape": {
          "value": 200
        },
        "shape": {
          "value": 14.966
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e0",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 12.35
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 0.64
        },
        "radius": {
          "value": 4.02
        },
        "colorShift": {
          "value": 4.41
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0.91
        },
        "y1": {
          "value": 0.37
        },
        "y2": {
          "value": 1.86
        },
        "center": {
          "value": 6.97
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 24.7
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.204
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 2.6
        },
        "x1": {
          "value": 0.1
        },
        "x2": {
          "value": 0
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 0.394
        },
        "center": {
          "value": 13.273
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 11.101
        },
        "contrast": {
          "value": 1.19
        },
        "orbSize": {
          "value": 1.003
        },
        "radius": {
          "value": 8.04
        },
        "colorShift": {
          "value": 4.625
        },
        "x1": {
          "value": 0.053
        },
        "x2": {
          "value": 1.82
        },
        "y1": {
          "value": 0.74
        },
        "y2": {
          "value": 3.72
        },
        "center": {
          "value": 3.859
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e1",
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv = k_swap(uv, uv * sin(.0001 * dot(uv, uv) + stream/5.), dotted, dottedTween, dottedTweenProgress);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 116.00066318094458
        },
        "yDivider": {
          "value": 2.0108340560372664
        },
        "xDivider": {
          "value": 19.66732405775273
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 26.2977033459619
        },
        "contrast": {
          "value": 3.1896125184039077
        },
        "radius": {
          "value": 51.601894147360014
        },
        "rotation": {
          "value": 10.745
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 1.485310136543849
        },
        "yShape": {
          "value": 14.65960528313752
        },
        "shape": {
          "value": 71.5548653767282
        },
        "dotted": {
          "value": true
        },
        "mirror": {
          "value": true
        }
      },
      {
        "zoom": {
          "value": 41.078
        },
        "yDivider": {
          "value": 0.648
        },
        "xDivider": {
          "value": 4.401
        },
        "multiplier": {
          "value": 5
        },
        "ballSize": {
          "value": 18.522
        },
        "contrast": {
          "value": 3.132
        },
        "radius": {
          "value": 28.094
        },
        "rotation": {
          "value": 10.745
        },
        "yDivide": {
          "value": 225.75
        },
        "xDivide": {
          "value": 0.788
        },
        "yShape": {
          "value": 4.193
        },
        "shape": {
          "value": 142.16
        },
        "dotted": {
          "value": false
        },
        "mirror": {
          "value": true
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e2",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.12
        },
        "contrast": {
          "value": 1.234
        },
        "orbSize": {
          "value": 2.298
        },
        "radius": {
          "value": 20.95
        },
        "colorShift": {
          "value": 5.41
        },
        "sides": {
          "value": 1
        },
        "rotation": {
          "value": 0
        },
        "sinMul": {
          "value": 0.56
        },
        "cosMul": {
          "value": 0.88
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.56
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": -2
        },
        "gloop": {
          "value": 0.0051
        },
        "yDivide": {
          "value": 3.65
        },
        "xDivide": {
          "value": 32.82
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e4",
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 14.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 15. - cos(.01*dist*uv.x/2. - stream/10.2) * sin(dist - uv.x/14. - stream/8.);\n    float x = t + radius * cos(dist * t - stream /-3.) * sin(dist + stream / 2.5);\n    float y = 0.;\n    vec2 position = vec2(x + sin(x+stream/2. + dist), y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.677086
        },
        "contrast": {
          "value": 1.67239
        },
        "orbSize": {
          "value": 0.062933
        },
        "radius": {
          "value": 0.708866
        },
        "colorShift": {
          "value": 4.5
        },
        "center": {
          "value": 0.353764
        },
        "sides": {
          "value": 6
        },
        "shape": {
          "value": 0.72
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e3",
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 6.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream/10.);\n    float y = radius * cos(sin(t + stream / 10.) + stream/20.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, (uv.x * .02 * dist + orbSize) * pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 5.831
        },
        "contrast": {
          "value": 2.21
        },
        "orbSize": {
          "value": 0.685
        },
        "radius": {
          "value": 2.435
        },
        "colorShift": {
          "value": 4.69
        },
        "center": {
          "value": 2.82
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.3
        },
        "sinMul": {
          "value": 7.27
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e5",
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = k_uv();\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.053
        },
        "shapeMultiplier": {
          "value": 223.96
        },
        "rotation": {
          "value": 0
        },
        "xMultiplier": {
          "value": 217.723
        },
        "yMultiplier": {
          "value": 157.966
        },
        "colorSpread": {
          "value": 0.001
        },
        "colorMultiplier": {
          "value": 0.863
        },
        "invert": {
          "value": true
        },
        "brightness": {
          "value": 1.636
        },
        "ballSize": {
          "value": 17.795
        },
        "glow": {
          "value": 0.714
        },
        "contrast": {
          "value": 2.278
        },
        "radius": {
          "value": 15.459
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e6",
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = k_uv();\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.008
        },
        "shapeMultiplier": {
          "value": 589.178
        },
        "rotation": {
          "value": 0.012
        },
        "xMultiplier": {
          "value": 251.592
        },
        "yMultiplier": {
          "value": 1549.9
        },
        "colorSpread": {
          "value": 0.000012
        },
        "colorMultiplier": {
          "value": 0.51
        },
        "invert": {
          "value": false
        },
        "brightness": {
          "value": 1.86
        },
        "ballSize": {
          "value": 6.194
        },
        "glow": {
          "value": 4.435
        },
        "contrast": {
          "value": 3.189
        },
        "radius": {
          "value": 10.691
        },
        "zoom2": {
          "value": 0.48
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e7",
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.177
        },
        "xMultiplier": {
          "value": 20.37
        },
        "yMultiplier": {
          "value": 44.741
        },
        "ballSize": {
          "value": 2.769
        },
        "colorSpread": {
          "value": 1.681
        },
        "colorMultiplier": {
          "value": 71.815
        },
        "shapeMultiplier": {
          "value": 76.571
        },
        "glow": {
          "value": 4786.254
        },
        "contrast": {
          "value": 3.473
        },
        "brightness": {
          "value": 10.92
        },
        "center": {
          "value": 0
        },
        "granularity": {
          "value": 22
        },
        "radius": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e8",
    "shader": "#define BALLS 5\n\nvoid main() {\n  float stream = stream / 3.2718;\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * sin(PI * float(1 + i)) + stream / rotationFactor * dist / rot2);\n    float t = float(i) * PI / float(BALLS) / divider;\n    float a = cos(float(i) * dist - uv.x/xDiv2);\n    float b = radius * sin(t) * sinMul * cos(stream*rotationSpeed + uv.x/wap + sin(uv.y / yDiv2));\n    float c = sin(uv.y / yDiv);\n    float x = xOuter - a * uv.x / dist * PI + b;\n    float y = radius * cos(dist + yOuter * uv.x / xDiv + t + yMultiplier - stream/.251);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(c + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/colorSpeed)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 6.404439730457706
        },
        "ballSize": {
          "value": 1.4751218196831208
        },
        "contrast": {
          "value": 2.15
        },
        "radius": {
          "value": 4.88
        },
        "yOuter": {
          "value": 1.5
        },
        "xOuter": {
          "value": 6.71
        },
        "mirror": {
          "value": true
        },
        "xMultiplier": {
          "value": 0.65
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 28
        },
        "rotation": {
          "value": 0
        },
        "xDiv": {
          "value": 30.19
        },
        "colorSpeed": {
          "value": 64.79
        },
        "rotationSpeed": {
          "value": 1.75
        },
        "yDiv": {
          "value": 28.3
        },
        "sinMul": {
          "value": 330.32
        },
        "xDiv2": {
          "value": 1
        },
        "rotationFactor": {
          "value": 87.67
        },
        "rot2": {
          "value": 1112
        },
        "yDiv2": {
          "value": 9.81
        },
        "wap": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 8.768
        },
        "ballSize": {
          "value": 29.087
        },
        "contrast": {
          "value": 2.15
        },
        "radius": {
          "value": 18.114
        },
        "yOuter": {
          "value": 2.31
        },
        "xOuter": {
          "value": 6.981
        },
        "mirror": {
          "value": true
        },
        "xMultiplier": {
          "value": 0.74
        },
        "yMultiplier": {
          "value": 1.881
        },
        "divider": {
          "value": 20.309
        },
        "rotation": {
          "value": 0
        },
        "xDiv": {
          "value": 4.51
        },
        "colorSpeed": {
          "value": 64.79
        },
        "rotationSpeed": {
          "value": 1.75
        },
        "yDiv": {
          "value": 10.09
        },
        "sinMul": {
          "value": 330.32
        },
        "xDiv2": {
          "value": 1.17
        },
        "rotationFactor": {
          "value": 87.67
        },
        "rot2": {
          "value": 1112
        },
        "yDiv2": {
          "value": 9.81
        },
        "wap": {
          "value": 2
        }
      },
      {
        "zoom": {
          "value": 30.768
        },
        "ballSize": {
          "value": 25.846
        },
        "contrast": {
          "value": 2.088
        },
        "radius": {
          "value": 30.748
        },
        "yOuter": {
          "value": 1.5
        },
        "xOuter": {
          "value": 6.71
        },
        "mirror": {
          "value": true
        },
        "xMultiplier": {
          "value": 0.65
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 0.433
        },
        "rotation": {
          "value": 0
        },
        "xDiv": {
          "value": 30.19
        },
        "colorSpeed": {
          "value": 12.49
        },
        "rotationSpeed": {
          "value": 1.67
        },
        "yDiv": {
          "value": 28.3
        },
        "sinMul": {
          "value": 330.32
        },
        "xDiv2": {
          "value": 1
        },
        "rotationFactor": {
          "value": 108.54
        },
        "rot2": {
          "value": 1112
        },
        "yDiv2": {
          "value": 9.81
        },
        "wap": {
          "value": 8.43
        }
      },
      {
        "zoom": {
          "value": 11.833
        },
        "ballSize": {
          "value": 15.769
        },
        "contrast": {
          "value": 2.15
        },
        "radius": {
          "value": 4.88
        },
        "yOuter": {
          "value": 1.5
        },
        "xOuter": {
          "value": 6.71
        },
        "mirror": {
          "value": true
        },
        "xMultiplier": {
          "value": 0.65
        },
        "yMultiplier": {
          "value": 4.84
        },
        "divider": {
          "value": 28
        },
        "rotation": {
          "value": 0
        },
        "xDiv": {
          "value": 30.19
        },
        "colorSpeed": {
          "value": 64.79
        },
        "rotationSpeed": {
          "value": 1.75
        },
        "yDiv": {
          "value": 28.3
        },
        "sinMul": {
          "value": 330.32
        },
        "xDiv2": {
          "value": 1
        },
        "rotationFactor": {
          "value": 87.67
        },
        "rot2": {
          "value": 1112
        },
        "yDiv2": {
          "value": 9.81
        },
        "wap": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8e9",
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (vUv/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.52
        },
        "thickness": {
          "value": 0.0028
        },
        "haze": {
          "value": 2
        },
        "col1": {
          "value": [0.9529411764705882, 0.9137254901960784, 0.3686274509803922]
        },
        "col2": {
          "value": [0.12156862745098039, 0.8235294117647058, 1]
        },
        "col3": {
          "value": [0, 1, 0.06666666666666667]
        },
        "size": {
          "value": 0.005
        },
        "a": {
          "value": 24.47
        },
        "b": {
          "value": 4.95
        },
        "c": {
          "value": 11.59
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ea",
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *=k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 27.87
        },
        "yDivider": {
          "value": 187.19
        },
        "xDivider": {
          "value": 130.77
        },
        "multiplier": {
          "value": 583.53
        },
        "ballSize": {
          "value": 1.8
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 19.36
        },
        "yOuter": {
          "value": 0.42
        },
        "xOuter": {
          "value": 0.42
        },
        "rotation": {
          "value": 0.58
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ec",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom / 1.5;\n  float stream = stream / 5.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/13.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream/.4), uv));\n  uv *= k_rotate2d(stream/1.5);\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 4.2));\n    float y = radius * cos((t));\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .25) * uv.y * .02 * dist + orbSize*1.5* pow(volume, .5), position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.222483
        },
        "contrast": {
          "value": 2.19
        },
        "orbSize": {
          "value": 0.573
        },
        "radius": {
          "value": 2.499
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 3.248
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.449923
        },
        "sinMul": {
          "value": 5.834043
        }
      },
      {
        "zoom": {
          "value": 7.411
        },
        "contrast": {
          "value": 2.490571
        },
        "orbSize": {
          "value": 0.284351
        },
        "radius": {
          "value": 1.45411
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 1.982842
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.6
        },
        "sinMul": {
          "value": 2.761415
        }
      },
      {
        "zoom": {
          "value": 8.535869
        },
        "contrast": {
          "value": 2.544121
        },
        "orbSize": {
          "value": 0.76
        },
        "radius": {
          "value": 3.52
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 0.586818
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.219598
        },
        "sinMul": {
          "value": 3.851995
        }
      },
      {
        "zoom": {
          "value": 1.935531
        },
        "contrast": {
          "value": 2.591991
        },
        "orbSize": {
          "value": 0.369118
        },
        "radius": {
          "value": 2.299153
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 0.760752
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.6
        },
        "sinMul": {
          "value": 11.975028
        }
      },
      {
        "zoom": {
          "value": 12.832807
        },
        "contrast": {
          "value": 2.591991
        },
        "orbSize": {
          "value": 0.694402
        },
        "radius": {
          "value": 0.893505
        },
        "colorShift": {
          "value": 9.38
        },
        "center": {
          "value": 4.290152
        },
        "sides": {
          "value": 6
        },
        "dotMul": {
          "value": 0.387826
        },
        "sinMul": {
          "value": 4.995423
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8eb",
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * vUv / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * vUv / resolution.xy).x), cos((-1. + 2. * vUv / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 3.135
        },
        "iterator": {
          "value": 1.071
        },
        "ot": {
          "value": 63.521
        },
        "I": {
          "value": 2.264
        },
        "J": {
          "value": 1.356
        },
        "K": {
          "value": 3.881
        },
        "iterations": {
          "value": 18.705
        },
        "L": {
          "value": 0.651
        },
        "M": {
          "value": 9.278
        },
        "colorShift": {
          "value": 0.676
        },
        "colorOffset": {
          "value": 0.5
        },
        "contrast": {
          "value": 1.676
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ed",
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .6) * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.32
        },
        "contrast": {
          "value": 0.656
        },
        "orbSize": {
          "value": 1.488
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 0.962
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.43
        },
        "colorOffset": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 0.307
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 2.979
        },
        "colorShift": {
          "value": 0
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.94
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 4.12
        }
      },
      {
        "zoom": {
          "value": 0.145
        },
        "contrast": {
          "value": 1.35
        },
        "orbSize": {
          "value": 8.789
        },
        "radius": {
          "value": 0
        },
        "colorShift": {
          "value": 1.277
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 5
        },
        "b": {
          "value": 0.19
        },
        "c": {
          "value": 1.77
        },
        "d": {
          "value": 0.47
        },
        "colorOffset": {
          "value": 2.06
        }
      },
      {
        "zoom": {
          "value": 1
        },
        "contrast": {
          "value": 1.358
        },
        "orbSize": {
          "value": 5.006
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.994
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0.56
        },
        "c": {
          "value": 0.8
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      },
      {
        "zoom": {
          "value": 0.089
        },
        "contrast": {
          "value": 0.617
        },
        "orbSize": {
          "value": 0.993
        },
        "radius": {
          "value": 8.327
        },
        "colorShift": {
          "value": 0.227
        },
        "orbs": {
          "value": 16
        },
        "a": {
          "value": 1.64
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 0
        },
        "d": {
          "value": 0.66
        },
        "colorOffset": {
          "value": 9.29
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ee",
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = k_uv();\n          i *= zoom;\n\n    i *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      {
        "zoom": {
          "value": 0.024
        },
        "mul": {
          "value": 0.46
        },
        "rot": {
          "value": 489.87
        },
        "sub": {
          "value": 42.73
        },
        "A": {
          "value": 2.34
        },
        "B": {
          "value": 5.57
        },
        "C": {
          "value": 10.18
        },
        "D": {
          "value": 3.59
        },
        "dep": {
          "value": 0.11
        },
        "wap": {
          "value": 0.7
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8f0",
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      {
        "zoom": {
          "value": 20.93585278614458
        },
        "ballSize": {
          "value": 10
        },
        "contrast": {
          "value": 2.96
        },
        "radius": {
          "value": 32.010777484939766
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 21.24435240963856
        },
        "xMultiplier": {
          "value": 1.3759412650602412
        },
        "yMultiplier": {
          "value": 0.9386201054216868
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 2.778567394578314
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 3.170444277108434
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 28.778237951807235
        },
        "yOuter": {
          "value": 0.004550781250000001
        },
        "xOuter": {
          "value": 1
        },
        "xMultiplier": {
          "value": 2.145849021084338
        },
        "yMultiplier": {
          "value": 1.6400000000000003
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 33.7234092620482
        },
        "ballSize": {
          "value": 6.476543674698796
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 31.092338102409645
        },
        "yOuter": {
          "value": 0.0005304028614457833
        },
        "xOuter": {
          "value": 130.72176204819277
        },
        "xMultiplier": {
          "value": 1.1696630271084338
        },
        "yMultiplier": {
          "value": 1.1726844879518075
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 3.607210090361446
        }
      },
      {
        "zoom": {
          "value": 13.757765436746988
        },
        "ballSize": {
          "value": 6.476543674698796
        },
        "contrast": {
          "value": 5.053252070783133
        },
        "radius": {
          "value": 10.042356927710845
        },
        "yOuter": {
          "value": 0.011533635853503293
        },
        "xOuter": {
          "value": 18.25225903614458
        },
        "xMultiplier": {
          "value": 0.8655402861445785
        },
        "yMultiplier": {
          "value": 2
        },
        "divider": {
          "value": 1
        },
        "rotation": {
          "value": 0
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8ef",
    "shader": "void main () {\n  float stream =stream * 1.6;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.35424
        },
        "iterator": {
          "value": 1.07941
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.79378
        },
        "colorOffset": {
          "value": 29.16356
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.11947
        },
        "wave": {
          "value": 0.9217
        },
        "split": {
          "value": 7.46972
        }
      },
      {
        "zoom": {
          "value": 1.16404
        },
        "iterator": {
          "value": 0.92054
        },
        "iterations": {
          "value": 21.63525
        },
        "colorShift": {
          "value": 0.76422
        },
        "colorOffset": {
          "value": 19.50448
        },
        "contrast": {
          "value": 0.93552
        },
        "orbSize": {
          "value": 0.13542
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.43899
        },
        "wave": {
          "value": 1.61956
        },
        "split": {
          "value": 14.62046
        }
      },
      {
        "zoom": {
          "value": 0.5544239457831327
        },
        "iterator": {
          "value": 1.00471
        },
        "iterations": {
          "value": 16.31461
        },
        "colorShift": {
          "value": 0.33359
        },
        "colorOffset": {
          "value": 21.77581
        },
        "contrast": {
          "value": 1.21895
        },
        "orbSize": {
          "value": 0.04777
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 3.11627
        },
        "wave": {
          "value": 1.07795
        },
        "split": {
          "value": 33.59867
        }
      },
      {
        "zoom": {
          "value": 2.88861
        },
        "iterator": {
          "value": 0.80495
        },
        "iterations": {
          "value": 13.72489
        },
        "colorShift": {
          "value": 0.38237
        },
        "colorOffset": {
          "value": 15.97272
        },
        "contrast": {
          "value": 1.05403
        },
        "orbSize": {
          "value": 0.17637
        },
        "div": {
          "value": 1.37978
        },
        "radius": {
          "value": 4.26167
        },
        "wave": {
          "value": 1.11087
        },
        "split": {
          "value": 3.30232
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8db",
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 1.78
        },
        "ballSize": {
          "value": 0.811
        },
        "contrast": {
          "value": 6.18
        },
        "radius": {
          "value": 0.37
        },
        "yOuter": {
          "value": 0
        },
        "xOuter": {
          "value": 55.27
        },
        "mirror": {
          "value": false
        },
        "xMultiplier": {
          "value": 4.14
        },
        "yMultiplier": {
          "value": 5.19
        },
        "divider": {
          "value": 4
        },
        "rotation": {
          "value": 0.0576
        }
      }
    ]
  },
  {
    "_id": "66f297ad0265dcaccb28d8dd",
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 0.602
        },
        "radius": {
          "value": 1.82
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 7.68
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 2.982958668830698
        },
        "yDot": {
          "value": 2.59
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 0
        }
      },
      {
        "zoom": {
          "value": 10.141
        },
        "contrast": {
          "value": 1.6
        },
        "orbSize": {
          "value": 1.535
        },
        "radius": {
          "value": 5.629
        },
        "colorShift": {
          "value": 17.42
        },
        "center": {
          "value": 5.341
        },
        "sides": {
          "value": 6
        },
        "xDot": {
          "value": 1.211
        },
        "yDot": {
          "value": 0.554
        },
        "dotMul": {
          "value": 0.11973979612093022
        },
        "rotation": {
          "value": 6.332
        }
      }
    ]
  },
  {
    "_id": "66f2d825d00fe62bf834580f",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(11. * uv.y);\n    float y = .1 * sin(uv.y / 1.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 4.225
        },
        "contrast": {
          "value": 1.956
        },
        "orbSize": {
          "value": 0.273
        },
        "radius": {
          "value": 3.411
        },
        "colorShift": {
          "value": 13.36
        }
      }
    ]
  },
  {
    "_id": "66f2d891d00fe62bf8345819",
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(1. * uv.y);\n    float y = .1 * radius *sin(uv.y / 1.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      {
        "zoom": {
          "value": 24.063
        },
        "contrast": {
          "value": 1.715
        },
        "orbSize": {
          "value": 0.383
        },
        "radius": {
          "value": 12.952
        },
        "colorShift": {
          "value": 13.36
        }
      }
    ]
  },
  {
    "_id": "66f2e3499d4334d41427cb36",
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\n\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *=k_rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 31.948
        },
        "yDivider": {
          "value": 1.5
        },
        "xDivider": {
          "value": 0.9
        },
        "multiplier": {
          "value": 1.07475
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 17.01
        },
        "rotation": {
          "value": 0.08
        },
        "a": {
          "value": 0.13
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 2.33
        },
        "d": {
          "value": 0.63
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 20.68
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 0.49
        },
        "multiplier": {
          "value": 64
        },
        "ballSize": {
          "value": 1.1
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 6.19
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 3.3
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.84005370031426
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.119977205335353
        },
        "multiplier": {
          "value": 8.310778794401344
        },
        "ballSize": {
          "value": 1.6599921687041703
        },
        "contrast": {
          "value": 0.8500047547153251
        },
        "radius": {
          "value": 4.0500299267376345
        },
        "rotation": {
          "value": 0.17
        },
        "a": {
          "value": 0.11999832186517936
        },
        "b": {
          "value": 0
        },
        "c": {
          "value": 6.879949935644517
        },
        "d": {
          "value": 0.71
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 16.43
        },
        "yDivider": {
          "value": 3.47
        },
        "xDivider": {
          "value": 0.79
        },
        "multiplier": {
          "value": 0.83
        },
        "ballSize": {
          "value": 3.58
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 13.28
        },
        "rotation": {
          "value": 0.16
        },
        "a": {
          "value": 0.53
        },
        "b": {
          "value": 0.08
        },
        "c": {
          "value": 2.12
        },
        "d": {
          "value": 1.16
        },
        "e": {
          "value": 1
        }
      },
      {
        "zoom": {
          "value": 14.53
        },
        "yDivider": {
          "value": 19.63
        },
        "xDivider": {
          "value": 2.73
        },
        "multiplier": {
          "value": 5.73
        },
        "ballSize": {
          "value": 2.16
        },
        "contrast": {
          "value": 1.19
        },
        "radius": {
          "value": 0.18
        },
        "rotation": {
          "value": 0.03
        },
        "a": {
          "value": 0
        },
        "b": {
          "value": 1.56
        },
        "c": {
          "value": 7.05
        },
        "d": {
          "value": 1.29
        },
        "e": {
          "value": 0.94
        }
      }
    ]
  },
  {
    "_id": "66f2ead217196506820da40f",
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.33726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  uv = abs(uv);\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.1);\n    float c = radius * wave * sin(split * uv.x - (stream / -.0355));\n    float d = radius * wave * cos(split * uv.y  - (stream / .035));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, stream/.5 + length(uv/.2));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.267
        },
        "iterator": {
          "value": 1.5
        },
        "iterations": {
          "value": 1.412
        },
        "colorShift": {
          "value": 0.035
        },
        "colorOffset": {
          "value": 20.312
        },
        "contrast": {
          "value": 1.294
        },
        "orbSize": {
          "value": 4.34
        },
        "div": {
          "value": 14.233
        },
        "radius": {
          "value": 5.486
        },
        "wave": {
          "value": 17.67
        },
        "split": {
          "value": 500
        },
        "inner": {
          "value": 9689533.356
        },
        "outer": {
          "value": 2.616
        }
      }
    ]
  },
  {
    "_id": "66f2eb5517196506820da41c",
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = k_uv();\n   uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.33726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  uv = abs(uv);\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.1);\n    float c = radius * wave * sin(split * uv.x - (stream / -.0355));\n    float d = radius * wave * cos(split * uv.y  - (stream / .035));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, stream/.5 + length(uv/.2));\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.267
        },
        "iterator": {
          "value": 1.5
        },
        "iterations": {
          "value": 1.412
        },
        "colorShift": {
          "value": 0.035
        },
        "colorOffset": {
          "value": 20.312
        },
        "contrast": {
          "value": 1.294
        },
        "orbSize": {
          "value": 7.351
        },
        "div": {
          "value": 14.233
        },
        "radius": {
          "value": 5.486
        },
        "wave": {
          "value": 17.67
        },
        "split": {
          "value": 500
        },
        "inner": {
          "value": 9689533.356
        },
        "outer": {
          "value": 2.616
        }
      }
    ]
  },
  {
    "_id": "66f2ef2517196506820da429",
    "shader": "#define orbs 5.\n\nvoid main () {\n  float stream = stream / 30.;\n  vec2 uv = k_uv();\n   uv *= k_rotate2d(stream / .4);\n  uv /= dot(uv, uv);\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-.08));\n  uv -= 21212.5*tan(uv.x/zoom - stream/.28);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(- t*PI), radius*sin(t - stream/-.08));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.035- uv.y/(.9*y + .26*y*sin(stream/.3123))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*pow(volume, .4)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 402043.804
        },
        "ballSize": {
          "value": 100999.516
        },
        "contrast": {
          "value": 0.902
        },
        "radius": {
          "value": 15666547.614
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 31929999
        },
        "y": {
          "value": 40348628.99
        },
        "rotation": {
          "value": 0.014
        },
        "colorOffset": {
          "value": 326.72
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 100000
        },
        "div2": {
          "value": 1031881.214
        },
        "wad": {
          "value": 8.806
        },
        "woot": {
          "value": 0.223
        },
        "wat": {
          "value": 0.075
        },
        "wob": {
          "value": 61.937
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 50.949
        },
        "wave": {
          "value": 2.122
        },
        "aWave": {
          "value": 0.336
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66f2ef2a17196506820da42e",
    "shader": "#define orbs 5.\n\nvoid main () {\n  float stream = stream / 30.;\n  vec2 uv = k_uv();\n   uv *= k_rotate2d(stream / .4);\n  uv /= dot(uv, uv);\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-.08));\n  uv -= 21212.5*tan(uv.x/zoom - stream/.28);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(- t*PI), radius*sin(t - stream/-.08));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.035- uv.y/(.9*y + .26*y*sin(stream/.3123))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*pow(volume, .4)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 301487.844
        },
        "ballSize": {
          "value": 37126.406
        },
        "contrast": {
          "value": 0.902
        },
        "radius": {
          "value": 15666547.614
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 31929999
        },
        "y": {
          "value": 40348628.99
        },
        "rotation": {
          "value": 0.014
        },
        "colorOffset": {
          "value": 326.72
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 100000
        },
        "div2": {
          "value": 1031881.214
        },
        "wad": {
          "value": 8.806
        },
        "woot": {
          "value": 0.223
        },
        "wat": {
          "value": 0.075
        },
        "wob": {
          "value": 61.937
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 50.949
        },
        "wave": {
          "value": 2.122
        },
        "aWave": {
          "value": 0.336
        }
      }
    ]
  },
  {
    "_id": "66f2fc9a17196506820da498",
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream/33.) + stream/2.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x/2.));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-4.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 6.483
        },
        "contrast": {
          "value": 1.524
        },
        "orbSize": {
          "value": 1.692
        },
        "radius": {
          "value": 3.824
        },
        "colorShift": {
          "value": 5.092
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 6.1
        },
        "contrast": {
          "value": 1.38
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 6.06
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 7.54
        },
        "contrast": {
          "value": 1.17
        },
        "orbSize": {
          "value": 0.56
        },
        "radius": {
          "value": 5.64
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 87.57
        },
        "contrast": {
          "value": 0.75
        },
        "orbSize": {
          "value": 1
        },
        "radius": {
          "value": 23.9
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 6
        },
        "sides": {
          "value": 3
        }
      },
      {
        "zoom": {
          "value": 34.31
        },
        "contrast": {
          "value": 1.87
        },
        "orbSize": {
          "value": 5
        },
        "radius": {
          "value": 13.4
        },
        "colorShift": {
          "value": 7.26
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 30.99
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66f2fc9e17196506820da49d",
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = k_uv();\n   \n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream/33.) + stream/2.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x/2.));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-4.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      {
        "zoom": {
          "value": 6.197
        },
        "contrast": {
          "value": 1.682
        },
        "orbSize": {
          "value": 1.314
        },
        "radius": {
          "value": 7.257
        },
        "colorShift": {
          "value": 5.092
        },
        "mirror": {
          "value": false
        },
        "kaleidoscope": {
          "value": false
        },
        "center": {
          "value": 1
        },
        "sides": {
          "value": 3
        }
      }
    ]
  },
  {
    "_id": "66f2fd5b17196506820da4c2",
    "shader": "\n  #define orbs 20.\n\nvoid main () {\n  vec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor +=k_orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      {
        "zoom": {
          "value": 0.31
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.06
        },
        "contrast": {
          "value": 1.59
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 18.4
        },
        "colorShift": {
          "value": 10
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.14
        },
        "contrast": {
          "value": 1.46
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 12.69
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.62
        },
        "contrast": {
          "value": 1.5
        },
        "orbSize": {
          "value": 2.7
        },
        "radius": {
          "value": 10.4
        },
        "colorShift": {
          "value": 4.31
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 0
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": 1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0059
        },
        "yDivide": {
          "value": 0.43
        },
        "xDivide": {
          "value": 12.45
        },
        "mirror": {
          "value": false
        }
      },
      {
        "zoom": {
          "value": 0.05
        },
        "contrast": {
          "value": 1.68
        },
        "orbSize": {
          "value": 6.95
        },
        "radius": {
          "value": 55.15
        },
        "colorShift": {
          "value": 7.11
        },
        "sides": {
          "value": 7
        },
        "rotation": {
          "value": 0.66
        },
        "sinMul": {
          "value": 0
        },
        "cosMul": {
          "value": 1.09
        },
        "yMul": {
          "value": 0
        },
        "xMul": {
          "value": 0.26
        },
        "xSpeed": {
          "value": -1
        },
        "ySpeed": {
          "value": 1
        },
        "gloop": {
          "value": 0.0022
        },
        "yDivide": {
          "value": 3.33
        },
        "xDivide": {
          "value": 3.33
        },
        "mirror": {
          "value": false
        }
      }
    ]
  },
  {
    "_id": "66f2fe6a17196506820da4d5",
    "shader": "#define BALLS 45.\n\nvoid main() {\n  float stream = stream / 3.67950;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/8.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 30.; i < BALLS; i++) {\n    // uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * i * PI / BALLS * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .86)/3. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 248.939
        },
        "xDiv": {
          "value": 322.096
        },
        "yDiv": {
          "value": 486.62
        },
        "xDiv2": {
          "value": 80.919
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 26.013
        },
        "yDiv3": {
          "value": 26.786
        },
        "multiplier": {
          "value": 5.982
        },
        "ballSize": {
          "value": 52.287
        },
        "contrast": {
          "value": 1.688
        },
        "radius": {
          "value": 26.877
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 3.482
        },
        "yMul": {
          "value": 4.196
        }
      }
    ]
  },
  {
    "_id": "66f2fe7917196506820da4da",
    "shader": "#define BALLS 45.\n\nvoid main() {\n  float stream = stream / 3.67950;\n  vec2 uv = k_uv();\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/8.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 30.; i < BALLS; i++) {\n    // uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * i * PI / BALLS * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .86)/3. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 248.939
        },
        "xDiv": {
          "value": 322.096
        },
        "yDiv": {
          "value": 486.62
        },
        "xDiv2": {
          "value": 80.919
        },
        "yDiv2": {
          "value": 116.964
        },
        "xDiv3": {
          "value": 26.013
        },
        "yDiv3": {
          "value": 26.786
        },
        "multiplier": {
          "value": 5.982
        },
        "ballSize": {
          "value": 52.287
        },
        "contrast": {
          "value": 1.688
        },
        "radius": {
          "value": 26.877
        },
        "rotation": {
          "value": 0
        },
        "xMul": {
          "value": 3.482
        },
        "yMul": {
          "value": 4.196
        }
      }
    ]
  },
  {
    "_id": "66f2ff5417196506820da4ed",
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/1.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 391569.402
        },
        "ballSize": {
          "value": 58607.908
        },
        "contrast": {
          "value": 3.38
        },
        "radius": {
          "value": 21822654.66
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 133300768.7
        },
        "y": {
          "value": 7915426.66
        },
        "rotation": {
          "value": 0
        },
        "colorOffset": {
          "value": 96.5
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 39960.707
        },
        "div2": {
          "value": 916935.078
        },
        "wad": {
          "value": 3.154
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.315
        },
        "wob": {
          "value": 70.691
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 40.203
        },
        "wave": {
          "value": 2.717
        },
        "aWave": {
          "value": 0.1027
        }
      },
      {
        "zoom": {
          "value": 596124.912
        },
        "ballSize": {
          "value": 3560.215
        },
        "contrast": {
          "value": 2.09
        },
        "radius": {
          "value": 6722295.77
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 33874060.38
        },
        "y": {
          "value": 6846884.45
        },
        "rotation": {
          "value": 0.00133
        },
        "colorOffset": {
          "value": 64.84
        },
        "sides": {
          "value": 3
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 36465.301
        },
        "div2": {
          "value": 299012.772
        },
        "wad": {
          "value": 10.028
        },
        "woot": {
          "value": 0.176
        },
        "wat": {
          "value": 0.768
        },
        "wob": {
          "value": 37.173
        },
        "outer": {
          "value": 48.182
        },
        "outer2": {
          "value": 11.052
        },
        "wave": {
          "value": 1.743
        },
        "aWave": {
          "value": 0.1027
        }
      }
    ]
  },
  {
    "_id": "66f3010917196506820da4f5",
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 17.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 1.28);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/31.3 - t*PI), radius*tan(t - stream/-33.8));\n    p /= (cos(wad * cos(stream/.27 - uv.x/x))*sin(stream/-.29- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 419328.267
        },
        "ballSize": {
          "value": 9569.469
        },
        "contrast": {
          "value": 2.176
        },
        "radius": {
          "value": 3832855.202
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 129670504.048
        },
        "y": {
          "value": 6535949.534
        },
        "rotation": {
          "value": 0.006
        },
        "colorOffset": {
          "value": 451.118
        },
        "sides": {
          "value": 3.5
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 37429.995
        },
        "div2": {
          "value": 500328.954
        },
        "wad": {
          "value": 1.945
        },
        "woot": {
          "value": 0.132
        },
        "wat": {
          "value": 0.232
        },
        "wob": {
          "value": 39.916
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 65.295
        },
        "wave": {
          "value": 1.181
        },
        "aWave": {
          "value": 0.28
        }
      }
    ]
  },
  {
    "_id": "66f3011917196506820da4fe",
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 17.;\n  vec2 uv = k_uv();\n   uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 1.28);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/31.3 - t*PI), radius*tan(t - stream/-33.8));\n    p /= (cos(wad * cos(stream/.27 - uv.x/x))*sin(stream/-.29- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      {
        "zoom": {
          "value": 419328.267
        },
        "ballSize": {
          "value": 9569.469
        },
        "contrast": {
          "value": 2.176
        },
        "radius": {
          "value": 3832855.202
        },
        "mirror": {
          "value": false
        },
        "x": {
          "value": 129670504.048
        },
        "y": {
          "value": 6535949.534
        },
        "rotation": {
          "value": 0.006
        },
        "colorOffset": {
          "value": 451.118
        },
        "sides": {
          "value": 3.5
        },
        "kaleidoscope": {
          "value": false
        },
        "div": {
          "value": 37429.995
        },
        "div2": {
          "value": 500328.954
        },
        "wad": {
          "value": 1.945
        },
        "woot": {
          "value": 0.132
        },
        "wat": {
          "value": 0.232
        },
        "wob": {
          "value": 39.916
        },
        "outer": {
          "value": 133
        },
        "outer2": {
          "value": 65.295
        },
        "wave": {
          "value": 1.181
        },
        "aWave": {
          "value": 0.28
        }
      }
    ]
  },
  {
    "_id": "6705290d1ae1c8822992404c",
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.259535
        },
        "color": {
          "value": [0.4745098039215686, 0.44313725490196076, 0.9568627450980393]
        },
        "shift": {
          "value": 78.474472
        },
        "offset": {
          "value": 11.60847
        },
        "height": {
          "value": 9.688396
        },
        "xDiv": {
          "value": 17508.178034
        },
        "width": {
          "value": 0.000675
        },
        "stretch": {
          "value": 1.197543
        }
      }
    ]
  },
  {
    "_id": "670529961ae1c8822992404f",
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.259535
        },
        "color": {
          "value": [0.4745098039215686, 0.44313725490196076, 0.9568627450980393]
        },
        "shift": {
          "value": 78.474472
        },
        "offset": {
          "value": 11.60847
        },
        "height": {
          "value": 9.688396
        },
        "xDiv": {
          "value": 17508.178034
        },
        "width": {
          "value": 0.000675
        },
        "stretch": {
          "value": 1.197543
        }
      }
    ]
  },
  {
    "_id": "67052a341ae1c88229924052",
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.259535
        },
        "color": {
          "value": [0.4745098039215686, 0.44313725490196076, 0.9568627450980393]
        },
        "shift": {
          "value": 78.474472
        },
        "offset": {
          "value": 11.60847
        },
        "height": {
          "value": 9.688396
        },
        "xDiv": {
          "value": 17508.178034
        },
        "width": {
          "value": 0.000675
        },
        "stretch": {
          "value": 1.197543
        }
      }
    ]
  },
  {
    "_id": "6737ea21d249204f58003f97",
    "shader": "void main() {\nvec2 uv = k_uv();\nuv *=  zoom;//(zoom * cos(stream/5000.) + zoom);\nvec2 frac = abs(fract(uv) - .5) * 1.;\nuv *= k_rotate2d(stream/-3.);\nfloat dist = distance(uv, vec2(0.));\nvec2 rotated = uv * k_rotate2d(dist/210. * stream/22.);\nvec2 rotated2 = uv * k_rotate2d(dist/100. + stream/4.);// * sin(uv.x) * cos(uv.y);\nuv *= k_rotate2d(stream/2.);\nuv = mix(rotated, rotated2, cos(dist - stream/5.5));\nuv = k_kale(uv, vec2(0), sides);\n// uv /= atan(dot(uv, uv));\nvec4 result = vec4(0, 0, 0, 1);\nfloat t = 0.;\nfloat base = 1. * atan(length(uv));\nfor (int p = 0; p < 3; p++) {\n    uv *= k_rotate2d(stream/15.);\n  float a = dist*cos((t * base) );\n  float b = cos(lines * uv.x / + dist);\n  result[p] = pMul * a + bMul  * b + base / 2.;\n  t += offset;\n}\nfloat col =  k_hue(result.xyxy, stream / 2.).g;\nresult.xyz *= brightness * log(result.x);\ngl_FragColor = result; \ngl_FragColor.r *= red;\ngl_FragColor.g *= green;\ngl_FragColor.b *= blue;\ngl_FragColor = k_hue(gl_FragColor, stream/1. - dist/4.); }",
    "variants": [
      {
        "zoom": {
          "value": 0.724369
        },
        "brightness": {
          "value": 4
        },
        "red": {
          "value": 0.219879
        },
        "green": {
          "value": 0.2
        },
        "blue": {
          "value": 0.25
        },
        "sides": {
          "value": 1
        },
        "offset": {
          "value": 1
        },
        "lines": {
          "value": 7.685157
        },
        "ySpread": {
          "value": 78.74546
        },
        "pMul": {
          "value": 2.395309
        },
        "bMul": {
          "value": 2.943299
        }
      }
    ]
  },
  {
    "_id": "6737f9bed249204f58003fc2",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "67ebbcd8c8ed129a42138550",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "67f34aa2ab0cc7f4153d3bcd",
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [
      {
        "zoom": {
          "value": 1
        }
      }
    ]
  },
  {
    "_id": "685391ef02fb9e6727d0298a",
    "shader": "void main () {\n  float stream = stream / 1.5; \nvec2 uv = k_uv();\n   uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (wob / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n    }\n  gl_FragColor.g *= .2;\n}",
    "variants": [
      {
        "zoom": {
          "value": 0.6347062999362257
        },
        "iterator": {
          "value": 9.545699904913453
        },
        "ot": {
          "value": 63.45670382482259
        },
        "I": {
          "value": 2.004611658162746
        },
        "J": {
          "value": 0.9292826277731768
        },
        "K": {
          "value": 1.7887850816908168
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 1.1279381425603259
        },
        "M": {
          "value": 0.43865731802863905
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 4.816923703081921
        },
        "contrast": {
          "value": 2.172935900983824
        },
        "orbSize": {
          "value": 1.3638092748249202
        },
        "div": {
          "value": 0.18712700275218697
        },
        "radius": {
          "value": 4.478964174125304
        },
        "wob": {
          "value": 0.027189022299892483
        }
      },
      {
        "zoom": {
          "value": 0.252383
        },
        "iterator": {
          "value": 7.569259349233938
        },
        "ot": {
          "value": 77.22702061398316
        },
        "I": {
          "value": 2.5421969305949066
        },
        "J": {
          "value": 2.3204582724811766
        },
        "K": {
          "value": 10.66774605644863
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.4078496791886295
        },
        "M": {
          "value": 0.49353160809578367
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 5.7879599494522385
        },
        "contrast": {
          "value": 1.72852776965142
        },
        "orbSize": {
          "value": 2
        },
        "div": {
          "value": 0.08027884559708552
        },
        "radius": {
          "value": 3.306594
        },
        "wob": {
          "value": 0.09822452407689686
        }
      },
      {
        "zoom": {
          "value": 0.5518645466466255
        },
        "iterator": {
          "value": 9.345306061754322
        },
        "ot": {
          "value": 76.95672847031916
        },
        "I": {
          "value": 2.0299764684706196
        },
        "J": {
          "value": 0.5775865735935444
        },
        "K": {
          "value": 4.5782725349372235
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.5327226221179027
        },
        "M": {
          "value": 0.9855923008127525
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 7.124793907730577
        },
        "contrast": {
          "value": 1.8673261085401902
        },
        "orbSize": {
          "value": 1.6922743948115222
        },
        "div": {
          "value": 0.06848968434306733
        },
        "radius": {
          "value": 3.145716
        },
        "wob": {
          "value": 0.003
        }
      },
      {
        "zoom": {
          "value": 0.380322
        },
        "iterator": {
          "value": 9.218471677489154
        },
        "ot": {
          "value": 131.63249519716393
        },
        "I": {
          "value": 1.3802125534214826
        },
        "J": {
          "value": 1.395041179704047
        },
        "K": {
          "value": 2.951226237343881
        },
        "iterations": {
          "value": 0.485278
        },
        "L": {
          "value": 2.974272682393624
        },
        "M": {
          "value": 0.8482203936410846
        },
        "colorShift": {
          "value": 1.2714860957637544
        },
        "colorOffset": {
          "value": 8.985077800486769
        },
        "contrast": {
          "value": 1.87270215686231
        },
        "orbSize": {
          "value": 0.8984214901639822
        },
        "div": {
          "value": 0.07098858854079364
        },
        "radius": {
          "value": 7.968495755292857
        },
        "wob": {
          "value": 0.012046381298866725
        }
      }
    ]
  }
]
