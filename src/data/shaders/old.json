[
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e98"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.01227268448795181, 0, 0.1, false, false],
        ["iterator", 0, 1.1649585843373496, 0.7, 1.5, false, false],
        ["iterations", 0, 33, 0, 33, false, false],
        ["colorShift", 0, 95.97937217620483, 0, 111, false, false],
        ["colorOffset", 0, 27.55784073795181, 15, 30, false, false],
        ["contrast", 0, 2.532153614457832, 0, 3, false, false],
        ["orbSize", 0, 56.92372716244819, 0, 133, false, false],
        ["div", 0, 329.4535185899849, 0.01, 333, false, false],
        ["radius", 0, 78.15404743975904, 0, 212, false, false],
        ["wave", 0, 1081.757605421687, 0, 1333, false, false],
        ["split", 0, 14.857868975903617, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb5"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .47)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 34.157784262048196, 0, 111, false, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 2.33, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.68, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 0.49, 0.1, 19, false, false],
        ["multiplier", 0, 64, 0.01, 64, false, false],
        ["ballSize", 0, 1.1, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 6.19, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84005370031426, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.119977205335353, 0.1, 19, false, false],
        ["multiplier", 0, 8.310778794401344, 0.01, 64, false, false],
        ["ballSize", 0, 1.6599921687041703, 0, 11, false, false],
        ["contrast", 0, 0.8500047547153251, 0, 5, false, false],
        ["radius", 0, 4.0500299267376345, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.11999832186517936, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.879949935644517, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ebe"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/2.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/5. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 17.4867, 0, 50, false],
        ["ballSize", 0, 16.60383, 2, 30, false],
        ["contrast", 0, 3.05951, 0, 15, false],
        ["radius", 0, 44.22667, 0, 90, false],
        ["yOuter", 0, 0.0136, 0, 0.05, false],
        ["xOuter", 0, 13.50143, 1, 241, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.09265, 0, 10, false],
        ["yMultiplier", 0, 1.6046, 0.2, 2, false],
        ["divider", 0, 1, 1, 2230, false],
        ["rotation", 0, 2.65104, 0, 5, false]
      ],
      [
        ["zoom", 0, 10.799115478202873, 0, 50, false, false],
        ["ballSize", 0, 2, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 5, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 4,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed1"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv)), radius*\n                  cos(- yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 50, 0, 50, false, false],
        ["ballSize", 0, 5.644772596244353, 2, 20, false, false],
        ["contrast", 0, 2.0819725358342556, 0, 15, false, false],
        ["radius", 0, 101.77377080342856, 0, 350, false, false],
        ["yOuter", 0, 0.0057841932917215766, 0, 1, false, false],
        ["xOuter", 0, 1.3756925605865846, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.6530241908797301, 0, 10, false, false],
        ["yMultiplier", 0, 1.1673474157861918, 0.2, 2, false, false],
        ["divider", 0, 0.8504663674228163, 0, 2, false, false],
        ["rotation", 0, 0.4485766399337586, 0, 5, false, false],
        ["yDiv", 0, 527.8882773525744, 0, 2210, false, false],
        ["yDiv2", 0, 23.835829475127074, 0, 112, false, false],
        ["xDiv", 0, 0.26825157533209015, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 45.44008038991905, 0, 190, false, false],
        ["ballSize", 0, 10.514816946006684, 2, 20, false, false],
        ["contrast", 0, 4.8104031880222715, 0, 15, false, false],
        ["radius", 0, 211.61748679287467, 0, 350, false, false],
        ["yOuter", 0, 0.018582703004400417, 0, 0.1, false, false],
        ["xOuter", 0, 1.4502035669533604, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.12136745223079821, 0, 1, false, false],
        ["yMultiplier", 0, 0.5327326946947949, 0.2, 2, false, false],
        ["divider", 0, 0.6384254187406873, 0, 2, false, false],
        ["rotation", 0, 1.2509849961981718, 0, 5, false, false],
        ["yDiv", 0, 11.422082832060672, 0, 2210, false, false],
        ["yDiv2", 0, 17.16405588173005, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 66.1722807367164, 0, 90, false, false],
        ["ballSize", 0, 12.605021134342056, 2, 20, false, false],
        ["contrast", 0, 2.4117830575230617, 0, 15, false, false],
        ["radius", 0, 190.85365479250993, 0, 350, false, false],
        ["yOuter", 0, 0, 0, 1, false, false],
        ["xOuter", 0, 1.3054196874779391, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.005347911421074928, 0, 1, false, false],
        ["yMultiplier", 0, 0.9057663515389685, 0.2, 2, false, false],
        ["divider", 0, 0.3392575735069184, 0, 2, false, false],
        ["rotation", 0, 1.523927619658321, 0, 5, false, false],
        ["yDiv", 0, 767.1698688597661, 0, 2210, false, false],
        ["yDiv2", 0, 40.448379112151734, 0, 112, false, false],
        ["xDiv", 0, 0.2818832948983434, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb2"
    },
    "shader": "\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.418, 1, 13, false, false],
        ["iterator", 0, 1.014, 0.7, 1.5, false, false],
        ["iterations", 0, 18, 0, 33, false, false],
        ["colorShift", 0, 0.266, 0, 1, false, false],
        ["colorOffset", 0, 25.265, 15, 30, false, false],
        ["contrast", 0, 0.831, 0, 3, false, false],
        ["orbSize", 0, 10.426, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 73.725, 0, 212, false, false],
        ["wave", 0, 1222, 0, 1222, false, false],
        ["split", 0, 5.288, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 12.26, 1, 13, false, false],
        ["iterator", 0, 1.079, 0.7, 1.5, false, false],
        ["iterations", 0, 15, 0, 33, false, false],
        ["colorShift", 0, 0.271, 0, 1, false, false],
        ["colorOffset", 0, 18.968, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false, false],
        ["orbSize", 0, 5.174, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 32.407, 0, 212, false, false],
        ["wave", 0, 0, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 8.452, 1, 13, false, false],
        ["iterator", 0, 0.978, 0.7, 1.5, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["colorShift", 0, 0.352, 0, 1, false, false],
        ["colorOffset", 0, 17.673, 15, 30, false, false],
        ["contrast", 0, 1.146, 0, 3, false, false],
        ["orbSize", 0, 26.704, 0, 37, false, false],
        ["div", 0, 3.174, 0.01, 15, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 865.131, 0, 1333, false, false],
        ["split", 0, 17.958, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb9"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 34.157784262048196, 0, 111, false, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 2.33, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.68, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 0.49, 0.1, 19, false, false],
        ["multiplier", 0, 64, 0.01, 64, false, false],
        ["ballSize", 0, 1.1, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 6.19, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.12, 0.1, 19, false, false],
        ["multiplier", 0, 8.31, 0.01, 64, false, false],
        ["ballSize", 0, 1.66, 0, 11, false, false],
        ["contrast", 0, 0.85, 0, 5, false, false],
        ["radius", 0, 4.05, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.12, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.88, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9a"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -3.);\n  uv = abs(uv);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0012443524096385546, 0, 0.1, false, false],
        ["iterator", 0, 0.7577447289156627, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 48.10121893825301, 0, 111, false, false],
        ["colorOffset", 0, 18.446018448795183, 15, 30, false, false],
        ["contrast", 0, 1.693994728915663, 0, 3, false, false],
        ["orbSize", 0, 701.3161285768074, 0, 1121, false, false],
        ["div", 0, 329.4535185899849, 0.01, 333, false, false],
        ["radius", 0, 212, 0, 212, false, false],
        ["wave", 0, 1333, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 0.0012968320198683304, 0, 0.1, false, false],
        ["iterator", 0, 0.8880798192771083, 0.7, 1.5, false, false],
        ["iterations", 0, 20.03311841114458, 0, 33, false, false],
        ["colorShift", 0, 63.033107943787634, 0, 111, false, false],
        ["colorOffset", 0, 29.441665097891565, 15, 30, false, false],
        ["contrast", 0, 2.379245105421687, 0, 3, false, false],
        ["orbSize", 0, 242.2608669051205, 0, 1133, false, false],
        ["div", 0, 333, 0.01, 333, false, false],
        ["radius", 0, 98.25054593373497, 0, 212, false, false],
        ["wave", 0, 309.7205534731702, 0, 333, false, false],
        ["split", 0, 59.95820783132531, 0, 240, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec0"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 4.641638929691454, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 12.163733057228916, 0, 50, false, false],
        ["ballSize", 0, 5, 2, 5, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 60.4480421686747, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 0.4060146837349398, 0, 2, false, false],
        ["rotation", 0, 0.3975432981927712, 0, 5, false, false],
        ["yDiv", 0, 5.762471762048194, 0, 110, false, false],
        ["yDiv2", 0, 4.357078313253012, 0, 112, false, false],
        ["xDiv", 0, 0.7352974397590362, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed5"
    },
    "shader": "void main () {\n  float stream = stream  /16.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/-3.);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/1.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/fuck-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (200.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 6.38083793915898, 0, 22, false, false],
        ["ballSize", 0, 4.262981598635755, 0, 55, false, false],
        ["contrast", 0, 2.5889260165662655, 0, 15, false, false],
        ["radius", 0, 4.875361982598363, 0, 34, false, false],
        ["yOuter", 0, 1.3027315438511862, 0, 3, false, false],
        ["xOuter", 0, 21.918668080525233, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.2610395500458869, 0, 10, false, false],
        ["yMultiplier", 0, 0.5742157625864788, 0, 10, false, false],
        ["divider", 0, 3.949900420315295, 0, 50, false, false],
        ["rotation", 0, 2.962652091520379, 0, 5, false, false],
        ["fuck", 0, 1.4575311499905876, 0, 2, false, false],
        ["xDiv", 0, 4.871233395496048, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e97"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.006632153614457834, 0, 0.1, false, false],
        ["iterator", 0, 1.5, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 48.10121893825301, 0, 111, false, false],
        ["colorOffset", 0, 18.446018448795183, 15, 30, false, false],
        ["contrast", 0, 2.025352974397591, 0, 3, false, false],
        ["orbSize", 0, 171.06751223644582, 0, 1121, false, false],
        ["div", 0, 1022.0045497458585, 0.01, 1333, false, false],
        ["radius", 0, 73.36788403614459, 0, 212, false, false],
        ["wave", 0, 959.7436888177713, 0, 1333, false, false],
        ["split", 0, 9.479103915662652, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec5"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 18.764354292168676, 0, 50, false, false],
        ["ballSize", 0, 30.02166792168675, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 48.605751129518076, 0, 250, false, false],
        ["yOuter", 0, 0.28322665662650603, -1, 4, false, false],
        ["xOuter", 0, 81.74359939759037, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.788685993975904, 0, 10, false, false],
        ["yMultiplier", 0, 2.4412114081325305, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 4.2250564759036155, 0, 5, false, false],
        ["yDiv", 0, 4.170557228915664, 0, 110, false, false],
        ["yDiv2", 0, 8.153840361445786, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed2"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream+xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv)), radius*\n                  cos(- yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 50, 0, 50, false, false],
        ["ballSize", 0, 5.644772596244353, 2, 20, false, false],
        ["contrast", 0, 2.0819725358342556, 0, 15, false, false],
        ["radius", 0, 101.77377080342856, 0, 350, false, false],
        ["yOuter", 0, 0.0057841932917215766, 0, 1, false, false],
        ["xOuter", 0, 1.3756925605865846, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.6530241908797301, 0, 10, false, false],
        ["yMultiplier", 0, 1.1673474157861918, 0.2, 2, false, false],
        ["divider", 0, 0.8504663674228163, 0, 2, false, false],
        ["rotation", 0, 0.4485766399337586, 0, 5, false, false],
        ["yDiv", 0, 527.8882773525744, 0, 2210, false, false],
        ["yDiv2", 0, 23.835829475127074, 0, 112, false, false],
        ["xDiv", 0, 0.26825157533209015, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 45.44008038991905, 0, 190, false, false],
        ["ballSize", 0, 3.7502623776355426, 2, 20, false, false],
        ["contrast", 0, 2.0365335625338274, 0, 15, false, false],
        ["radius", 0, 182.3945488987199, 0, 350, false, false],
        ["yOuter", 0, 0.018582703004400417, 0, 0.1, false, false],
        ["xOuter", 0, 1.4502035669533604, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.12136745223079821, 0, 1, false, false],
        ["yMultiplier", 0, 0.5327326946947949, 0.2, 2, false, false],
        ["divider", 0, 0.6384254187406873, 0, 2, false, false],
        ["rotation", 0, 1.2509849961981718, 0, 5, false, false],
        ["yDiv", 0, 11.422082832060672, 0, 2210, false, false],
        ["yDiv2", 0, 17.16405588173005, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 66.1722807367164, 0, 90, false, false],
        ["ballSize", 0, 12.605021134342056, 2, 20, false, false],
        ["contrast", 0, 2.4117830575230617, 0, 15, false, false],
        ["radius", 0, 190.85365479250993, 0, 350, false, false],
        ["yOuter", 0, 0, 0, 1, false, false],
        ["xOuter", 0, 1.3054196874779391, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.005347911421074928, 0, 1, false, false],
        ["yMultiplier", 0, 0.9057663515389685, 0.2, 2, false, false],
        ["divider", 0, 0.3392575735069184, 0, 2, false, false],
        ["rotation", 0, 1.523927619658321, 0, 5, false, false],
        ["yDiv", 0, 767.1698688597661, 0, 2210, false, false],
        ["yDiv2", 0, 40.448379112151734, 0, 112, false, false],
        ["xDiv", 0, 0.2818832948983434, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 29.53490475574172, 0, 1190, false, false],
        ["ballSize", 0, 18.763334894754802, 2, 20, false, false],
        ["contrast", 0, 2.4117830575230617, 0, 15, false, false],
        ["radius", 0, 6.786545213446561, 0, 350, false, false],
        ["yOuter", 0, 0.18734175900378863, 0, 1, false, false],
        ["xOuter", 0, 2.0486279499099918, 1, 4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.0833488556275885, 0, 1, false, false],
        ["yMultiplier", 0, 0.037316765842667556, 0, 2, false, false],
        ["divider", 0, 0.3392575735069184, 0, 2, false, false],
        ["rotation", 0, 0.6698602883212539, 0, 5, false, false],
        ["yDiv", 0, 537.9855964384884, 0, 2210, false, false],
        ["yDiv2", 0, 21.203650196489086, 0, 112, false, false],
        ["xDiv", 0, 0.41686075968914726, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea1"
    },
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -15.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-3.21605);\n    float d = radius * wave * cos(split * uv.y  - stream /0.346);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.)/1. * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6465079066265061, 0, 3, false, false],
        ["iterator", 0, 1.3677409638554219, 0.7, 1.5, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 1.5186370481927711, 0, 3, false, false],
        ["colorOffset", 0, 18.31640625, 15, 30, false, false],
        ["contrast", 0, 1.1740634412650603, 0, 3, false, false],
        ["orbSize", 0, 0.5971385542168676, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.226694277108434, 0, 6, false, false],
        ["wave", 0, 0.6340361445783134, 0, 20, false, false],
        ["split", 0, 15.149849397590366, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 1.8872270331325305, 0, 3, false, false],
        ["iterator", 0, 1.2201590737951808, 0.7, 2, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 0.5885212725903615, 0, 3, false, false],
        ["colorOffset", 0, 20.50647119728916, 15, 30, false, false],
        ["contrast", 0, 1.3051157756024097, 0, 3, false, false],
        ["orbSize", 0, 1, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.707699548192772, 0, 6, false, false],
        ["wave", 0, 1.2741905120481931, 0, 20, false, false],
        ["split", 0, 2.777334337349398, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 0.20455572289156632, 0, 3, false, false],
        ["iterator", 0, 2.0409450301204823, 0.7, 3, false, false],
        ["iterations", 0, 7.585899849397592, 0, 33, false, false],
        ["colorShift", 0, 6.072355045180723, 0, 23, false, false],
        ["colorOffset", 0, 16.54249811746988, 15, 30, false, false],
        ["contrast", 0, 0.857741905120482, 0, 3, false, false],
        ["orbSize", 0, 0.19678087349397594, 0, 1, false, false],
        ["div", 0, 3.954046216114458, 0.01, 15, false, false],
        ["radius", 0, 4.343053463855423, 0, 6, false, false],
        ["wave", 0, 0.9644201807228918, 0, 20, false, false],
        ["split", 0, 15.434064382530124, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea2"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8.675150886158583, 1, 13, false, false],
        ["iterator", 0, 1.1274359939759038, 0.7, 1.5, false, false],
        ["iterations", 0, 7.958174887048194, 0, 33, false, false],
        ["colorShift", 0, 0.32937217619416226, 0, 1, false, false],
        ["colorOffset", 0, 15, 15, 30, false, false],
        ["contrast", 0, 0.831, 0, 3, false, false],
        ["orbSize", 0, 25.7765389683735, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 73.725, 0, 212, false, false],
        ["wave", 0, 197.5915568524097, 0, 1222, false, false],
        ["split", 0, 6.847326807228917, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 1.93, 1, 13, false, false],
        ["iterator", 0, 1.079, 0.7, 1.5, false, false],
        ["iterations", 0, 15, 0, 33, false, false],
        ["colorShift", 0, 0.271, 0, 1, false, false],
        ["colorOffset", 0, 18.968, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false, false],
        ["orbSize", 0, 5.174, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 32.407, 0, 212, false, false],
        ["wave", 0, 0, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 8.452, 1, 13, false, false],
        ["iterator", 0, 0.978, 0.7, 1.5, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["colorShift", 0, 0.352, 0, 1, false, false],
        ["colorOffset", 0, 17.673, 15, 30, false, false],
        ["contrast", 0, 1.146, 0, 3, false, false],
        ["orbSize", 0, 26.704, 0, 37, false, false],
        ["div", 0, 3.174, 0.01, 15, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 865.131, 0, 1333, false, false],
        ["split", 0, 17.958, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea5"
    },
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 0.6);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6465079066265061, 0, 3, false, false],
        ["iterator", 0, 1.3677409638554219, 0.7, 1.5, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 1.5186370481927711, 0, 3, false, false],
        ["colorOffset", 0, 18.31640625, 15, 30, false, false],
        ["contrast", 0, 1.1740634412650603, 0, 3, false, false],
        ["orbSize", 0, 0.5971385542168676, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.226694277108434, 0, 6, false, false],
        ["wave", 0, 0.6340361445783134, 0, 20, false, false],
        ["split", 0, 15.149849397590366, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 1.8872270331325305, 0, 3, false, false],
        ["iterator", 0, 1.2201590737951808, 0.7, 2, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 0.5885212725903615, 0, 3, false, false],
        ["colorOffset", 0, 20.50647119728916, 15, 30, false, false],
        ["contrast", 0, 1.3051157756024097, 0, 3, false, false],
        ["orbSize", 0, 1, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.707699548192772, 0, 6, false, false],
        ["wave", 0, 1.2741905120481931, 0, 20, false, false],
        ["split", 0, 2.777334337349398, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 0.9513930722891566, 0, 3, false, false],
        ["iterator", 0, 1.823339137801205, 0.7, 3, false, false],
        ["iterations", 0, 27.0210796310241, 0, 33, false, false],
        ["colorShift", 0, 0, 0, 23, false, false],
        ["colorOffset", 0, 26.667286332831328, 15, 30, false, false],
        ["contrast", 0, 1.1627470948138394, 0, 3, false, false],
        ["orbSize", 0, 0.3594597138554217, 0, 1, false, false],
        ["div", 0, 5.113429028614458, 0.01, 15, false, false],
        ["radius", 0, 4.177099021084338, 0, 6, false, false],
        ["wave", 0, 0.7246799698795182, 0, 20, false, false],
        ["split", 0, 4.043100527108434, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb1"
    },
    "shader": "\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 14.886, 1, 213, false, false],
        ["iterator", 0, 1.006, 0.7, 1.5, false, false],
        ["iterations", 0, 26, 0, 33, false, false],
        ["colorShift", 0, 0.07, 0, 1, false, false],
        ["colorOffset", 0, 28.499, 15, 30, false, false],
        ["contrast", 0, 1.146, 0, 3, false, false],
        ["orbSize", 0, 239.719, 0, 337, false, false],
        ["div", 0, 8.811, 0.01, 15, false, false],
        ["radius", 0, 50.228, 0, 212, false, false],
        ["wave", 0, 651.105, 0, 1333, false, false],
        ["split", 0, 21.39, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb4"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/2.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 34.157784262048196, 0, 111, false, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 2.33, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 18.95431570030121, 0, 111, false, false],
        ["yDivider", 0, 25.59162509412651, 0.1, 32, false, false],
        ["xDivider", 0, 0.6188427146084339, 0.1, 19, false, false],
        ["multiplier", 0, 6.285826477786146, 0.01, 64, false, false],
        ["ballSize", 0, 1.5564006024096386, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 12.120933734939761, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.36300357680722894, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.7258377259036145, 0, 2, false, false],
        ["e", 0, 0.04823983433734941, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84005370031426, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.119977205335353, 0.1, 19, false, false],
        ["multiplier", 0, 8.310778794401344, 0.01, 64, false, false],
        ["ballSize", 0, 1.6599921687041703, 0, 11, false, false],
        ["contrast", 0, 0.8500047547153251, 0, 5, false, false],
        ["radius", 0, 4.0500299267376345, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.11999832186517936, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.879949935644517, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec4"
    },
    "shader": "void main () {\n  float stream = stream/4. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume,.5)* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 2.3806736222232683, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ecd"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/5.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 7.9502541415662655, 0, 33, false, false],
        ["ballSize", 0, 6.678379141566266, 0, 22, false, false],
        ["contrast", 0, 4.247623305722891, 0, 15, false, false],
        ["radius", 0, 0.010951618975903618, 0, 0.05, false, false],
        ["yOuter", 0, 28.494415003765063, 0, 54.1, false, false],
        ["xOuter", 0, 14.311078689759038, 0, 33, false, false],
        ["xMultiplier", 0, 3.790050828313254, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 18.47632718373494, 0, 50, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["xDiv", 0, 0.638441265060241, 0, 2, false, false],
        ["yDiv", 0, 0.20608998493975908, 0, 2, false, false],
        ["yDiv2", 0, 0.757464231927711, 0, 2, false, false],
        ["uvDiv", 0, 130.7125423569277, 0, 323, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed3"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 169.99143347682727, 0, 250, false, false],
        ["ballSize", 0, 5.722396960890437, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.713377987045845, 0, 50, false, false],
        ["yOuter", 0, 0.847429169804217, 0, 4, false, false],
        ["xOuter", 0, 12.030296049922347, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.3520320294851281, 0, 10, false, false],
        ["yMultiplier", 0, 3.2669278285015064, 0.2, 5, false, false],
        ["divider", 0, 0.41733546431168683, 0, 2, false, false],
        ["rotation", 0, 0.6490649947200915, 0, 5, false, false],
        ["yDiv", 0, 8.247158693980024, 0, 210, false, false],
        ["yDiv2", 0, 51.70744459772685, 0, 112, false, false],
        ["xDiv", 0, 24.251763842479296, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e95"
    },
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -5.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / .5);\n    float b = radius * sin(uv.y + stream / -1.);\n    float c = radius * wave * sin(split * uv.x - stream /11.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.705Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.705Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea6"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 9.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -2.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb0"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -8.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.);\n    float b = radius * sin(uv.y + stream / -4.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ebb"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/130.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 20.829, 0, 1111, false],
        ["yDivider", 0, 2.56557, 0.1, 22, false],
        ["xDivider", 0, 0.97527, 0.1, 3, false],
        ["multiplier", 0, 66.97836, 0.01, 121, false],
        ["ballSize", 0, 1.57538, 0, 22, false],
        ["contrast", 0, 0.4939, 0, 5, false],
        ["radius", 0, 11.43989, 0, 151, false],
        ["rotation", 0, 0, 0, 1, false],
        ["a", 0, 0, 0, 1, false],
        ["b", 0, 0, 0, 1, false],
        ["c", 0, 0.04909, 0, 0.8, false],
        ["d", 0, 2.93478, 1, 13, false],
        ["e", 0, 0.47379, 0, 2, false],
        ["f", 0, 0.0721, 0, 2, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 40,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec3"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/2. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 2.3806736222232683, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 31.472457518060526, 0, 150, false, false],
        ["ballSize", 0, 2.110821689467832, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 24.179171826466025, 0, 50, false, false],
        ["yOuter", 0, 1.428772046192583, 0, 4, false, false],
        ["xOuter", 0, 20.940836976522426, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 0.3408098979168628, 0.2, 2, false, false],
        ["divider", 0, 1.023770785044475, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 0.7667471644390061, 0, 10, false, false],
        ["yDiv2", 0, 43.96754676175405, 0, 112, false, false],
        ["xDiv", 0, 1.7746264354292172, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9b"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0012443524096385546, 0, 0.1, false, false],
        ["iterator", 0, 0.7577447289156627, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 48.10121893825301, 0, 111, false, false],
        ["colorOffset", 0, 18.446018448795183, 15, 30, false, false],
        ["contrast", 0, 1.693994728915663, 0, 3, false, false],
        ["orbSize", 0, 701.3161285768074, 0, 1121, false, false],
        ["div", 0, 329.4535185899849, 0.01, 333, false, false],
        ["radius", 0, 212, 0, 212, false, false],
        ["wave", 0, 1333, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb3"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 40.433, 0, 211, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 1.07475, 0.01, 4, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.68, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 0.49, 0.1, 19, false, false],
        ["multiplier", 0, 64, 0.01, 64, false, false],
        ["ballSize", 0, 1.1, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 6.19, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84005370031426, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.119977205335353, 0.1, 19, false, false],
        ["multiplier", 0, 8.310778794401344, 0.01, 64, false, false],
        ["ballSize", 0, 1.6599921687041703, 0, 11, false, false],
        ["contrast", 0, 0.8500047547153251, 0, 5, false, false],
        ["radius", 0, 4.0500299267376345, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.11999832186517936, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.879949935644517, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 20,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eae"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.);\n    float b = radius * sin(uv.y + stream / -4.);\n    float c = radius * wave * sin(split * uv.x - stream / 1.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .3)/1.5 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ece"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x/shape+ sin(stream + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(.001*yOuter*uv.x/.5+t+yMultiplier+1.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 1.8318806475903617, 0, 6, false, false],
        ["ballSize", 0, 128.00044710090364, 0, 255, false, false],
        ["contrast", 0, 3.7043957078313254, 0, 15, false, false],
        ["radius", 0, 3.9535391566265066, 0, 24, false, false],
        ["yOuter", 0, 0.6684017319277109, 0, 2, false, false],
        ["xOuter", 0, 69.76950771837349, 0, 233, false, false],
        ["xMultiplier", 0, 29.147307981927714, 0, 110, false, false],
        ["yMultiplier", 0, 172.48564570783137, 0, 310, false, false],
        ["divider", 0, 38.312782379518076, 0, 50, false, false],
        ["rotation", 0, 2.2631541792168677, 0, 5, false, false],
        ["yDiv", 0, 0.2586690512048193, 0, 2, false, false],
        ["dhspr", 0, 1, 0, 2, false, false],
        ["dhspr", 0, 1, 0, 2, false, false],
        ["shape", 0, 1.2469691265060243, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed4"
    },
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation + stream/-100. + sin(uv.x/xDiv*\n                                                sin(stream/30.)));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/1.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/fuck-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (200.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1.1/pow(volume, .0), 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 6.8758408511977605, 0, 22, false, false],
        ["ballSize", 0, 37.76308937532357, 0, 55, false, false],
        ["contrast", 0, 2.5889260165662655, 0, 15, false, false],
        ["radius", 0, 17.113900095008947, 0, 34, false, false],
        ["yOuter", 0, 1.3027315438511862, 0, 3, false, false],
        ["xOuter", 0, 23.2248299839985, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.925161246793816, 0, 10, false, false],
        ["yMultiplier", 0, 2.6590740709419713, 0, 10, false, false],
        ["divider", 0, 3.949900420315295, 0, 50, false, false],
        ["rotation", 0, 2.962652091520379, 0, 5, false, false],
        ["fuck", 0, 1.4575311499905876, 0, 2, false, false],
        ["xDiv", 0, 4.871233395496048, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eaa"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6465079066265061, 0, 3, false, false],
        ["iterator", 0, 1.3677409638554219, 0.7, 1.5, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 1.5186370481927711, 0, 3, false, false],
        ["colorOffset", 0, 18.31640625, 15, 30, false, false],
        ["contrast", 0, 1.1740634412650603, 0, 3, false, false],
        ["orbSize", 0, 0.5971385542168676, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.226694277108434, 0, 6, false, false],
        ["wave", 0, 0.6340361445783134, 0, 20, false, false],
        ["split", 0, 15.149849397590366, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 1.5, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 2.4140625000000004, 0, 3, false, false],
        ["colorOffset", 0, 15, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.5174228162650604, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 4.123590484371238, 0, 20, false, false],
        ["split", 0, 2.3798945783132535, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 2.3402814382530126, 0, 13, false, false],
        ["iterator", 0, -0.6901025978915662, -2, 1.5, false, false],
        ["iterations", 0, 19.132017131024103, 0, 33, false, false],
        ["colorShift", 0, 1.8957831325301209, 0, 3, false, false],
        ["colorOffset", 0, 19.664203689759034, 15, 30, false, false],
        ["contrast", 0, 0.6084713855421688, 0, 3, false, false],
        ["orbSize", 0, 0.28940135542168677, 0, 1, false, false],
        ["div", 0, 3.5612359751506024, 0.01, 15, false, false],
        ["radius", 0, 1.3431664156626508, 0, 6, false, false],
        ["wave", 0, 5.866528614457832, 0, 20, false, false],
        ["split", 0, 5.772684487951808, 0, 15, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e99"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -2.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * tan(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.012176675451807232, 0, 0.1, false, false],
        ["iterator", 0, 0.9413253012048193, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 48.10121893825301, 0, 111, false, false],
        ["colorOffset", 0, 18.446018448795183, 15, 30, false, false],
        ["contrast", 0, 2.025352974397591, 0, 3, false, false],
        ["orbSize", 0, 250.5209196159639, 0, 1121, false, false],
        ["div", 0, 489.837401214232, 0.01, 1333, false, false],
        ["radius", 0, 20.803896837349402, 0, 212, false, false],
        ["wave", 0, 1333, 0, 1333, false, false],
        ["split", 0, 10.636295180722893, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb8"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c - stream);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)/cos(uv.y/100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1112. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 28.25, 0, 111, false, false],
        ["yDivider", 0, 9.4, 0.1, 22, false, false],
        ["xDivider", 0, 3.96, 0.1, 19, false, false],
        ["multiplier", 0, 22069.06, 0.01, 22224, false, false],
        ["ballSize", 0, 5.68, 0, 22, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 151, false, false],
        ["rotation", 0, 0.31, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 1, false, false],
        ["c", 0, 1.06, 0, 8, false, false],
        ["d", 0, 2.06, 1, 13, false, false],
        ["e", 0, 0.53, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9d"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv = abs(uv);\n  uv *=\n  uv *= k_rotate2d(stream / -1.);\n  for (float i = 2.; i < 17.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -.5);\n    float b = radius * sin(uv.y / div + stream / -.8);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / .5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05941076807228917, 0, 1.1, false, false],
        ["iterator", 0, 0.9375640060240964, 0.7, 1.5, false, false],
        ["iterations", 0, 4.923597515060242, 0, 33, false, false],
        ["colorShift", 0, 44.49821159638555, 0, 111, false, false],
        ["colorOffset", 0, 16.446771460843372, 15, 30, false, false],
        ["contrast", 0, 2.193425263554217, 0, 3, false, false],
        ["orbSize", 0, 105.40193900602412, 0, 222, false, false],
        ["div", 0, 5333, 0.01, 5333, false, false],
        ["radius", 0, 4.278953313253012, 0, 12, false, false],
        ["wave", 0, 3812.620039533133, 0, 11333, false, false],
        ["split", 0, 86.38253012048195, 0, 140, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea8"
    },
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 2.125);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6465079066265061, 0, 3, false, false],
        ["iterator", 0, 1.3677409638554219, 0.7, 1.5, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 1.5186370481927711, 0, 3, false, false],
        ["colorOffset", 0, 18.31640625, 15, 30, false, false],
        ["contrast", 0, 1.1740634412650603, 0, 3, false, false],
        ["orbSize", 0, 0.5971385542168676, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.226694277108434, 0, 6, false, false],
        ["wave", 0, 0.6340361445783134, 0, 20, false, false],
        ["split", 0, 15.149849397590366, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 1.8872270331325305, 0, 3, false, false],
        ["iterator", 0, 1.2201590737951808, 0.7, 2, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 0.5885212725903615, 0, 3, false, false],
        ["colorOffset", 0, 20.50647119728916, 15, 30, false, false],
        ["contrast", 0, 1.3051157756024097, 0, 3, false, false],
        ["orbSize", 0, 1, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.707699548192772, 0, 6, false, false],
        ["wave", 0, 1.2741905120481931, 0, 20, false, false],
        ["split", 0, 2.777334337349398, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 0.9513930722891566, 0, 3, false, false],
        ["iterator", 0, 1.823339137801205, 0.7, 3, false, false],
        ["iterations", 0, 27.0210796310241, 0, 33, false, false],
        ["colorShift", 0, 0, 0, 23, false, false],
        ["colorOffset", 0, 20.030379329819276, 15, 30, false, false],
        ["contrast", 0, 1.1627470948138394, 0, 3, false, false],
        ["orbSize", 0, 0.3594597138554217, 0, 1, false, false],
        ["div", 0, 5.113429028614458, 0.01, 15, false, false],
        ["radius", 0, 4.177099021084338, 0, 6, false, false],
        ["wave", 0, 0.7246799698795182, 0, 20, false, false],
        ["split", 0, 4.043100527108434, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eba"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 18.73, 0, 111, false, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 2.33, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.68, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 0.49, 0.1, 19, false, false],
        ["multiplier", 0, 64, 0.01, 64, false, false],
        ["ballSize", 0, 1.1, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 6.19, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.12, 0.1, 19, false, false],
        ["multiplier", 0, 8.31, 0.01, 64, false, false],
        ["ballSize", 0, 1.66, 0, 11, false, false],
        ["contrast", 0, 0.85, 0, 5, false, false],
        ["radius", 0, 4.05, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.12, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.88, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea9"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 4.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * abs(.1+abs(tan((stream-uv.x + div))));\n    float b = radius * cos(stream + uv.y - div);\n    float c = radius * wave * sin(split * uv.x - stream /-.0605);\n    float d = radius * wave * cos(split * uv.y  - stream / 2.9125);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.9513930722891566, 0, 3, false, false],
        ["iterator", 0, 1.823339137801205, 0.7, 3, false, false],
        ["iterations", 0, 27.0210796310241, 0, 33, false, false],
        ["colorShift", 0, 0, 0, 23, false, false],
        ["colorOffset", 0, 26.667286332831328, 15, 30, false, false],
        ["contrast", 0, 1.1627470948138394, 0, 3, false, false],
        ["orbSize", 0, 0.3594597138554217, 0, 1, false, false],
        ["div", 0, 5.113429028614458, 0.01, 15, false, false],
        ["radius", 0, 4.177099021084338, 0, 6, false, false],
        ["wave", 0, 0.7246799698795182, 0, 20, false, false],
        ["split", 0, 4.043100527108434, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 2.6071253765060245, 0, 3, false, false],
        ["iterator", 0, 0.7, 0.7, 3, false, false],
        ["iterations", 0, 0, 0, 33, false, false],
        ["colorShift", 0, 0.0254376882530121, 0, 23, false, false],
        ["colorOffset", 0, 28.594526543674704, 15, 30, false, false],
        ["contrast", 0, 1.1222609186746988, 0, 3, false, false],
        ["orbSize", 0, 0.3232868975903615, 0, 1, false, false],
        ["div", 0, 15, 0.01, 15, false, false],
        ["radius", 0, 2.036803463855422, 0, 6, false, false],
        ["wave", 0, 1.4388177710843377, 0, 20, false, false],
        ["split", 0, 17.269813629518076, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea7"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.289744917168675, 0, 3, false, false],
        ["iterator", 0, 1.336984186746988, 0.7, 1.5, false, false],
        ["iterations", 0, 19.638944841867474, 0, 33, false, false],
        ["colorShift", 0, 3, 0, 3, false, false],
        ["colorOffset", 0, 18.935876317771083, 15, 30, false, false],
        ["contrast", 0, 1.1055299322289158, 0, 3, false, false],
        ["orbSize", 0, 0.5138225659350154, 0, 1, false, false],
        ["div", 0, 5.55512890625, 0.01, 15, false, false],
        ["radius", 0, 2.675207078313253, 0, 6, false, false],
        ["wave", 0, 1.3555158132530123, 0, 20, false, false],
        ["split", 0, 2.469479480421687, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eab"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -9.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.5);\n    float b = radius * sin(uv.y + stream);\n    float c = radius * wave * sin(split * uv.x - stream /-12.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 11.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.4446906864375482, 0, 3, false, false],
        ["iterator", 0, 1.336984186746988, 0.7, 1.5, false, false],
        ["iterations", 0, 19.638944841867474, 0, 33, false, false],
        ["colorShift", 0, 1.2591161521084338, 0, 3, false, false],
        ["colorOffset", 0, 22.498735586912325, 15, 30, false, false],
        ["contrast", 0, 0.8990822665662651, 0, 3, false, false],
        ["orbSize", 0, 0.4297678884425685, 0, 1, false, false],
        ["div", 0, 3.102181334713856, 0.01, 15, false, false],
        ["radius", 0, 3.1522307981927717, 0, 6, false, false],
        ["wave", 0, 7.64432837097393, 0, 20, false, false],
        ["split", 0, 2.469479480421687, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ead"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 30.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.418, 1, 13, false, false],
        ["iterator", 0, 1.014, 0.7, 1.5, false, false],
        ["iterations", 0, 18, 0, 33, false, false],
        ["colorShift", 0, 0.266, 0, 1, false, false],
        ["colorOffset", 0, 25.265, 15, 30, false, false],
        ["contrast", 0, 0.831, 0, 3, false, false],
        ["orbSize", 0, 10.426, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 73.725, 0, 212, false, false],
        ["wave", 0, 1222, 0, 1222, false, false],
        ["split", 0, 5.288, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 1.93, 1, 13, false, false],
        ["iterator", 0, 1.079, 0.7, 1.5, false, false],
        ["iterations", 0, 15, 0, 33, false, false],
        ["colorShift", 0, 0.271, 0, 1, false, false],
        ["colorOffset", 0, 18.968, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false, false],
        ["orbSize", 0, 5.174, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 32.407, 0, 212, false, false],
        ["wave", 0, 0, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 8.452, 1, 13, false, false],
        ["iterator", 0, 0.978, 0.7, 1.5, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["colorShift", 0, 0.352, 0, 1, false, false],
        ["colorOffset", 0, 17.673, 15, 30, false, false],
        ["contrast", 0, 1.146, 0, 3, false, false],
        ["orbSize", 0, 26.704, 0, 37, false, false],
        ["div", 0, 3.174, 0.01, 15, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 865.131, 0, 1333, false, false],
        ["split", 0, 17.958, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec2"
    },
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/12.);\n  float dist = length(uv);\n  for (float i = 0.; i < 40.; i++) {\n    uv *= k_rotate2d(rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/100.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 2.3806736222232683, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 31.472457518060526, 0, 150, false, false],
        ["ballSize", 0, 2.110821689467832, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 24.179171826466025, 0, 50, false, false],
        ["yOuter", 0, 1.428772046192583, 0, 4, false, false],
        ["xOuter", 0, 20.940836976522426, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 0.3408098979168628, 0.2, 2, false, false],
        ["divider", 0, 1.023770785044475, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 0.7667471644390061, 0, 10, false, false],
        ["yDiv2", 0, 43.96754676175405, 0, 112, false, false],
        ["xDiv", 0, 1.7746264354292172, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 76.04349848735765, 0, 150, false, false],
        ["ballSize", 0, 7, 2, 7, false, false],
        ["contrast", 0, 1.6782306648162477, 0, 15, false, false],
        ["radius", 0, 46.73833272543298, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 121.90263440235556, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4497109654438065, 0, 1, false, false],
        ["yMultiplier", 0, 0.9904435643541671, 0.2, 2, false, false],
        ["divider", 0, 0.4888161349009319, 0, 2, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["yDiv", 0, 5.318059162921217, 0, 10, false, false],
        ["yDiv2", 0, 66.56326227762614, 0, 112, false, false],
        ["xDiv", 0, 5.000529057146556, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 2.512914450771838, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 31.12488712172911, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 35.98427204913405, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5644670969032382, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 2.512914450771838, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 31.12488712172911, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 35.98427204913405, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5644670969032382, 0, 10, false, false],
        ["yMultiplier", 0, 12, 0.2, 12, false, false],
        ["divider", 0, 0.2073346609092621, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 16.904170254626912, 0, 110, false, false],
        ["yDiv2", 0, 5.818779598373966, 0, 112, false, false],
        ["xDiv", 0, 1.3528976256588858, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec8"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /2.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.756140619300935, 0, 122, false, false],
        ["ballSize", 0, 45.40572738647462, 0, 255, false, false],
        ["contrast", 0, 2.723491561226182, 0, 15, false, false],
        ["radius", 0, 34, 0, 34, false, false],
        ["yOuter", 0, 1.814596318624106, 0, 3, false, false],
        ["xOuter", 0, 109.75608219008849, 1, 241, false, false],
        ["xMultiplier", 0, 11.466961596385545, 0, 110, false, false],
        ["yMultiplier", 0, 3.877400225903615, 0, 10, false, false],
        ["divider", 0, 8.398908132530122, 0, 50, false, false],
        ["rotation", 0, 2.103468561746988, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ecc"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 169.99143347682727, 0, 250, false, false],
        ["ballSize", 0, 7.6826047598597516, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 45.23564166333303, 0, 50, false, false],
        ["yOuter", 0, 0.8148220567818149, 0, 4, false, false],
        ["xOuter", 0, 0, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.13444751142019254, 0, 10, false, false],
        ["yMultiplier", 0, 2.553389377823796, 0.2, 5, false, false],
        ["divider", 0, 0.5201743803828596, 0, 2, false, false],
        ["rotation", 0, 2.665821305240494, 0, 5, false, false],
        ["yDiv", 0, 8.247158693980024, 0, 210, false, false],
        ["yDiv2", 0, 51.70744459772685, 0, 112, false, false],
        ["xDiv", 0, 24.251763842479296, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed0"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 4.641638929691454, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9c"
    },
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv = abs(uv);\n  uv *=\n  uv *= k_rotate2d(stream / -1.);\n  for (float i = 2.; i < 4.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -.8);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(splitY * uv.y / div - stream / 2.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.3039443712349398, 0, 1.1, false, false],
        ["iterator", 0, 0.9804518072289157, 0.7, 1.5, false, false],
        ["iterations", 0, 14.394013554216869, 0, 33, false, false],
        ["colorShift", 0, 44.49821159638555, 0, 111, false, false],
        ["colorOffset", 0, 25.174204631024097, 15, 30, false, false],
        ["contrast", 0, 2.193425263554217, 0, 3, false, false],
        ["orbSize", 0, 36.37590361445784, 0, 222, false, false],
        ["div", 0, 4082.999342714609, 0.01, 25333, false, false],
        ["radius", 0, 3.138704819277109, 0, 12, false, false],
        ["wave", 0, 152.38319371234942, 0, 11333, false, false],
        ["split", 0, 336.14759036144585, 0, 2140, false, false],
        ["splitY", 0, 2222, 0, 2222, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea3"
    },
    "shader": "void main () {\n  float stream =stream * 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -9.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.184, 0, 3, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec6"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 18.764354292168676, 0, 50, false, false],
        ["ballSize", 0, 30.02166792168675, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 48.605751129518076, 0, 250, false, false],
        ["yOuter", 0, 0.28322665662650603, -1, 4, false, false],
        ["xOuter", 0, 81.74359939759037, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.788685993975904, 0, 10, false, false],
        ["yMultiplier", 0, 2.4412114081325305, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 4.2250564759036155, 0, 5, false, false],
        ["yDiv", 0, 4.170557228915664, 0, 110, false, false],
        ["yDiv2", 0, 8.153840361445786, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 27.986163403614462, 0, 50, false, false],
        ["ballSize", 0, 30.118298192771086, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 35.58805534638555, 0, 250, false, false],
        ["yOuter", 0, 1.2504471009036147, -1, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.8991434487951809, 0, 10, false, false],
        ["yMultiplier", 0, 1.1380355798192774, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 4.2250564759036155, 0, 5, false, false],
        ["yDiv", 0, 4.170557228915664, 0, 110, false, false],
        ["yDiv2", 0, 8.153840361445786, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 27.986163403614462, 0, 50, false, false],
        ["ballSize", 0, 30.118298192771086, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 35.58805534638555, 0, 250, false, false],
        ["yOuter", 0, -0.4964937876506023, -1, 4, false, false],
        ["xOuter", 0, 100.0960090361446, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.373635165662651, 0, 10, false, false],
        ["yMultiplier", 0, 2.555668298192771, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0.5422628012048194, 0, 5, false, false],
        ["yDiv", 0, 23.19743034638555, 0, 110, false, false],
        ["yDiv2", 0, 20.34111445783133, 0, 112, false, false],
        ["xDiv", 0, 0.7005271084337351, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 33.30431099397591, 0, 250, false, false],
        ["ballSize", 0, 4.467959337349398, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 47.4550545933735, 0, 250, false, false],
        ["yOuter", 0, 6.027861445783134, -1, 44, false, false],
        ["xOuter", 0, 117.67243975903617, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.8636577560240974, 0, 10, false, false],
        ["yMultiplier", 0, 1.62468561746988, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 94.5881965361446, 0, 110, false, false],
        ["yDiv2", 0, 112, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ecb"
    },
    "shader": "void main () {\n  float stream = time/1.2 + pow(stream, .85) * 12.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/300.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(1.5);// + stream/50.;\n    vec2 p = vec2(xOuter-volume*(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/4. -uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/-40. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .8)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 169.99143347682727, 0, 250, false, false],
        ["ballSize", 0, 5.722396960890437, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.713377987045845, 0, 50, false, false],
        ["yOuter", 0, 0.847429169804217, 0, 4, false, false],
        ["xOuter", 0, 12.030296049922347, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.3520320294851281, 0, 10, false, false],
        ["yMultiplier", 0, 3.2669278285015064, 0.2, 5, false, false],
        ["divider", 0, 0.41733546431168683, 0, 2, false, false],
        ["rotation", 0, 0.6490649947200915, 0, 5, false, false],
        ["yDiv", 0, 8.247158693980024, 0, 210, false, false],
        ["yDiv2", 0, 51.70744459772685, 0, 112, false, false],
        ["xDiv", 0, 24.251763842479296, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 162.2453896396132, 0, 1150, false, false],
        ["ballSize", 0, 3.0370996314359004, 0, 5, false, false],
        ["contrast", 0, 1.1543580939970826, 0, 15, false, false],
        ["radius", 0, 150, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 34.43159944465362, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.7613210213902486, 0.2, 2, false, false],
        ["divider", 0, 1.523868119672102, 0, 2, false, false],
        ["rotation", 0, 1.8953206625329444, 0, 5, false, false],
        ["yDiv", 0, 10, 0, 10, false, false],
        ["yDiv2", 0, 32.300220608998494, 0, 112, false, false],
        ["xDiv", 0, 6.118289331642979, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 12.824288793357022, 0, 50, false, false],
        ["ballSize", 0, 13.057620459866813, 2, 20, false, false],
        ["contrast", 0, 5.0040220697242095, 0, 15, false, false],
        ["radius", 0, 24.45897849209338, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 37.8479404679264, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.484278667403992, 0, 10, false, false],
        ["yMultiplier", 0, 21.752694415356743, 0.2, 32, false, false],
        ["divider", 0, 0.1945240152716073, 0, 2, false, false],
        ["rotation", 0, 1.316509660468044, 0, 5, false, false],
        ["yDiv", 0, 3.2968676463667173, 0, 10, false, false],
        ["yDiv2", 0, 24.586253265013184, 0, 112, false, false],
        ["xDiv", 0, 1.3163675055446398, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e96"
    },
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0009083207831325305, 0, 0.1, false, false],
        ["iterator", 0, 1.0063290662650601, 0.7, 1.5, false, false],
        ["iterations", 0, 11.885466867469882, 0, 33, false, false],
        ["colorShift", 0, 11, 0, 11, false, false],
        ["colorOffset", 0, 24.787478817442864, 15, 30, false, false],
        ["contrast", 0, 1.8087396460843377, 0, 3, false, false],
        ["orbSize", 0, 728.2701430722893, 0, 1121, false, false],
        ["div", 0, 224.36903125000003, 0.01, 3115, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 1333, 0, 1333, false, false],
        ["split", 0, 5.037838855421688, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.706Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea0"
    },
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8.675150886158583, 1, 13, false, false],
        ["iterator", 0, 1.1274359939759038, 0.7, 1.5, false, false],
        ["iterations", 0, 7.958174887048194, 0, 33, false, false],
        ["colorShift", 0, 0.32937217619416226, 0, 1, false, false],
        ["colorOffset", 0, 15, 15, 30, false, false],
        ["contrast", 0, 0.831, 0, 3, false, false],
        ["orbSize", 0, 25.7765389683735, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 73.725, 0, 212, false, false],
        ["wave", 0, 197.5915568524097, 0, 1222, false, false],
        ["split", 0, 6.847326807228917, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 1.93, 1, 13, false, false],
        ["iterator", 0, 1.079, 0.7, 1.5, false, false],
        ["iterations", 0, 15, 0, 33, false, false],
        ["colorShift", 0, 0.271, 0, 1, false, false],
        ["colorOffset", 0, 18.968, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false, false],
        ["orbSize", 0, 5.174, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 32.407, 0, 212, false, false],
        ["wave", 0, 0, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 0.034158509036144584, 0, 1, false, false],
        ["iterator", 0, 1.2030685240963856, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 11, 0, 11, false, false],
        ["colorOffset", 0, 24.787478817442864, 15, 30, false, false],
        ["contrast", 0, 1.5351986069277113, 0, 3, false, false],
        ["orbSize", 0, 251.05905026355427, 0, 1121, false, false],
        ["div", 0, 77.85446338478917, 0.01, 115, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 1306.0802757906629, 0, 1333, false, false],
        ["split", 0, 35.035561300634974, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ebc"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.1 + wow * sin(stream/.5 - length(uv)));\n\n  uv.x += sin(uv.y/fuck) * sin(uv.y+stream);\n\n  uv += shit*sin(stream/1.1 - dot(uv, uv)/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * tan(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, pink * color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.453303840361446, 0, 22, false, false],
        ["contrast", 0, 1.1512989457831329, 0, 2, false, false],
        ["orbSize", 0, 0.40576995481927713, 0, 1, false, false],
        ["radius", 0, 4.253859186746989, 0, 5, false, false],
        ["colorShift", 0, 3.487217620481928, 0, 12, false, false],
        ["pink", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["fuck", 0, 0.2044615963855422, 0, 1, false, false],
        ["shit", 0, 4.951073042168675, 0, 12, false, false],
        ["wow", 0, 0.5113140060240964, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a37"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9e"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.22349, 0, 4, false],
        ["iterator", 0, 3.08602, 0.7, 5, false],
        ["iterations", 0, 27.10833, 0, 33, false],
        ["colorShift", 0, 4.91799, 0, 44, false],
        ["colorOffset", 0, 1, 1, 318, false],
        ["contrast", 0, 1.3316, 0, 3, false],
        ["orbSize", 0, 2109.05161, 0, 15121, false],
        ["div", 0, 778.14317, 0.01, 33233, false],
        ["radius", 0, 185.26612, 0, 1512, false],
        ["wave", 0, 7442.65944, 0, 32222, false],
        ["split", 0, 16.47992, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ea4"
    },
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 3.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x);\n    float b = radius * sin(uv.y);\n    float c = radius * wave * sin(split * uv.x - stream /-.605);\n    float d = radius * wave * cos(split * uv.y  - stream / 0.6);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6465079066265061, 0, 3, false, false],
        ["iterator", 0, 1.3677409638554219, 0.7, 1.5, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 1.5186370481927711, 0, 3, false, false],
        ["colorOffset", 0, 18.31640625, 15, 30, false, false],
        ["contrast", 0, 1.1740634412650603, 0, 3, false, false],
        ["orbSize", 0, 0.5971385542168676, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.226694277108434, 0, 6, false, false],
        ["wave", 0, 0.6340361445783134, 0, 20, false, false],
        ["split", 0, 15.149849397590366, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 1.8872270331325305, 0, 3, false, false],
        ["iterator", 0, 1.2201590737951808, 0.7, 2, false, false],
        ["iterations", 0, 23.672467996987955, 0, 33, false, false],
        ["colorShift", 0, 0.5885212725903615, 0, 3, false, false],
        ["colorOffset", 0, 20.50647119728916, 15, 30, false, false],
        ["contrast", 0, 1.3051157756024097, 0, 3, false, false],
        ["orbSize", 0, 1, 0, 1, false, false],
        ["div", 0, 5.05099421121988, 0.01, 15, false, false],
        ["radius", 0, 3.707699548192772, 0, 6, false, false],
        ["wave", 0, 1.2741905120481931, 0, 20, false, false],
        ["split", 0, 2.777334337349398, 0, 22, false, false]
      ],
      [
        ["zoom", 0, 0.9513930722891566, 0, 3, false, false],
        ["iterator", 0, 1.823339137801205, 0.7, 3, false, false],
        ["iterations", 0, 27.0210796310241, 0, 33, false, false],
        ["colorShift", 0, 0, 0, 23, false, false],
        ["colorOffset", 0, 26.667286332831328, 15, 30, false, false],
        ["contrast", 0, 1.1627470948138394, 0, 3, false, false],
        ["orbSize", 0, 0.3594597138554217, 0, 1, false, false],
        ["div", 0, 5.113429028614458, 0.01, 15, false, false],
        ["radius", 0, 4.177099021084338, 0, 6, false, false],
        ["wave", 0, 0.7246799698795182, 0, 20, false, false],
        ["split", 0, 4.043100527108434, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb6"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 20.39, 0, 111, false, false],
        ["yDivider", 0, 9.62, 0.1, 22, false, false],
        ["xDivider", 0, 4.19, 0.1, 19, false, false],
        ["multiplier", 0, 4079.47, 0.01, 22224, false, false],
        ["ballSize", 0, 1.43, 0, 22, false, false],
        ["contrast", 0, 0.98, 0, 5, false, false],
        ["radius", 0, 6.55, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.11, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 1.23, 0, 8, false, false],
        ["d", 0, 2.08, 1, 13, false, false],
        ["e", 0, 0.65, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e9f"
    },
    "shader": "void main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.034158509036144584, 0, 1, false, false],
        ["iterator", 0, 1.2030685240963856, 0.7, 1.5, false, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 11, 0, 11, false, false],
        ["colorOffset", 0, 24.787478817442864, 15, 30, false, false],
        ["contrast", 0, 1.5351986069277113, 0, 3, false, false],
        ["orbSize", 0, 251.05905026355427, 0, 1121, false, false],
        ["div", 0, 77.85446338478917, 0.01, 115, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 1306.0802757906629, 0, 1333, false, false],
        ["split", 0, 35.035561300634974, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.707Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eb7"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + sin(uv.x/c + stream/-1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider) - f*sin(uv.y/d - stream/5.);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)/cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 11. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*(.2 + (pow(volume, .8)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 20.39, 0, 111, false, false],
        ["yDivider", 0, 9.62, 0.1, 22, false, false],
        ["xDivider", 0, 4.19, 0.1, 19, false, false],
        ["multiplier", 0, 4079.47, 0.01, 22224, false, false],
        ["ballSize", 0, 1.43, 0, 22, false, false],
        ["contrast", 0, 0.98, 0, 5, false, false],
        ["radius", 0, 6.55, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.11, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 1.23, 0, 8, false, false],
        ["d", 0, 2.08, 1, 13, false, false],
        ["e", 0, 0.65, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 7.58, 0, 111, false, false],
        ["yDivider", 0, 1.3, 0.1, 22, false, false],
        ["xDivider", 0, 5.09, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 1.06, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 3.19, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.06, 0, 1, false, false],
        ["b", 0, 0.06, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a36"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ebf"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /4.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*abs(cos(stream - uv.x/20. + sin(stream + uv.y/.52)));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.25+t+yMultiplier+1.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.756140619300935, 0, 122, false, false],
        ["ballSize", 0, 4.494423004518073, 0, 255, false, false],
        ["contrast", 0, 2.723491561226182, 0, 15, false, false],
        ["radius", 0, 34, 0, 34, false, false],
        ["yOuter", 0, 0, 0, 3, false, false],
        ["xOuter", 0, 202.30496987951813, 1, 241, false, false],
        ["xMultiplier", 0, 11.466961596385545, 0, 110, false, false],
        ["yMultiplier", 0, 3.805111069277109, 0, 10, false, false],
        ["divider", 0, 8.398908132530122, 0, 50, false, false],
        ["rotation", 0, 2.103468561746988, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eca"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * (.6 + .3 * sin(uv.y/yDiv-stream/1.4))), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 169.99143347682727, 0, 250, false, false],
        ["ballSize", 0, 5.722396960890437, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.713377987045845, 0, 50, false, false],
        ["yOuter", 0, 0.847429169804217, 0, 4, false, false],
        ["xOuter", 0, 12.030296049922347, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.3520320294851281, 0, 10, false, false],
        ["yMultiplier", 0, 3.2669278285015064, 0.2, 5, false, false],
        ["divider", 0, 0.41733546431168683, 0, 2, false, false],
        ["rotation", 0, 0.6490649947200915, 0, 5, false, false],
        ["yDiv", 0, 8.247158693980024, 0, 210, false, false],
        ["yDiv2", 0, 51.70744459772685, 0, 112, false, false],
        ["xDiv", 0, 24.251763842479296, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ecf"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .25)/2.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 7.336954066265062, 0, 12, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9e94"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00353, 0, 0.01, false],
        ["shapeMultiplier", 0, 2714.93266, 0, 3000, false],
        ["rotation", 0, 30.1, 0, 30.1, false],
        ["xMultiplier", 0, 1246.07946, 0, 1500, false],
        ["yMultiplier", 0, 256.11565, 0, 1000, false],
        ["colorSpread", 0, 0.00011, -0.01, 0.009, false],
        ["colorMultiplier", 0, 7.27113, 0, 13, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 9.26335, 0, 10, false],
        ["ballSize", 0, 55, 0, 55, false],
        ["glow", 0, 4, 0, 4, false],
        ["contrast", 0, 5.40886, 0, 15, false],
        ["radius", 0, 8.12585, 0, 20, false],
        ["col", 0, 2.15358, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.704Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.705Z"
    },
    "__v": 8,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eac"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.);\n  for (float i = 0.; i < 5.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i - iterations, colorShift, sin(length(uv/1.1)/1.1-stream/.015));\n    float a = radius * cos(uv.x * div);\n    float b = radius * cos(uv.y * div);\n    float c = wave * sin(split * uv.x - stream);\n    float d = wave * cos(split * uv.y  - stream);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n  gl_FragColor = 1.-gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 2.9360504518072297, 0, 23, false, false],
        ["iterator", 0, 1.1357097138554217, 0.7, 3, false, false],
        ["iterations", 0, 0.21614975527108435, 0, 0.5, false, false],
        ["colorShift", 0, 0.1667756965361446, 0, 0.5, false, false],
        ["colorOffset", 0, 24.866057981927714, 15, 30, false, false],
        ["contrast", 0, 1.1175592996987953, 0, 3, false, false],
        ["orbSize", 0, 0.7946489081325303, 0, 1, false, false],
        ["div", 0, 3.0465191076807234, 0.01, 15, false, false],
        ["radius", 0, 6, 0, 6, false, false],
        ["wave", 0, 14.466961596385545, 0, 20, false, false],
        ["split", 0, 3.4255929969879526, 0, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eaf"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / 3.);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 2.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, .52) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.418, 1, 13, false, false],
        ["iterator", 0, 1.014, 0.7, 1.5, false, false],
        ["iterations", 0, 18, 0, 33, false, false],
        ["colorShift", 0, 0.266, 0, 1, false, false],
        ["colorOffset", 0, 25.265, 15, 30, false, false],
        ["contrast", 0, 0.831, 0, 3, false, false],
        ["orbSize", 0, 10.426, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 73.725, 0, 212, false, false],
        ["wave", 0, 1222, 0, 1222, false, false],
        ["split", 0, 5.288, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 1.93, 1, 13, false, false],
        ["iterator", 0, 1.079, 0.7, 1.5, false, false],
        ["iterations", 0, 15, 0, 33, false, false],
        ["colorShift", 0, 0.271, 0, 1, false, false],
        ["colorOffset", 0, 18.968, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false, false],
        ["orbSize", 0, 5.174, 0, 37, false, false],
        ["div", 0, 4.782, 0.01, 15, false, false],
        ["radius", 0, 32.407, 0, 212, false, false],
        ["wave", 0, 0, 0, 1333, false, false],
        ["split", 0, 0, 0, 40, false, false]
      ],
      [
        ["zoom", 0, 8.452, 1, 13, false, false],
        ["iterator", 0, 0.978, 0.7, 1.5, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["colorShift", 0, 0.352, 0, 1, false, false],
        ["colorOffset", 0, 17.673, 15, 30, false, false],
        ["contrast", 0, 1.146, 0, 3, false, false],
        ["orbSize", 0, 26.704, 0, 37, false, false],
        ["div", 0, 3.174, 0.01, 15, false, false],
        ["radius", 0, 79.158, 0, 212, false, false],
        ["wave", 0, 865.131, 0, 1333, false, false],
        ["split", 0, 17.958, 0, 40, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ebd"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.1 + wow * sin(stream/.5 - length(uv)));\n\n  uv.x += sin(uv.y/fuck) * sin(uv.y+stream);\n\n  uv += shit*sin(stream/1.1 - dot(uv, uv)/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * tan(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, pink * color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.453303840361446, 0, 22, false, false],
        ["contrast", 0, 1.1512989457831329, 0, 2, false, false],
        ["orbSize", 0, 0.40576995481927713, 0, 1, false, false],
        ["radius", 0, 4.253859186746989, 0, 5, false, false],
        ["colorShift", 0, 3.487217620481928, 0, 12, false, false],
        ["pink", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["fuck", 0, 0.2044615963855422, 0, 1, false, false],
        ["shit", 0, 4.951073042168675, 0, 12, false, false],
        ["wow", 0, 0.5113140060240964, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a37"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec7"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/2.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/5. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eda"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.2-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 98.6929431593562, 0, 150, false, false],
        ["ballSize", 0, 5.52510052416698, 2, 7, false, false],
        ["contrast", 0, 1.6600951465185185, 0, 15, false, false],
        ["radius", 0, 57.937847734933875, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.11999418879129803, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 38.26181390601469, 0, 112, false, false],
        ["xDiv", 0, 3.6583544995411335, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0f"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n   uv *= rotate(-stream/4.);\n\n uv = kale(uv, vec2(0.),sides);\n   uv *= rotate(stream/10.);\n\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  // uv *= rotate(rotation*stream/9.);\n  for (float i = 0.; i < 22.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-1.16);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/-2.9);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n    \n  }\n  gl_FragColor = k_hue(gl_FragColor, colorShift);\n}",
    "variants": [
      [
        ["zoom", 0, 0.10960007674990807, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.5761122458584342, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 11.727513177710845, 4, 22, false, false],
        ["sides", 0, 6, 0, 6, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0.65417921686747, 0, 4, false, false],
        ["cosMul", 0, 1.8823653990963858, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, 0, 3, false, false],
        ["ySpeed", 0, 0, 0, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 2.2388271837349403, 0, 11, false, false],
        ["xDivide", 0, 3.883353727409639, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f15"
    },
    "shader": "#define orbs 20.\n\nvoid main( ) {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0.);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul ) + cos(uv.y / yDivide - stream);\n    uv.y += cosMul * cos(uv.x * xMul) - sin(uv.x / xDivide - stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12831795933734944, 0, 1, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["contrast", 0, 0.18341490963855425, 0, 2, false, false],
        ["orbSize", 0, 16.973806918435542, 0, 20, false, false],
        ["radius", 0, 10.246100840333934, 0, 14, false, false],
        ["colorShift", 0, 10.699804770356076, 0, 20, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 2.6060240963855428, 0, 3, false, false],
        ["yMul", 0, 0.07099962349397591, 0, 2, false, false],
        ["xMul", 0, 0.2037697665662651, 0, 1, false, false],
        ["yDivide", 0, 4.311429036179833, 0, 5, false, false],
        ["xDivide", 0, 4.846658260793775, 0, 7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed8"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 2.2154850143984146, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 15.88807067411492, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 28.503943468576463, 0, 33, false, false],
        ["xMultiplier", 0, 20.76713074833514, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 32.78597406594151, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef2"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.1)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 0.6764400987740024, 0, 1, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 3.485498175563583, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 10.29427609730916, 0, 33, false, false],
        ["xMultiplier", 0, 64.29451646000507, 0, 110, false, false],
        ["yMultiplier", 0, 362.13499121608504, 1, 1330, false, false],
        ["divider", 0, 9.619286778461504, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 23, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.13272710593349965, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 2.0719639743667058, 0, 33, false, false],
        ["ballSize", 0, 25.215378190691247, 0, 33, false, false],
        ["contrast", 0, 3.3798278900514176, 0, 15, false, false],
        ["radius", 0, 0.14887378187064668, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.194977266242707, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 34.414792348103354, 0, 50, false, false],
        ["rotation", 0, 4.1073160746011395, 0, 5, false, false],
        ["xDiv", 0, 0.9732506074101094, 0, 2, false, false],
        ["yDiv", 0, 1.2935981474727036, 0, 2, false, false],
        ["yDiv2", 0, 0.5701666958360787, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9efd"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream/1.5 + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.t/2.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.756140619300935, 0, 122, false, false],
        ["ballSize", 0, 45.40572738647462, 0, 255, false, false],
        ["contrast", 0, 2.723491561226182, 0, 15, false, false],
        ["radius", 0, 34, 0, 34, false, false],
        ["yOuter", 0, 1.814596318624106, 0, 3, false, false],
        ["xOuter", 0, 109.75608219008849, 1, 241, false, false],
        ["xMultiplier", 0, 11.466961596385545, 0, 110, false, false],
        ["yMultiplier", 0, 3.877400225903615, 0, 10, false, false],
        ["divider", 0, 8.398908132530122, 0, 50, false, false],
        ["rotation", 0, 2.103468561746988, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed9"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 2.2154850143984146, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9edc"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 36.246470256024104, 0, 50, false, false],
        ["ballSize", 0, 20, 2, 20, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 0, 0, 50, false, false],
        ["yOuter", 0, 0.015615116716867473, 0, 0.05, false, false],
        ["xOuter", 0, 97.3038403614458, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22948042168674704, 0, 10, false, false],
        ["yMultiplier", 0, 0.3789241340361446, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 9.248164533132531, 0, 50, false, false],
        ["ballSize", 0, 9.403896837349398, 2, 30, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 7.808028990963857, 0, 50, false, false],
        ["yOuter", 0, 0.009356880647590363, 0, 0.05, false, false],
        ["xOuter", 0, 5.24698795180723, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1, 0, 1, false, false],
        ["yMultiplier", 0, 0.2, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 13.802240210843376, 0, 50, false, false],
        ["ballSize", 0, 20, 2, 20, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 0, 0, 50, false, false],
        ["yOuter", 0, 0.015615116716867473, 0, 0.05, false, false],
        ["xOuter", 0, 97.3038403614458, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22948042168674704, 0, 10, false, false],
        ["yMultiplier", 0, 0.3789241340361446, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 6.220169976592644, 0, 50, false, false],
        ["ballSize", 0, 8.297458584337349, 2, 20, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.2287650602409639, 0, 2, false, false],
        ["xOuter", 0, 1.3874246987951813, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.0312500000000004, 0, 10, false, false],
        ["yMultiplier", 0, 0.9511238704819278, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 1.7532473644578315, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eef"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 24.188629518072297, 0, 150, false, false],
        ["ballSize", 0, 32.67104668674699, 2, 410, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 232.6218938253012, 0, 250, false, false],
        ["yOuter", 0, 0.0010238610692771088, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 0.49793862951807233, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 0, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9efe"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation + stream/4./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.y/20.+ cos(stream-uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 33.) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.9950065888554223, 0, 33, false, false],
        ["ballSize", 0, 11.836751694277112, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 11.370670180722895, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 3.485498175563583, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 10.29427609730916, 0, 33, false, false],
        ["xMultiplier", 0, 64.29451646000507, 0, 110, false, false],
        ["yMultiplier", 0, 362.13499121608504, 1, 1330, false, false],
        ["divider", 0, 9.619286778461504, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 23, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.13272710593349965, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 2.0719639743667058, 0, 33, false, false],
        ["ballSize", 0, 25.215378190691247, 0, 33, false, false],
        ["contrast", 0, 3.3798278900514176, 0, 15, false, false],
        ["radius", 0, 0.14887378187064668, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.194977266242707, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 34.414792348103354, 0, 50, false, false],
        ["rotation", 0, 4.1073160746011395, 0, 5, false, false],
        ["xDiv", 0, 0.9732506074101094, 0, 2, false, false],
        ["yDiv", 0, 1.2935981474727036, 0, 2, false, false],
        ["yDiv2", 0, 0.5701666958360787, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef6"
    },
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/1.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 68.17255271084338, 0, 122, false, false],
        ["ballSize", 0, 8.56362951807229, 0, 25, false, false],
        ["contrast", 0, 2.8231598268072293, 0, 15, false, false],
        ["radius", 0, 59.41100338855423, 0, 325, false, false],
        ["yOuter", 0, 2.0321912650602414, 0, 100, false, false],
        ["xOuter", 0, 72.87236445783132, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 152.81835937500003, 0, 249, false, false],
        ["yMultiplier", 0, 4.17531061746988, 0, 10, false, false],
        ["divider", 0, 56.23923374162738, 0, 100, false, false],
        ["rotation", 0, 3.958419615963856, 0, 5, false, false],
        ["xDiv", 0, 256.81297063253015, 0, 323, false, false],
        ["yDiv", 0, 2.611314006024097, 0, 23, false, false],
        ["yDiv2", 0, 21.816556852409644, 0, 222, false, false],
        ["xDiv3", 0, 200.19099209337355, 0, 242, false, false],
        ["div", 0, 103.22031250000002, 0, 332, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f06"
    },
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 13.209459713855425, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 17.647628012048195, 0, 44, false, false],
        ["ballSize", 0, 43.71983245481929, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 55.744658320783145, 0, 325, false, false],
        ["yOuter", 0, 16.551152945464164, 0, 100, false, false],
        ["xOuter", 0, 103.83358433734941, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.2462820030120487, 0, 10, false, false],
        ["yMultiplier", 0, 9.4296875, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.5707963268, 0, 1.5707963268, false, false]
      ],
      [
        ["zoom", 0, 16.598362198795183, 0, 44, false, false],
        ["ballSize", 0, 42.25292733433736, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 325, 0, 325, false, false],
        ["yOuter", 0, 7.271743222891567, 0, 100, false, false],
        ["xOuter", 0, 59.877259036144586, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.10918674698795185, 0, 10, false, false],
        ["yMultiplier", 0, 0.18924134036144583, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 0.3854715737951808, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 17.53494917168675, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 31.667921686746997, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.739410768072291, 0, 10, false, false],
        ["yMultiplier", 0, 2.6839231927710845, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 0.7260918674698796, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0a"
    },
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter*(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/1.)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 0.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 12.551233057228918, 0, 222, false, false],
        ["contrast", 0, 2.571983245481928, 0, 15, false, false],
        ["radius", 0, 7.949101091867472, 0, 325, false, false],
        ["yOuter", 0, 7.7498117469879535, 0, 40, false, false],
        ["xOuter", 0, 2.282073606927711, 1, 40, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4946347891566266, 0, 10, false, false],
        ["yMultiplier", 0, 1.9728915662650606, 0, 10, false, false],
        ["divider", 0, 3.5445124246987953, 2, 4, false, false],
        ["rotation", 0, 1.1198336314006025, 0, 1.75, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9efa"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 2.2154850143984146, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 15.88807067411492, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 28.503943468576463, 0, 33, false, false],
        ["xMultiplier", 0, 20.76713074833514, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 32.78597406594151, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 23, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.13272710593349965, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 2.0719639743667058, 0, 33, false, false],
        ["ballSize", 0, 25.215378190691247, 0, 33, false, false],
        ["contrast", 0, 3.3798278900514176, 0, 15, false, false],
        ["radius", 0, 0.14887378187064668, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.194977266242707, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 34.414792348103354, 0, 50, false, false],
        ["rotation", 0, 4.1073160746011395, 0, 5, false, false],
        ["xDiv", 0, 0.9732506074101094, 0, 2, false, false],
        ["yDiv", 0, 1.2935981474727036, 0, 2, false, false],
        ["yDiv2", 0, 0.5701666958360787, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee6"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 13.138648343373497, 0, 50, false, false],
        ["ballSize", 0, 15.823861069277111, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.82177146084338, 0, 50, false, false],
        ["yOuter", 0, 0.468655873493976, 0, 4, false, false],
        ["xOuter", 0, 20.044804216867476, 1, 241, false, false],
        ["xMultiplier", 0, 1.9600432981927716, 0, 10, false, false],
        ["yMultiplier", 0, 0.863190888554217, 0.2, 2, false, false],
        ["divider", 0, 1.0117187500000002, 0, 2, false, false],
        ["rotation", 0, 2.331681951304134, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec1"
    },
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/12.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/-1.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/100.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 4.089656526496611, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 76.04349848735765, 0, 150, false, false],
        ["ballSize", 0, 7, 2, 7, false, false],
        ["contrast", 0, 1.6782306648162477, 0, 15, false, false],
        ["radius", 0, 46.73833272543298, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 121.90263440235556, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4497109654438065, 0, 1, false, false],
        ["yMultiplier", 0, 0.9904435643541671, 0.2, 2, false, false],
        ["divider", 0, 0.4888161349009319, 0, 2, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["yDiv", 0, 5.318059162921217, 0, 10, false, false],
        ["yDiv2", 0, 66.56326227762614, 0, 112, false, false],
        ["xDiv", 0, 5.000529057146556, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 2.512914450771838, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 31.12488712172911, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 35.98427204913405, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5644670969032382, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee9"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0.23066641566265064, 0, 4, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef3"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f03"
    },
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/6. + sin(uv.y/50. + stream/10.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .4)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 17.22788027108434, 0, 22, false, false],
        ["ballSize", 0, 14.472628012048197, 0, 222, false, false],
        ["contrast", 0, 2.1693806475903616, 0, 15, false, false],
        ["radius", 0, 32.883918486445786, 0, 325, false, false],
        ["yOuter", 0, 0.04762330572289158, 0, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5703595632530123, 0, 10, false, false],
        ["yMultiplier", 0, 0.352456701807229, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 17.22788027108434, 0, 22, false, false],
        ["ballSize", 0, 29.301534262048197, 0, 222, false, false],
        ["contrast", 0, 3.1542931904625604, 0, 15, false, false],
        ["radius", 0, 53.459502070783145, 0, 325, false, false],
        ["yOuter", 0, 0.05249435240963857, 0, 3, false, false],
        ["xOuter", 0, 15.192394578313257, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 8.853774472891567, 0, 10, false, false],
        ["yMultiplier", 0, 2.4906344126506026, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 6.410937500000001, 0, 22, false, false],
        ["ballSize", 0, 14.472628012048197, 0, 222, false, false],
        ["contrast", 0, 2.1693806475903616, 0, 15, false, false],
        ["radius", 0, 32.883918486445786, 0, 325, false, false],
        ["yOuter", 0, 0.04762330572289158, 0, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5703595632530123, 0, 10, false, false],
        ["yMultiplier", 0, 0.352456701807229, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 7.577793427373488, 0, 22, false, false],
        ["ballSize", 0, 58.52993222891567, 0, 222, false, false],
        ["contrast", 0, 2.1693806475903616, 0, 15, false, false],
        ["radius", 0, 146.9326359518514, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.080148719879518, 0, 10, false, false],
        ["yMultiplier", 0, 1.4089796686746991, 0, 10, false, false],
        ["divider", 0, 35.120011295180724, 0, 100, false, false],
        ["rotation", 0, 1.7179499246987953, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 3.7691359186746993, 0, 22, false, false],
        ["ballSize", 0, 2.939090737951808, 0, 6, false, false],
        ["contrast", 0, 2.613069465361446, 0, 15, false, false],
        ["radius", 0, 6.540380271084339, 0, 325, false, false],
        ["yOuter", 0, 1.0349397590361447, 1, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 0.699077560240964, 0, 10, false, false],
        ["divider", 0, 35.07200677710844, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 6.12082078313253, 0, 22, false, false],
        ["ballSize", 0, 6, 0, 6, false, false],
        ["contrast", 0, 4.603421498493976, 0, 15, false, false],
        ["radius", 0, 2.5390625000000013, 0, 325, false, false],
        ["yOuter", 0, 1.9721573795180727, 1, 3, false, false],
        ["xOuter", 0, 15.500753012048198, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.380835843373494, 0, 10, false, false],
        ["yMultiplier", 0, 1.0129423945783136, 0, 10, false, false],
        ["divider", 0, 1.1751694277108438, 0, 100, false, false],
        ["rotation", 0, 0.7095726656626506, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0e"
    },
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.07584582078313254, 0, 0.74, false, false],
        ["contrast", 0, 0.20117573418674703, 0, 0.26, false, false],
        ["orbSize", 0, 7.28865606174699, 0, 116.68, false, false],
        ["radius", 0, 10.575385918674701, 0, 22, false, false],
        ["colorShift", 0, 5.054118975903616, 0, 20.64, false, false],
        ["sides", 0, 0.7601185993975904, 0, 2, false, false],
        ["rotation", 0, 1.2313253012048195, 0, 2, false, false],
        ["sinMul", 0, 0.6959807981927711, 0, 3, false, false],
        ["cosMul", 0, 6.535983810240964, 0, 21.56, false, false],
        ["yMul", 0, 0.3850009412650603, 0, 1, false, false],
        ["xMul", 0, 0.4664166039156627, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0022381682981927713, 0, 0.006, false, false],
        ["yDivide", 0, 3.05937311746988, 0, 3.6, false, false],
        ["xDivide", 0, 3.200705948795181, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f12"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream /8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 12.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 12.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 0.137, 0, 0.274, false, false],
        ["orbSize", 0, 7.11, 0, 14.22, false, false],
        ["radius", 0, 36.25, 0, 72.5, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.89, 0, 9.78, false, false],
        ["xDivide", 0, 7.14, 0, 14.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9edd"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n\n  float i = 1.;\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 36.246470256024104, 0, 50, false, false],
        ["ballSize", 0, 20, 2, 20, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 0, 0, 50, false, false],
        ["yOuter", 0, 0.015615116716867473, 0, 0.05, false, false],
        ["xOuter", 0, 97.3038403614458, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22948042168674704, 0, 10, false, false],
        ["yMultiplier", 0, 0.3789241340361446, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 9.248164533132531, 0, 50, false, false],
        ["ballSize", 0, 9.403896837349398, 2, 30, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 7.808028990963857, 0, 50, false, false],
        ["yOuter", 0, 0.009356880647590363, 0, 0.05, false, false],
        ["xOuter", 0, 5.24698795180723, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1, 0, 1, false, false],
        ["yMultiplier", 0, 0.2, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 13.802240210843376, 0, 50, false, false],
        ["ballSize", 0, 20, 2, 20, false, false],
        ["contrast", 0, 1.9728445030120483, 0, 15, false, false],
        ["radius", 0, 0, 0, 50, false, false],
        ["yOuter", 0, 0.015615116716867473, 0, 0.05, false, false],
        ["xOuter", 0, 97.3038403614458, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22948042168674704, 0, 10, false, false],
        ["yMultiplier", 0, 0.3789241340361446, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.258400790662651, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 17.042545180722893, 0, 50, false, false],
        ["ballSize", 0, 52.903049698795186, 2, 120, false, false],
        ["contrast", 0, 2.3970491340361453, 0, 15, false, false],
        ["radius", 0, 5.784779743975905, 0, 50, false, false],
        ["yOuter", 0, 0.7183546686746989, 0, 2, false, false],
        ["xOuter", 0, 18.679216867469883, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4366057981927712, 0, 10, false, false],
        ["yMultiplier", 0, 1.3538874246987953, 0.2, 2, false, false],
        ["divider", 0, 6.722232680722893, 0, 10, false, false],
        ["rotation", 0, 0, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9edf"
    },
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;\n    float a = cos(xMultiplier*uv.x - stream);\n    float b = uv.x/yMultiplier;\n    float c = PI+radius*cos(t-stream/-5.);\n    float d = yMultiplier*cos(stream/9. -uv.x* sin(uv.y/4.-stream/.6));\n    float x = xOuter - a - b *c * d;\n    float y = cos(stream/3. - .91 * yOuter*  uv.x / xDiv +t+yMultiplier+1.);\n    vec2 p = vec2(radius2  *x, radius * y);\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 22, 0, 22, false, false],
        ["ballSize", 0, 222, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 230.54075677710847, 0, 325, false, false],
        ["yOuter", 0, 22.523060993975907, 0, 100, false, false],
        ["xOuter", 0, 125.5440512048193, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 20.496987951807235, 0, 100, false, false],
        ["rotation", 0, 1.8675404743975905, 0, 5, false, false],
        ["radius2", 0, 1.6828878012048196, 0, 10, false, false],
        ["xDiv", 0, 19.27454819277109, 0, 222, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eec"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 6.476543674698796, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 31.092338102409645, 0, 50, false, false],
        ["yOuter", 0, 0.0005304028614457833, 0, 0.05, false, false],
        ["xOuter", 0, 130.72176204819277, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.1696630271084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.1726844879518075, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 13.757765436746988, 0, 50, false, false],
        ["ballSize", 0, 6.476543674698796, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 10.042356927710845, 0, 50, false, false],
        ["yOuter", 0, 0.011533635853503293, 0, 0.05, false, false],
        ["xOuter", 0, 18.25225903614458, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.8655402861445785, 0, 10, false, false],
        ["yMultiplier", 0, 2, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 0, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f07"
    },
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 13.209459713855425, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 7.1110692771084345, 0, 22, false, false],
        ["ballSize", 0, 68.75438629518074, 0, 222, false, false],
        ["contrast", 0, 2.900848972223537, 0, 15, false, false],
        ["radius", 0, 97.87321159638554, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 77.33847891566266, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 2.3576336596385543, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 24.060796310240967, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 52.09666792168676, 0, 100, false, false],
        ["xOuter", 0, 20.664909638554224, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.739410768072291, 0, 10, false, false],
        ["yMultiplier", 0, 6.721667921686748, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 30.776807228915672, 0, 44, false, false],
        ["ballSize", 0, 24.154828689759043, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 55.744658320783145, 0, 325, false, false],
        ["yOuter", 0, 16.551152945464164, 0, 100, false, false],
        ["xOuter", 0, 103.83358433734941, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.338855421686747, 0, 10, false, false],
        ["yMultiplier", 0, 0.8790945030120484, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.5707963268, 0, 1.5707963268, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f13"
    },
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.09821507906626509, 0, 0.74, false, false],
        ["contrast", 0, 0.183140436746988, 0, 0.26, false, false],
        ["orbSize", 0, 12.909258659638557, 0, 16.68, false, false],
        ["radius", 0, 19.90608856669016, 0, 22, false, false],
        ["colorShift", 0, 8.129428463855422, 0, 20.64, false, false],
        ["sides", 0, 0.7601185993975904, 0, 2, false, false],
        ["rotation", 0, 0.33273719879518077, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 2.505228915662651, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0020074077560240967, 0, 0.006, false, false],
        ["yDivide", 0, 2.2532360692771087, 0, 3.6, false, false],
        ["xDivide", 0, 0.8332261859939759, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eea"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0.23066641566265064, 0, 4, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f02"
    },
    "shader": "void main () {\n  float stream = stream  /1.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation + stream/10.);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.0384615384615383, 0, 22, false, false],
        ["ballSize", 0, 31.316961596385546, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 36.36363636363637, 0, 325, false, false],
        ["yOuter", 0, 0.4300699300699301, 0, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 2.56331890060241, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 7.1110692771084345, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 77.33847891566266, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.5005647590361446, 0, 10, false, false],
        ["yMultiplier", 0, 0.19545368975903618, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 4.713723644578314, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.2896743222891573, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0.11183640813253015, 0, 3, false, false],
        ["xOuter", 0, 33.473644578313255, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.087255271084339, 0, 10, false, false],
        ["yMultiplier", 0, 0.19545368975903618, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0b"
    },
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 20.337114081325307, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 7.1110692771084345, 0, 22, false, false],
        ["ballSize", 0, 68.75438629518074, 0, 222, false, false],
        ["contrast", 0, 2.900848972223537, 0, 15, false, false],
        ["radius", 0, 97.87321159638554, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 77.33847891566266, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 10, false, false],
        ["yMultiplier", 0, 2.3576336596385543, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 24.060796310240967, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 52.09666792168676, 0, 100, false, false],
        ["xOuter", 0, 20.664909638554224, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.739410768072291, 0, 10, false, false],
        ["yMultiplier", 0, 6.721667921686748, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee0"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 16.946536144578314, 0, 50, false, false],
        ["ballSize", 0, 4.591603915662651, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 129.8467741759196, 0, 222, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 56.4175451807229, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.665333207831327, 0, 10, false, false],
        ["yMultiplier", 0, 1.1659497364457834, 0.2, 2, false, false],
        ["divider", 0, 1924.404183923193, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eee"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d((i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 34.832638704121344, 0, 50, false, false],
        ["ballSize", 0, 4.407340158987528, 2, 10, false, false],
        ["contrast", 0, 5.053075235628817, 0, 15, false, false],
        ["radius", 0, 11.050260000214896, 0, 50, false, false],
        ["yOuter", 0, 0.04999356892232551, 0, 0.05, false, false],
        ["xOuter", 0, 6.847317946075236, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.19113066136076556, 0, 10, false, false],
        ["yMultiplier", 0, 1.3790737271967741, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.6071400877272546, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 34.833866716867476, 0, 50, false, false],
        ["ballSize", 0, 4.406927710843373, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 11.047628012048195, 0, 50, false, false],
        ["yOuter", 0, 0.05, 0, 0.05, false, false],
        ["xOuter", 0, 6.846385542168676, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.19093561746987955, 0, 10, false, false],
        ["yMultiplier", 0, 1.3790982680722894, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ec9"
    },
    "shader": "void main () {\n  float stream = stream;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d((.2*stream/(i+1.))+rotation / (PI * i + 1.));\n    float t = float(i) * PI / float(1);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream/.1-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(-uv.x/xDiv * sin(uv.y/yDiv-stream/.4)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.15)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 4.089656526496611, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 1350, 0, 1350, false, false],
        ["ballSize", 0, 88, 2, 88, false, false],
        ["contrast", 0, 3.3665371630565235, 0, 15, false, false],
        ["radius", 0, 896.0313424719387, 0, 1150, false, false],
        ["yOuter", 0, 4, 1, 4, false, false],
        ["xOuter", 0, 184.70476633094881, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1, 0, 1, false, false],
        ["yMultiplier", 0, 1.3178916471550266, 0.2, 2, false, false],
        ["divider", 0, 1.4259570386036335, 0, 2, false, false],
        ["rotation", 0, 3.8320608483739655, 0, 5, false, false],
        ["yDiv", 0, 16.398728290236143, 0, 110, false, false],
        ["yDiv2", 0, 68.05689506071161, 0, 112, false, false],
        ["xDiv", 0, 212, 0, 212, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 2.512914450771838, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 31.12488712172911, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 35.98427204913405, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.5644670969032382, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.709Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef1"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.4)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 169.99143347682727, 0, 250, false, false],
        ["ballSize", 0, 7.6826047598597516, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 45.23564166333303, 0, 50, false, false],
        ["yOuter", 0, 0.8148220567818149, 0, 4, false, false],
        ["xOuter", 0, 0, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.13444751142019254, 0, 10, false, false],
        ["yMultiplier", 0, 2.553389377823796, 0.2, 5, false, false],
        ["divider", 0, 0.5201743803828596, 0, 2, false, false],
        ["rotation", 0, 2.665821305240494, 0, 5, false, false],
        ["yDiv", 0, 8.247158693980024, 0, 210, false, false],
        ["yDiv2", 0, 51.70744459772685, 0, 112, false, false],
        ["xDiv", 0, 24.251763842479296, 0, 42, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 18.764354292168676, 0, 50, false, false],
        ["ballSize", 0, 30.02166792168675, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 48.605751129518076, 0, 250, false, false],
        ["yOuter", 0, 0.28322665662650603, -1, 4, false, false],
        ["xOuter", 0, 81.74359939759037, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.788685993975904, 0, 10, false, false],
        ["yMultiplier", 0, 2.4412114081325305, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 4.2250564759036155, 0, 5, false, false],
        ["yDiv", 0, 4.170557228915664, 0, 110, false, false],
        ["yDiv2", 0, 8.153840361445786, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9efc"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 2.2154850143984146, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 3.485498175563583, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 10.29427609730916, 0, 33, false, false],
        ["xMultiplier", 0, 64.29451646000507, 0, 110, false, false],
        ["yMultiplier", 0, 362.13499121608504, 1, 1330, false, false],
        ["divider", 0, 9.619286778461504, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 23, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.13272710593349965, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 2.0719639743667058, 0, 33, false, false],
        ["ballSize", 0, 25.215378190691247, 0, 33, false, false],
        ["contrast", 0, 3.3798278900514176, 0, 15, false, false],
        ["radius", 0, 0.14887378187064668, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.194977266242707, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 34.414792348103354, 0, 50, false, false],
        ["rotation", 0, 4.1073160746011395, 0, 5, false, false],
        ["xDiv", 0, 0.9732506074101094, 0, 2, false, false],
        ["yDiv", 0, 1.2935981474727036, 0, 2, false, false],
        ["yDiv2", 0, 0.5701666958360787, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0d"
    },
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.09821507906626509, 0, 0.74, false, false],
        ["contrast", 0, 0.183140436746988, 0, 0.26, false, false],
        ["orbSize", 0, 4.850500941265062, 0, 116.68, false, false],
        ["radius", 0, 10.575385918674701, 0, 22, false, false],
        ["colorShift", 0, 6.237557981927711, 0, 20.64, false, false],
        ["sides", 0, 0.7601185993975904, 0, 2, false, false],
        ["rotation", 0, 0.8464984939759037, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 2.7214832454819278, 0, 21.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.3449747740963856, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0020074077560240967, 0, 0.006, false, false],
        ["yDivide", 0, 2.2532360692771087, 0, 3.6, false, false],
        ["xDivide", 0, 0.8332261859939759, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f14"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.08638846009036147, 0, 0.14, false, false],
        ["contrast", 0, 0.11821997364457834, 0, 0.26, false, false],
        ["orbSize", 0, 3.960884789156627, 0, 12.92, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 2.38, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.28, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.99, 0, 9.98, false, false],
        ["xDivide", 0, 6.27, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.033166980421686754, 0, 0.14, false, false],
        ["contrast", 0, 0.12439815512048197, 0, 0.26, false, false],
        ["orbSize", 0, 9.584353162650604, 0, 312.92, false, false],
        ["radius", 0, 22, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.8233670933734941, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.4288580572289158, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 0.7236063629518074, 0, 9.98, false, false],
        ["xDivide", 0, 8.498375941265062, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.008450865963855424, 0, 0.14, false, false],
        ["contrast", 0, 0.12439815512048197, 0, 0.26, false, false],
        ["orbSize", 0, 85.2886669804217, 0, 312.92, false, false],
        ["radius", 0, 360.3195406626507, 0, 522, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.8233670933734941, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.02921762048192772, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 8.053467338102411, 0, 9.98, false, false],
        ["xDivide", 0, 12.54, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9edb"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 30.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.2-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 7.336954066265062, 0, 12, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.071959713855422, 0, 10, false, false],
        ["yMultiplier", 0, 1.3968373493975907, 0.2, 2, false, false],
        ["divider", 0, 0.4658226656626506, 0, 2, false, false],
        ["rotation", 0, 2.081160579819277, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 98.6929431593562, 0, 150, false, false],
        ["ballSize", 0, 5.52510052416698, 2, 7, false, false],
        ["contrast", 0, 1.6600951465185185, 0, 15, false, false],
        ["radius", 0, 57.937847734933875, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.11999418879129803, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 38.26181390601469, 0, 112, false, false],
        ["xDiv", 0, 3.6583544995411335, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee5"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 13.138648343373497, 0, 50, false, false],
        ["ballSize", 0, 15.823861069277111, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.82177146084338, 0, 50, false, false],
        ["yOuter", 0, 0.468655873493976, 0, 4, false, false],
        ["xOuter", 0, 20.044804216867476, 1, 241, false, false],
        ["xMultiplier", 0, 1.9600432981927716, 0, 10, false, false],
        ["yMultiplier", 0, 0.863190888554217, 0.2, 2, false, false],
        ["divider", 0, 1.0117187500000002, 0, 2, false, false],
        ["rotation", 0, 2.331681951304134, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9efb"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation + stream/8./(i+1.) + .5 + .3 * PI/.2 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(stream-.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-10.)), length(uv)/10./zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 2.9559209203841617, 0, 3, false, false],
        ["ballSize", 0, 2.2154850143984146, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.03184048756059395, 0, 1, false, false],
        ["yOuter", 0, 0.017453195273158067, 0, 0.1, false, false],
        ["xOuter", 0, 7.812164580103863, 0, 33, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 573.5728769738992, 1, 1330, false, false],
        ["divider", 0, 18.25563063104469, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.4550589320171311, 0, 2, false, false],
        ["yDiv", 0, 0.23577797211796409, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 12.515899603050876, 0, 33, false, false],
        ["ballSize", 0, 15.88807067411492, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.02487082883536098, 0, 1, false, false],
        ["yOuter", 0, 0.03216003555849375, 0, 0.1, false, false],
        ["xOuter", 0, 28.503943468576463, 0, 33, false, false],
        ["xMultiplier", 0, 20.76713074833514, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 32.78597406594151, 0, 50, false, false],
        ["rotation", 0, 1.3997481932123024, 0, 5, false, false],
        ["xDiv", 0, 0.1232371870293675, 0, 2, false, false],
        ["yDiv", 0, 1.3197303588131826, 0, 2, false, false],
        ["yDiv2", 0, 0.39814647077077847, 0, 2, false, false],
        ["uvDiv", 0, 11.854713007915453, 0, 33, false, false]
      ],
      [
        ["zoom", 0, 3.3430857371134937, 0, 33, false, false],
        ["ballSize", 0, 6.370043228333255, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 0.010405317559299703, 0, 1, false, false],
        ["yOuter", 0, 0.046984939575195325, 0, 0.1, false, false],
        ["xOuter", 0, 6.67446219662586, 0, 33, false, false],
        ["xMultiplier", 0, 53.282295291852456, 0, 110, false, false],
        ["yMultiplier", 0, 1330, 1, 1330, false, false],
        ["divider", 0, 30.613560044621853, 0, 50, false, false],
        ["rotation", 0, 1.9098261178257956, 0, 5, false, false],
        ["xDiv", 0, 0.7193660230521697, 0, 2, false, false],
        ["yDiv", 0, 0.7171324120946678, 0, 2, false, false],
        ["yDiv2", 0, 0.3574060830725245, 0, 2, false, false],
        ["uvDiv", 0, 5.76971131290298, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f00"
    },
    "shader": "#define BALLS 5\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/111.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/5.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.  / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 10.185560993975907, 0, 22, false, false],
        ["ballSize", 0, 25.938309487951813, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0.29838102409638584, 0, 100, false, false],
        ["xOuter", 0, 7.768072289156628, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 3, 0, 100, false, false],
        ["rotation", 0, 0.1593, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f01"
    },
    "shader": "void main () {\n  float stream = stream  /1.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 15.556758283132533, 0, 22, false, false],
        ["ballSize", 0, 31.316961596385546, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 2.56331890060241, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 7.1110692771084345, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 1.7615540286144582, 0, 3, false, false],
        ["xOuter", 0, 77.33847891566266, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.5005647590361446, 0, 10, false, false],
        ["yMultiplier", 0, 0.19545368975903618, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 4.713723644578314, 0, 22, false, false],
        ["ballSize", 0, 34.510928087349406, 0, 222, false, false],
        ["contrast", 0, 2.2896743222891573, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0.11183640813253015, 0, 3, false, false],
        ["xOuter", 0, 33.473644578313255, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.087255271084339, 0, 10, false, false],
        ["yMultiplier", 0, 0.19545368975903618, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 3.675263554216868, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ede"
    },
    "shader": "void main () {\n  float stream = stream / 10.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/3.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/yDiv2-stream/1.6)), radius*\n                  cos(stream/11. - yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv-stream/1.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 19.60866905120482, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 40.1065982680723, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 0, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.5201901355421688, 0, 10, false, false],
        ["yMultiplier", 0, 1.6588827183734942, 0.2, 2, false, false],
        ["divider", 0, 2.30464984939759, 2, 3, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 3.276618975903615, 0, 12, false, false],
        ["yDiv2", 0, 16.096686746987956, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee1"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/120.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(100.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - .1*yOuter*uv.x/.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 22.012424698795183, 0, 50, false, false],
        ["ballSize", 0, 4.484186746987952, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 36.5726185993976, 0, 50, false, false],
        ["yOuter", 0, 0.01675381212349398, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4025790662650603, 0, 10, false, false],
        ["yMultiplier", 0, 0.3666745105421687, 0.2, 2, false, false],
        ["divider", 0, 549.270218373494, 1, 2230, false, false],
        ["rotation", 0, 0.5101421310240966, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee8"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/30. - yOuter*uv.x/1.05+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 14.781626506024098, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.4503482680722897, 0, 10, false, false],
        ["yMultiplier", 0, 0.7763761295180723, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 4.338808358433735, 0, 10, false, false],
        ["yDiv2", 0, 19.944201807228918, 0, 112, false, false],
        ["xDiv", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef4"
    },
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 10.43550451807229, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef8"
    },
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 89.15967620481929, 0, 122, false, false],
        ["ballSize", 0, 4.9001082454819285, 0, 25, false, false],
        ["contrast", 0, 2.8231598268072293, 0, 15, false, false],
        ["radius", 0, 26.735104480421693, 0, 325, false, false],
        ["yOuter", 0, 2.0321912650602414, 0, 100, false, false],
        ["xOuter", 0, 72.87236445783132, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 102.42890625000001, 0, 249, false, false],
        ["yMultiplier", 0, 4.814335466867471, 0, 10, false, false],
        ["divider", 0, 24.287932981927714, 0, 100, false, false],
        ["rotation", 0, 0.31049981174698804, 0, 5, false, false],
        ["xDiv", 0, 280.8920368975904, 0, 323, false, false],
        ["yDiv", 0, 1.3295792545180725, 0, 23, false, false],
        ["yDiv2", 0, 12.641613328313255, 0, 22, false, false],
        ["xDiv3", 0, 42, 0, 42, false, false],
        ["div", 0, 103.22031250000002, 0, 332, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f04"
    },
    "shader": "void main () {\n  float stream = stream  /6.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + sin(uv.x/10.*\n                                                sin(stream/2.)));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.)), radius*cos(11.1*yOuter*uv.x/1.5+t+yMultiplier+12.));\n    vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .5), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 4.985203313253013, 0, 22, false, false],
        ["ballSize", 0, 19.99858810240964, 0, 55, false, false],
        ["contrast", 0, 2.5889260165662655, 0, 15, false, false],
        ["radius", 0, 28.156250000000004, 0, 34, false, false],
        ["yOuter", 0, 0, 0, 3, false, false],
        ["xOuter", 0, 3.7390813253012056, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.3571630271084345, 0, 10, false, false],
        ["yMultiplier", 0, 0.8000282379518074, 0, 10, false, false],
        ["divider", 0, 10.18425263554217, 0, 50, false, false],
        ["rotation", 0, 1.6163638930722892, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f05"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  \n  for (float i = 1.; i < 6.; i++) {\n    uv *= k_rotate2d((rotation - i) + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) - divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = tan(t-stream/14.) * yMultiplier*cos(uv.x + sin(uv.y/100.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)- stream), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .5), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 6.797618599397591, 0, 122, false, false],
        ["ballSize", 0, 6.738328313253014, 0, 55, false, false],
        ["contrast", 0, 1.2748023343373498, 0, 15, false, false],
        ["radius", 0, 4.569230045180723, 0, 34, false, false],
        ["yOuter", 0, 0.10073889307228917, 0, 3, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["xMultiplier", 0, 17.385777484939762, 0, 110, false, false],
        ["yMultiplier", 0, 4.878012048192772, 0, 10, false, false],
        ["divider", 0, 3.1055158132530125, 0, 10, false, false],
        ["rotation", 0, 2.3890248493975905, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 5.151694277108434, 0, 22, false, false],
        ["ballSize", 0, 22.96265530873494, 0, 55, false, false],
        ["contrast", 0, 1.2748023343373498, 0, 15, false, false],
        ["radius", 0, 5.819267695783134, 0, 34, false, false],
        ["yOuter", 0, 0.2970632530120483, 0, 3, false, false],
        ["xOuter", 0, 38.66490963855422, 1, 241, false, false],
        ["xMultiplier", 0, 34.81918298192771, 0, 110, false, false],
        ["yMultiplier", 0, 10, 0, 10, false, false],
        ["divider", 0, 3.3943900602409642, 0, 10, false, false],
        ["rotation", 0, 0.9234045557228918, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f08"
    },
    "shader": "void main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/1. -uv.x * sin(uv.y/4.-stream/1.)), radius*\n                  cos(stream/30. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 0.)/2. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 20.337114081325307, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 1.844597138554217, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed7"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = pow(stream  /1., .351)*1000.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(PI/.2 * rotation + stream/8./(i+1.) + .5 + .3 * sin(stream/.0 + uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream/.582325 + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(.1*yOuter*uv.x/xDiv*t+yMultiplier);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/uvDiv - stream/-20.)), length(uv)/zoom/1.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .05)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 6.726694378220893, 0, 122, false, false],
        ["ballSize", 0, 4.62000617521355, 0, 23, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 3.5971404293933555, 0, 34, false, false],
        ["yOuter", 0, 0, 0, 0.1, false, false],
        ["xOuter", 0, 0.5854752965720305, 0, 3, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 10, 1, 10, false, false],
        ["divider", 0, 17.388596592179265, 0, 50, false, false],
        ["rotation", 0, 1.6389976869146508, 0, 5, false, false],
        ["xDiv", 0, 0.5166686276355422, 0, 2, false, false],
        ["yDiv", 0, 0.5852864093091115, 0, 2, false, false],
        ["yDiv2", 0, 0.7892679421298476, 0, 2, false, false],
        ["uvDiv", 0, 6.699874740049065, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eed"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef7"
    },
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p =vec2(radius * xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)),radius * \n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 53.43126882530121, 0, 122, false, false],
        ["ballSize", 0, 7.950512989457832, 0, 25, false, false],
        ["contrast", 0, 2.8231598268072293, 0, 15, false, false],
        ["radius", 0, 0.936050451807229, 0, 1, false, false],
        ["yOuter", 0, 32.44305346385543, 0, 100, false, false],
        ["xOuter", 0, 82.93637048192772, 1, 241, false, false],
        ["xMultiplier", 0, 180.22617187500003, 0, 249, false, false],
        ["yMultiplier", 0, 1.434252635542169, 0, 10, false, false],
        ["divider", 0, 37.18844126506025, 0, 100, false, false],
        ["rotation", 0, 0.4398296310240965, 0, 5, false, false],
        ["xDiv", 0, 162.5990634412651, 0, 323, false, false],
        ["yDiv", 0, 10.444212953170046, 0, 23, false, false],
        ["yDiv2", 0, 4.441933358433736, 0, 22, false, false],
        ["xDiv3", 0, 9.845726656626507, 0, 42, false, false],
        ["div", 0, 58.914062500000014, 0, 332, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eff"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /4.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/yDiv2));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = yMultiplier*cos(uv.x + sin(stream + uv.y/yDiv));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(100.1*yOuter*uv.x/xDiv+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.756140619300935, 0, 122, false, false],
        ["ballSize", 0, 0.5078473746058454, 0, 3, false, false],
        ["contrast", 0, 3.7571877858724942, 0, 15, false, false],
        ["radius", 0, 2.7378595558993792, 0, 34, false, false],
        ["yOuter", 0, 0, 0, 5, false, false],
        ["xOuter", 0, 0, 0, 3, false, false],
        ["xMultiplier", 0, 0, 0, 110, false, false],
        ["yMultiplier", 0, 1.078976952886007, 1, 10, false, false],
        ["divider", 0, 17.388596592179265, 0, 50, false, false],
        ["rotation", 0, 0.44312153092349876, 0, 5, false, false],
        ["xDiv", 0, 0.10408700230609942, 0, 2, false, false],
        ["yDiv", 0, 0.9242708321077279, 0, 2, false, false],
        ["yDiv2", 0, 0.7795379270990211, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f09"
    },
    "shader": "void main () {\n  float stream = stream  /3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 3.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(4.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter*(cos(xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius*cos(t-stream/4.) * yMultiplier*cos(stream/11. -uv.x * sin(uv.y/yDiv2-stream/1.)), radius*\n                  cos(stream/11. - .1*yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 18.40838540364059, 0, 22, false, false],
        ["ballSize", 0, 93.23414909638555, 0, 222, false, false],
        ["contrast", 0, 5.104927522590362, 0, 15, false, false],
        ["radius", 0, 108.7621187876506, 0, 325, false, false],
        ["yOuter", 0, 8.498682228915664, 0, 40, false, false],
        ["xOuter", 0, 9.706904179216867, 1, 40, false, false],
        ["xMultiplier", 0, 3.080948795180723, 0, 10, false, false],
        ["yMultiplier", 0, 5.837114081325302, 0, 10, false, false],
        ["divider", 0, 2.619154743975904, 2, 4, false, false],
        ["rotation", 0, 0.803296780873494, 0, 1.75, false, false],
        ["xDiv", 0, 2.942137543154226, 0, 52, false, false],
        ["yDiv", 0, 2.405440512048193, 0, 52, false, false],
        ["yDiv2", 0, 45.54506777108435, 0, 232, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f10"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/9.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/-1.9);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n    \n  }\n  gl_FragColor = k_hue(gl_FragColor, colorShift);\n}",
    "variants": [
      [
        ["zoom", 0, 0.13627164909638556, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.15886671686747, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 14.394220632530123, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0.65417921686747, 0, 4, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -0.5496234939759033, -3, 3, false, false],
        ["ySpeed", 0, -3, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 4.308617281626506, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ed6"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = atan(t+stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 3.756140619300935, 0, 122, false, false],
        ["ballSize", 0, 45.40572738647462, 0, 255, false, false],
        ["contrast", 0, 2.723491561226182, 0, 15, false, false],
        ["radius", 0, 34, 0, 34, false, false],
        ["yOuter", 0, 1.814596318624106, 0, 3, false, false],
        ["xOuter", 0, 109.75608219008849, 1, 241, false, false],
        ["xMultiplier", 0, 11.466961596385545, 0, 110, false, false],
        ["yMultiplier", 0, 3.877400225903615, 0, 10, false, false],
        ["divider", 0, 8.398908132530122, 0, 50, false, false],
        ["rotation", 0, 2.103468561746988, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.710Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee2"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee3"
    },
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.45823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/1.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 14.781626506024098, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.4503482680722897, 0, 10, false, false],
        ["yMultiplier", 0, 0.7763761295180723, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef9"
    },
    "shader": "void main () {\n    float stream = stream /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n    uv *= k_rotate2d(-stream/10.);\n\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream/-4.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/.6)), radius*\n                  cos(stream/100. - .1*yOuter*uv.x/3.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/11.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 16.393561746987956, 0, 22, false, false],
        ["ballSize", 0, 10.43550451807229, 0, 222, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 28.024519954819286, 0, 325, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.22, 0, 10, false, false],
        ["yMultiplier", 0, 1.45, 0, 10, false, false],
        ["divider", 0, 1.2570594879518076, 0, 100, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f0c"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n  float stream = stream  /6.;\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < 6.; i++) {\n    uv *= k_rotate2d(rotation + stream/-5. + .5 + .3 * sin(uv.y/3.));\n    float t = float(i) * PI / float(1.) * (5. + 1.) / divider;// + stream/50.;\n    float j = (cos(xMultiplier*uv.x));\n    float mul = j*uv.x/yMultiplier*PI+radius;\n    float shape = tan(t-stream) * yMultiplier*cos(uv.x + sin(stream + uv.y/11.));\n    float x = xOuter - mul * shape;\n    float y = radius * cos(10.1*yOuter*uv.x/.5+t+yMultiplier+12.);\n    vec2 p = vec2(x, y);\n    vec3 col = k_rainbow(sin(length(uv/2.1 - stream)- stream), uv.y/10.,1.);\n    // vec3 col = cos(sin(uv.y/3.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(1./pow(volume, .225), 1.)/3. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 6.76263, 0, 122, false],
        ["ballSize", 0, 62.38067112198795, 0, 255, false, false],
        ["contrast", 0, 2.723491561226182, 0, 15, false, false],
        ["radius", 0, 10.933189006024097, 0, 34, false, false],
        ["yOuter", 0, 1.5610786897590363, 0, 3, false, false],
        ["xOuter", 0, 59.18260542168675, 1, 241, false, false],
        ["xMultiplier", 0, 11.466961596385545, 0, 110, false, false],
        ["yMultiplier", 0, 3.877400225903615, 0, 10, false, false],
        ["divider", 0, 8.398908132530122, 0, 50, false, false],
        ["rotation", 0, 2.103468561746988, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.712Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f11"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = stream / 2.5;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream /8.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / -2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 0.137, 0, 0.274, false, false],
        ["orbSize", 0, 7.11, 0, 14.22, false, false],
        ["radius", 0, 36.25, 0, 72.5, false, false],
        ["colorShift", 0, 9.4728546686747, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.89, 0, 9.78, false, false],
        ["xDivide", 0, 7.14, 0, 14.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee4"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  float stream = stream / 2.;\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.9)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 13.138648343373497, 0, 50, false, false],
        ["ballSize", 0, 15.823861069277111, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.82177146084338, 0, 50, false, false],
        ["yOuter", 0, 0.468655873493976, 0, 4, false, false],
        ["xOuter", 0, 20.044804216867476, 1, 241, false, false],
        ["xMultiplier", 0, 1.9600432981927716, 0, 10, false, false],
        ["yMultiplier", 0, 0.863190888554217, 0.2, 2, false, false],
        ["divider", 0, 1.0117187500000002, 0, 2, false, false],
        ["rotation", 0, 2.331681951304134, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 3.256071159638555, 0, 50, false, false],
        ["ballSize", 0, 8.369634789156628, 2, 20, false, false],
        ["contrast", 0, 4.271554969879518, 0, 15, false, false],
        ["radius", 0, 25.5202842620482, 0, 50, false, false],
        ["yOuter", 0, 4, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["xMultiplier", 0, 1.9600432981927716, 0, 10, false, false],
        ["yMultiplier", 0, 0.863190888554217, 0.2, 2, false, false],
        ["divider", 0, 1.0117187500000002, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.094785391566266, 0, 50, false, false],
        ["ballSize", 0, 9.303350903614458, 2, 20, false, false],
        ["contrast", 0, 3.1080101656626513, 0, 15, false, false],
        ["radius", 0, 4.077089608433735, 0, 50, false, false],
        ["yOuter", 0, 4, 0, 4, false, false],
        ["xOuter", 0, 27.933358433734945, 1, 241, false, false],
        ["xMultiplier", 0, 0.4031438253012049, 0, 10, false, false],
        ["yMultiplier", 0, 0.2, 0.2, 2, false, false],
        ["divider", 0, 0.6639118975903615, 0, 2, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9eeb"
    },
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/.6)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/1.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 14.781626506024098, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.4503482680722897, 0, 10, false, false],
        ["yMultiplier", 0, 0.7763761295180723, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 91.82205384036146, 0, 150, false, false],
        ["ballSize", 0, 24.87360692771085, 2, 120, false, false],
        ["contrast", 0, 1.959713855421687, 0, 15, false, false],
        ["radius", 0, 85.86031626506026, 0, 150, false, false],
        ["yOuter", 0, 0.6169615963855423, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.36454254518072293, 0, 1, false, false],
        ["yMultiplier", 0, 0.8480440512048194, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 4.831395896084338, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 62.11498493975905, 0, 112, false, false],
        ["xDiv", 0, 9.780101656626508, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef5"
    },
    "shader": "void main () {\n  float stream = stream  /32.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (PI*(i/1.2+1.)));\n    float t = float(i) * PI / float(5.) * (5. + 1.);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x/xDiv - stream))*uv.x/yMultiplier*PI+radius*cos(t-stream)\n                  * yMultiplier*cos(stream/.1 -length(uv/div) * sin(uv.y/yDiv-stream/.16)), radius*\n                  cos(stream/2. - yOuter*uv.x/xDiv3+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 68.17255271084338, 0, 122, false, false],
        ["ballSize", 0, 8.56362951807229, 0, 25, false, false],
        ["contrast", 0, 2.8231598268072293, 0, 15, false, false],
        ["radius", 0, 59.41100338855423, 0, 325, false, false],
        ["yOuter", 0, 2.0321912650602414, 0, 100, false, false],
        ["xOuter", 0, 72.87236445783132, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 152.81835937500003, 0, 249, false, false],
        ["yMultiplier", 0, 4.17531061746988, 0, 10, false, false],
        ["divider", 0, 56.23923374162738, 0, 100, false, false],
        ["rotation", 0, 3.958419615963856, 0, 5, false, false],
        ["xDiv", 0, 256.81297063253015, 0, 323, false, false],
        ["yDiv", 0, 2.611314006024097, 0, 23, false, false],
        ["yDiv2", 0, 21.816556852409644, 0, 222, false, false],
        ["xDiv3", 0, 200.19099209337355, 0, 242, false, false],
        ["div", 0, 103.22031250000002, 0, 332, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f23"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.74, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 1.8, 0, 3.6, false, false],
        ["xDivide", 0, 2.09, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f29"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide+stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.14, 0, 1, false, false],
        ["contrast", 0, 0.168, 0, 0.3, false, false],
        ["orbSize", 0, 4.15, 0.01, 5, false, false],
        ["radius", 0, 5, 0, 5, false, false],
        ["colorShift", 0, 10.64, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 0.1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 1, false, false],
        ["cosMul", 0, 0.93, 0, 2, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.46, 0, 5, false, false],
        ["xSpeed", 0, 0, -1, 3, false, false],
        ["ySpeed", 0, -1, -2, 1, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.01, 0, 11, false, false],
        ["xDivide", 0, 6.97, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["col", 0, 0.07, 0, 0.2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f32"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.004230092243975904, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 572.8845067771085, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.0028510918674698794, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1550451807228916, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 6.708819653614459, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.1656100288222486, 0, 5, false, false],
        ["radius", 0, 9.566547439759038, 0, 20, false, false],
        ["col", 0, 2.335363328313253, 0, 3, false, false],
        ["r", 0, 0, 0, 2, false, false],
        ["g", 0, 1, 0, 2, false, false],
        ["b", 0, -1, -1, 2, false, false]
      ],
      [
        ["zoom", 0, 0.001252565406891237, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 1038.1714234869166, 0, 5000, false, false],
        ["rotation", 0, 1.0737520700477694, 0, 2, false, false],
        ["xMultiplier", 0, 458.79628744470074, 0, 1500, false, false],
        ["yMultiplier", 0, 253.24566822373455, 0, 1000, false, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.8454003943018171, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 4.879474685852787, 0, 10, false, false],
        ["ballSize", 0, 13.348558517823738, 0, 55, false, false],
        ["glow", 0, 0.2331257647778615, 0, 4, false, false],
        ["contrast", 0, 2.169806790639119, 0, 5, false, false],
        ["radius", 0, 4.719248208654933, 0, 20, false, false],
        ["col", 0, 0.48043036403426215, 0, 3, false, false],
        ["r", 0, 1, 0, 2, false, false],
        ["g", 0, 1, 0, 2, false, false],
        ["b", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.005071751973715174, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 499.16060114481365, 0, 2000, false, false],
        ["rotation", 0, 1.6588170890348506, 0, 2, false, false],
        ["xMultiplier", 0, 582.7281905944089, 0, 1500, false, false],
        ["yMultiplier", 0, 571.9553476356599, 0, 1000, false, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1512100587408227, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 6.684393411659334, 0, 55, false, false],
        ["glow", 0, 2.334541633330196, 0, 4, false, false],
        ["contrast", 0, 4.050712769290051, 0, 5, false, false],
        ["radius", 0, 7.976359172039722, 0, 20, false, false],
        ["col", 0, 1.7341189832572481, 0, 3, false, false],
        ["r", 0, 0, 0, 2, false, false],
        ["g", 0, 1.5417580110480988, 0, 2, false, false],
        ["b", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f30"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.002891330948795181, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3788.091820406627, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 1560.1044215926206, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00007496355539344881, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7095667827560241, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 1.2520472515060241, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3f"
    },
    "shader": "void main() {\n  float stream = stream / 4.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/10.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.16);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.1606359186746988, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 21.267764118975908, 0, 62.28, false, false],
        ["ballSize", 0, 44.899672910391565, 0, 319.34, false, false],
        ["colorSpread", 0, 0.029814570783132547, 0, 5, false, false],
        ["colorMultiplier", 0, 445.51694700677723, 0, 3228.3, false, false],
        ["shapeMultiplier", 0, 56.08766434487952, 0, 226.04, false, false],
        ["glow", 0, 4900.67022496235, 0, 18444.68, false, false],
        ["contrast", 0, 3.103421498493976, 0, 7.5, false, false],
        ["brightness", 0, 11.57032793674699, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 8.024077560240965, 0, 44, false, false],
        ["radius", 0, 5.128962725903616, 0, 34, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["shape", 0, 0.005611351656626507, 0, 0.1, false, false],
        ["xDiv", 0, 1118.053765060241, 0, 4432, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f42"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.004230092243975904, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 572.8845067771085, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.0028510918674698794, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1550451807228916, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 6.708819653614459, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.1656100288222486, 0, 5, false, false],
        ["radius", 0, 9.566547439759038, 0, 20, false, false],
        ["col", 0, 2.335363328313253, 0, 3, false, false],
        ["r", 0, 0, 0, 2, false, false],
        ["g", 0, 1, 0, 2, false, false],
        ["b", 0, -1, -1, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0032695237125258854, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 958.5411163697761, 0, 2000, false, false],
        ["rotation", 0, 0.07531402220208963, 0, 0.1, false, false],
        ["xMultiplier", 0, 458.79628744470074, 0, 1500, false, false],
        ["yMultiplier", 0, 253.24566822373455, 0, 1000, false, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1770482810146838, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 6.708819653614459, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.2273183615810908, 0, 5, false, false],
        ["radius", 0, 9.566547439759038, 0, 20, false, false],
        ["col", 0, 1.9071265163191835, 0, 3, false, false],
        ["r", 0, 1, 0, 2, false, false],
        ["g", 0, 1, 0, 2, false, false],
        ["b", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.005206392127347282, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 359.8970344267696, 0, 2000, false, false],
        ["rotation", 0, 0.07531402220208963, 0, 0.1, false, false],
        ["xMultiplier", 0, 819.6193189506073, 0, 1500, false, false],
        ["yMultiplier", 0, 266.17671552910866, 0, 1000, false, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1770482810146838, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.3203389730798196, 0, 10, false, false],
        ["ballSize", 0, 5.9304377544357125, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 4.154999882341868, 0, 5, false, false],
        ["radius", 0, 9.566547439759038, 0, 20, false, false],
        ["col", 0, 1.9071265163191835, 0, 3, false, false],
        ["r", 0, 1, 0, 2, false, false],
        ["g", 0, 1, 0, 2, false, false],
        ["b", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f48"
    },
    "shader": "void main() {\n  float stream = stream / 62.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      [
        ["zoom", 0, 0.026278473268072294, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 31.806092338102417, 0, 62.28, false, false],
        ["ballSize", 0, 4.534667145143073, 0, 9.34, false, false],
        ["colorSpread", 0, 2.8148529273343375, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 8.467989457831326, 0, 226.04, false, false],
        ["glow", 0, 9317.067772260922, 0, 18444.68, false, false],
        ["contrast", 0, 3.3251070689006026, 0, 7.5, false, false],
        ["brightness", 0, 5.406551204819277, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 38.61648155120483, 0, 44, false, false],
        ["radius", 0, 0.6829230986445783, 0, 2, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f50"
    },
    "shader": "#define BALLS 30\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle),\n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/2.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist - stream/150.));\n  float _grid = (cos(uv.x * xMultiplier - stream/-5.) - sin(uv.y * yMultiplier + stream/-3.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), tan(t));\n    p += cos(stream/30. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 9. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. / gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.165, 0, 1, false, false],
        ["xMultiplier", 0, 0, 0, 200, false, false],
        ["yMultiplier", 0, 163.325, 0, 1200, false, false],
        ["ballSize", 0, 0.809, 0, 2, false, false],
        ["colorSpread", 0, 1.864, 0.2, 7, false, false],
        ["colorMultiplier", 0, 197.23, 1, 500, false, false],
        ["shapeMultiplier", 0, 284.312, 0, 4210, false, false],
        ["glow", 0, 5303.896, 0, 10000, false, false],
        ["contrast", 0, 6.031, 1, 10, false, false],
        ["rotation", 0, 23.538, 0, 115, false, false],
        ["brightness", 0, 3794.182, 0, 11100, false, false],
        ["sides", 0, 2, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f51"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 1.23, 0, 2.46, false, false],
        ["xMultiplier", 0, 29.96, 0, 59.92, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 1.68, 0, 3.36, false, false],
        ["colorSpread", 0, 1.79, 0, 3.58, false, false],
        ["colorMultiplier", 0, 383.24, 0, 766.48, false, false],
        ["shapeMultiplier", 0, 13.45, 0, 26.9, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 5.1, 0, 10.2, false, false],
        ["rotation", 0, 11.628, 0, 23.256, false, false],
        ["brightness", 0, 8078.46, 0, 16156.92, false, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2e"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.015395801957831329, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 638.9213102409639, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 402.9485128012049, 0, 1500, false, false],
        ["yMultiplier", 0, 384.40794427710847, 0, 1000, false, false],
        ["colorSpread", 0, 0.00742722138554217, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.3159429284081192, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.3544804216867474, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 5.837161144578314, 0, 20, false, false],
        ["col", 0, 0.4254894578313254, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.02155873493975904, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 664.222515060241, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 101.98136295180726, 0, 1500, false, false],
        ["yMultiplier", 0, 505.7605421686748, 0, 1000, false, false],
        ["colorSpread", 0, 0.002387699284719246, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.8847279743975907, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.3544804216867474, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.798098644578314, 0, 5, false, false],
        ["radius", 0, 15.26440135542169, 0, 20, false, false],
        ["col", 0, 1.5800122364457834, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.01465455572289157, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 115.95444277108437, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 131.5888554216868, 0, 1500, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.008179141566265062, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 0.8356315888554218, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.761389307228916, 0, 10, false, false],
        ["ballSize", 0, 36.31610033885543, 0, 55, false, false],
        ["glow", 0, 1.7608245481927713, 0, 4, false, false],
        ["contrast", 0, 3.6879000376506035, 0, 5, false, false],
        ["radius", 0, 15.26440135542169, 0, 20, false, false],
        ["col", 0, 1.5800122364457834, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f39"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 2.1;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume , .2)* ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.015301204819277112, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 465.06024096385545, 0, 2000, false, false],
        ["rotation", 0, 3.766937093381839, 0, 10.1, false, false],
        ["xMultiplier", 0, 424.6987951807229, 0, 1500, false, false],
        ["yMultiplier", 0, 268.67469879518075, 0, 1000, false, false],
        ["colorSpread", 0, 0.00013810843373493977, 0.00001, 0.0005, false, false],
        ["colorMultiplier", 0, 1.8361445783132533, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 9.843373493975903, 0, 10, false, false],
        ["ballSize", 0, 223.6927710843374, 0, 355, false, false],
        ["glow", 0, 3.572119728915663, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 30.755421686746995, 0, 201, false, false],
        ["col", 0, 0.18579160391566268, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.003879518072289157, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 1874.698795180723, 0, 2000, false, false],
        ["rotation", 0, 6.0356626506024105, 0, 10.1, false, false],
        ["xMultiplier", 0, 625.3012048192771, 0, 1500, false, false],
        ["yMultiplier", 0, 572.2891566265062, 0, 1000, false, false],
        ["colorSpread", 0, 0.000028807228915662654, 0.000005, 0.0001, false, false],
        ["colorMultiplier", 0, 1.391566265060241, 1, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 64.28554216867471, 0, 233, false, false],
        ["ballSize", 0, 187.7650602409639, 0, 355, false, false],
        ["glow", 0, 3.572119728915663, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 36.56746987951808, 0, 201, false, false],
        ["col", 0, 1.987951807228916, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f41"
    },
    "shader": "void main() {\n  float stream = pow(stream ,1.5)/620.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.212);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .52) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.1822475527108434, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 21.267764118975908, 0, 62.28, false, false],
        ["ballSize", 0, 2.186469032379518, 0, 9.34, false, false],
        ["colorSpread", 0, 4.021717338102411, 0, 111.34, false, false],
        ["colorMultiplier", 0, 58.88867846385543, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 50.70687405873495, 0, 226.04, false, false],
        ["glow", 0, 4900.67022496235, 0, 18444.68, false, false],
        ["contrast", 0, 3.3251070689006026, 0, 7.5, false, false],
        ["brightness", 0, 3.1475173192771093, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 26.054179216867475, 0, 44, false, false],
        ["radius", 0, 2.5349962349397597, 0, 4, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4f"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.769, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f53"
    },
    "shader": "\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nmat2 rotate2d(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = 1. - (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.34, 0.05, 0.5, false, false],
        ["xMultiplier", 0, 20.37, 20, 150, false, false],
        ["yMultiplier", 0, 31.14, 20, 150, false, false],
        ["ballSize", 0, 4.67, 3, 12, false, false],
        ["colorSpread", 0, 5.67, 0.2, 7, false, false],
        ["colorMultiplier", 0, 114.15, 80, 150, false, false],
        ["shapeMultiplier", 0, 13.02, 2, 50, false, false],
        ["glow", 0, 9222.34, 0, 10000, false, false],
        ["contrast", 0, 3.75, 3, 5, false, false],
        ["brightness", 0, 10.92, 2, 51, false, false],
        ["center", 0, 0, 0, 0.2, false, false],
        ["granularity", 0, 22, 5, 22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1f"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0); \n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime); \n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.34, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1e"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 19900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.09, 0, 0.18, false, false],
        ["contrast", 0, 0.43, 0, 0.86, false, false],
        ["orbSize", 0, 7.54, 0, 15.08, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 5.43, 0, 10.86, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.49, 0, 0.98, false, false],
        ["cosMul", 0, 2.87, 0, 5.74, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.44, 0, 0.88, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 5.78, 0, 11.56, false, false],
        ["xDivide", 0, 5, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f38"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.02447853915662651, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 10.43147590361446, 0, 20, false, false],
        ["col", 0, 0.7912348800524701, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f25"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide+stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.14, 0, 0.28, false, false],
        ["contrast", 0, 0.168, 0, 0.336, false, false],
        ["orbSize", 0, 4.15, 0, 8.3, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 10.64, 0, 21.28, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.1, 0, 0.2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.93, 0, 1.86, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.46, 0, 0.92, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, -1, 0, -2, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 3.01, 0, 6.02, false, false],
        ["xDivide", 0, 6.97, 0, 13.94, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["col", 0, 0.07, 0, 0.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f26"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5.66, 0, 11, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.34, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2d"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5.66, 0, 11.32, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 1.8, 0, 3.6, false, false],
        ["xDivide", 0, 2.09, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f43"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f45"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .004*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.04466, 0, 0.1, false],
        ["shapeMultiplier", 0, 83.35476, 0, 1000, false],
        ["rotation", 0, 0.0153725883759648, 0, 0.1, false, false],
        ["xMultiplier", 0, 163.26853, 0, 1500, false],
        ["yMultiplier", 0, 100.61898, 0, 1000, false],
        ["colorSpread", 0, 0.0009439968430852318, 0, 0.04, false, false],
        ["colorMultiplier", 0, 1, 0, 1, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.992922495646649, 0, 10, false, false],
        ["ballSize", 0, 23.91730200526226, 0, 55, false, false],
        ["glow", 0, 1.7764066029743977, 0, 4, false, false],
        ["contrast", 0, 4.3513181755341686, 0, 5, false, false],
        ["radius", 0, 17.692998433708883, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4e"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.769, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f54"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 4.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 4.) + sin(uv.y * yMultiplier + stream / 10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x += uv.y; // / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.124, false, false],
        ["shapeMultiplier", 0, 203.13, 0, 406.26, false, false],
        ["rotation", 0, 0.05, 0, 0.1, false, false],
        ["xMultiplier", 0, 59.27, 0, 118.54, false, false],
        ["yMultiplier", 0, 88, 0, 176, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.81, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 3.86, 0, 7.72, false, false],
        ["ballSize", 0, 36.72, 0, 73.44, false, false],
        ["glow", 0, 1.22, 0, 2.44, false, false],
        ["contrast", 0, 2.72, 0, 5.44, false, false],
        ["radius", 0, 16.24, 0, 32.48, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f18"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.08638846009036147, 0, 0.14, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 6.46, 0, 12.92, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 2.38, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.28, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.99, 0, 9.98, false, false],
        ["xDivide", 0, 6.27, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.033166980421686754, 0, 0.14, false, false],
        ["contrast", 0, 0.12439815512048197, 0, 0.26, false, false],
        ["orbSize", 0, 9.584353162650604, 0, 312.92, false, false],
        ["radius", 0, 22, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.8233670933734941, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.4288580572289158, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 0.7236063629518074, 0, 9.98, false, false],
        ["xDivide", 0, 8.498375941265062, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.008450865963855424, 0, 0.14, false, false],
        ["contrast", 0, 0.12439815512048197, 0, 0.26, false, false],
        ["orbSize", 0, 85.2886669804217, 0, 312.92, false, false],
        ["radius", 0, 360.3195406626507, 0, 522, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.8233670933734941, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.02921762048192772, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 8.053467338102411, 0, 9.98, false, false],
        ["xDivide", 0, 12.54, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f36"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.0015165919108563162, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3205.0498135118605, 0, 5000, false, false],
        ["rotation", 0, 1.7442496058452563, 0, 2, false, false],
        ["xMultiplier", 0, 3466.821977362576, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.00015843905610666358, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 3.2414770700845383, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 3.933267984045558, 0, 5, false, false],
        ["radius", 0, 6.233824948230422, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 0.30809296757341875, 0, 2, false, false],
        ["b", 0, 0.4314934787980046, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 0.869916286238705, 0, 4, false, false],
        ["contrast", 0, 4.6129678933017235, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 0.14978036535791608, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f19"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool b, bool bT, float bTP) {\n\tif (bT) {\n    vec2 from = b ? uv : uv2;\n    vec2 to = b ? uv2 : uv;\n\t\tuv = mix(from, to, bTP);\n  } else {\n    vec2 from = b ? uv : uv2;\n    vec2 to = b ? uv2 : uv;\n\t\tuv = b ? uv2 : uv;\n  }\n \treturn uv; \n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n  uv *= rotate(-stream/40.);\n  uv = swap(uv, kale(uv, vec2(0.),sides), kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= rotate(stream/10.);\n  //uv *= rotate(rotation*stream/5.);\n\tuv = swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.29, 0, 1, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 2.32, 0.01, 11, false, false],
        ["radius", 0, 3.69, 0, 11, false, false],
        ["colorShift", 0, 8.96, 4, 22, false, false],
        ["sides", 0, 8, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0.09, 0, 4, false, false],
        ["cosMul", 0, 0.51, 0, 1, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.0041, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.13, 0, 11, false, false],
        ["xDivide", 0, 1.47, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ef0"
    },
    "shader": "void main () {\n  float stream = time/2. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/31. -uv.x/xDiv * sin(uv.y/yDiv-stream/.4)), radius*\n                  cos(stream/21. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/3.5)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 14.781626506024098, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.56339420180724, 0, 50, false, false],
        ["yOuter", 0, 0.20745481927710846, 0, 4, false, false],
        ["xOuter", 0, 22.210090361445786, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.4503482680722897, 0, 10, false, false],
        ["yMultiplier", 0, 0.7763761295180723, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 68.64279583256703, 0, 150, false, false],
        ["ballSize", 0, 8.67511295180723, 2, 20, false, false],
        ["contrast", 0, 5.334502070783133, 0, 15, false, false],
        ["radius", 0, 37.61742281626507, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 192.88166415662656, 0, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.4011671686746988, 0, 10, false, false],
        ["yMultiplier", 0, 1.3276346009036146, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 8.098493975903617, 0, 112, false, false],
        ["xDiv", 0, 1.7434770331325304, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 26.91665097891567, 0, 50, false, false],
        ["ballSize", 0, 5.19921875, 2, 20, false, false],
        ["contrast", 0, 1.7383400498471584, 0, 15, false, false],
        ["radius", 0, 50, 0, 50, false, false],
        ["yOuter", 0, 0.07575301204819279, 0, 4, false, false],
        ["xOuter", 0, 42.83960843373495, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.22849209337349405, 0, 10, false, false],
        ["yMultiplier", 0, 1.0121686746987952, 0.2, 2, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.39937876506024106, 0, 5, false, false],
        ["yDiv", 0, 9.797910391566266, 0, 10, false, false],
        ["yDiv2", 0, 33.01069277108434, 0, 112, false, false],
        ["xDiv", 0, 0.46692394578313257, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 62.13196536144579, 0, 150, false, false],
        ["ballSize", 0, 5.748752823795181, 2, 7, false, false],
        ["contrast", 0, 1.5164486069277112, 0, 15, false, false],
        ["radius", 0, 73.47938629518073, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 4, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0.14090416836516378, 0, 1, false, false],
        ["yMultiplier", 0, 0.5855666415662651, 0.2, 2, false, false],
        ["divider", 0, 0.31706513554216875, 0, 2, false, false],
        ["rotation", 0, 1.9195689006024097, 0, 5, false, false],
        ["yDiv", 0, 5.4796216114457845, 0, 10, false, false],
        ["yDiv2", 0, 22.009412650602414, 0, 112, false, false],
        ["xDiv", 0, 3.2801769578313253, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.40709713855422, 0, 50, false, false],
        ["ballSize", 0, 30.064984939759036, 2, 120, false, false],
        ["contrast", 0, 3.5711831701807233, 0, 15, false, false],
        ["radius", 0, 50.229433358433745, 0, 250, false, false],
        ["yOuter", 0, 0.2781061746987952, 0, 4, false, false],
        ["xOuter", 0, 51.656626506024104, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.460890436746989, 0, 10, false, false],
        ["yMultiplier", 0, 1.6981579442771089, 0.2, 12, false, false],
        ["divider", 0, 2, 0, 2, false, false],
        ["rotation", 0, 0.3976138930722892, 0, 5, false, false],
        ["yDiv", 0, 1.8983904367469886, 0, 110, false, false],
        ["yDiv2", 0, 4.981701807228917, 0, 112, false, false],
        ["xDiv", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f33"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 0.869916286238705, 0, 4, false, false],
        ["contrast", 0, 4.6129678933017235, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 0.14978036535791608, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.002629553002047252, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 2220.700321427311, 0, 5000, false, false],
        ["rotation", 0, 0.3912666964243694, 0, 2, false, false],
        ["xMultiplier", 0, 751.4546360797194, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 3.933267984045558, 0, 5, false, false],
        ["radius", 0, 39.377560167427525, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 0.30809296757341875, 0, 2, false, false],
        ["b", 0, 0.4314934787980046, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0012806754054793396, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 1.6306559918874721, 0, 2, false, false],
        ["xMultiplier", 0, 2452.3762628026757, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 29.790788673492806, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 4.846765173486917, 0, 5, false, false],
        ["radius", 0, 24.204514469008853, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.8626607504235694, 0, 2, false, false],
        ["g", 0, 0.7242171322006777, 0, 2, false, false],
        ["b", 0, 1.9394326399761599, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.153767229562783, 0, 10, false, false],
        ["ballSize", 0, 18.93753672220621, 0, 55, false, false],
        ["glow", 0, 0.28189998764589613, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 12.95189179569842, 0, 20, false, false],
        ["col", 0, 0.3760011787874154, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f35"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 0.869916286238705, 0, 4, false, false],
        ["contrast", 0, 4.6129678933017235, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 0.14978036535791608, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.002629553002047252, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 2220.700321427311, 0, 5000, false, false],
        ["rotation", 0, 0.3912666964243694, 0, 2, false, false],
        ["xMultiplier", 0, 751.4546360797194, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 3.933267984045558, 0, 5, false, false],
        ["radius", 0, 39.377560167427525, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 0.30809296757341875, 0, 2, false, false],
        ["b", 0, 0.4314934787980046, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0012806754054793396, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 1.6306559918874721, 0, 2, false, false],
        ["xMultiplier", 0, 2452.3762628026757, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 29.790788673492806, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 4.846765173486917, 0, 5, false, false],
        ["radius", 0, 24.204514469008853, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.8626607504235694, 0, 2, false, false],
        ["g", 0, 0.7242171322006777, 0, 2, false, false],
        ["b", 0, 1.9394326399761599, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f31"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.002891330948795181, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3788.091820406627, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 1560.1044215926206, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00007496355539344881, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7095667827560241, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 1.2520472515060241, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.002629553002047252, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 2220.700321427311, 0, 5000, false, false],
        ["rotation", 0, 0.3912666964243694, 0, 2, false, false],
        ["xMultiplier", 0, 751.4546360797194, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 3.933267984045558, 0, 5, false, false],
        ["radius", 0, 39.377560167427525, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 0.30809296757341875, 0, 2, false, false],
        ["b", 0, 0.4314934787980046, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0012806754054793396, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 1.6306559918874721, 0, 2, false, false],
        ["xMultiplier", 0, 2452.3762628026757, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 29.790788673492806, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 4.846765173486917, 0, 5, false, false],
        ["radius", 0, 24.204514469008853, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.8626607504235694, 0, 2, false, false],
        ["g", 0, 0.7242171322006777, 0, 2, false, false],
        ["b", 0, 1.9394326399761599, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.153767229562783, 0, 10, false, false],
        ["ballSize", 0, 18.93753672220621, 0, 55, false, false],
        ["glow", 0, 0.28189998764589613, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 12.95189179569842, 0, 20, false, false],
        ["col", 0, 0.3760011787874154, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3e"
    },
    "shader": "void main() {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.33);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-.425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(pow(volume, 1.24) * ballSize, .7) / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.1606359186746988, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 21.267764118975908, 0, 62.28, false, false],
        ["ballSize", 0, 2.186469032379518, 0, 9.34, false, false],
        ["colorSpread", 0, 4.021717338102411, 0, 111.34, false, false],
        ["colorMultiplier", 0, 58.88867846385543, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 23.783773908132535, 0, 226.04, false, false],
        ["glow", 0, 4900.67022496235, 0, 18444.68, false, false],
        ["contrast", 0, 3.3251070689006026, 0, 7.5, false, false],
        ["brightness", 0, 6.846585090361446, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 26.054179216867475, 0, 44, false, false],
        ["radius", 0, 2.5349962349397597, 0, 4, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4c"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.769, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4d"
    },
    "shader": "#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.124, false, false],
        ["shapeMultiplier", 0, 203.13, 0, 406.26, false, false],
        ["rotation", 0, 0.05, 0, 0.1, false, false],
        ["xMultiplier", 0, 59.27, 0, 118.54, false, false],
        ["yMultiplier", 0, 88, 0, 176, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.81, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 3.86, 0, 7.72, false, false],
        ["ballSize", 0, 36.72, 0, 73.44, false, false],
        ["glow", 0, 1.22, 0, 2.44, false, false],
        ["contrast", 0, 2.72, 0, 5.44, false, false],
        ["radius", 0, 16.24, 0, 32.48, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f21"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.07, 0, 0.14, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 6.46, 0, 12.92, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 2.38, 0, 4.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.28, 0, 0.56, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.99, 0, 9.98, false, false],
        ["xDivide", 0, 6.27, 0, 12.54, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2a"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.34, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2c"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/18900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.058, 0, 0.5, false, false],
        ["contrast", 0, 0.14, 0, 1, false, false],
        ["orbSize", 0, 2.38, 0.01, 11, false, false],
        ["radius", 0, 6.38, 0, 21, false, false],
        ["colorShift", 0, 5.43, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, -1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.08, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 3, false, false],
        ["ySpeed", 0, -1.5, -2, 1, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.56, 0, 11, false, false],
        ["xDivide", 0, 5, 0, 5, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3a"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 9.1;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.005787838855421688, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 33.21724397590362, 0, 2000, false, false],
        ["rotation", 0, 7.260325677710845, 0, 10.1, false, false],
        ["xMultiplier", 0, 454.3698230421687, 0, 1500, false, false],
        ["yMultiplier", 0, 308.2784262048193, 0, 1000, false, false],
        ["colorSpread", 0, 0.0004538973079819278, 0.0001, 0.009, false, false],
        ["colorMultiplier", 0, 1.6406250000000004, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.244964231927712, 0, 10, false, false],
        ["ballSize", 0, 65.16575677710844, 0, 355, false, false],
        ["glow", 0, 3.572119728915663, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 15.978539156626507, 0, 20, false, false],
        ["col", 0, 0.18579160391566268, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3b"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/.4);\n  uv *= k_rotate2d(rotation + 1.1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(length(uv*zoom) / pow(volume, .2) * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.016035391566265066, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 1401.7978162650604, 0, 2000, false, false],
        ["rotation", 0, 2.2002870858433736, 0, 3, false, false],
        ["xMultiplier", 0, 415.48616340361446, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.015395801957831329, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 638.9213102409639, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 402.9485128012049, 0, 1500, false, false],
        ["yMultiplier", 0, 384.40794427710847, 0, 1000, false, false],
        ["colorSpread", 0, 0.00742722138554217, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.3159429284081192, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.3544804216867474, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 5.837161144578314, 0, 20, false, false],
        ["col", 0, 0.4254894578313254, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.02155873493975904, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 664.222515060241, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 101.98136295180726, 0, 1500, false, false],
        ["yMultiplier", 0, 505.7605421686748, 0, 1000, false, false],
        ["colorSpread", 0, 0.002387699284719246, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.8847279743975907, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.3544804216867474, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.798098644578314, 0, 5, false, false],
        ["radius", 0, 15.26440135542169, 0, 20, false, false],
        ["col", 0, 1.5800122364457834, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 0.01465455572289157, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 115.95444277108437, 0, 2000, false, false],
        ["rotation", 0, 1.610448042168675, 0, 10.1, false, false],
        ["xMultiplier", 0, 131.5888554216868, 0, 1500, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.008179141566265062, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 0.8356315888554218, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.761389307228916, 0, 10, false, false],
        ["ballSize", 0, 36.31610033885543, 0, 55, false, false],
        ["glow", 0, 1.7608245481927713, 0, 4, false, false],
        ["contrast", 0, 3.6879000376506035, 0, 5, false, false],
        ["radius", 0, 15.26440135542169, 0, 20, false, false],
        ["col", 0, 1.5800122364457834, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f16"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.34, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.11358595656421253, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 5.804883385285957, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.044943060344178255, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 9.409707095513692, 0, 11, false, false],
        ["xDivide", 0, 12.76840419598715, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.07, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 5.53, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 2.97, 0, 5, false, false],
        ["yMul", 0, 3.45, 0, 5, false, false],
        ["xMul", 0, 0.14, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.02, 0, 0.1, false, false],
        ["contrast", 0, 0.1, 0, 1, false, false],
        ["orbSize", 0, 5.53, 0.01, 11, false, false],
        ["radius", 0, 6.59, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 2.97, 0, 5, false, false],
        ["yMul", 0, 3.45, 0, 5, false, false],
        ["xMul", 0, 0, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 11, 0, 11, false, false],
        ["xDivide", 0, 15, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ee7"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.823425) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-2.)\n                  * yMultiplier*cos(stream/1.5 -uv.x/xDiv * sin(uv.y/yDiv-stream/1.6)), radius*\n                  cos(stream/3. - yOuter*uv.x/xDiv2+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/10.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 13.138648343373497, 0, 50, false, false],
        ["ballSize", 0, 15.823861069277111, 2, 20, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 38.82177146084338, 0, 50, false, false],
        ["yOuter", 0, 0.468655873493976, 0, 4, false, false],
        ["xOuter", 0, 20.044804216867476, 1, 241, false, false],
        ["xMultiplier", 0, 1.9600432981927716, 0, 10, false, false],
        ["yMultiplier", 0, 0.863190888554217, 0.2, 2, false, false],
        ["divider", 0, 1.0117187500000002, 0, 2, false, false],
        ["rotation", 0, 2.331681951304134, 0, 5, false, false],
        ["yDiv", 0, 3.222279743975904, 0, 10, false, false],
        ["yDiv2", 0, 3.7387801204819286, 0, 112, false, false],
        ["xDiv", 0, 0.503765060240964, 0, 12, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.711Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a38"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f20"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0); \n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime); \n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.74, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 1.8, 0, 3.6, false, false],
        ["xDivide", 0, 2.09, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f24"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 0.137, 0, 0.274, false, false],
        ["orbSize", 0, 7.11, 0, 14.22, false, false],
        ["radius", 0, 36.25, 0, 72.5, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, 0, -2, false, false],
        ["ySpeed", 0, -2, 0, -4, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.89, 0, 9.78, false, false],
        ["xDivide", 0, 7.14, 0, 14.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2b"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/19900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.09, 0, 0.2, false, false],
        ["contrast", 0, 0.43, 0, 1, false, false],
        ["orbSize", 0, 7.54, 0.01, 111, false, false],
        ["radius", 0, 0, 0, 1111, false, false],
        ["colorShift", 0, 5.43, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 0, 0, 2, false, false],
        ["sinMul", 0, 0.49, 0, 4, false, false],
        ["cosMul", 0, 2.87, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.44, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 3, false, false],
        ["ySpeed", 0, -2, -2, 1, false, false],
        ["gloop", 0, 0.0051, 0.001, 0.01, false, false],
        ["yDivide", 0, 5.78, 0, 11, false, false],
        ["xDivide", 0, 5, 0, 5, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f34"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/40.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.16));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 0.869916286238705, 0, 4, false, false],
        ["contrast", 0, 4.6129678933017235, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 0.14978036535791608, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.002629553002047252, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 2220.700321427311, 0, 5000, false, false],
        ["rotation", 0, 0.3912666964243694, 0, 2, false, false],
        ["xMultiplier", 0, 751.4546360797194, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 55, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 3.933267984045558, 0, 5, false, false],
        ["radius", 0, 39.377560167427525, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 0.30809296757341875, 0, 2, false, false],
        ["b", 0, 0.4314934787980046, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0012806754054793396, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 1.6306559918874721, 0, 2, false, false],
        ["xMultiplier", 0, 2452.3762628026757, 0, 5410, false, false],
        ["yMultiplier", 0, 2133.7535444512428, 0, 11000, false, false],
        ["colorSpread", 0, 0.000047810932352456705, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.3967557424522309, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 29.790788673492806, 0, 55, false, false],
        ["glow", 0, 0.8978996552616718, 0, 4, false, false],
        ["contrast", 0, 4.846765173486917, 0, 5, false, false],
        ["radius", 0, 24.204514469008853, 0, 120, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.8626607504235694, 0, 2, false, false],
        ["g", 0, 0.7242171322006777, 0, 2, false, false],
        ["b", 0, 1.9394326399761599, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0008370846208319609, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 5000, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 2876.168172721404, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00003663346969420652, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7390385179634554, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.153767229562783, 0, 10, false, false],
        ["ballSize", 0, 18.93753672220621, 0, 55, false, false],
        ["glow", 0, 0.28189998764589613, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 12.95189179569842, 0, 20, false, false],
        ["col", 0, 0.3760011787874154, 0, 3, false, false],
        ["r", 0, 2, 0, 2, false, false],
        ["g", 0, 2, 0, 2, false, false],
        ["b", 0, 2, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3c"
    },
    "shader": "void main() {\n  float stream = pow(stream ,1.3)/90.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.212);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .2) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      [
        ["zoom", 0, 0.09918053463855425, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 21.267764118975908, 0, 62.28, false, false],
        ["ballSize", 0, 3.88734422063253, 0, 9.34, false, false],
        ["colorSpread", 0, 10.493669239457834, 0, 111.34, false, false],
        ["colorMultiplier", 0, 58.88867846385543, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 39.67082850150603, 0, 226.04, false, false],
        ["glow", 0, 15674.245313441268, 0, 18444.68, false, false],
        ["contrast", 0, 3.3251070689006026, 0, 7.5, false, false],
        ["brightness", 0, 8.960690512048194, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 26.054179216867475, 0, 44, false, false],
        ["radius", 0, 1.2730609939759039, 0, 2, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f46"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.9764835164835164, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f47"
    },
    "shader": "void main() {\n  float stream = stream / 45.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/2.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.r *= .01;\n}",
    "variants": [
      [
        ["zoom", 0, 0.026278473268072294, 0, 0.68, false, false],
        ["xMultiplier", 0, 5.364285344503013, 0, 40.74, false, false],
        ["yMultiplier", 0, 15.957271507906627, 0, 62.28, false, false],
        ["ballSize", 0, 4.534667145143073, 0, 9.34, false, false],
        ["colorSpread", 0, 3.3978505035768074, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 137.48647896272593, 0, 226.04, false, false],
        ["glow", 0, 9317.067772260922, 0, 18444.68, false, false],
        ["contrast", 0, 2.5810811605798194, 0, 7.5, false, false],
        ["brightness", 0, 0.4651073042168676, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 28.11217526355422, 0, 44, false, false],
        ["radius", 0, 1.0314500188253015, 0, 2, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f52"
    },
    "shader": "\n\n#define BALLS 15\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle),\n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist - stream/200.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.21, 1, 8, false, false],
        ["xMultiplier", 0, 49.77, 0, 200, false, false],
        ["yMultiplier", 0, 0, 0, 200, false, false],
        ["ballSize", 0, 1.37, 0, 2, false, false],
        ["colorSpread", 0, 1.21, 0.2, 7, false, false],
        ["colorMultiplier", 0, 500, 1, 500, false, false],
        ["shapeMultiplier", 0, 17.27, 0, 210, false, false],
        ["glow", 0, 2080.32, 0, 10000, false, false],
        ["contrast", 0, 4.53, 1, 10, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["brightness", 0, 6430.09, 0, 11100, false, false],
        ["sides", 0, 9, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f17"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 3.34, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 1.8, 0, 11, false, false],
        ["xDivide", 0, 2.09, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1b"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 0.137, 0, 0.274, false, false],
        ["orbSize", 0, 7.11, 0, 14.22, false, false],
        ["radius", 0, 36.25, 0, 72.5, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.89, 0, 9.78, false, false],
        ["xDivide", 0, 7.14, 0, 14.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f28"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.03*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 1, false, false],
        ["contrast", 0, 0.137, 0, 0.3, false, false],
        ["orbSize", 0, 7.11, 0.01, 15, false, false],
        ["radius", 0, 36.25, 0, 5, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 1, false, false],
        ["cosMul", 0, 1.08, 0, 2, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 3, false, false],
        ["ySpeed", 0, -2, -2, 1, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 4.89, 0, 11, false, false],
        ["xDivide", 0, 7.14, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f2f"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing =.0003 * sin(shapeMultiplier*dot(uv, uv)/dist);\n  uv *= k_rotate2d(rotation + 50.1*(dist - stream/140.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.56));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(r, g, b) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.002891330948795181, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3788.091820406627, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 1560.1044215926206, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00007496355539344881, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7095667827560241, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 1.2520472515060241, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.00030632294804216873, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3788.091820406627, 0, 5000, false, false],
        ["rotation", 0, 2, 0, 2, false, false],
        ["xMultiplier", 0, 0, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.000006393407614834339, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7095667827560241, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 36.36424604668675, 0, 55, false, false],
        ["glow", 0, 1.8864212915287457, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 20, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0010805722891566267, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 3788.091820406627, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 1560.1044215926206, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00007496355539344881, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 1.0814606080572289, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 1.2520472515060241, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.0020881377070783138, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 630.8240775602411, 0, 5000, false, false],
        ["rotation", 0, 0.5176957831325302, 0, 2, false, false],
        ["xMultiplier", 0, 1560.1044215926206, 0, 5410, false, false],
        ["yMultiplier", 0, 3456.9860894996004, 0, 11000, false, false],
        ["colorSpread", 0, 0.00007496355539344881, 0.000001, 0.0002, false, false],
        ["colorMultiplier", 0, 0.7095667827560241, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.510078889777863, 0, 10, false, false],
        ["ballSize", 0, 18.486439164862578, 0, 55, false, false],
        ["glow", 0, 1.2520472515060241, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 13.537957800440044, 0, 20, false, false],
        ["col", 0, 0.6504346916474493, 0, 3, false, false],
        ["r", 0, 0.18946748296898536, 0, 2, false, false],
        ["g", 0, 1.3596809111445787, 0, 2, false, false],
        ["b", 0, 1.6122340926204821, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f44"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .002 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.004617375753012049, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4b"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n    gl_FragColor.rgb *= sap;\n  gl_FragColor.r *= .001;\n}",
    "variants": [
      [
        ["zoom", 0, 0.00384683264307229, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.007697853915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 0.773472797439759, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 10, 0, 10, false, false],
        ["ballSize", 0, 8.248511624623497, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.6166698042168677, 0, 8, false, false],
        ["radius", 0, 8.394319465361447, 0, 20, false, false],
        ["col", 0, 1.4261930534638556, 0, 3, false, false],
        ["sap", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f27"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n//  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.07, 0, 0.1, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 6.46, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 2.38, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.28, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 4.99, 0, 11, false, false],
        ["xDivide", 0, 6.27, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f37"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.004230092243975904, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 572.8845067771085, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.0028510918674698794, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1550451807228916, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 6.708819653614459, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.1656100288222486, 0, 5, false, false],
        ["radius", 0, 9.566547439759038, 0, 20, false, false],
        ["col", 0, 2.335363328313253, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f3d"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 1.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .4)*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/20. + sin(uv.x/10. - stream/10.));\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f40"
    },
    "shader": "void main() {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/-5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.13);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-.425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .4) * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.1606359186746988, 0, 0.68, false, false],
        ["xMultiplier", 0, 13.236713220067774, 0, 40.74, false, false],
        ["yMultiplier", 0, 21.267764118975908, 0, 62.28, false, false],
        ["ballSize", 0, 2.186469032379518, 0, 9.34, false, false],
        ["colorSpread", 0, 4.021717338102411, 0, 111.34, false, false],
        ["colorMultiplier", 0, 58.88867846385543, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 37.93467789909639, 0, 226.04, false, false],
        ["glow", 0, 4900.67022496235, 0, 18444.68, false, false],
        ["contrast", 0, 3.3251070689006026, 0, 7.5, false, false],
        ["brightness", 0, 6.846585090361446, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 26.054179216867475, 0, 44, false, false],
        ["radius", 0, 2.5349962349397597, 0, 4, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.714Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f4a"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .25));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.769, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.169, 0, 0.68, false, false],
        ["xMultiplier", 0, 21.69, 0, 40.74, false, false],
        ["yMultiplier", 0, 25.112, 0, 62.28, false, false],
        ["ballSize", 0, 1.712, 0, 9.34, false, false],
        ["colorSpread", 0, 0.299, 0, 11.34, false, false],
        ["colorMultiplier", 0, 30.706, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 226.04, 0, 226.04, false, false],
        ["glow", 0, 6069.68, 0, 18444.68, false, false],
        ["contrast", 0, 1.791, 0, 7.5, false, false],
        ["brightness", 0, 12.119, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 101.544, 0, 144, false, false],
        ["radius", 0, 9.65, 0, 21, false, false]
      ],
      [
        ["zoom", 0, 0.11, 0, 0.68, false, false],
        ["xMultiplier", 0, 62.497, 0, 140.741, false, false],
        ["yMultiplier", 0, 0, 0, 62.28, false, false],
        ["ballSize", 0, 2.957, 0, 9.34, false, false],
        ["colorSpread", 0, 0.539, 0, 11.34, false, false],
        ["colorMultiplier", 0, 30.706, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 31.454, 0, 226.04, false, false],
        ["glow", 0, 6069.68, 0, 18444.68, false, false],
        ["contrast", 0, 1.791, 0, 7.5, false, false],
        ["brightness", 0, 12.119, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 121.691, 0, 222, false, false],
        ["radius", 0, 13.27, 0, 21, false, false]
      ],
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 40.74, 0, 40.74, false, false],
        ["yMultiplier", 0, 14.076, 0, 62.28, false, false],
        ["ballSize", 0, 5.257, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 499.03, 0, 11226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 2.997, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 27.692, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1a"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  //  uv *= sin(dist*.005*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.37, 0, 0.74, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 1.8, 0, 3.6, false, false],
        ["xDivide", 0, 2.09, 0, 4.18, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f22"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation*stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream/18900.01*uv.x+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.058, 0, 0.116, false, false],
        ["contrast", 0, 0.14, 0, 0.28, false, false],
        ["orbSize", 0, 2.38, 0, 4.76, false, false],
        ["radius", 0, 6.38, 0, 12.76, false, false],
        ["colorShift", 0, 5.43, 0, 10.86, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, -1, 0, -2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, 0, -2, false, false],
        ["ySpeed", 0, -1.5, 0, -3, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 3.56, 0, 7.12, false, false],
        ["xDivide", 0, 5, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f49"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/-20.);\n  uv *= zoom;\n  // uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/-1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/-1.) * sin(uv.y * yMultiplier + stream/-1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + uv.y/150. + float(i) / 5.)) * 0.25 + 0.25;\n    gl_FragColor += vec4(volume * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.016, false, false],
        ["shapeMultiplier", 0, 1700.47, 0, 11000, false, false],
        ["rotation", 0, 0.22591, 0.009, 2, false, false],
        ["xMultiplier", 0, 444.91, 0, 2222, false, false],
        ["yMultiplier", 0, 498.49, 0, 1100, false, false],
        ["colorSpread", 0, 0.000046, 0, 0.0001, false, false],
        ["colorMultiplier", 0, 3, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 4.36, 0, 10, false, false],
        ["ballSize", 0, 24.47, 0, 100, false, false],
        ["glow", 0, 1.27, 0, 4, false, false],
        ["contrast", 0, 2.28, 0, 5, false, false],
        ["radius", 0, 6.66, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f55"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.053, 0, 0.13, false, false],
        ["shapeMultiplier", 0, 223.96, 0, 447.92, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 217.723, 0, 3385.88, false, false],
        ["yMultiplier", 0, 157.966, 0, 1223, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.863, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.636, 0, 7.72, false, false],
        ["ballSize", 0, 17.795, 0, 18.74, false, false],
        ["glow", 0, 0.714, 0, 2.32, false, false],
        ["contrast", 0, 2.278, 0, 10, false, false],
        ["radius", 0, 15.459, 0, 23.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f75"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.x / yDiv + stream / .9);// - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.);// - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * sin(t / multiplier + stream / 11.), yMul * tan(t / multiplier + stream / 5.));\n    p /= sin(PI * cos(uv.x / xDiv3 + stream / 9.) - sin(uv.y / yDiv3 - stream / 9.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize *1. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 26.786, 0, 100, false, false],
        ["xDiv", 0, 1.108, 0, 20, false, false],
        ["yDiv", 0, 6.093, 0, 50, false, false],
        ["xDiv3", 0, 0.475, 0, 10, false, false],
        ["yDiv3", 0, 0.365, 0, 5, false, false],
        ["multiplier", 0, 8.31, 0, 10, false, false],
        ["ballSize", 0, 1.829, 0, 20, false, false],
        ["contrast", 0, 2.808, 0, 3, false, false],
        ["radius", 0, 12.458, 0, 20, false, false],
        ["rotation", 0, 0.000571, 0, 0.001, false, false],
        ["xMul", 0, 0.342, 0, 5, false, false],
        ["yMul", 0, 0.777, 0, 5, false, false],
        ["oY", 0, 57.237, 0, 111, false, false],
        ["oX", 0, 45.861, 0, 100, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7e"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom + (zoom * .5 * sin(stream / 15.));\n  uv *= k_rotate2d(stream/12.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 49.443, 0, 200, false, false],
        ["xDiv", 0, 13.853, 0, 200, false, false],
        ["yDiv", 0, 2.857, 0, 20, false, false],
        ["xDiv2", 0, 2.597, 0, 40, false, false],
        ["yDiv2", 0, 2.424, 0, 40, false, false],
        ["xDiv3", 0, 27.706, 0, 400, false, false],
        ["yDiv3", 0, 17.13, 1, 70, false, false],
        ["multiplier", 0, 1.779, 0, 3, false, false],
        ["ballSize", 0, 1.818, 0, 10, false, false],
        ["contrast", 0, 1.61, 0, 3, false, false],
        ["radius", 0, 1.271, 0, 5, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 24.589, 0, 80, false, false],
        ["yMul", 0, 4.329, 0, 200, false, false],
        ["oY", 0, 80, 0, 80, false, false],
        ["oX", 0, 32.035, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f83"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 90.275, 0, 294.9, false, false],
        ["yDivider", 0, 18.646, 0, 49.4, false, false],
        ["xDivider", 0, 9.294, 0, 14.94, false, false],
        ["multiplier", 0, 1.219, 0, 1.73, false, false],
        ["ballSize", 0, 34.82, 0, 69.64, false, false],
        ["contrast", 0, 1.8, 0, 3.6, false, false],
        ["radius", 0, 76.67, 0, 153.34, false, false],
        ["rotation", 0, 14.858, 0, 15.2, false, false],
        ["yDivide", 0, 307.888, 0, 703.66, false, false],
        ["xDivide", 0, 0.408, 0, 0.64, false, false],
        ["yShape", 0, 200, 0, 200, false, false],
        ["shape", 0, 14.966, 0, 33.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f84"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, 1.26)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 362.832, 0, 1000, false, false],
        ["xDiv", 0, 11.463, 0, 100, false, false],
        ["yDiv", 0, 122.317, 0, 200, false, false],
        ["xDiv2", 0, 7.522, 0, 200, false, false],
        ["yDiv2", 0, 2.89, 0, 200, false, false],
        ["xDiv3", 0, 15.832, 0, 200, false, false],
        ["yDiv3", 0, 172.525, 0, 200, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 70.762, 0, 100, false, false],
        ["contrast", 0, 1.714, 0, 2, false, false],
        ["radius", 0, 18.079, 0, 100, false, false],
        ["rotation", 0, 0.000054, 0, 0.001, false, false],
        ["xMul", 0, 0, 0, 20, false, false],
        ["yMul", 0, 13.037, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f88"
    },
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.135, 0, 21, false, false],
        ["iterator", 0, 1.071, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 18.705, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f90"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.411, 0, 20, false, false],
        ["contrast", 0, 2.19, 0, 4.42, false, false],
        ["orbSize", 0, 0.573, 0, 0.76, false, false],
        ["radius", 0, 2.499, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 3.248, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.388, 0, 0.6, false, false],
        ["sinMul", 0, 6.426, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa0"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.509076148343374, 0, 2.74, false, false],
        ["orbSize", 0, 0.5489348644578315, 0, 2.78, false, false],
        ["radius", 0, 4.144187123493976, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb4"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}  \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= rotate(stream/13.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 26.95, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.24, 0.01, 2, false, false],
        ["radius", 0, 11.34, 1, 115, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0.64, 0, 1, false, false],
        ["x2", 0, 0.34, 0, 1, false, false],
        ["y1", 0, 0.41, 0, 1, false, false],
        ["y2", 0, 1.06, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc3"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.);\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 3.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = (gl_FragCoord.xy+(o-n)*.5)/n.y,\n          m       = mouse.xy/n*2.-1.;\n          \n    for (float a = 0.; a < 100.; a++) {\n        vec3 p = r*vec3(i*.35 - m*.05, 1.);\n        p.xy  *= mat2(cos(r*m.x*.07 + vec4(0,33,11,0)));\n        p.z   += stream*.6; p = abs(fract(p)-.5);            \n        r += t = (p.x + p.y + p.z - .12)*.6;        \n    }\n    tot += mix(.7 - vec3(r*r*2e-4), \n        1.5*cos(r*(vec3(5.7, 5.76, 5.82) + length(i))), \n        exp(-r*.07) * (1.2-length(i))); \n_AA_END \n} ",
    "variants": [[["zoom", 0, 1, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a42"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe3"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1276364.983, 0.01, 2111000, false, false],
        ["ballSize", 0, 9105.983, 0, 36122, false, false],
        ["contrast", 0, 2.55, 0, 5, false, false],
        ["radius", 0, 52570255.53, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 133300768.7, 10000000, 192999999, false, false],
        ["y", 0, 7915426.66, 0, 119133112, false, false],
        ["rotation", 0, 0, 0, 0.01, false, false],
        ["colorOffset", 0, 96.5, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 39960.707, 1, 100000, false, false],
        ["div2", 0, 916935.078, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fed"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 2.;\n  mat2 rotation = k_rotate2d(stream/(PI*10.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .58) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.049, 0, 1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 4.962735316265062, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.5863422439759036, 0, 2, false, false],
        ["colorOffset", 0, 9.61846762048193, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.45104942723058306, 0, 2, false, false],
        ["div", 0, 0.12494399472891568, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.38244540662650606, 0, 1, false, false],
        ["iterator", 0, 1.3380082831325304, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 22.118138177710847, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.10004955760542171, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff2"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = abs(uv);\n  uv *= tanMul * tan(logMul * log(abs(uv)) + stream/1.5);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 1.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.2740185534982027, 0.1, 1.2, false, false],
        ["contrast", 0, 1.769083618187107, 1.2, 2, false, false],
        ["ballSize", 0, 0.2369975037592189, 0.2, 0.3, false, false],
        ["radius", 0, 37.791448683102594, 15, 40, false, false],
        ["tanMul", 0, 1.104046078583356, 1, 2, false, false],
        ["logMul", 0, 1.031424398377955, 1, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff6"
    },
    "shader": "void main() { \n  float stream = stream / 40.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv + sin(uv - stream)); \n  float i = sin(uv.x) * cos(uv.y);\n  float rot = rotation * abs(dist / wobble);\n  uv *= k_rotate2d(stream / 01. - rot); \n  float t = i * PI / i * (5. + 1.);\n  float a = cos(yOuter * uv.y);\n  float b = cos(xOuter * uv.x * sin(stream+uv.y / 1.)); \n  float c = sin(t) * b;\n  vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n  vec3 col = k_rainbow(i, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 13.799, 0, 21.456, false, false],
        ["ballSize", 0, 1.4232967569006496, 0, 5.808, false, false],
        ["contrast", 0, 1.0016479198042174, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.48578690678240316, 0, 1, false, false],
        ["yOuter", 0, 1.2013437815863983, 0, 2.32, false, false],
        ["xOuter", 0, 7.477495764307228, 0, 20.4, false, false],
        ["rotation", 0, 0.01897741662450584, 0, 0.1, false, false],
        ["wobble", 0, 0.193156892707549, 0.1, 0.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a47"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd4"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= rotate(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= rotate(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.64, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 4.35, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca016"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 17;\n\n#define PHI   sin(sqrt(PI))\n#define TAU   (PI*PI)\n#define TTIME (stream)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.5/_z, .5*_x) * dot(z-vec3(size,0.,.2),plnormal);\n        \n  dmin = abs(dmin) - width*0.05*(0.105 + 0.05/sin(1.0*length(p) - 1.5*p.y + TTIME/20.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =11.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.434, 0, 4, false, false],
        ["size", 0, 3.495, 0, 12, false, false],
        ["offc", 0, 0, 0, 4, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 7.311, 0, 12, false, false],
        ["_x", 0, 8.265, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02d"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 2.19, 0, 15, false, false],
        ["yDivider", 0, 238.11, 0.1, 333, false, false],
        ["xDivider", 0, 0.2, 0.1, 1, false, false],
        ["multiplier", 0, 2.62, 0.01, 12, false, false],
        ["ballSize", 0, 0.101, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 9.38, 0, 12, false, false],
        ["xOuter", 0, 0.72, 0, 11, false, false],
        ["yOuter", 0, 0.06, 0, 1, false, false],
        ["xDiv", 0, 71.248, 0, 111, false, false],
        ["xDiv2", 0, 4, 0, 4, false, false],
        ["warp", 0, 274.655, 0, 321, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca054"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(i) + stream;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 31. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.25150756835938, 0, 44, false, false],
        ["ballSize", 0, 2.3322930308524503, 1, 8, false, false],
        ["contrast", 0, 9.391235995005415, 0, 15, false, false],
        ["radius", 0, 131.4271090404097, 0, 150, false, false],
        ["yOuter", 0, 1.0550338184382608, 0, 4, false, false],
        ["xOuter", 0, 222.85680931734757, 1, 241, false, false],
        ["xMultiplier", 0, 5.567485892054547, 0, 11, false, false],
        ["yMultiplier", 0, 1.2840676135327445, 0.2, 2, false, false],
        ["divider", 0, 0.81470752394343, 0, 2, false, false],
        ["rotation", 0, 1, 0, 1, false, false],
        ["yDiv", 0, 1.999332933540804, 0, 10, false, false],
        ["yDiv2", 0, 0.1528573139604316, 0, 3, false, false],
        ["xDiv", 0, 0.6099122380635825, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a51"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05c"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.46, 0, 4.92, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 2.32, 0, 4.64, false, false],
        ["colorShift", 0, 6.24, 0, 12.48, false, false],
        ["outer", 0, 2.78, 0, 5.56, false, false],
        ["inner", 0, 0.03, 0, 0.06, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca071"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/1.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 17.22, 0, 111, false, false],
        ["contrast", 0, 1.39, 0, 4, false, false],
        ["orbSize", 0, 3.81, 0.01, 5, false, false],
        ["radius", 0, 19.08, 1, 115, false, false],
        ["colorShift", 0, 28.21, 1, 40, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["rotation", 0, 50, 0, 50, false, false],
        ["sinMul", 0, 3.65, 0, 5, false, false],
        ["cosMul", 0, 1.39, 0, 3, false, false],
        ["yMul", 0, 0.2, 0, 1, false, false],
        ["xMul", 0, 0.75, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.002, 0.001, 0.01, false, false],
        ["yDivide", 0, 19, 0, 19, false, false],
        ["xDivide", 0, 19, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca081"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv) - stream)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  // uv /= dot(sin(uv+stream), cos(uv+stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 5000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 55.74, false, false],
        ["yDivider", 0, 187.19, 0, 374.38, false, false],
        ["xDivider", 0, 130.77, 0, 261.54, false, false],
        ["multiplier", 0, 583.53, 0, 1167.06, false, false],
        ["ballSize", 0, 1.8, 0, 3.6, false, false],
        ["contrast", 0, 2.09, 0, 4.18, false, false],
        ["radius", 0, 19.36, 0, 38.72, false, false],
        ["yOuter", 0, 0.42, 0, 0.84, false, false],
        ["xOuter", 0, 0.42, 0, 0.84, false, false],
        ["rotation", 0, 0.58, 0, 1.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca083"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 55.74, false, false],
        ["yDivider", 0, 187.19, 0, 374.38, false, false],
        ["xDivider", 0, 130.77, 0, 261.54, false, false],
        ["multiplier", 0, 583.53, 0, 1167.06, false, false],
        ["ballSize", 0, 1.8, 0, 3.6, false, false],
        ["contrast", 0, 2.09, 0, 4.18, false, false],
        ["radius", 0, 19.36, 0, 38.72, false, false],
        ["yOuter", 0, 0.42, 0, 0.84, false, false],
        ["xOuter", 0, 0.42, 0, 0.84, false, false],
        ["rotation", 0, 0.58, 0, 1.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08a"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = i/radius * tan(t + stream/6.) * sin(t-stream/3.);\n    float y = i/radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 1.)* orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 33.63, 0, 151, false, false],
        ["contrast", 0, 0.85, 0, 2, false, false],
        ["orbSize", 0, 0.29, 0.01, 1, false, false],
        ["radius", 0, 5.57, 0, 14, false, false],
        ["colorShift", 0, 12.71, 3, 33, false, false],
        ["div", 0, 9.908, 1, 101, false, false],
        ["div2", 0, 12.178, 1, 110, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca095"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *= rotate2d(stream/70.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/20)*cos(uv.y/yDivider + stream/21.) + sin(uv.x/50. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider + stream/21.) * sin(uv.y/50. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 58.06, 0, 111, false, false],
        ["yDivider", 0, 1001, 0.1, 1001, false, false],
        ["xDivider", 0, 345.32, 0.1, 1001, false, false],
        ["multiplier", 0, 5.87, 0.01, 12, false, false],
        ["ballSize", 0, 0.2, 0, 1, false, false],
        ["contrast", 0, 1.86, 0, 5, false, false],
        ["radius", 0, 9.94, 0, 15, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a4"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += .2*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/12.);\n    uv.x += .2*float(i)*sin(uv.x/xDivider - stream/11.) - sin(uv.y/20. + stream/12.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50.47, 0, 1010, false, false],
        ["yDivider", 0, 397.41, 0.1, 1001, false, false],
        ["xDivider", 0, 815.27, 0.1, 1001, false, false],
        ["multiplier", 0, 4.29, 0.01, 12, false, false],
        ["ballSize", 0, 0.22, 0, 1, false, false],
        ["contrast", 0, 1.96, 0, 5, false, false],
        ["radius", 0, 9.33, 0, 115, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a8"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.22, 0, 5.22, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.203, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a58"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ac"
    },
    "shader": "\n#define BALLS 20.\n  \nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 2, false, false],
        ["contrast", 0, 3.03, 0, 8, false, false],
        ["ballSize", 0, 0.016, 0, 0.05, false, false],
        ["radius", 0, 45.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 0.71, 0, 3, false, false],
        ["contrast", 0, 4.38, 0, 8, false, false],
        ["ballSize", 0, 0.021, 0, 0.1, false, false],
        ["radius", 0, 104.1, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 0.3039, 0.01, 1, false, false],
        ["contrast", 0, 4.18, 0, 8, false, false],
        ["ballSize", 0, 0.015, 0, 0.1, false, false],
        ["radius", 0, 259.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 2.72, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 1.49, 0, 21, false, false],
        ["contrast", 0, 4.18, 0, 8, false, false],
        ["ballSize", 0, 0.02, 0, 0.1, false, false],
        ["radius", 0, 188.51, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.07, 0, 16, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 5.39, 0, 8, false, false],
        ["ballSize", 0, 0.06, 0, 0.1, false, false],
        ["radius", 0, 188.51, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, -16.76, -30, 30, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0be"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.19, 0, 21, false, false],
        ["contrast", 0, 4.95, 0, 8, false, false],
        ["ballSize", 0, 0.08, 0, 0.1, false, false],
        ["radius", 0, 1, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 10, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0cd"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/50.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) + sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/350. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.003, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 1000, 0, 1000, false, false],
        ["rotation", 0, 0.00912, 0.009, 0.01, false, false],
        ["xMultiplier", 0, 3094.4, 0, 11500, false, false],
        ["yMultiplier", 0, 288.23, 0, 1000, false, false],
        ["colorSpread", 0, 0.00003, 0, 0.0001, false, false],
        ["colorMultiplier", 0, 1.2, 0, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.69, 0, 10, false, false],
        ["ballSize", 0, 8.04, 0, 100, false, false],
        ["glow", 0, 1.01, 0, 4, false, false],
        ["contrast", 0, 2.25, 0, 5, false, false],
        ["radius", 0, 6.23, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d4"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 64.73, 0, 151, false, false],
        ["contrast", 0, 1.42, 0, 2, false, false],
        ["orbSize", 0, 1.05, 0.01, 2, false, false],
        ["radius", 0, 11.83, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 17.328, 10, 40, false, false],
        ["div2", 0, 14.483, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca114"
    },
    "shader": "\n\n#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.64, 0, 3.28, false, false],
        ["xMultiplier", 0, 86.71, 0, 173.42, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 2.25, 0, 4.5, false, false],
        ["colorSpread", 0, 3.36, 0, 6.72, false, false],
        ["colorMultiplier", 0, 115.44, 0, 230.88, false, false],
        ["shapeMultiplier", 0, 13.45, 0, 26.9, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 5.1, 0, 10.2, false, false],
        ["rotation", 0, 11.471, 0, 22.942, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8c"
    },
    "shader": "void main () {\n  float stream = stream  / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize,vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.668, 0, 5, false, false],
        ["iterator", 0, 1.186, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 23.76, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false],
        ["orbSize", 0, 0.071, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8e"
    },
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.199, 0, 0.2, false, false],
        ["contrast", 0, 1.262, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 0.825, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.43, 0, 1, false, false],
        ["colorOffset", 0, 0, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.307, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 2.979, 0, 25.38, false, false],
        ["colorShift", 0, 0, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 4.12, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.145, 0, 1, false, false],
        ["contrast", 0, 1.35, 0, 2.92, false, false],
        ["orbSize", 0, 8.789, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 1.277, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 5, 0, 5, false, false],
        ["b", 0, 0.19, 0, 5, false, false],
        ["c", 0, 1.77, 0, 5, false, false],
        ["d", 0, 0.47, 0, 1, false, false],
        ["colorOffset", 0, 2.06, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.994, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.8, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.089, 0, 1, false, false],
        ["contrast", 0, 0.617, 0, 2.92, false, false],
        ["orbSize", 0, 0.993, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.227, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0, 0, 5, false, false],
        ["c", 0, 0, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f99"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 10, 0, 20, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 0.38, 0, 0.76, false, false],
        ["radius", 0, 1.76, 0, 3.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc0"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2 i = k_uv() * zoom;\ni *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      [
        ["zoom", 0, 0.033, 0, 0.1, false, false],
        ["mul", 0, 0.46, 0, 1, false, false],
        ["rot", 0, 489.87, 0, 1112, false, false],
        ["sub", 0, 42.73, 0, 112, false, false],
        ["A", 0, 2.34, 0, 4, false, false],
        ["B", 0, 5.57, 0, 43, false, false],
        ["C", 0, 10.18, 0, 34, false, false],
        ["D", 0, 3.59, 0, 14, false, false],
        ["dep", 0, 0.11, 0, 1, false, false],
        ["wap", 0, 0.7, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a42"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc5"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 7.7158, 0, 15, false],
        ["contrast", 0, 1.13968, 0, 2, false],
        ["orbSize", 0, 0.44755, 0.01, 1, false],
        ["radius", 0, 5, 1, 5, false],
        ["colorShift", 0, 81.54882, 1, 110, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false],
        ["center", 0, 0.88063, 0, 1, false],
        ["sides", 0, 2.75927, 0, 8, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd7"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.2);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .14) * _uv.y/div - stream/.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.43 - t*PI), radius*tan(t - stream/-.9));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.13- uv.y/(.7*y + .3*y*sin(stream/.7393))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.4  * float(i) / 6.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1227038.805, 0.01, 2111000, false, false],
        ["ballSize", 0, 12794.352, 0, 36122, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 57335073.78, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 164362793.61, 10000000, 192999999, false, false],
        ["y", 0, 17556518.17, 0, 119133112, false, false],
        ["rotation", 0, 0.00224, 0, 0.01, false, false],
        ["colorOffset", 0, 330.39, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 63549.947, 1, 100000, false, false],
        ["div2", 0, 551932.42, 0, 1313311, false, false],
        ["wad", 0, 4.882, 1, 18, false, false],
        ["woot", 0, 0.135, 0, 0.2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fea"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.1) * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0015747364457831328, 0, 0.1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 1.0034073795180722, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 13.64527014307229, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.7545274849397591, 0, 2, false, false],
        ["colorOffset", 0, 37.88460090361446, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.2960278614457832, 0, 2, false, false],
        ["div", 0, 0.03972143260542169, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6151637801204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 7.6585843373493985, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.07135316265060243, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff9"
    },
    "shader": "void main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  float i = sin(uv.x);\n  float rot = -rotation * abs(stream + dist / .2);\n  uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n  float t = i * PI / i * (5. + 1.);\n  float a = cos(uv.y - stream / .5);\n  float b = cos(uv.x * sin(uv.y / 1.)); \n  float c = radius * sin(stream+t) * 20. * b;\n  vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n  vec3 col = k_rainbow(i / 5. * i, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs((gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n} ",
    "variants": [
      [
        ["zoom", 0, 8.304, 0, 21.456, false, false],
        ["ballSize", 0, 2.304, 0, 5.808, false, false],
        ["contrast", 0, 1.113, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.216, 0, 2.32, false, false],
        ["xOuter", 0, 12.54, 0, 20.4, false, false],
        ["rotation", 0, 0.02, 0, 0.1, false, false],
        ["wobble", 0, 0.15, 0.1, 0.7, false, false]
      ],
      [
        ["zoom", 0, 7.405, 0, 21.456, false, false],
        ["ballSize", 0, 0.861, 0, 5.808, false, false],
        ["contrast", 0, 0.999, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.789, 0, 1, false, false],
        ["yOuter", 0, 2.32, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["rotation", 0, 0, 0, 0.1, false, false],
        ["wobble", 0, 0.7, 0.1, 0.7, false, false]
      ],
      [
        ["zoom", 0, 5.969, 0, 21.456, false, false],
        ["ballSize", 0, 1.511, 0, 5.808, false, false],
        ["contrast", 0, 0.961, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.789, 0, 1, false, false],
        ["yOuter", 0, 0.258, 0, 11, false, false],
        ["xOuter", 0, 60.148, 0, 120.4, false, false],
        ["rotation", 0, -0.07, -0.1, 0.1, false, false],
        ["wobble", 0, 1.29, 0.1, 10.7, false, false]
      ],
      [
        ["zoom", 0, 2.275, 0, 21.456, false, false],
        ["ballSize", 0, 0.489, 0, 1, false, false],
        ["contrast", 0, 1.133, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.789, 0, 1, false, false],
        ["yOuter", 0, 2.32, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["rotation", 0, 0, 0, 0.1, false, false],
        ["wobble", 0, 0.7, 0.1, 0.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fff"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 8.224, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca012"
    },
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale =2.5;\nconst float shell = .1243;\nconst float carve = .8393;\nconst float falloff = 3.1;\nconst float blend = .22;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n  float stream = stream / .5;\n    vec3 pp = p;\n    float d = 10.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 4.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -=  .025 + .505 * (.01*cos(.5 + .1 * sin(i * PI + i / PI)));\n        d = smin(d, abs(mul*sin(dot(p, p)/30.*.00001030215*shape*dot(1.2*cos(stream/-5. + p),2.*cos(stream/2.5*shape2 - p.yzx)))*scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    // d += abs(.1 - .25 * cos(p.z/zid+stream*warpSpeed)) * cos(1./length(p)/.92+stream*warpSpeed);\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(3.51,-0.5);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n  float stream = stream / .5;\n    // coordinates\n    vec2 uv = (gl_FragCoord.xy - resolution.xy / 2.)/resolution.y * zoom;\n    vec3 ray = normalize(vec3(uv, -0.0014325));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 10.;\n    const float count = 10.;\n    for (float index = count; index > 0.; --index)\n    {\n        pos += ray*map(pos);\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.3*normal;\n    float backLight = dot(normal, vec3(-1,-.5,.5))*.25+.25;\n    float bottomLight = 1.*dot(normal, vec3(0,-1,-2))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*20.-stream/10. * pow(5.*volume, .9)*sin(.00015*length(.5*uv))- stream/15.);\n    color += pow(volume, .5)*vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.002, 0, 0.1, false, false],
        ["warpSpeed", 0, 2.439, 0, 10.1, false, false],
        ["mul", 0, 1531.318, 0, 2222, false, false],
        ["zid", 0, 36.043, 0, 1121, false, false],
        ["shape", 0, 1.481, 0, 2, false, false],
        ["shape2", 0, 0.317, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02c"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv); \n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 4.72, 0, 15, false, false],
        ["yDivider", 0, 99.63, 0.1, 333, false, false],
        ["xDivider", 0, 0.33, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.182, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 3.01, 0, 12, false, false],
        ["xOuter", 0, 2.47, 0, 11, false, false],
        ["yOuter", 0, 0.21, 0, 1, false, false],
        ["xDiv", 0, 26.512, 0, 111, false, false],
        ["xDiv2", 0, 0.321, 0, 4, false, false],
        ["warp", 0, 9.129, 0, 321, false, false]
      ],
      [
        ["zoom", 0, 1.22, 0, 15, false, false],
        ["yDivider", 0, 99.63, 0.1, 333, false, false],
        ["xDivider", 0, 0.33, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.129, 0, 0.3, false, false],
        ["contrast", 0, 1.02, 0, 5, false, false],
        ["radius", 0, 3.01, 0, 12, false, false],
        ["xOuter", 0, 1.12, 0, 11, false, false],
        ["yOuter", 0, 0.15, 0, 1, false, false],
        ["xDiv", 0, 53.776, 0, 111, false, false],
        ["xDiv2", 0, 0.12, 0, 4, false, false],
        ["warp", 0, 1.121, 0, 66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca038"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * sin( .001 * dot(uv, uv) + stream/5.) * sin(.0001 * dot(uv, uv)-stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * cos(t+stream/-10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 27.12, 0, 151, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 1.52, 0.01, 2, false, false],
        ["radius", 0, 3.73, 0, 14, false, false],
        ["colorShift", 0, 26.54, 3, 33, false, false],
        ["div", 0, 29.235, 10, 40, false, false],
        ["div2", 0, 28.885, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca045"
    },
    "shader": "#define orbs 12.\n\nconst vec3 TEENAGE_DREAM[6] = vec3[6](\n  vec3(0.51,0.816,0.855),\n  vec3(0.78,0.886,0.8),\n  vec3(0.596,0.749,0.863),\n  vec3(0.337,0.475,0.604),\n  vec3(0.416,0.369,0.592),\n  vec3(0.631,0.278,0.451)\n);\n\nconst vec3 NEVER_REALLY_OVER[6] = vec3[6](\n  vec3(0.996,0.737,0.114),\n  vec3(0.98,0.576,0.204),\n  vec3(0.631,0.278,0.451),\n  vec3(0.306,0.702,0.843),\n  vec3(0.596,0.749,0.863),\n  vec3(0.988,0.937,0.824)\n);\n\nconst vec3 WAKING_UP_IN_VEGAS[6] = vec3[6](\n  vec3(0.737,0.235,0.216),\n  vec3(0.518,0.231,0.251), \n  vec3(0.925,0.812,0.761),\n  vec3(0.988,0.855,0.537),\n  vec3(0.98,0.576,0.204),\n  vec3(0.631,0.278,0.451)\n);\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool t, bool tp, float tps) {\n  return tp ? t ? mix(uv, uv2, tps): mix(uv2, uv, tps) : t ? uv2 : uv;\n}\n \nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n \tconst vec3 palette[6] = TEENAGE_DREAM;\n  float dist = length(uv);\n  gl_FragColor += .1 * vec4(palette[0], 1.);\n  vec2 _swirl = uv * rotate(sin(distMul * dist + stream/1.1) + rotation*stream/3.);\n  vec2 _warp = uv / dot(uv, uv);\n\tuv = swap(uv, _swirl, swirl, swirlTween, swirlTweenProgress);\n  uv = swap(uv, _warp, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) { \n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-3.);\n    uv.y += cos(cosMul *  uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = palette[int(i)];\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 9.18, 0, 18.36, false, false],
        ["contrast", 0, 2.03, 0, 4.06, false, false],
        ["orbSize", 0, 2.13, 0, 4.26, false, false],
        ["radius", 0, 5.23, 0, 10.46, false, false],
        ["colorShift", 0, 6.88, 0, 13.76, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0.19, 0, 0.38, false, false],
        ["cosMul", 0, 0.11, 0, 0.22, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 3.12, 0, 6.24, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, -0.8, 0, -1.6, false, false],
        ["gloop", 0, 0.0036, 0, 0.0072, false, false],
        ["yDivide", 0, 2, 0, 4, false, false],
        ["xDivide", 0, 0.99, 0, 1.98, false, false],
        ["swirl", 1, false, null, null, null, false],
        ["warp", 1, false, null, null, null, false],
        ["distMul", 0, 0.67, 0, 1.34, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca047"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/41.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 20.75, 0, 41.5, false, false],
        ["contrast", 0, 0.96, 0, 1.92, false, false],
        ["orbSize", 0, 0.17, 0, 0.34, false, false],
        ["radius", 0, 3.65, 0, 7.3, false, false],
        ["colorShift", 0, 8.07, 0, 16.14, false, false],
        ["div", 0, 10.673, 0, 21.346, false, false],
        ["div2", 0, 16.837, 0, 33.674, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca055"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i <3.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.))* k_rotate2d(stream/-10.);;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-43.+uv.x/xDiv * sin(stream/5.4-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(1.11*uv.y/yDiv2+stream/21.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 38.853428263836605, 0, 444, false, false],
        ["ballSize", 0, 4.33719298581043, 1, 8, false, false],
        ["contrast", 0, 11.279379541655185, 0, 15, false, false],
        ["radius", 0, 13.15456667980516, 0, 333, false, false],
        ["yOuter", 0, 3.9243387612951808, 0, 4, false, false],
        ["xOuter", 0, 241, 1, 241, false, false],
        ["xMultiplier", 0, 0.18037186588149476, 0, 1, false, false],
        ["yMultiplier", 0, 22, 0.2, 22, false, false],
        ["divider", 0, 0.81470752394343, 0, 2, false, false],
        ["rotation", 0, 0, 0, 1, false, false],
        ["yDiv", 0, 8.593662675604763, 0, 10, false, false],
        ["yDiv2", 0, 1.3630719655967622, 0, 3, false, false],
        ["xDiv", 0, 3.2700821658214894, 0, 6, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 97.72096903237953, 0, 144, false, false],
        ["ballSize", 0, 4.8438897006482975, 1, 28, false, false],
        ["contrast", 0, 5.919895493840597, 0, 15, false, false],
        ["radius", 0, 11.349076190626766, 0, 150, false, false],
        ["yOuter", 0, 0, 0, 64, false, false],
        ["xOuter", 0, 89.56573143924577, 10, 363, false, false],
        ["xMultiplier", 0, 0.37678829330995867, 0, 11, false, false],
        ["yMultiplier", 0, 0.4365751059658557, 0.2, 2, false, false],
        ["divider", 0, 0.81470752394343, 0, 2, false, false],
        ["rotation", 0, 0.41953459130712306, 0, 1, false, false],
        ["yDiv", 0, 65.15596486286945, 0, 210, false, false],
        ["yDiv2", 0, 1, 0, 1, false, false],
        ["xDiv", 0, 2, 0, 2, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 24.11030300518538, 0, 44, false, false],
        ["ballSize", 0, 2.3485876726816937, 1, 8, false, false],
        ["contrast", 0, 11.279379541655185, 0, 15, false, false],
        ["radius", 0, 80.28082277918438, 0, 333, false, false],
        ["yOuter", 0, 3.9243387612951808, 0, 4, false, false],
        ["xOuter", 0, 241, 1, 241, false, false],
        ["xMultiplier", 0, 1, 0, 1, false, false],
        ["yMultiplier", 0, 3.899312461025745, 0.2, 22, false, false],
        ["divider", 0, 0.81470752394343, 0, 2, false, false],
        ["rotation", 0, 0.37987304365778546, 0, 1, false, false],
        ["yDiv", 0, 8.593662675604763, 0, 10, false, false],
        ["yDiv2", 0, 1.3630719655967622, 0, 3, false, false],
        ["xDiv", 0, 3.2700821658214894, 0, 6, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 21.858797666250947, 0, 44, false, false],
        ["ballSize", 0, 1.8032996763665994, 1, 8, false, false],
        ["contrast", 0, 15, 0, 15, false, false],
        ["radius", 0, 12.57758987610599, 0, 333, false, false],
        ["yOuter", 0, 0.8930718479386297, 0, 4, false, false],
        ["xOuter", 0, 241, 1, 241, false, false],
        ["xMultiplier", 0, 2, 0, 2, false, false],
        ["yMultiplier", 0, 5.592455407567772, 0.2, 22, false, false],
        ["divider", 0, 0.81470752394343, 0, 2, false, false],
        ["rotation", 0, 0.607568800592997, 0, 2, false, false],
        ["yDiv", 0, 6.869864084634437, 0, 10, false, false],
        ["yDiv2", 0, 322.07657191265065, 0, 333, false, false],
        ["xDiv", 0, 57.74705273731646, 0, 61, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 301.28439117799326, 0, 544, false, false],
        ["ballSize", 0, 47.95304866928653, 2, 358, false, false],
        ["contrast", 0, 7.721214432314219, 0, 15, false, false],
        ["radius", 0, 24.617146076558566, -1, 35, false, false],
        ["yOuter", 0, 2.617563367712016, 0, 4, false, false],
        ["xOuter", 0, 3.853854627494353, 1, 66, false, false],
        ["xMultiplier", 0, 0.04411929946347892, 0, 2, false, false],
        ["yMultiplier", 0, 22, 0.2, 22, false, false],
        ["divider", 0, 0.8680771425545935, 0, 2, false, false],
        ["rotation", 0, 2.0988518404673386, 0, 21, false, false],
        ["yDiv", 0, 1.882273662521179, 0, 10, false, false],
        ["yDiv2", 0, 0.8095045618264072, 0, 3, false, false],
        ["xDiv", 0, 121.48361413062824, 0, 222, false, false],
        ["xDiv2", 0, 231918.70456432668, 0, 333772, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a51"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca051"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0003 * dot(uv, uv) - stream) * sin(.00005 * dot(uv, uv)+stream/.98378);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 67.31, 0, 134.62, false, false],
        ["contrast", 0, 1.49, 0, 2.98, false, false],
        ["orbSize", 0, 0.93, 0, 1.86, false, false],
        ["radius", 0, 3.36, 0, 6.72, false, false],
        ["colorShift", 0, 15.2, 0, 30.4, false, false],
        ["div", 0, 12.15, 0, 24.3, false, false],
        ["div2", 0, 40, 0, 80, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06c"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/21.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/21.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .7)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 31.68, 0, 111, false, false],
        ["contrast", 0, 1.03, 0, 2, false, false],
        ["orbSize", 0, 2, 0.01, 2, false, false],
        ["radius", 0, 13, 1, 115, false, false],
        ["colorShift", 0, 7.12, 4, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["rotation", 0, 0, 0, 2, false, false],
        ["sinMul", 0, 2, 0, 2, false, false],
        ["cosMul", 0, 0.94, 0, 3, false, false],
        ["yMul", 0, 0.14, 0, 1, false, false],
        ["xMul", 0, 0.05, 0, 5, false, false],
        ["xSpeed", 0, -0.5, -1, 1, false, false],
        ["ySpeed", 0, 0.5, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.2, 0, 19, false, false],
        ["xDivide", 0, 2.08, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca080"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv) - stream)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  // uv /= dot(sin(uv+stream), cos(uv+stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 13.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 6000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 19.15, 0, 38.3, false, false],
        ["yDivider", 0, 187.19, 0, 374.38, false, false],
        ["xDivider", 0, 130.77, 0, 261.54, false, false],
        ["multiplier", 0, 378.53, 0, 757.06, false, false],
        ["ballSize", 0, 0.87, 0, 1.74, false, false],
        ["contrast", 0, 1.77, 0, 3.54, false, false],
        ["radius", 0, 11.96, 0, 23.92, false, false],
        ["yOuter", 0, 0.42, 0, 0.84, false, false],
        ["xOuter", 0, 0.42, 0, 0.84, false, false],
        ["rotation", 0, 0.76, 0, 1.52, false, false],
        ["_pow", 0, 4.09, 0, 8.18, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08e"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = i/radius * tan(t + stream/6.) * sin(t-stream/3.);\n    float y = i/radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 1.)* orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 33.63, 0, 67.26, false, false],
        ["contrast", 0, 0.85, 0, 1.7, false, false],
        ["orbSize", 0, 0.29, 0, 0.58, false, false],
        ["radius", 0, 5.57, 0, 11.14, false, false],
        ["colorShift", 0, 12.71, 0, 25.42, false, false],
        ["div", 0, 9.908, 0, 19.816, false, false],
        ["div2", 0, 12.178, 0, 24.356, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca092"
    },
    "shader": "precision highp float;\n\n\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv *= rotate2d(1.);\n  vec2 p = 1.3 / abs(vec2(1. / shape));\n  p /= abs(tan(sin(xShape * uv.x-stream) * (cos(yShape * uv.y - stream))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (time / 3.23 + colorShape * uv.x)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y - cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.b *= .42;\n}",
    "variants": [
      [
        ["zoom", 0, 1.032, 0, 2, false, false],
        ["xShape", 0, 11, 0, 11, false, false],
        ["yShape", 0, 11, 0, 11, false, false],
        ["colorShape", 0, 11, 0, 11, false, false],
        ["contrast", 0, 0.376, 0, 1, false, false],
        ["ballSize", 0, 1, 0, 1, false, false],
        ["shape", 0, 0.016, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a56"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09c"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 61.35, 0, 122.7, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 345.32, 0, 690.64, false, false],
        ["multiplier", 0, 5.87, 0, 11.74, false, false],
        ["ballSize", 0, 0.2, 0, 0.4, false, false],
        ["contrast", 0, 1.86, 0, 3.72, false, false],
        ["radius", 0, 9.94, 0, 19.88, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0bb"
    },
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.513, 0, 1, false, false],
        ["contrast", 0, 2.1, 0, 30, false, false],
        ["ballSize", 0, 0.0083, 0, 0.1, false, false],
        ["radius", 0, 105.45, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 2.24, 0, 5, false, false],
        ["tanMul", 0, 3.12, 0, 10, false, false],
        ["sinMul", 0, 1.61, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e5"
    },
    "shader": "\n#define BALLS 10.\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *= rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.896, 0, 115, false, false],
        ["contrast", 0, 1.51, 0, 5, false, false],
        ["ballSize", 0, 0.1211, 0, 1, false, false],
        ["radius", 0, 2.2, 0, 110, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 1, 5, false, false],
        ["tanMul", 0, 4.35, 0, 10, false, false],
        ["sinMul", 0, 2.8, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 23.182, 0, 31, false, false],
        ["contrast", 0, 1.99, 0, 5, false, false],
        ["ballSize", 0, 0.9576, 0, 6, false, false],
        ["radius", 0, 18, 0, 18, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 1, 5, false, false],
        ["tanMul", 0, 35.05, 0, 50, false, false],
        ["sinMul", 0, 2.8, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e8"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2. * stream / 3. + log(.1 * abs(uv))));\n  uv *= k_rotate2d(dist - rotation - stream / .5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv)))) - stream / .5) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(t), sin(radius * t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5) * pow(dist, 2.) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.896, 0, 5.792, false, false],
        ["contrast", 0, 1.51, 0, 3.02, false, false],
        ["ballSize", 0, 0.1211, 0, 0.2422, false, false],
        ["radius", 0, 2.2, 0, 4.4, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 0, 2, false, false],
        ["tanMul", 0, 4.35, 0, 8.7, false, false],
        ["sinMul", 0, 2.8, 0, 5.6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0eb"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n // uv = sin(stream*1.+(1.-log(sin(uv)))); \n // uv *= rotate2d(stream);\n  uv += sin(dotMultiplier*(cos(dot(abs(uv), log(abs(uv)))) - stream/1.));\n // uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = radius*vec2(tanMul*tan(t), sinMul*sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.778, 0, 1.556, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 0.1491, 0, 0.2982, false, false],
        ["radius", 0, 2.25, 0, 4.5, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 2.17, 0, 4.34, false, false],
        ["dotMultiplier", 0, 5, 0, 10, false, false],
        ["tanMul", 0, 0.9, 0, 1.8, false, false],
        ["sinMul", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ed"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n // uv = sin(stream*1.+(1.-log(sin(uv)))); \n // uv *= rotate2d(stream);\n  uv += sin(dotMultiplier*(cos(dot(abs(uv), log(abs(uv)))) - stream/1.));\n // uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = radius*vec2(tanMul*tan(t), sinMul*sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.778, 0, 5, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["ballSize", 0, 0.1491, 0, 0.5, false, false],
        ["radius", 0, 2.25, 0, 10, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 2.17, 0, 10, false, false],
        ["dotMultiplier", 0, 5, 0, 5, false, false],
        ["tanMul", 0, 0.9, 0, 10, false, false],
        ["sinMul", 0, 0, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca106"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/20. - i);\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/11.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .802716175) * orbSize, vec2(radius*abs(sin(stream/.3-uv.x/div)) * L * sin(stream - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y), radius*cos(stream/11.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 571.305, 0, 1145, false, false],
        ["iterator", 0, 0.518, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 24.905, 0, 33, false, false],
        ["L", 0, 4.002, 0, 213, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 1.791, 0, 2, false, false],
        ["colorOffset", 0, 22.942, 0, 111, false, false],
        ["contrast", 0, 2.614, 1, 3, false, false],
        ["orbSize", 0, 2.212, 0, 13, false, false],
        ["div", 0, 0.994, 0, 14, false, false],
        ["radius", 0, 5.661, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca10c"
    },
    "shader": "\n\n#define BALLS 3\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.94, 0, 23, false, false],
        ["xMultiplier", 0, 35.99, 0, 200, false, false],
        ["yMultiplier", 0, 49.25, 0, 200, false, false],
        ["ballSize", 0, 8.09, 0, 12, false, false],
        ["colorSpread", 0, 7, 0.2, 7, false, false],
        ["colorMultiplier", 0, 111.05, 1, 500, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 210, false, false],
        ["glow", 0, 1862.09, 0, 10000, false, false],
        ["contrast", 0, 3.17, 1, 10, false, false],
        ["rotation", 0, 11.471, 0, 15, false, false],
        ["brightness", 0, 1, 0, 1, false, false],
        ["sides", 0, 11, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f58"
    },
    "shader": "\n\n#define BALLS 15\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/1.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/2.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.23, 0, 3, false, false],
        ["xMultiplier", 0, 29.96, 0, 200, false, false],
        ["yMultiplier", 0, 49.25, 0, 200, false, false],
        ["ballSize", 0, 1.68, 0, 2, false, false],
        ["colorSpread", 0, 1.79, 0.2, 7, false, false],
        ["colorMultiplier", 0, 383.24, 1, 500, false, false],
        ["shapeMultiplier", 0, 13.45, 0, 210, false, false],
        ["glow", 0, 1862.09, 0, 10000, false, false],
        ["contrast", 0, 5.1, 1, 10, false, false],
        ["rotation", 0, 11.628, 0, 15, false, false],
        ["brightness", 0, 8078.46, 0, 11100, false, false],
        ["sides", 0, 10, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f61"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.55, 0, 1.1, false, false],
        ["xMultiplier", 0, 114.44, 0, 228.88, false, false],
        ["yMultiplier", 0, 102.79, 0, 205.58, false, false],
        ["ballSize", 0, 1.04, 0, 2.08, false, false],
        ["colorSpread", 0, 0.17, 0, 0.34, false, false],
        ["colorMultiplier", 0, 282.59, 0, 565.18, false, false],
        ["shapeMultiplier", 0, 210, 0, 420, false, false],
        ["glow", 0, 53480.75, 0, 106961.5, false, false],
        ["contrast", 0, 4.57, 0, 9.14, false, false],
        ["rotation", 0, 3.784, 0, 7.568, false, false],
        ["brightness", 0, 4926.49, 0, 9852.98, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6c"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .7);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.3;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .9)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 14808.906439864471, 0, 21622.18, false, false],
        ["ballSize", 0, 5646.8056502539575, 0, 12120.2, false, false],
        ["contrast", 0, 1.4018456312432348, 0, 8.94, false, false],
        ["radius", 0, 20278.94704856131, 0, 23223, false, false],
        ["yOuter", 0, 2184.1534747983637, 0, 2225.42, false, false],
        ["xOuter", 0, 16.83638119010466, 0, 302.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.2490805134600906, 0, 7.36, false, false],
        ["yMultiplier", 0, 5.983607041324478, 0, 19.24, false, false],
        ["divider", 0, 2.87705232551299, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7a"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 43.29, 0, 200, false, false],
        ["xDiv", 0, 32.251, 0, 50, false, false],
        ["yDiv", 0, 1.558, 0, 20, false, false],
        ["xDiv2", 0, 0.606, 0, 20, false, false],
        ["yDiv2", 0, 3.463, 0, 40, false, false],
        ["xDiv3", 0, 19.048, 0, 400, false, false],
        ["yDiv3", 0, 5.277, 1, 20, false, false],
        ["multiplier", 0, 0.649, 0, 3, false, false],
        ["ballSize", 0, 19.697, 0, 50, false, false],
        ["contrast", 0, 2.234, 0, 3, false, false],
        ["radius", 0, 13.117, 0, 30, false, false],
        ["rotation", 0, 0.000242, 0, 0.001, false, false],
        ["xMul", 0, 0.346, 0, 20, false, false],
        ["yMul", 0, 3.29, 0, 20, false, false],
        ["oY", 0, 39.81, 0, 44, false, false],
        ["oX", 0, 5.455, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9d"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/23.);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream/5.), uv));\n  uv *= rotate(stream/-21.);\n  uv /= dot(tan(uv), cos(uv));\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/5.)-stream/9.);\n    float y = radius * cos(sin(t+stream/5.)+stream)/4.;\n    vec2 position = vec2(x, y);\n    vec3 color = col + cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 7.95, 0, 10, false, false],
        ["contrast", 0, 2.93, 1, 5, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 15, 1, 15, false, false],
        ["colorShift", 0, 7.05, 4, 10, false, false],
        ["center", 0, 2.13, 0, 10, false, false],
        ["sides", 0, 8, 0, 12, false, false],
        ["dotMul", 0, 0.2, 0, 0.2, false, false],
        ["sinMul", 0, 10, 0, 10, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa8"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 0.64, 0, 1.28, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0.91, 0, 1.82, false, false],
        ["y1", 0, 0.37, 0, 0.74, false, false],
        ["y2", 0, 1.86, 0, 3.72, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ],
      [
        ["zoom", 0, 24.7, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.204, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 2.6, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 0.394, 0, 3.72, false, false],
        ["center", 0, 13.273, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 11.101, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.003, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 4.625, 0, 8.82, false, false],
        ["x1", 0, 0.053, 0, 0.2, false, false],
        ["x2", 0, 1.82, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 3.72, 0, 3.72, false, false],
        ["center", 0, 3.859, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fab"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 0.64, 0, 1.28, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0.91, 0, 1.82, false, false],
        ["y1", 0, 0.37, 0, 0.74, false, false],
        ["y2", 0, 1.86, 0, 3.72, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ],
      [
        ["zoom", 0, 24.7, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.204, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 2.6, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 0.394, 0, 3.72, false, false],
        ["center", 0, 13.273, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 11.101, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.003, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 4.625, 0, 8.82, false, false],
        ["x1", 0, 0.053, 0, 0.2, false, false],
        ["x2", 0, 1.82, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 3.72, 0, 3.72, false, false],
        ["center", 0, 3.859, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fbf"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2 i = k_uv() * zoom;\ni *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      [
        ["zoom", 0, 0.033, 0, 0.1, false, false],
        ["mul", 0, 0.46, 0, 1, false, false],
        ["rot", 0, 489.87, 0, 1112, false, false],
        ["sub", 0, 42.73, 0, 112, false, false],
        ["A", 0, 2.34, 0, 4, false, false],
        ["B", 0, 5.57, 0, 43, false, false],
        ["C", 0, 10.18, 0, 34, false, false],
        ["D", 0, 3.59, 0, 14, false, false],
        ["dep", 0, 0.11, 0, 1, false, false],
        ["wap", 0, 0.7, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a42"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc7"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/3.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 9.79, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 4.35, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe4"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / -6.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (.3 + .22*sin(6.*cos(_uv.x/div2 + stream / 3.) * _uv.y/div - stream/1.19));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(.5*tan(t*PI), .5*sin(t/PI));\n    p /= sin(stream/1.+PI * sin(uv.x/x)*cos(stream+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1834.822, 0.01, 2000, false, false],
        ["ballSize", 0, 0.036, 0, 0.1, false, false],
        ["contrast", 0, 4, 0, 5, false, false],
        ["radius", 0, 140.06, 0, 200, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50.41, 0, 1100, false, false],
        ["y", 0, 85.83, 0, 1100, false, false],
        ["rotation", 0, 0, 0, 4, false, false],
        ["colorOffset", 0, 915.9, 0, 1110, false, false],
        ["sides", 0, 2, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 3785.106, 0, 11200, false, false],
        ["div2", 0, 580.357, 0, 2000, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9feb"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / -6.;\n  mat2 rotation = k_rotate2d(stream/(PI*2.));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.720) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.0015747364457831328, 0, 0.1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 3.5794004141566274, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.7545274849397591, 0, 2, false, false],
        ["colorOffset", 0, 37.88460090361446, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.2960278614457832, 0, 2, false, false],
        ["div", 0, 0.03972143260542169, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6151637801204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 7.6585843373493985, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.07135316265060243, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe8"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.5)/shape * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0015747364457831328, 0, 0.1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 1.0034073795180722, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 13.64527014307229, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.7545274849397591, 0, 2, false, false],
        ["colorOffset", 0, 37.88460090361446, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.2960278614457832, 0, 2, false, false],
        ["div", 0, 0.03972143260542169, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false],
        ["shape", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6151637801204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 7.6585843373493985, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.07135316265060243, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false],
        ["shape", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6268825301204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 8.869992469879518, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.5174934111445784, 0, 3, false, false],
        ["orbSize", 0, 0.732445406626506, 0, 2, false, false],
        ["div", 0, 0.20228308546686752, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false],
        ["shape", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff5"
    },
    "shader": "#define BALLS 10.\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 0.84, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["ballSize", 0, 0.13, 0, 0.26, false, false],
        ["radius", 0, 22.12, 0, 44.24, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca014"
    },
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 2.;\nconst float shell = .43;\nconst float carve = .3;\nconst float falloff = 2.8;\nconst float blend = .2;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 10.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 4.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -=  .025 + .205 * (.01*cos(.5 + .1 * sin(i * PI + i / PI)));\n        d = smin(d, abs(mul*sin(dot(p, p)/20.*.0000000215*dot(cos(stream + p),cos(stream - p.yzx)- stream))*scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += abs(.1 - .25 * cos(p.z/zid+stream*warpSpeed)) * cos(1./length(p)/.92+stream*warpSpeed);\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n    // coordinates\n    vec2 uv = (gl_FragCoord.xy - resolution.xy / 2.)/resolution.y * zoom;\n    float dither = hash12(gl_FragCoord.xy);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 10.;\n    const float count = 12.;\n    for (float index = count; index > 0.; --index)\n    {\n        pos += ray*map(pos/3.);\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-stream);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.467, 0, 2, false, false],
        ["warpSpeed", 0, 0.041, 0, 1, false, false],
        ["mul", 0, 97.97, 0, 2211, false, false],
        ["zid", 0, 1177.219, 0, 12121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca023"
    },
    "shader": "mat2 r2d(in float degree) {\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p) {\n  p = vec2(dot(p, vec2(1227.1, 311.7)),\n    dot(p, vec2(269.5, 183.3)));\n\n  return -1. + 120. * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(1.));\n}\n\nfloat fbm(in vec2 p) {\n  mat2 rot = r2d(0.);\n  float d = noise(p);\n  p *= rot;\n  d += .625 * noise(p);\n\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale) {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  return uv;\n}\n\nvoid main() {\n  vec2 uv = mapToScreen(gl_FragCoord.xy / resolution.xy, zoom);\n  uv = uv * sin(1.14 * (dot(uv, uv)) - stream / 5.) + cos(sin(stream * .1) * (dot(uv, uv) * 2.) - stream * .391);;\n  float thicc = thickness * length(abs(uv)) / length(size * cos(uv + stream));\n  float d1 = abs(sin(stream + uv.x * (sin(stream / 8.)) * haze) * thicc * (cos(uv.x + stream) + fbm(uv + stream) * .023));\n  float d2 = abs(log(stream - yMul * uv.y * -haze) * thicc * (sin(xMul * uv.y - stream / 17.) * fbm(uv + stream * .987)));\n  float d3 = abs(.1 * cos(stream / 6. + (xMul * uv.x) - (yMul * uv.y)) * thicc / (1. - uv.x + log(uv.y) + fbm(uv - 1. * stream / 4.)));\n  vec3 col = vec3(.0) * haze;\n  col += d1 * size * abs(sin(col1 - stream / 5.));\n  col *= d2 * size * abs(cos(col2 - stream / 13.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.54, 0, 1.08, false, false],
        ["thickness", 0, 0.4587, 0, 0.9174, false, false],
        ["haze", 0, 39.37, 0, 78.74, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 2.46, 0, 4.92, false, false],
        ["yMul", 0, 5.2, 0, 10.4, false, false],
        ["xMul", 0, 200, 0, 400, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca027"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.52, 0, 2, false, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02e"
    },
    "shader": "#define BALLS 10.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/-8. - length(uv/warp) + (.25 + .25 * (.0015*dot(cos(length(uv) - stream/1.)/log(stream), -.5101*(stream)))));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/11.*sin(uv.y/yDivider - stream/10.) - sin(uv.x/xDiv - stream/21.);\n    uv.x += yOuter*float(i)/11.95*cos(uv.y/xDivider - stream/11.) - (.5 + .5 *cos(stream/2. - uv.x/xDiv2));\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec3 color = k_rainbow(i / BALLS, 1., 1.);\n    gl_FragColor += length(.5/uv) * k_orb(uv, volume*ballSize, vec2(t), color, contrast);\n    // gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.260)) / length(uv  * 0.9) * k_orb * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.77, 0, 35, false, false],
        ["yDivider", 0, 2.69, 0.1, 5, false, false],
        ["xDivider", 0, 2.21, 0.1, 5, false, false],
        ["multiplier", 0, 60.33, 0.01, 512, false, false],
        ["ballSize", 0, 0.201, 0, 1, false, false],
        ["contrast", 0, 0.92, 0, 5, false, false],
        ["radius", 0, 390.57, 0, 3412, false, false],
        ["xOuter", 0, 11, 0, 11, false, false],
        ["yOuter", 0, 1.14, 0, 2, false, false],
        ["xDiv", 0, 1.327, 0, 36, false, false],
        ["xDiv2", 0, 4.538, 0, 43, false, false],
        ["warp", 0, 1.751, 0, 329, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca058"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/-9.);\n  float dist = length(uv);\n  for (float i = 0.; i < 15.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(i) + stream;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(uv.x/xDiv * sin(uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/yDiv2+stream/PI)+vec3(-2, 0, -1) * PI * 2. / 31. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 44, 0, 44, false, false],
        ["ballSize", 0, 3.888313376185406, 1, 8, false, false],
        ["contrast", 0, 15, 0, 15, false, false],
        ["radius", 0, 463.90730998946964, 222, 650, false, false],
        ["yOuter", 0, 2.6622053399143453, 0, 4, false, false],
        ["xOuter", 0, 119.49976394837165, 1, 241, false, false],
        ["xMultiplier", 0, 9.87278689648732, 0, 11, false, false],
        ["yMultiplier", 0, 2.2934277049604668, 0.2, 5, false, false],
        ["divider", 0, 1.8808178269719504, 0, 2, false, false],
        ["rotation", 0, 0.3062661228409733, 0, 3, false, false],
        ["yDiv", 0, 5.945459572665664, 0, 10, false, false],
        ["yDiv2", 0, 0.8229053796055806, 0, 3, false, false],
        ["xDiv", 0, 6, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a51"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04f"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv - cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 8.24, 0, 16.48, false, false],
        ["contrast", 0, 0.82, 0, 1.64, false, false],
        ["orbSize", 0, 0.3, 0, 0.6, false, false],
        ["radius", 0, 12.89, 0, 25.78, false, false],
        ["colorShift", 0, 10.54, 0, 21.08, false, false],
        ["div", 0, 40, 0, 80, false, false],
        ["div2", 0, 40, 0, 80, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09e"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 20.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 66.15, 0, 132.3, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 345.32, 0, 690.64, false, false],
        ["multiplier", 0, 5.87, 0, 11.74, false, false],
        ["ballSize", 0, 0.29, 0, 0.58, false, false],
        ["contrast", 0, 2.07, 0, 4.14, false, false],
        ["radius", 0, 7.65, 0, 15.3, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0bf"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius*tan(t), radius*sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.26, 0, 2, false, false],
        ["contrast", 0, 6.4, 0, 18, false, false],
        ["ballSize", 0, 0.03, 0, 0.1, false, false],
        ["radius", 0, 1.54, 1, 5, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0.98, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d6"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 64.73, 0, 151, false, false],
        ["contrast", 0, 1.42, 0, 2, false, false],
        ["orbSize", 0, 1.05, 0.01, 2, false, false],
        ["radius", 0, 11.83, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 17.328, 10, 40, false, false],
        ["div2", 0, 14.483, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d8"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 67.31, 0, 134.62, false, false],
        ["contrast", 0, 1.49, 0, 2.98, false, false],
        ["orbSize", 0, 1.05, 0, 2.1, false, false],
        ["radius", 0, 3.77, 0, 7.54, false, false],
        ["colorShift", 0, 23.99, 0, 47.98, false, false],
        ["div", 0, 17.974, 0, 35.948, false, false],
        ["div2", 0, 27.909, 0, 55.818, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0db"
    },
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6.67, 0, 22, false, false],
        ["yDivider", 0, 0.69, 0.1, 122, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 5.86, 0.01, 11, false, false],
        ["ballSize", 0, 0.39, 0, 1, false, false],
        ["contrast", 0, 0.87, 0, 5, false, false],
        ["radius", 0, 1.14, 0, 11, false, false],
        ["rotation", 0, 0.22587259377776392, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0.18, 0, 1, false, false],
        ["c", 0, 1.61, 0, 8, false, false],
        ["d", 0, 3.05, 1, 13, false, false],
        ["e", 0, 0.34, 0, 2, false, false],
        ["f", 0, 0.95, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0fc"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 15.688, 0, 113, false, false],
        ["iterator", 0, 1.043, 0, 3, false, false],
        ["ot", 0, 44.606, 0, 151, false, false],
        ["I", 0, 2.374, 0, 3, false, false],
        ["J", 0, 0.918, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 38, 0, 122, false, false],
        ["L", 0, 13, 0, 13, false, false],
        ["M", 0, 6.292, 0, 11, false, false],
        ["colorShift", 0, 0.768, 0, 2, false, false],
        ["colorOffset", 0, 21.783, 0, 111, false, false],
        ["contrast", 0, 1.612, 1, 3, false, false],
        ["orbSize", 0, 1, 0, 1, false, false],
        ["div", 0, 4.452, 0.01, 112, false, false],
        ["radius", 0, 0.727, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0fd"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  uv *= 2. * sin( length(uv) * .000091 * dot(uv, uv) + stream / 16. );\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 41.603, 0, 212, false, false],
        ["iterator", 0, 0.873, 0, 2, false, false],
        ["ot", 0, 79.283, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 3, 0, 3, false, false],
        ["K", 0, 111, 0, 111, false, false],
        ["iterations", 0, 16.982, 0, 33, false, false],
        ["L", 0, 0.906, 0, 31, false, false],
        ["M", 0, 2.962, 0, 11, false, false],
        ["colorShift", 0, 0.685, 0, 2, false, false],
        ["colorOffset", 0, 42.639, 0, 111, false, false],
        ["contrast", 0, 2.499, 1, 3, false, false],
        ["orbSize", 0, 3.026, 0, 13, false, false],
        ["div", 0, 3.848, 1, 12, false, false],
        ["radius", 0, 26.428, 1, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca110"
    },
    "shader": "\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nmat2 rotate2d(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\tuv = kale(uv, vec2(center), 12.);\n  uv *= rotate2d(stream/1.);//+ max((5.2*pow(volume, .2)), .001));\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.91, 0.05, 1, false, false],
        ["xMultiplier", 0, 20, 20, 150, false, false],
        ["yMultiplier", 0, 80.77, 20, 150, false, false],
        ["ballSize", 0, 6.38, 3, 12, false, false],
        ["colorSpread", 0, 7, 0.2, 7, false, false],
        ["colorMultiplier", 0, 98.61, 80, 150, false, false],
        ["shapeMultiplier", 0, 13.02, 2, 50, false, false],
        ["glow", 0, 597.16, 0, 10000, false, false],
        ["contrast", 0, 3.75, 3, 5, false, false],
        ["brightness", 0, 14.91, 2, 51, false, false],
        ["center", 0, 0.2, 0, 0.2, false, false],
        ["granularity", 0, 51.47, 5, 122, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6e"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .7);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.48;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t), radius *\ncos(t + yMultiplier + -1. + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 1. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.6)/8.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2162.18, 0, 2162.18, false, false],
        ["ballSize", 0, 823.2115042224565, 0, 12120.2, false, false],
        ["contrast", 0, 1.5036299622317397, 0, 8.94, false, false],
        ["radius", 0, 7099.501722680518, 0, 23223, false, false],
        ["yOuter", 0, 23.179561450268853, 0, 25.42, false, false],
        ["xOuter", 0, 30.54, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.1705011261755147, 0, 7.36, false, false],
        ["yMultiplier", 0, 10.696722047001483, 0, 19.24, false, false],
        ["divider", 0, 8, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7d"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom + (zoom * .5 * sin(stream / 15.));\n  uv *= k_rotate2d(stream/10.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / -1.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 2.) - sin(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 68.065, 0, 200, false, false],
        ["xDiv", 0, 13.853, 0, 200, false, false],
        ["yDiv", 0, 2.857, 0, 20, false, false],
        ["xDiv2", 0, 2.597, 0, 40, false, false],
        ["yDiv2", 0, 2.424, 0, 40, false, false],
        ["xDiv3", 0, 27.706, 0, 400, false, false],
        ["yDiv3", 0, 17.13, 1, 70, false, false],
        ["multiplier", 0, 1.779, 0, 3, false, false],
        ["ballSize", 0, 1.818, 0, 10, false, false],
        ["contrast", 0, 1.61, 0, 3, false, false],
        ["radius", 0, 1.271, 0, 5, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 24.589, 0, 80, false, false],
        ["yMul", 0, 4.329, 0, 200, false, false],
        ["oY", 0, 80, 0, 80, false, false],
        ["oX", 0, 32.035, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8b"
    },
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.135, 0, 21, false, false],
        ["iterator", 0, 1.071, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 18.705, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f93"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.831, 0, 20, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 0.685, 0, 0.76, false, false],
        ["radius", 0, 2.435, 0, 3.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f97"
    },
    "shader": "#define orbs 35.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.94, 0, 11.88, false, false],
        ["contrast", 0, 2.34, 0, 4.68, false, false],
        ["orbSize", 0, 0.17, 0, 0.34, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb6"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(stream/20.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 115, false, false],
        ["contrast", 0, 1.37, 1, 5, false, false],
        ["orbSize", 0, 1.39, 0.01, 2, false, false],
        ["radius", 0, 4.02, 1, 15, false, false],
        ["colorShift", 0, 5.37, 4, 10, false, false],
        ["x1", 0, 0.57, 0, 1, false, false],
        ["x2", 0, 0.3, 0, 1, false, false],
        ["y1", 0, 0.63, 0, 1, false, false],
        ["y2", 0, 0.53, 0, 5, false, false],
        ["center", 0, 6.97, 0, 11, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd9"
    },
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 0.4) * _uv.y/div - stream/-.25));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*sin(t + stream), radius*cos(t - stream));\n    p /= (cos(wad * cos(stream/-.2 - uv.x/x))+sin(stream/-.635- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 175436.315, 0.01, 2111000, false, false],
        ["ballSize", 0, 5124.44, 0, 6122, false, false],
        ["contrast", 0, 2.8, 0, 5, false, false],
        ["radius", 0, 6991118.11, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 25909282.53, 0, 818888881, false, false],
        ["y", 0, 8873738.81, 0, 19133112, false, false],
        ["rotation", 0, 0.0029, 0, 0.01, false, false],
        ["colorOffset", 0, 1412.22, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 5736.673, 1000, 100000, false, false],
        ["div2", 0, 556866.94, 0, 1313311, false, false],
        ["wad", 0, 14.718, 1, 180, false, false],
        ["woot", 0, 0.153, 0, 2, false, false],
        ["wat", 0, 1.428, 0, 5, false, false],
        ["wob", 0, 34.031, 0, 160, false, false],
        ["outer", 0, 120.684, 0, 133, false, false],
        ["outer2", 0, 46.748, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 15914.588, 0.01, 211100, false, false],
        ["ballSize", 0, 99.53, 0, 16122, false, false],
        ["contrast", 0, 2.7, 0, 5, false, false],
        ["radius", 0, 1400070.68, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 122414.56, 0, 3818881, false, false],
        ["y", 0, 79591.9, 0, 193311, false, false],
        ["rotation", 0, 0.00386, 0, 0.01, false, false],
        ["colorOffset", 0, 1971.97, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 7434.224, 20, 50000, false, false],
        ["div2", 0, 121617.307, 0, 1313311, false, false],
        ["wad", 0, 2.126, 1, 180, false, false],
        ["woot", 0, 0.596, 0, 2, false, false],
        ["wat", 0, 1.423, 0, 5, false, false],
        ["wob", 0, 14.902, 0, 160, false, false],
        ["outer", 0, 152.317, 0, 3133, false, false],
        ["outer2", 0, 56.629, 0, 132, false, false],
        ["wave", 0, 1.816, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff1"
    },
    "shader": "\n#define BALLS 10.\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 2, false, false],
        ["contrast", 0, 1.37, 0, 3, false, false],
        ["ballSize", 0, 0.13, 0, 0.2, false, false],
        ["radius", 0, 22.12, 1, 51, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ffa"
    },
    "shader": "void main() { \n  float stream = stream / 30.;\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv + sin(uv * cos(uv/4.) - stream)); \n  float rot = rotation * dist;\n  uv *= k_rotate2d(stream / 01. - rot); \n  float a = cos(yOuter * uv.y);\n  vec2 p = vec2(xOuter * uv.x, 0.)* a ;\n  vec3 col = k_rainbow(uv.x, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  gl_FragColor.xyz = 1.-pow(abs(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 11.481706626506025, 0, 21.456, false, false],
        ["ballSize", 0, 2.5316243222891566, 0, 5.808, false, false],
        ["contrast", 0, 0.8430481927710848, 0, 2.5600000000000014, false, false],
        ["radius", 0, 80.945502090338, 0, 111, false, false],
        ["yOuter", 0, 2.32, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["rotation", 0, 0, 0, 0.1, false, false],
        ["wobble", 0, 0.44281228863406596, 0.1, 0.7, false, false]
      ],
      [
        ["zoom", 0, 5.1897103915662655, 0, 21.456, false, false],
        ["ballSize", 0, 2.5316243222891566, 0, 5.808, false, false],
        ["contrast", 0, 0.8430481927710848, 0, 2.5600000000000014, false, false],
        ["radius", 0, 80.945502090338, 0, 111, false, false],
        ["yOuter", 0, 2.32, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["rotation", 0, 0.05237339984939761, 0, 0.1, false, false],
        ["wobble", 0, 0.30741622740963853, 0.1, 0.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ffd"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 26.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider; // + stream/50.;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = 1.-pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 8.224, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01c"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 6;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/2.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n2); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,-n1); if (t>0.0) { z-=120.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(TTIME/2. - .001*length(p) -1.12*p.x/2.-atan(p.y/10.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(01. *sin(TTIME/2.+length(p/PI)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.))+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/2.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/2.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =11.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/1.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p)) + TTIME/2.10;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.667, 0, 2, false, false],
        ["size", 0, 5.11, 0, 122, false, false],
        ["offc", 0, 0, 0, 2, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 5.085, 0, 22, false, false],
        ["_x", 0, 0.425, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03c"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv - 10.*cos( .005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 21.18, 0, 151, false, false],
        ["contrast", 0, 0.8, 0, 2, false, false],
        ["orbSize", 0, 0.2, 0.01, 2, false, false],
        ["radius", 0, 6.65, 0, 14, false, false],
        ["colorShift", 0, 9.24, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03d"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  float div = 25.;\n  const float radius = 1000.;\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/20. - stream);\n    uv.y += cos((i+1.)*uv.x/20. + stream);\n    float t = i * PI / orbs;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/2.1);\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, 1.1, position, color, 1.2);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 30, 0, 30, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 0.65, 0.01, 2, false, false],
        ["colorShift", 0, 13.76, 3, 15, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca060"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 2.1 * uv) - stream);\n  //  uv /= sin(.01*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.45, 0, 6.9, false, false],
        ["contrast", 0, 1.71, 0, 3.42, false, false],
        ["orbSize", 0, 0.19, 0, 0.38, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.35, 0, 10.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca065"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= .5 * sin(.005 * dot(uv, uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 2.;\n    float x = radius * tan(dist * t + stream) * sin(dist);\n    float y = radius * cos(dist * t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15, 0, 30, false, false],
        ["contrast", 0, 1.01, 0, 2.02, false, false],
        ["orbSize", 0, 0.2, 0, 0.4, false, false],
        ["radius", 0, 3.9, 0, 7.8, false, false],
        ["colorShift", 0, 7.56, 0, 15.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca076"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 55.74, false, false],
        ["contrast", 0, 0.89, 0, 1.78, false, false],
        ["orbSize", 0, 0.66, 0, 1.32, false, false],
        ["radius", 0, 12.33, 0, 24.66, false, false],
        ["colorShift", 0, 9.55, 0, 19.1, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.7, 0, 1.4, false, false],
        ["cosMul", 0, 0.98, 0, 1.96, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.57, 0, 1.14, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0048, 0, 0.0096, false, false],
        ["yDivide", 0, 4.98, 0, 9.96, false, false],
        ["xDivide", 0, 19, 0, 38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca078"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/2.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 21.06, 0, 42.12, false, false],
        ["yDivider", 0, 818.46, 0, 1636.92, false, false],
        ["xDivider", 0, 656.67, 0, 1313.34, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 2.03, 0, 4.06, false, false],
        ["radius", 0, 26.22, 0, 52.44, false, false],
        ["yOuter", 0, 0.12, 0, 0.24, false, false],
        ["xOuter", 0, 0.29, 0, 0.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07e"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 4.94, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 0.14, 0, 1, false, false],
        ["contrast", 0, 2.49, 0, 5, false, false],
        ["radius", 0, 0.75, 0, 111, false, false],
        ["yOuter", 0, 0.1, 0, 1, false, false],
        ["xOuter", 0, 0.21, 0, 1, false, false],
        ["rotation", 0, 2.52, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 43.23, 0, 150, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1, 0, 1, false, false],
        ["contrast", 0, 2.56, 0, 5, false, false],
        ["radius", 0, 8.11, 0, 111, false, false],
        ["yOuter", 0, 0.32, 0, 1, false, false],
        ["xOuter", 0, 0.04, 0, 1, false, false],
        ["rotation", 0, 3.28, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca085"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca087"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/14.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 73.49, 0, 151, false, false],
        ["contrast", 0, 0.99, 0, 2, false, false],
        ["orbSize", 0, 0.98, 0.01, 1, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 11.72, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 16.002, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca088"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 1.7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 24.95, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.32, 0.01, 2, false, false],
        ["radius", 0, 4.75, 0, 14, false, false],
        ["colorShift", 0, 12.71, 3, 33, false, false],
        ["div", 0, 10, 1, 10, false, false],
        ["div2", 0, 10, 1, 10, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca096"
    },
    "shader": "\n#define orbs 40.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n \n\n\n\nvec4 k_orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n\n\n\nvec2 k_swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  if (vT) {\n    return mix(v ? uv : uv2, v ? uv2 : uv, vTP);\n  }\n  return v ? uv2 : uv;\n}\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv))/ dist + (tatumStream + beatStream)  / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < orbs; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor +=   barVolume * vec4(pow(tatumVolume ,1.5)  * orbsize / length(uv + p *(spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor= vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.01, false, false],
        ["shapeMultiplier", 0, 1583.68, 0, 2222, false, false],
        ["spreadMultiplier", 0, 1.913, 0.4, 3, false, false],
        ["rotation", 0, 50, -200, 200, false, false],
        ["xMultiplier", 0, 369.731, 0, 4441, false, false],
        ["yMultiplier", 0, 403.636, 0, 4443, false, false],
        ["colorSpread", 0, 0.00007, 0, 0.000104, false, false],
        ["invert", 1, false, null, null, null, false],
        ["orbsize", 0, 35.636, 0, 100, false, false],
        ["contrast", 0, 1.258, 0, 4, false, false],
        ["radius", 0, 9.636, 0, 10, false, false],
        ["sides", 0, 7, 0, 24, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["aSpeed", 0, -10, -10, 10, false, false],
        ["bSpeed", 0, 8.3, -10, 10, false, false],
        ["sinMul", 0, -0.109, -0.5, 0.5, false, false],
        ["cosMul", 0, 0.055, -0.5, 0.5, false, false],
        ["rippleSpeed", 0, -20, -20, 20, false, false],
        ["wobbleSpeed", 0, 4.145, -20, 20, false, false],
        ["swirl", 0, -0.5, -0.5, 0.5, false, false],
        ["energy", 0, 1.1, -2.2, 4.4, false, false],
        ["punch", 0, 1, -2, 4, false, false],
        ["borderSpeed", 0, 616.364, 0, 3000, false, false],
        ["hueShift", 0, -31.964, -120, 60, false, false],
        ["colorMultiplier", 0, 0.0034, 0, 0.005, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a2"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 2) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i / 1) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 61.35, 0, 122.7, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 345.32, 0, 690.64, false, false],
        ["multiplier", 0, 5.87, 0, 11.74, false, false],
        ["ballSize", 0, 0.2, 0, 0.4, false, false],
        ["contrast", 0, 1.86, 0, 3.72, false, false],
        ["radius", 0, 9.94, 0, 19.88, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b9"
    },
    "shader": "#define BALLS 20.\n  \nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 1.58, false, false],
        ["contrast", 0, 3.03, 0, 6.06, false, false],
        ["ballSize", 0, 0.016, 0, 0.032, false, false],
        ["radius", 0, 45.33, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 3.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ca"
    },
    "shader": "#define BALLS 5\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= primaryZoom;\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *= rotate2d(stream/-12. + length(cos(uv))/-1.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/.5);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/550. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 2.0) * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 125.89, 0, 301, false, false],
        ["rotation", 0, 0.67548, 0.009, 3, false, false],
        ["xMultiplier", 0, 51.4, 0, 1000, false, false],
        ["yMultiplier", 0, 164.79, 0, 1000, false, false],
        ["colorSpread", 0, 0.000081, 0, 0.001, false, false],
        ["colorMultiplier", 0, 2, 0, 2, false, false],
        ["brightness", 0, 3.34, 0, 10, false, false],
        ["ballSize", 0, 16.18, 0, 33, false, false],
        ["glow", 0, 1.44, 0, 4, false, false],
        ["contrast", 0, 1.5, 0, 5, false, false],
        ["radius", 0, 10.23, 0, 120, false, false],
        ["invert", 1, false, null, null, null, false],
        ["primaryZoom", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.031, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 114.61, 0, 301, false, false],
        ["rotation", 0, 0.67548, 0.009, 3, false, false],
        ["xMultiplier", 0, 799.82, 0, 1000, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.000081, 0, 0.001, false, false],
        ["colorMultiplier", 0, 0.88, 0, 2, false, false],
        ["brightness", 0, 3.34, 0, 10, false, false],
        ["ballSize", 0, 9.02, 0, 33, false, false],
        ["glow", 0, 1.44, 0, 4, false, false],
        ["contrast", 0, 1.5, 0, 5, false, false],
        ["radius", 0, 10.23, 0, 120, false, false],
        ["invert", 1, false, null, null, null, false],
        ["primaryZoom", 0, 0.39, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.028, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 590.39, 0, 1301, false, false],
        ["rotation", 0, 2.31062, 0.009, 3, false, false],
        ["xMultiplier", 0, 0, 0, 1000, false, false],
        ["yMultiplier", 0, 321.66, 0, 1000, false, false],
        ["colorSpread", 0, 0.000043, 0, 0.001, false, false],
        ["colorMultiplier", 0, 2, 0, 2, false, false],
        ["brightness", 0, 1.77, 0, 10, false, false],
        ["ballSize", 0, 23.87, 0, 33, false, false],
        ["glow", 0, 1.44, 0, 4, false, false],
        ["contrast", 0, 2.43, 0, 5, false, false],
        ["radius", 0, 0.5, 0, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["primaryZoom", 0, 0.46, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0da"
    },
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n \nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6.67, 0, 22, false, false],
        ["yDivider", 0, 0.69, 0.1, 122, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 5.86, 0.01, 11, false, false],
        ["ballSize", 0, 0.39, 0, 1, false, false],
        ["contrast", 0, 0.87, 0, 5, false, false],
        ["radius", 0, 1.14, 0, 11, false, false],
        ["rotation", 0, 0.22587259377776392, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0.18, 0, 1, false, false],
        ["c", 0, 1.61, 0, 8, false, false],
        ["d", 0, 3.05, 1, 13, false, false],
        ["e", 0, 0.34, 0, 2, false, false],
        ["f", 0, 0.95, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ee"
    },
    "shader": "\n#define BALLS 10.\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *= rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.896, 0, 115, false, false],
        ["contrast", 0, 1.51, 0, 5, false, false],
        ["ballSize", 0, 0.1211, 0, 1, false, false],
        ["radius", 0, 2.2, 0, 110, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 1, 5, false, false],
        ["tanMul", 0, 4.35, 0, 10, false, false],
        ["sinMul", 0, 2.8, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca105"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/121.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    ot = M * dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .7175) * orbSize, vec2(radius*abs(tan(stream/1.3+uv.x/div)) * L * sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(-1. + 2. * gl_FragCoord.xy / resolution.xy));\n}",
    "variants": [
      [
        ["zoom", 0, 0.066, 0, 1, false, false],
        ["iterator", 0, 1.614, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.139, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 20, 0, 33, false, false],
        ["L", 0, 1.457, 1, 2, false, false],
        ["M", 0, 0.358, 0, 1, false, false],
        ["colorShift", 0, 1.645, 0, 2, false, false],
        ["colorOffset", 0, 44.956, 0, 111, false, false],
        ["contrast", 0, 0.965, 0, 3, false, false],
        ["orbSize", 0, 0.413, 0, 2, false, false],
        ["div", 0, 1.487, 0.01, 12, false, false],
        ["radius", 0, 7.992, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca109"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  uv *= k_rotate2d(stream/-2.);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * gl_FragCoord.xy / resolution.xy)/2.)+ stream/3.);\n  float ot = ot;\n  uv = k_kale(uv, vec2(0.), 3.);\n  uv *= k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 7763.719, 0, 33222, false, false],
        ["iterator", 0, 0.259, 0, 2, false, false],
        ["ot", 0, 99.903, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.987, 0, 3, false, false],
        ["K", 0, 58.378, 0, 111, false, false],
        ["iterations", 0, 10.467, 0, 33, false, false],
        ["L", 0, 187.608, 0, 213, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 1.01, 0, 2, false, false],
        ["colorOffset", 0, 35.208, 0, 111, false, false],
        ["contrast", 0, 0.996, 0, 1, false, false],
        ["orbSize", 0, 0.53, 0, 2, false, false],
        ["div", 0, 0.564, 0.1, 2, false, false],
        ["radius", 0, 0.196, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6a"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .5);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.7;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.6)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 208050.8613461032, 0, 321622.18, false, false],
        ["ballSize", 0, 46674.3601778991, 0, 112120.2, false, false],
        ["contrast", 0, 0.7017193147590363, 0, 8.94, false, false],
        ["radius", 0, 333232, 0, 333232, false, false],
        ["yOuter", 0, 684.2579981174699, 0, 2225.42, false, false],
        ["xOuter", 0, 27.236858339608442, 0, 302.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.7860331325301209, 0, 7.36, false, false],
        ["yMultiplier", 0, 19.24, 0, 19.24, false, false],
        ["divider", 0, 4.888253012048193, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f71"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  //uv /= dot(uv, uv);\n // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter*(atan(uv.x+stream))*uv.x+radius*tan(t+xMultiplier+stream), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["ballSize", 0, 0.047, 0, 0.094, false, false],
        ["contrast", 0, 4.47, 0, 8.94, false, false],
        ["radius", 0, 0.33, 0, 0.66, false, false],
        ["yOuter", 0, 12.71, 0, 25.42, false, false],
        ["xOuter", 0, 15.27, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.68, 0, 7.36, false, false],
        ["yMultiplier", 0, 9.62, 0, 19.24, false, false],
        ["divider", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f74"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .7) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 64.629, 0, 500, false, false],
        ["xDiv", 0, 196.985, 0, 200, false, false],
        ["yDiv", 0, 1.915, 0, 20, false, false],
        ["xDiv2", 0, 2.349, 0, 20, false, false],
        ["yDiv2", 0, 92.714, 0, 100, false, false],
        ["xDiv3", 0, 89.609, 0, 100, false, false],
        ["yDiv3", 0, 1.918, 1, 20, false, false],
        ["multiplier", 0, 0.88, 0, 10, false, false],
        ["ballSize", 0, 3.665, 0, 20, false, false],
        ["contrast", 0, 2.575, 0, 3, false, false],
        ["radius", 0, 2.781, 0, 20, false, false],
        ["rotation", 0, 0.000032, 0, 0.001, false, false],
        ["xMul", 0, 1.153, 0, 20, false, false],
        ["yMul", 0, 7.296, 0, 20, false, false],
        ["oY", 0, 14.593, 0, 44, false, false],
        ["oX", 0, 3.208, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa4"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 22.345463102409646, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 2.404405120481928, 0, 3, false, false],
        ["x2", 0, 0.8480045180722893, 0, 1, false, false],
        ["y1", 0, 0.41, 0, 1, false, false],
        ["y2", 0, 1.06, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 6.943693524096386, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.35281795933734944, 0.01, 2, false, false],
        ["radius", 0, 1.463413027108434, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0, 0, 1, false, false],
        ["x2", 0, 0.07756023333999278, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 3.9954113328313263, 0, 5, false, false],
        ["center", 0, 9.759704442771085, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.516971009036148, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.6914401355421687, 0.01, 2, false, false],
        ["radius", 0, 1.0743787650602412, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0.006485316265060244, 0, 1, false, false],
        ["x2", 0, 0.39095914909638557, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 0.29673381024096396, 0, 5, false, false],
        ["center", 0, 2.7102409638554223, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fae"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.79, 0, 31.58, false, false],
        ["contrast", 0, 1.38, 0, 2.76, false, false],
        ["orbSize", 0, 2, 0, 4, false, false],
        ["radius", 0, 8.15, 0, 16.3, false, false],
        ["colorShift", 0, 4, 0, 8, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.45, 0, 0.9, false, false],
        ["cosMul", 0, 0.98, 0, 1.96, false, false],
        ["yMul", 0, 0.5, 0, 1, false, false],
        ["xMul", 0, 0.57, 0, 1.14, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0048, 0, 0.0096, false, false],
        ["yDivide", 0, 1.13, 0, 2.26, false, false],
        ["xDivide", 0, 19, 0, 38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fbd"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.78, 0, 3.56, false, false],
        ["ballSize", 0, 0.811, 0, 1.622, false, false],
        ["contrast", 0, 6.18, 0, 12.36, false, false],
        ["radius", 0, 0.37, 0, 0.74, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 55.27, 0, 110.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.14, 0, 8.28, false, false],
        ["yMultiplier", 0, 5.19, 0, 10.38, false, false],
        ["divider", 0, 4, 0, 8, false, false],
        ["rotation", 0, 0.0576, 0, 0.1152, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a41"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd6"
    },
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.101);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/.5295 - t*PI), radius*tan(t - stream/.4));\n    p /= (cos(wad * cos(stream/-.83 - uv.x/x))*sin(stream/-.35- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 565165.39186, 0.01, 2111000, false],
        ["ballSize", 0, 4482.02508, 0, 6122, false],
        ["contrast", 0, 2.1075, 0, 5, false],
        ["radius", 0, 21662190.72162, 0, 31115555, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 453727305.7104, 0, 818888881, false],
        ["y", 0, 3069728.03718, 0, 19133112, false],
        ["rotation", 0, 0, 0, 0.01, false],
        ["colorOffset", 0, 1485.37, 0, 2110, false, false],
        ["sides", 0, 2.09639, 0, 12, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 17284.96846, 1000, 100000, false],
        ["div2", 0, 688250.07416, 0, 1313311, false],
        ["wad", 0, 27.299, 1, 180, false, false],
        ["woot", 0, 0.18, 0, 2, false, false],
        ["wat", 0, 0.174, 0, 1, false, false],
        ["wob", 0, 43.234, 0, 160, false, false],
        ["outer", 0, 76.693, 0, 133, false, false],
        ["outer2", 0, 17.019, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 530156.163, 0.01, 2111000, false, false],
        ["ballSize", 0, 247.533, 0, 1122, false, false],
        ["contrast", 0, 3.21, 0, 5, false, false],
        ["radius", 0, 4177483.47, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 13745054.8, 0, 71121201, false, false],
        ["y", 0, 1553415.58, 0, 9133112, false, false],
        ["rotation", 0, 0.00319, 0, 0.01, false, false],
        ["colorOffset", 0, 2099.71, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 32307.371, 1000, 100000, false, false],
        ["div2", 0, 408995.916, 0, 1313311, false, false],
        ["wad", 0, 34.823, 1, 180, false, false],
        ["woot", 0, 0.556, 0, 2, false, false],
        ["wat", 0, 0.121, 0, 1, false, false],
        ["wob", 0, 48.389, 0, 160, false, false],
        ["outer", 0, 13.813, 0, 22, false, false],
        ["outer2", 0, 1.099, 0, 2, false, false],
        ["wave", 0, 1, 0, 2, false, false],
        ["aWave", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 265211.762, 0.01, 2111000, false, false],
        ["ballSize", 0, 222.169, 0, 1122, false, false],
        ["contrast", 0, 3.39, 0, 5, false, false],
        ["radius", 0, 1787836.23, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 10007048.42, 0, 71121201, false, false],
        ["y", 0, 2998103.64, 0, 9133112, false, false],
        ["rotation", 0, 0.00323, 0, 0.01, false, false],
        ["colorOffset", 0, 2789.01, 0, 12110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 34777.356, 1000, 100000, false, false],
        ["div2", 0, 276101.35, 0, 1313311, false, false],
        ["wad", 0, 25.891, 1, 180, false, false],
        ["woot", 0, 0.773, 0, 2, false, false],
        ["wat", 0, 0.176, 0, 1, false, false],
        ["wob", 0, 48.531, 0, 160, false, false],
        ["outer", 0, 20.254, 0, 22, false, false],
        ["outer2", 0, 1.007, 0, 2, false, false],
        ["wave", 0, 1, 0, 2, false, false],
        ["aWave", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fdf"
    },
    "shader": "#define orbs 20.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.101);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/.5295 - t*PI), radius*tan(t - stream/.4));\n    p /= (cos(wad * cos(stream/-.83 - uv.x/x))*sin(stream/-.35- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 189685.229, 0.01, 2111000, false, false],
        ["ballSize", 0, 1334.245, 0, 6122, false, false],
        ["contrast", 0, 3.12, 0, 5, false, false],
        ["radius", 0, 3571727.6, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 13845195.75, 0, 818888881, false, false],
        ["y", 0, 5685594.69, 0, 19133112, false, false],
        ["rotation", 0, 0.0038, 0, 0.01, false, false],
        ["colorOffset", 0, 2110, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 12632.124, 1000, 100000, false, false],
        ["div2", 0, 116199.582, 0, 1313311, false, false],
        ["wad", 0, 8.073, 1, 180, false, false],
        ["woot", 0, 0.18, 0, 2, false, false],
        ["wat", 0, 0.174, 0, 1, false, false],
        ["wob", 0, 43.234, 0, 160, false, false],
        ["outer", 0, 76.693, 0, 133, false, false],
        ["outer2", 0, 17.019, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 530156.163, 0.01, 2111000, false, false],
        ["ballSize", 0, 247.533, 0, 1122, false, false],
        ["contrast", 0, 3.21, 0, 5, false, false],
        ["radius", 0, 4177483.47, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 13745054.8, 0, 71121201, false, false],
        ["y", 0, 1553415.58, 0, 9133112, false, false],
        ["rotation", 0, 0.00319, 0, 0.01, false, false],
        ["colorOffset", 0, 2099.71, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 32307.371, 1000, 100000, false, false],
        ["div2", 0, 408995.916, 0, 1313311, false, false],
        ["wad", 0, 34.823, 1, 180, false, false],
        ["woot", 0, 0.556, 0, 2, false, false],
        ["wat", 0, 0.121, 0, 1, false, false],
        ["wob", 0, 48.389, 0, 160, false, false],
        ["outer", 0, 13.813, 0, 22, false, false],
        ["outer2", 0, 1.099, 0, 2, false, false],
        ["wave", 0, 1, 0, 2, false, false],
        ["aWave", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 265211.762, 0.01, 2111000, false, false],
        ["ballSize", 0, 222.169, 0, 1122, false, false],
        ["contrast", 0, 3.39, 0, 5, false, false],
        ["radius", 0, 1787836.23, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 10007048.42, 0, 71121201, false, false],
        ["y", 0, 2998103.64, 0, 9133112, false, false],
        ["rotation", 0, 0.00323, 0, 0.01, false, false],
        ["colorOffset", 0, 2789.01, 0, 12110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 34777.356, 1000, 100000, false, false],
        ["div2", 0, 276101.35, 0, 1313311, false, false],
        ["wad", 0, 25.891, 1, 180, false, false],
        ["woot", 0, 0.773, 0, 2, false, false],
        ["wat", 0, 0.176, 0, 1, false, false],
        ["wob", 0, 48.531, 0, 160, false, false],
        ["outer", 0, 20.254, 0, 22, false, false],
        ["outer2", 0, 1.007, 0, 2, false, false],
        ["wave", 0, 1, 0, 2, false, false],
        ["aWave", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff3"
    },
    "shader": "#define BALLS 10.\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= k_rotate2d(float(i));\n    //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream / 10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15) * dist * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 0.84, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["ballSize", 0, 0.13, 0, 0.26, false, false],
        ["radius", 0, 22.12, 0, 44.24, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca017"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 12;\n\n#define PHI   PI - atan(1./PI, sqrt(PI))\n#define TAU   2. * PI\n#define TTIME (stream/15.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(PI,-PI,1.0));\nconst vec3 n2 = n1 * normalize(vec3(PI/2.,-PHI,PHI-1.0));\nconst vec3 n3 = n2 / normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=1.25*PI*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=PI*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=1.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=1.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.5/_z, .5*_x) * dot(z*vec3(size,0.,.2),plnormal);\n        \n  dmin = abs(dmin) - width*0.05*(0.105 + 0.05-sin(length(p) - p.y - TTIME/2.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 10.0;\n  float off = 0.7  + 0.525*(0.0625 + 3.5*cos(stream/20. - length(p) - length(.5*sin(stream/12.1-dot(p, p)/10. - stream/20.)-PI*sin(stream/4. + p))));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = ip;\n    rot(ip, TTIME/2.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(.33))), -.5);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 1.0)/r;\n  col *= vec3(1.0 - .009*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =100.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + .5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*tan(d - 0.050) - stream/10.04));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/1.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.059, 0, 0.2, false, false],
        ["size", 0, 0.8, 0, 12, false, false],
        ["offc", 0, 1.831, 0, 4, false, false],
        ["width", 0, 0, 0, 4, false, false],
        ["_z", 0, 0.003, 0, 0.1, false, false],
        ["_x", 0, 0.003, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca028"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["yDivider", 0, 67.32, 0.1, 333, false, false],
        ["xDivider", 0, 0.48, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.101, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 9.38, 0, 12, false, false],
        ["xOuter", 0, 2.47, 0, 11, false, false],
        ["yOuter", 0, 0.21, 0, 1, false, false],
        ["xDiv", 0, 26.512, 0, 111, false, false],
        ["xDiv2", 0, 0.321, 0, 4, false, false],
        ["warp", 0, 321, 0, 321, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca037"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.83206, 0, 1, false, false],
        ["contrast", 0, 1.3, 0, 2, false, false],
        ["orbSize", 0, 0.67, 0.01, 3, false, false],
        ["radius", 0, 0, 0, 11, false, false],
        ["colorShift", 0, 9.96, 4, 10, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 0, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 1, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 1, 0, 1, false, false],
        ["xMul", 0, 4.91, 0, 5, false, false],
        ["xSpeed", 0, 0, -1, 1, false, false],
        ["ySpeed", 0, 0, -2, 1, false, false],
        ["gloop", 0, 0.0049, 0.001, 0.01, false, false],
        ["yDivide", 0, 5.34, 0, 11, false, false],
        ["xDivide", 0, 1.73, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca036"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .00001 * dot(uv, uv) + stream/1.) * sin(.001 * dot(uv, uv)+stream/.5);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 79.62, 0, 151, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.61, 0.01, 2, false, false],
        ["radius", 0, 6.7, 0, 14, false, false],
        ["colorShift", 0, 23.39, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca043"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0003 * dot(uv, uv) - stream) * sin(.00005 * dot(uv, uv)+stream/.98378);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 67.31, 0, 151, false, false],
        ["contrast", 0, 1.49, 0, 2, false, false],
        ["orbSize", 0, 0.93, 0.01, 2, false, false],
        ["radius", 0, 3.36, 0, 14, false, false],
        ["colorShift", 0, 15.2, 3, 33, false, false],
        ["div", 0, 12.15, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca056"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  for (float i = 0.; i <3.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.))* k_rotate2d(stream/-10.);;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-43.+uv.x/xDiv * sin(stream/5.4-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(1.11*uv.y/yDiv2+stream/21.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.09) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 301.28439117799326, 0, 544, false, false],
        ["ballSize", 0, 47.95304866928653, 2, 358, false, false],
        ["contrast", 0, 7.721214432314219, 0, 15, false, false],
        ["radius", 0, 24.617146076558566, -1, 35, false, false],
        ["yOuter", 0, 2.617563367712016, 0, 4, false, false],
        ["xOuter", 0, 3.853854627494353, 1, 66, false, false],
        ["xMultiplier", 0, 0.04411929946347892, 0, 2, false, false],
        ["yMultiplier", 0, 22, 0.2, 22, false, false],
        ["divider", 0, 0.8680771425545935, 0, 2, false, false],
        ["rotation", 0, 2.0988518404673386, 0, 21, false, false],
        ["yDiv", 0, 1.882273662521179, 0, 10, false, false],
        ["yDiv2", 0, 0.8095045618264072, 0, 3, false, false],
        ["xDiv", 0, 121.48361413062824, 0, 222, false, false],
        ["xDiv2", 0, 231918.70456432668, 0, 333772, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a51"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca070"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 39.53, 0, 111, false, false],
        ["contrast", 0, 1.07, 0, 4, false, false],
        ["orbSize", 0, 1.3, 0.01, 5, false, false],
        ["radius", 0, 11.24, 1, 115, false, false],
        ["colorShift", 0, 28.21, 1, 40, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["rotation", 0, 417.56, 0, 500, false, false],
        ["sinMul", 0, 1.52, 0, 5, false, false],
        ["cosMul", 0, 0.63, 0, 3, false, false],
        ["yMul", 0, 0.13, 0, 1, false, false],
        ["xMul", 0, 0.88, 0, 5, false, false],
        ["xSpeed", 0, 0, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false],
        ["gloop", 0, 0.001, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.1, 0, 19, false, false],
        ["xDivide", 0, 19, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07f"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09a"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  uv = abs(uv);\n\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 620.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .162 * float(i) * cos(uv.y / yDivider - stream / 110.) + sin(uv.x / 10. - stream / 112.);\n    uv.x += .52 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider) - sin(uv.y / 10.);\n    float t = .005 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 50.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 415. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 49.16, 0, 98.32, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 10.18, 0, 20.36, false, false],
        ["multiplier", 0, 1, 0, 2, false, false],
        ["ballSize", 0, 6.43, 0, 12.86, false, false],
        ["contrast", 0, 2.02, 0, 4.04, false, false],
        ["radius", 0, 8.25, 0, 16.5, false, false],
        ["rotation", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ad"
    },
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.513, 0, 1, false, false],
        ["contrast", 0, 2.1, 0, 30, false, false],
        ["ballSize", 0, 0.0083, 0, 0.1, false, false],
        ["radius", 0, 105.45, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 2.24, 0, 5, false, false],
        ["tanMul", 0, 3.12, 0, 10, false, false],
        ["sinMul", 0, 1.61, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 0.478, 0, 1, false, false],
        ["contrast", 0, 6.22, 0, 30, false, false],
        ["ballSize", 0, 0.0472, 0, 0.1, false, false],
        ["radius", 0, 0.77, 0, 10, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 2.24, 0, 5, false, false],
        ["tanMul", 0, 3.12, 0, 10, false, false],
        ["sinMul", 0, 0.19, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 0.288, 0, 1, false, false],
        ["contrast", 0, 3.31, 0, 30, false, false],
        ["ballSize", 0, 0.031, 0, 0.1, false, false],
        ["radius", 0, 500, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 5, 0, 5, false, false],
        ["tanMul", 0, 6.94, 0, 10, false, false],
        ["sinMul", 0, 0, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 0.451, 0, 1, false, false],
        ["contrast", 0, 2.98, 0, 30, false, false],
        ["ballSize", 0, 0.0084, 0, 0.1, false, false],
        ["radius", 0, 126.91, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 100, false, false],
        ["dotMultiplier", 0, 5, 0, 5, false, false],
        ["tanMul", 0, 0, 0, 10, false, false],
        ["sinMul", 0, 2.6, 0, 10, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 5.36, 0, 30, false, false],
        ["ballSize", 0, 0.0409, 0, 0.1, false, false],
        ["radius", 0, 500, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 5, 0, 5, false, false],
        ["tanMul", 0, 1.36, 0, 10, false, false],
        ["sinMul", 0, 0.81, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d2"
    },
    "shader": "#define BALLS 15\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *= rotate2d(stream/-2. + length(cos(uv-stream/3.)));\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.1, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 30.11, 0, 301, false, false],
        ["rotation", 0, 0.0195, 0.009, 0.041, false, false],
        ["xMultiplier", 0, 376.89, 0, 1500, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.000114, 0, 0.001, false, false],
        ["colorMultiplier", 0, 2, 0, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 3.34, 0, 10, false, false],
        ["ballSize", 0, 17.33, 0, 100, false, false],
        ["glow", 0, 2.39, 0, 4, false, false],
        ["contrast", 0, 1.5, 0, 5, false, false],
        ["radius", 0, 10.09, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ea"
    },
    "shader": "#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv += sin(+((uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.777, 0, 9.554, false, false],
        ["contrast", 0, 2.28, 0, 4.56, false, false],
        ["ballSize", 0, 0.0329, 0, 0.0658, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["dotMultiplier", 0, 0.31, 0, 0.62, false, false],
        ["tanMul", 0, 10, 0, 20, false, false],
        ["sinMul", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f9"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 66.929, 0, 122, false, false],
        ["iterator", 0, 1.01, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 33, 0, 33, false, false],
        ["L", 0, 3, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.636, 0, 2, false, false],
        ["colorOffset", 0, 25.259, 0, 111, false, false],
        ["contrast", 0, 1.999, 1, 3, false, false],
        ["orbSize", 0, 2.746, 0, 13, false, false],
        ["div", 0, 1, 1, 12, false, false],
        ["radius", 0, 18.203, 0, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca104"
    },
    "shader": "void main () {\n float stream = stream / .8; \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.172716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}  ",
    "variants": [
      [
        ["zoom", 0, 4.203, 0, 122, false, false],
        ["iterator", 0, 1.478, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 5.27, 0, 33, false, false],
        ["L", 0, 1.935, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.497, 0, 2, false, false],
        ["colorOffset", 0, 57.701, 0, 111, false, false],
        ["contrast", 0, 1.434, 1, 3, false, false],
        ["orbSize", 0, 3.433, 0, 13, false, false],
        ["div", 0, 3.159, 1, 12, false, false],
        ["radius", 0, 16.167, 0, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca10a"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv += (uv) * iterator - 1.;\n    uv *= rotation;\n    ot = dot(uv, uv) - tan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.0569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.2970175) * orbSize, vec2(radius*(tan(stream/-2.+uv.x/div)) * sin(stream/2. - uv.y + (-1. + 2. * gl_FragCoord.xy / resolution.xy).x), radius*cos(stream/-4.+(-1. + 2. * gl_FragCoord.xy / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 22.765, 0, 113, false, false],
        ["iterator", 0, 0.303, 0, 5, false, false],
        ["ot", 0, 29.633, 0, 151, false, false],
        ["I", 0, 0.698, 0, 3, false, false],
        ["J", 0, 0.918, 0, 3, false, false],
        ["K", 0, 2.848, 0, 11, false, false],
        ["iterations", 0, 20.511, 0, 50, false, false],
        ["L", 0, 4.722, 0, 13, false, false],
        ["M", 0, 2.962, 0, 11, false, false],
        ["colorShift", 0, 16.221, 0, 30, false, false],
        ["colorOffset", 0, 8.706, 0, 30, false, false],
        ["contrast", 0, 1.706, 1, 3, false, false],
        ["orbSize", 0, 2.042, 0, 12, false, false],
        ["div", 0, 9.935, 0.01, 12, false, false],
        ["radius", 0, 34.129, 0, 122, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f56"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * _dist * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, abs(uv), float(warpTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = abs(uv);\n  }\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 220. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.xyz += lightness;\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n  gl_FragColor.r *= r;\n  gl_FragColor.g *= g;\n  gl_FragColor.b *= b;\n}",
    "variants": [
      [
        ["zoom", 0, 0.3, 0, 0.6, false, false],
        ["xMultiplier", 0, 200, 0, 400, false, false],
        ["yMultiplier", 0, 48.06, 0, 96.12, false, false],
        ["ballSize", 0, 1.8, 0, 3.6, false, false],
        ["colorSpread", 0, 0.1, 0, 0.2, false, false],
        ["colorMultiplier", 0, 519.17, 0, 1038.34, false, false],
        ["shapeMultiplier", 0, 1111, 0, 2222, false, false],
        ["glow", 0, 10000, 0, 20000, false, false],
        ["contrast", 0, 4.47, 0, 8.94, false, false],
        ["rotation", 0, 0.051, 0, 0.102, false, false],
        ["brightness", 0, 4872.2, 0, 9744.4, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false],
        ["lightness", 0, 0.63, 0, 1.26, false, false],
        ["r", 0, 0.55, 0, 1.1, false, false],
        ["g", 0, 0.03, 0, 0.06, false, false],
        ["b", 0, 0.2, 0, 0.4, false, false],
        ["center", 0, 0.04, 0, 0.08, false, false],
        ["_dist", 0, 0.0009, 0, 0.0018, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f57"
    },
    "shader": "#define BALLS 25\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv *= zoom;\n  uv *= log(dot(uv, uv));\n  uv = normalize(uv) * length(uv);\n  uv *= k_rotate2d(rotation/70.*-stream);\n  uv *= a * sin(b * dot(uv, uv) - stream);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/1.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n  uv *= k_rotate2d(rotation + (log(1./dist) - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) + stream/120.;\n    vec2 p = vec2(c * sin(e * t), c * cos(d * t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (false) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.018, 0, 0.1, false, false],
        ["xMultiplier", 0, 405.818, 0, 2100, false, false],
        ["yMultiplier", 0, 90.078, 0, 200, false, false],
        ["ballSize", 0, 17.164, 0, 112, false, false],
        ["colorSpread", 0, 0.00464, 0.001, 0.01, false, false],
        ["colorMultiplier", 0, 282.111, 1, 1500, false, false],
        ["shapeMultiplier", 0, 210, 0, 210, false, false],
        ["glow", 0, 9132.468, 0, 10000, false, false],
        ["contrast", 0, 5.259, 1, 10, false, false],
        ["rotation", 0, -79.338, -100, 115, false, false],
        ["brightness", 0, 7282.753, 0, 11100, false, false],
        ["sides", 0, 17.461, 2, 48, false, false],
        ["a", 0, 139.761, 0, 1121, false, false],
        ["b", 0, 182.954, 0, 1111, false, false],
        ["c", 0, 34.444, 0, 112, false, false],
        ["d", 0, 8.097, 0, 11, false, false],
        ["e", 0, 3.383, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f94"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv);\n  uv *= rotate(.42*stream);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(-stream/.6);\n  uv += cos(dotMul*dot(uv + sinMul*sin(uv+stream/.241), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(cos(t-stream)-stream/2.);\n    float y = radius * cos(sin(t+stream/2.)+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, (orbSize)*volume, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.542, 0, 20, false, false],
        ["contrast", 0, 2.541, 0, 4.42, false, false],
        ["orbSize", 0, 1.086, 0, 3, false, false],
        ["radius", 0, 6.138, 0, 13.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 3.853, 0, 5.64, false, false],
        ["sides", 0, 8, 0, 12, false, false],
        ["dotMul", 0, 0.524, 0, 0.6, false, false],
        ["sinMul", 0, 3.923, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f95"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.411, 0, 20, false, false],
        ["contrast", 0, 2.19, 0, 4.42, false, false],
        ["orbSize", 0, 0.573, 0, 0.76, false, false],
        ["radius", 0, 2.499, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 3.248, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.388, 0, 0.6, false, false],
        ["sinMul", 0, 6.426, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9c"
    },
    "shader": "\n#define orbs 35.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5.94, 0, 10, false, false],
        ["contrast", 0, 2.34, 1, 5, false, false],
        ["orbSize", 0, 0.17, 0.01, 1, false, false],
        ["radius", 0, 1, 1, 15, false, false],
        ["colorShift", 0, 4.69, 4, 10, false, false],
        ["center", 0, 2.82, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 10, false, false],
        ["sinMul", 0, 7.27, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa7"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 1.2967;\n  float dist = length(uv);\n  uv *= rotate(stream/20.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .7)*orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 26.54, 0, 53.08, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 5.39, 0, 10.78, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb2"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(stream/20.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb3"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}  \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= rotate(stream/3.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/15.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 5.87, 0, 221, false, false],
        ["contrast", 0, 2.25, 1, 5, false, false],
        ["orbSize", 0, 0.67, 0.01, 2, false, false],
        ["radius", 0, 1, 1, 15, false, false],
        ["colorShift", 0, 6.72, 4, 10, false, false],
        ["x1", 0, 0.71, 0, 1, false, false],
        ["x2", 0, 0.24, 0, 1, false, false],
        ["y1", 0, 0.23, 0, 1, false, false],
        ["y2", 0, 1.83, 0, 5, false, false],
        ["center", 0, 4.27, 0, 11, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd3"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(cos(sin(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv += (i+1.)/10.;\n      uv *= rotate(i+stream/4.);\n      uv.x /= abs(dist+distMul* dist*(i+1.));\n      float t = (i) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);// / cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// + sin(t-stream/1.) - cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.39, 0, 5, false, false],
        ["contrast", 0, 1.81, 1, 5, false, false],
        ["orbSize", 0, 0.84, 0.01, 1, false, false],
        ["radius", 0, 2.51, 1, 50, false, false],
        ["colorShift", 0, 9.12, 4, 10, false, false],
        ["distMul", 0, 0.00668, 0, 0.01, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe0"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/9.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(wat*tan(stream/1.28295 - t*PI), cos(t - stream/2.5));\n    p /= (cos(wad * cos(stream/6. - uv.x/x))*sin(stream/-.5- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 435915.092, 0.01, 2111000, false, false],
        ["ballSize", 0, 250.873, 0, 1122, false, false],
        ["contrast", 0, 2.51, 0, 5, false, false],
        ["radius", 0, 1718856.72, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 4037425.8, 0, 7111201, false, false],
        ["y", 0, 2271711.24, 0, 9133112, false, false],
        ["rotation", 0, 0.00028, 0, 0.01, false, false],
        ["colorOffset", 0, 1525.71, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 17650.456, 1000, 100000, false, false],
        ["div2", 0, 692166.125, 0, 1313311, false, false],
        ["wad", 0, 22.423, 1, 180, false, false],
        ["woot", 0, 0.117, 0, 2, false, false],
        ["wat", 0, 0.917, 0, 33, false, false],
        ["wob", 0, 44.093, 0, 160, false, false],
        ["outer", 0, 9.645, 0, 14, false, false],
        ["outer2", 0, 1.282, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 530156.163, 0.01, 2111000, false, false],
        ["ballSize", 0, 247.533, 0, 1122, false, false],
        ["contrast", 0, 3.21, 0, 5, false, false],
        ["radius", 0, 4177483.47, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 13745054.8, 0, 71121201, false, false],
        ["y", 0, 1553415.58, 0, 9133112, false, false],
        ["rotation", 0, 0.00319, 0, 0.01, false, false],
        ["colorOffset", 0, 2099.71, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 32307.371, 1000, 100000, false, false],
        ["div2", 0, 408995.916, 0, 1313311, false, false],
        ["wad", 0, 34.823, 1, 180, false, false],
        ["woot", 0, 0.556, 0, 2, false, false],
        ["wat", 0, 0.121, 0, 1, false, false],
        ["wob", 0, 48.389, 0, 160, false, false],
        ["outer", 0, 13.813, 0, 22, false, false],
        ["outer2", 0, 1.099, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 265211.762, 0.01, 2111000, false, false],
        ["ballSize", 0, 222.169, 0, 1122, false, false],
        ["contrast", 0, 3.39, 0, 5, false, false],
        ["radius", 0, 1787836.23, 0, 11115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 10007048.42, 0, 71121201, false, false],
        ["y", 0, 2998103.64, 0, 9133112, false, false],
        ["rotation", 0, 0.00323, 0, 0.01, false, false],
        ["colorOffset", 0, 2789.01, 0, 12110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 34777.356, 1000, 100000, false, false],
        ["div2", 0, 276101.35, 0, 1313311, false, false],
        ["wad", 0, 25.891, 1, 180, false, false],
        ["woot", 0, 0.773, 0, 2, false, false],
        ["wat", 0, 0.176, 0, 1, false, false],
        ["wob", 0, 48.531, 0, 160, false, false],
        ["outer", 0, 20.254, 0, 22, false, false],
        ["outer2", 0, 1.007, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe2"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / 11.1) * _uv.y/div - stream/1.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += aWave * sin(uv.y/wave - stream/.9);\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = vec2(radius*wat*cos(stream/2.5295 - t*PI), radius*tan(t - stream/.34));\n    p /= (cos(wad * cos(stream/-10.83 - uv.x/x))*sin(stream/-.835- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 4033.844, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 7666579.57, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 9489403.83, 0, 818888881, false, false],
        ["y", 0, 15865507.96, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fef"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-30.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5) * orbSize, vec2(radius*abs(tan(stream/1.3+uv.x/div)) * L * sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.104, 0, 1, false, false],
        ["iterator", 0, 1.31, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.139, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 20, 0, 33, false, false],
        ["L", 0, 1.457, 1, 2, false, false],
        ["M", 0, 0.358, 0, 1, false, false],
        ["colorShift", 0, 0.572, 0, 2, false, false],
        ["colorOffset", 0, 23.207, 0, 111, false, false],
        ["contrast", 0, 1.392, 0, 3, false, false],
        ["orbSize", 0, 0.647, 0, 2, false, false],
        ["div", 0, 0.735, 0.01, 12, false, false],
        ["radius", 0, 7.992, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca000"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 10.518, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca001"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 8.224, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca011"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  vec2 _uv = uv;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *= rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream) - sin(uv.x/xDiv - stream/3.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/20. + .01*uv))*cos(uv.x/xDiv - stream/3.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/10.- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 53.73293577243752, 0, 117.14, false, false],
        ["yDivider", 0, 2.1694277108433737, 0, 4, false, false],
        ["xDivider", 0, 4.430280496987952, 0, 18, false, false],
        ["multiplier", 0, 1.2283603162650605, 0, 2, false, false],
        ["ballSize", 0, 7.5453642695783145, 0, 33, false, false],
        ["contrast", 0, 0.6708647402108434, 0, 2.38, false, false],
        ["radius", 0, 128.25703125, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 151.80625, 0, 332, false, false],
        ["xDiv2", 0, 15.67018542921687, 0, 33, false, false],
        ["itY", 0, 0.1551346009036145, 0, 0.2, false, false],
        ["itX", 0, 0.09707172439759039, 0, 0.2, false, false],
        ["oS", 0, 0.249378765060241, 0, 2, false, false],
        ["oT", 0, 0.6427899096385543, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 45.72914495481928, 0, 117.14, false, false],
        ["yDivider", 0, 2.160560993975904, 0, 4, false, false],
        ["xDivider", 0, 5.3695877259036155, 0, 18, false, false],
        ["multiplier", 0, 1.7478256777108436, 0, 2, false, false],
        ["ballSize", 0, 14.114923757530121, 0, 33, false, false],
        ["contrast", 0, 1.367424698795181, 0, 2.38, false, false],
        ["radius", 0, 46.70274849397591, 0, 333, false, false],
        ["rotation", 0, 0.2937717432228916, 0, 0.46, false, false],
        ["xDiv", 0, 4.192112198795181, 1, 111, false, false],
        ["yDiv", 0, 3.116528614457832, 0, 4, false, false],
        ["xDiv2", 0, 1.7964278990963858, 1, 8, false, false],
        ["itY", 0, 0.7522778614457832, 0, 1, false, false],
        ["itX", 0, 0.019126506024096393, 0, 0.2, false, false],
        ["oS", 0, 1, 0, 2, false, false],
        ["oT", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca041"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 7.398509653019611, 0, 1, false, false],
        ["contrast", 0, 1.7564941541932788, 0, 2, false, false],
        ["orbSize", 0, 3, 0.01, 11, false, false],
        ["radius", 0, 2.380929656167552, 1, 14, false, false],
        ["colorShift", 0, 10.95, 3, 16, false, false],
        ["div", 0, 15.427, 0, 100, false, false],
        ["div2", 0, 32.974, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03e"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/41.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize * pow(volume, 6.), position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 20.75, 0, 151, false, false],
        ["contrast", 0, 0.96, 0, 2, false, false],
        ["orbSize", 0, 0.17, 0.01, 1, false, false],
        ["radius", 0, 3.65, 0, 14, false, false],
        ["colorShift", 0, 8.07, 3, 33, false, false],
        ["div", 0, 10.673, 10, 40, false, false],
        ["div2", 0, 16.837, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca050"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .00005 * dot(uv, uv) + stream/3.) * sin(.0001 * dot(uv, uv)-stream/6.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 91.99, 0, 183.98, false, false],
        ["contrast", 0, 1.25, 0, 2.5, false, false],
        ["orbSize", 0, 1.11, 0, 2.22, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 23.45, 0, 46.9, false, false],
        ["div", 0, 45.722, 0, 91.444, false, false],
        ["div2", 0, 63.807, 0, 127.614, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca066"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.41, 0, 4.82, false, false],
        ["contrast", 0, 1.32, 0, 2.64, false, false],
        ["orbSize", 0, 0.36, 0, 0.72, false, false],
        ["radius", 0, 4.94, 0, 9.88, false, false],
        ["colorShift", 0, 6.24, 0, 12.48, false, false],
        ["outer", 0, 2.78, 0, 5.56, false, false],
        ["inner", 0, 0.03, 0, 0.06, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08c"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * 2.*cos( .0005 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t + stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 16.43, 0, 151, false, false],
        ["contrast", 0, 1.05, 0, 2, false, false],
        ["orbSize", 0, 0.38, 0.01, 2, false, false],
        ["radius", 0, 2.71, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 36.913, 10, 40, false, false],
        ["div2", 0, 36.105, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09d"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  uv = abs(uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .12 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += 1.02 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 210. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 45. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 46.25, 0, 92.5, false, false],
        ["yDivider", 0, 244.25, 0, 488.5, false, false],
        ["xDivider", 0, 352.43, 0, 704.86, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.7, 0, 1.4, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 23.3, 0, 46.6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e0"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / .7;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream/2.))/2. + stream/5.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 1.5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream/2.), radius * sin(sinMul * t + stream/2.));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .2)/1.5 * pow(dist, 1.) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6.501, 0, 15.792, false, false],
        ["contrast", 0, 1.194, 0, 3.02, false, false],
        ["ballSize", 0, 0.191, 0, 1, false, false],
        ["radius", 0, 2.021, 0, 14.4, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 10, -10, 10, false, false],
        ["dotMultiplier", 0, 2.794, 0, 12, false, false],
        ["tanMul", 0, 18.7, 0, 18.7, false, false],
        ["sinMul", 0, 13.724, 0, 15.6, false, false],
        ["shift", 0, 0.824, 0, 1, false, false],
        ["offset", 0, 1.751, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e7"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv = sin(stream*1.+(1.-log(sin(uv))));\n  // uv *= k_rotate2d(stream);\n  uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 1.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t), sinMul * sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.778, 0, 1.556, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 0.1491, 0, 0.2982, false, false],
        ["radius", 0, 2.25, 0, 4.5, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 2.17, 0, 4.34, false, false],
        ["dotMultiplier", 0, 5, 0, 10, false, false],
        ["tanMul", 0, 0.9, 0, 1.8, false, false],
        ["sinMul", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e9"
    },
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv += sin(+((uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.777, 0, 11, false, false],
        ["contrast", 0, 2.28, 0, 30, false, false],
        ["ballSize", 0, 0.0329, 0, 0.1, false, false],
        ["radius", 0, 1, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 0.31, 0, 5, false, false],
        ["tanMul", 0, 10, 0, 10, false, false],
        ["sinMul", 0, 0, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f8"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  uv = abs(uv);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    uv.x += .5*tan((-1. + 2. * gl_FragCoord.xy / resolution.xy).x) * iterator - 1.;\n    uv.y += sinMul * sin(stream+uv.x) * iterator + 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .82716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 122, 0, 122, false, false],
        ["iterator", 0, 1.01, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 33, 0, 33, false, false],
        ["L", 0, 3, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.636, 0, 2, false, false],
        ["colorOffset", 0, 25.259, 0, 111, false, false],
        ["contrast", 0, 1.987, 1, 3, false, false],
        ["orbSize", 0, 6.079, 0, 13, false, false],
        ["div", 0, 7.216, 1, 12, false, false],
        ["radius", 0, 26.903, 0, 121, false, false],
        ["sinMul", 0, 0.5, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0fa"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  uv *= outer * sin( length(uv) * inner * dot(uv, uv) + stream / 16. );\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    gl_FragColor += k_orb(uv, orbSize, vec2(x, y),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 8.795, 0, 22, false, false],
        ["iterator", 0, 1.102, 0, 2, false, false],
        ["ot", 0, 97.06010404603832, 0, 151, false, false],
        ["I", 0, 0.839, 0, 3, false, false],
        ["J", 0, 0.808, 0, 3, false, false],
        ["K", 0, 93.01354204390226, 0, 111, false, false],
        ["iterations", 0, 24.216, 0, 33, false, false],
        ["L", 0, 9.481, 0, 31, false, false],
        ["M", 0, 2.446, 0, 11, false, false],
        ["colorShift", 0, 1.029, 0, 2, false, false],
        ["colorOffset", 0, 22.942, 0, 111, false, false],
        ["contrast", 0, 2.666, 1, 3, false, false],
        ["orbSize", 0, 0.706, 0, 2, false, false],
        ["div", 0, 1, 1, 4, false, false],
        ["radius", 0, 1.775, 1, 15, false, false],
        ["inner", 0, 0.00061, 0, 0.01, false, false],
        ["outer", 0, 1.074, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0fb"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 12.585, 0, 22, false, false],
        ["iterator", 0, 1.05, 0, 2, false, false],
        ["ot", 0, 65.885, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 3, 0, 3, false, false],
        ["K", 0, 4.685, 0, 11, false, false],
        ["iterations", 0, 11.987, 0, 33, false, false],
        ["L", 0, 28.663, 0, 113, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.372, 0, 2, false, false],
        ["colorOffset", 0, 51.908, 0, 111, false, false],
        ["contrast", 0, 1.873, 1, 3, false, false],
        ["orbSize", 0, 2.733, 0, 11, false, false],
        ["div", 0, 1.567, 1, 2, false, false],
        ["radius", 0, 7.052, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca102"
    },
    "shader": "void main () {\n  float stream = stream / volumeDivider;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  uv *= k_rotate2d(stream/-3.);\n  uv = abs(uv);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * gl_FragCoord.xy / resolution.xy)/12.)+ stream/3.);\n  uv *= k_rotate2d(stream/31.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    vec2 position = vec2(x, y);\n    gl_FragColor += k_orb(uv, pow(volume, reactivity) * orbSize, position,  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.971, 0, 100, false, false],
        ["iterator", 0, 0.33, 0, 2, false, false],
        ["ot", 0, 99.903, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.987, 0, 3, false, false],
        ["K", 0, 58.378, 0, 111, false, false],
        ["iterations", 0, 3.892, 0, 33, false, false],
        ["L", 0, 187.608, 0, 213, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 0.382, 0, 2, false, false],
        ["colorOffset", 0, 7.804, 0, 12, false, false],
        ["contrast", 0, 1.503, 0, 5, false, false],
        ["orbSize", 0, 0.873, 0, 2, false, false],
        ["div", 0, 0.185, 0.1, 2, false, false],
        ["radius", 0, 0.097, 0, 1, false, false],
        ["sides", 0, 8, 0, 12, false, false],
        ["reactivity", 0, 0, 0, 2, false, false],
        ["volumeDivider", 0, 1.763, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca108"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/10.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - tan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/.0569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.0175) * orbSize, vec2(radius*(tan(stream/-2.+uv.x/div)) * sin(stream/2. - uv.y + (-1. + 2. * gl_FragCoord.xy / resolution.xy).x), radius*cos(stream/-4.+(-1. + 2. * gl_FragCoord.xy / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}     ",
    "variants": [
      [
        ["zoom", 0, 13, 0, 13, false, false],
        ["iterator", 0, 1.347, 0, 5, false, false],
        ["ot", 0, 70.614, 0, 151, false, false],
        ["I", 0, 0.416, 0, 3, false, false],
        ["J", 0, 0.918, 0, 3, false, false],
        ["K", 0, 10.77, 0, 11, false, false],
        ["iterations", 0, 123.282, 0, 133, false, false],
        ["L", 0, 5.129, 0, 13, false, false],
        ["M", 0, 6.292, 0, 11, false, false],
        ["colorShift", 0, 9.244, 0, 12, false, false],
        ["colorOffset", 0, 1.432, 0, 4, false, false],
        ["contrast", 0, 1.486, 1, 3, false, false],
        ["orbSize", 0, 5.173, 0, 12, false, false],
        ["div", 0, 9.935, 0.01, 12, false, false],
        ["radius", 0, 12, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f63"
    },
    "shader": "void main () {\n  float stream = stream / 45.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = uv.x/granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = .2 * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.15496988641210352, 0, 3, false, false],
        ["xMultiplier", 0, 16.201666413640403, 0, 40.74, false, false],
        ["yMultiplier", 0, 15.621596795323384, 0, 62.28, false, false],
        ["ballSize", 0, 4.67, 0, 9.34, false, false],
        ["colorSpread", 0, 5.31327548107469, 0, 11.34, false, false],
        ["colorMultiplier", 0, 159.33728218170538, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 13.20382188544216, 0, 26.04, false, false],
        ["glow", 0, 18444.68, 0, 18444.68, false, false],
        ["contrast", 0, 3.8245473654873408, 0, 7.5, false, false],
        ["brightness", 0, 11.161348291603918, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 42.21581365746188, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6d"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.8), radius *\ncos(.1 * dist * yOuter * uv.x / 3.5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .21)/3.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.467786754929877, 0, 62.18, false, false],
        ["ballSize", 0, 0.17738216905708776, 0, 0.2, false, false],
        ["contrast", 0, 2.8809567326924888, 0, 8.94, false, false],
        ["radius", 0, 0.4156118107071843, 0, 0.66, false, false],
        ["yOuter", 0, 17.969914545633713, 0, 25.42, false, false],
        ["xOuter", 0, 27.03570903824037, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.0018560335090365, 0, 7.36, false, false],
        ["yMultiplier", 0, 5.055801225041768, 0, 19.24, false, false],
        ["divider", 0, 6.095766072100905, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6f"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x + stream)) * uv.x + radius * tan(t + xMultiplier + stream), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["ballSize", 0, 0.047, 0, 0.094, false, false],
        ["contrast", 0, 4.47, 0, 8.94, false, false],
        ["radius", 0, 0.33, 0, 0.66, false, false],
        ["yOuter", 0, 12.71, 0, 25.42, false, false],
        ["xOuter", 0, 15.27, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.68, 0, 7.36, false, false],
        ["yMultiplier", 0, 9.62, 0, 19.24, false, false],
        ["divider", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f89"
    },
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.135, 0, 21, false, false],
        ["iterator", 0, 1.071, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 18.705, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8d"
    },
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.199, 0, 0.2, false, false],
        ["contrast", 0, 1.262, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 0.825, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.43, 0, 1, false, false],
        ["colorOffset", 0, 0, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.307, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 2.979, 0, 25.38, false, false],
        ["colorShift", 0, 0, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 4.12, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.145, 0, 1, false, false],
        ["contrast", 0, 1.35, 0, 2.92, false, false],
        ["orbSize", 0, 8.789, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 1.277, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 5, 0, 5, false, false],
        ["b", 0, 0.19, 0, 5, false, false],
        ["c", 0, 1.77, 0, 5, false, false],
        ["d", 0, 0.47, 0, 1, false, false],
        ["colorOffset", 0, 2.06, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.994, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.8, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.089, 0, 1, false, false],
        ["contrast", 0, 0.617, 0, 2.92, false, false],
        ["orbSize", 0, 0.993, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.227, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0, 0, 5, false, false],
        ["c", 0, 0, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f96"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.831, 0, 20, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 0.685, 0, 0.76, false, false],
        ["radius", 0, 2.435, 0, 3.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9a"
    },
    "shader": "#define orbs 35.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5.94, 0, 11.88, false, false],
        ["contrast", 0, 2.34, 0, 4.68, false, false],
        ["orbSize", 0, 0.17, 0, 0.34, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9b"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/10.)-stream);\n    float y = radius * cos(sin(t+stream/10.)+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 10, 0, 10, false, false],
        ["contrast", 0, 2.21, 1, 5, false, false],
        ["orbSize", 0, 0.38, 0.01, 1, false, false],
        ["radius", 0, 1.76, 1, 15, false, false],
        ["colorShift", 0, 4.69, 4, 10, false, false],
        ["center", 0, 2.82, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 10, false, false],
        ["sinMul", 0, 7.27, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9f"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .9) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.509076148343374, 0, 2.74, false, false],
        ["orbSize", 0, 0.5489348644578315, 0, 2.78, false, false],
        ["radius", 0, 4.144187123493976, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9faa"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.78, 0, 31.56, false, false],
        ["contrast", 0, 1.06, 0, 2.12, false, false],
        ["orbSize", 0, 0.36, 0, 0.72, false, false],
        ["radius", 0, 3.52, 0, 7.04, false, false],
        ["colorShift", 0, 4.45, 0, 8.9, false, false],
        ["x1", 0, 0.4, 0, 0.8, false, false],
        ["x2", 0, 0.21, 0, 0.42, false, false],
        ["y1", 0, 0.55, 0, 1.1, false, false],
        ["y2", 0, 1.62, 0, 3.24, false, false],
        ["center", 0, 11, 0, 22, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb9"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/30.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/50.);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 9.75, 0, 19.5, false, false],
        ["contrast", 0, 1.72, 0, 3.44, false, false],
        ["orbSize", 0, 0.54, 0, 1.08, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4, 0, 8, false, false],
        ["x1", 0, 0.22, 0, 0.44, false, false],
        ["x2", 0, 0.38, 0, 0.76, false, false],
        ["y1", 0, 0.22, 0, 0.44, false, false],
        ["y2", 0, 1.03, 0, 2.06, false, false],
        ["center", 0, 3.95, 0, 7.9, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fba"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}  \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= rotate(stream/13.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 26.95, 0, 53.9, false, false],
        ["contrast", 0, 1.08, 0, 2.16, false, false],
        ["orbSize", 0, 1.24, 0, 2.48, false, false],
        ["radius", 0, 11.34, 0, 22.68, false, false],
        ["colorShift", 0, 7.42, 0, 14.84, false, false],
        ["x1", 0, 0.64, 0, 1.28, false, false],
        ["x2", 0, 0.34, 0, 0.68, false, false],
        ["y1", 0, 0.41, 0, 0.82, false, false],
        ["y2", 0, 1.06, 0, 2.12, false, false],
        ["center", 0, 7.7, 0, 15.4, false, false],
        ["sides", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fbe"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.78, 0, 3.56, false, false],
        ["ballSize", 0, 0.811, 0, 1.622, false, false],
        ["contrast", 0, 6.18, 0, 12.36, false, false],
        ["radius", 0, 0.37, 0, 0.74, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 55.27, 0, 110.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.14, 0, 8.28, false, false],
        ["yMultiplier", 0, 5.19, 0, 10.38, false, false],
        ["divider", 0, 4, 0, 8, false, false],
        ["rotation", 0, 0.0576, 0, 0.1152, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a41"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc6"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    float stream = stream / 10.;\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/.45));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-2.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, .8)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 5.366905120481928, 0, 15, false, false],
        ["contrast", 0, 1.13, 0, 2, false, false],
        ["orbSize", 0, 0.14320511015827703, 0.01, 1, false, false],
        ["radius", 0, 5.42, 1, 50, false, false],
        ["colorShift", 0, 4, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00e"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / 2.5;\n  \n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  vec2 _uv = uv;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *= rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/1.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4.3 + .01*uv))*cos(uv.x/xDiv - stream/1.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/.812 + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/1.94+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 53.73293577243752, 0, 117.14, false, false],
        ["yDivider", 0, 2.1694277108433737, 0, 4, false, false],
        ["xDivider", 0, 4.430280496987952, 0, 18, false, false],
        ["multiplier", 0, 1.2283603162650605, 0, 2, false, false],
        ["ballSize", 0, 16.450013944327118, 0, 33, false, false],
        ["contrast", 0, 1.6010978582267232, 0, 2.38, false, false],
        ["radius", 0, 170.7015577201384, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 151.80625, 0, 332, false, false],
        ["xDiv2", 0, 15.67018542921687, 0, 33, false, false],
        ["itY", 0, 0.1551346009036145, 0, 0.2, false, false],
        ["itX", 0, 0.09707172439759039, 0, 0.2, false, false],
        ["oS", 0, 0.249378765060241, 0, 2, false, false],
        ["oT", 0, 0.6427899096385543, 0, 2, false, false],
        ["yShape", 0, 4.247590361445784, 0, 32, false, false]
      ],
      [
        ["zoom", 0, 32.46323842243976, 0, 117.14, false, false],
        ["yDivider", 0, 2.951618975903615, 0, 4, false, false],
        ["xDivider", 0, 0.42119728915662663, 0, 18, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 21.58139118975904, 0, 33, false, false],
        ["contrast", 0, 1.1464503012048195, 0, 2.38, false, false],
        ["radius", 0, 165.77595067771088, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 23.026562500000004, 0, 332, false, false],
        ["xDiv2", 0, 33, 0, 33, false, false],
        ["itY", 0, 0.041319008087971405, 0, 0.2, false, false],
        ["itX", 0, 0, 0, 0.2, false, false],
        ["oS", 0, 0, 0, 2, false, false],
        ["oT", 0, 1.8478727409638558, 0, 2, false, false],
        ["yShape", 0, 25.166716867469884, 0, 32, false, false]
      ],
      [
        ["zoom", 0, 25.434176863704824, 0, 117.14, false, false],
        ["yDivider", 0, 2.951618975903615, 0, 4, false, false],
        ["xDivider", 0, 0.42119728915662663, 0, 18, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 17.750080007530123, 0, 33, false, false],
        ["contrast", 0, 1.1464503012048195, 0, 2.38, false, false],
        ["radius", 0, 182.8381259412651, 0, 333, false, false],
        ["rotation", 0, 0.2845297439759037, 0, 0.46, false, false],
        ["xDiv", 0, 1, 1, 111, false, false],
        ["yDiv", 0, 0, 0, 332, false, false],
        ["xDiv2", 0, 33, 0, 33, false, false],
        ["itY", 0, 0, 0, 0.2, false, false],
        ["itX", 0, 0, 0, 0.2, false, false],
        ["oS", 0, 0, 0, 2, false, false],
        ["oT", 0, 0.9522213855421688, 0, 2, false, false],
        ["yShape", 0, 17.82530120481928, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02a"
    },
    "shader": "#define BALLS 9.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/34. + length(uv/warp));\n  uv.x += sin(uv.y/4. - stream/2.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\tuv.y += xOuter*i/50.*sin(uv.y/yDivider) + sin(uv.x/xDiv - stream/9.05);\n    uv.x += yOuter*i*cos(uv.y/xDivider) * cos(uv.x/xDiv2 - stream/-1.95);\n    float t = float(i) * PI / BALLS * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.x + stream)*cos(uv.y - stream));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.75, 0, 33, false, false],
        ["yDivider", 0, 4390.12, 0.1, 11001, false, false],
        ["xDivider", 0, 0.44, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.03, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 2.64, 0, 12, false, false],
        ["xOuter", 0, 11, 0, 11, false, false],
        ["yOuter", 0, 0.23, 0, 1, false, false],
        ["xDiv", 0, 98.024, 0, 111, false, false],
        ["xDiv2", 0, 0.905, 0, 4, false, false],
        ["warp", 0, 5.826, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ffc"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 8.224, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca033"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * outer*cos( .00001 * dot(uv, uv) - stream/4.) + uv.x / 1110. * sin(11.01 * dot(uv, uv)-stream/1.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize * pow(volume, 3.5), position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 91.91, 0, 151, false, false],
        ["contrast", 0, 1.26, 0, 2, false, false],
        ["orbSize", 0, 0.51, 0.01, 1, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 8.07, 3, 33, false, false],
        ["div", 0, 18.147, 10, 40, false, false],
        ["div2", 0, 16.837, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false],
        ["outer", 0, 0.448, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05f"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.7, 0, 13.4, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["orbSize", 0, 0.97, 0, 1.94, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 7.15, 0, 14.3, false, false],
        ["outer", 0, 4.79, 0, 9.58, false, false],
        ["inner", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca064"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 20000.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.03, 0, 6.06, false, false],
        ["contrast", 0, 1.32, 0, 2.64, false, false],
        ["orbSize", 0, 0.35, 0, 0.7, false, false],
        ["radius", 0, 2.62, 0, 5.24, false, false],
        ["colorShift", 0, 10, 0, 20, false, false],
        ["outer", 0, 1.43, 0, 2.86, false, false],
        ["inner", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca069"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 6.7, 0, 13.4, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["orbSize", 0, 0.97, 0, 1.94, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 7.15, 0, 14.3, false, false],
        ["outer", 0, 4.79, 0, 9.58, false, false],
        ["inner", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08b"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 18.41, 0, 151, false, false],
        ["contrast", 0, 1.42, 0, 2, false, false],
        ["orbSize", 0, 0.7, 0.01, 2, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 10.119, 10, 40, false, false],
        ["div2", 0, 10, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08f"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * 2.*cos( .0005 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t + stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 16.43, 0, 32.86, false, false],
        ["contrast", 0, 1.05, 0, 2.1, false, false],
        ["orbSize", 0, 0.38, 0, 0.76, false, false],
        ["radius", 0, 2.71, 0, 5.42, false, false],
        ["colorShift", 0, 11.52, 0, 23.04, false, false],
        ["div", 0, 36.913, 0, 73.826, false, false],
        ["div2", 0, 36.105, 0, 72.21, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca098"
    },
    "shader": "\n#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n \n\n\n\nvec4 k_orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n\n\n\nvec2 k_swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  if (vT) {\n    return mix(v ? uv : uv2, v ? uv2 : uv, vTP);\n  }\n  return v ? uv2 : uv;\n}\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv))/ dist + (tatumStream + beatStream)  / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < orbs; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor +=   barVolume * vec4(pow(tatumVolume ,1.5)  * orbsize / length(uv + p *(spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor= vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 1583.68, 0, 2222, false, false],
        ["spreadMultiplier", 0, 1.913, 0.4, 3, false, false],
        ["rotation", 0, 50, -200, 200, false, false],
        ["xMultiplier", 0, 369.731, 0, 444, false, false],
        ["yMultiplier", 0, 403.636, 0, 444, false, false],
        ["colorSpread", 0, 0.00007, 0, 0.000104, false, false],
        ["invert", 1, false, null, null, null, false],
        ["orbsize", 0, 35.636, 0, 1400, false, false],
        ["contrast", 0, 1.258, 0, 4, false, false],
        ["radius", 0, 9.636, 0, 100, false, false],
        ["sides", 0, 7, 0, 24, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["aSpeed", 0, -10, -10, 10, false, false],
        ["bSpeed", 0, 8.3, -10, 10, false, false],
        ["sinMul", 0, -0.109, -0.5, 0.5, false, false],
        ["cosMul", 0, 0.055, -0.5, 0.5, false, false],
        ["rippleSpeed", 0, -20, -20, 20, false, false],
        ["wobbleSpeed", 0, 4.145, -20, 20, false, false],
        ["swirl", 0, -0.5, -0.5, 0.5, false, false],
        ["energy", 0, 1.1, -2.2, 4.4, false, false],
        ["punch", 0, 1, -2, 4, false, false],
        ["borderSpeed", 0, 616.364, 0, 3000, false, false],
        ["hueShift", 0, -31.964, -120, 60, false, false],
        ["colorMultiplier", 0, 0.0034, 0, 0.005, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a1"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .02 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .02 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 210. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 45. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 36.26, 0, 72.52, false, false],
        ["yDivider", 0, 244.25, 0, 488.5, false, false],
        ["xDivider", 0, 352.43, 0, 704.86, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.32, 0, 0.64, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 4.74, 0, 9.48, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c1"
    },
    "shader": "\n#define BALLS 20.\n  \nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 2, false, false],
        ["contrast", 0, 3.03, 0, 8, false, false],
        ["ballSize", 0, 0.016, 0, 0.05, false, false],
        ["radius", 0, 45.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d3"
    },
    "shader": "#define BALLS 15\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *= rotate2d(stream/-3. + length(3.*cos(uv-stream/4.))/2.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/1.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.014, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 259.21, 0, 301, false, false],
        ["rotation", 0, 0.02567, 0.009, 0.041, false, false],
        ["xMultiplier", 0, 734.64, 0, 1500, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.000012, 0, 0.001, false, false],
        ["colorMultiplier", 0, 0.51, 0, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.86, 0, 10, false, false],
        ["ballSize", 0, 14.39, 0, 100, false, false],
        ["glow", 0, 3.79, 0, 4, false, false],
        ["contrast", 0, 2.15, 0, 5, false, false],
        ["radius", 0, 19.16, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d5"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 88.11, 0, 501, false, false],
        ["yDivider", 0, 1, 0.1, 1, false, false],
        ["xDivider", 0, 111, 0.1, 111, false, false],
        ["multiplier", 0, 111, 0.1, 111, false, false],
        ["ballSize", 0, 1.69, 0, 2, false, false],
        ["contrast", 0, 1.66, 0, 5, false, false],
        ["radius", 0, 26.57, 0, 111, false, false]
      ],
      [
        ["zoom", 0, 51, 0, 51, false, false],
        ["yDivider", 0, 9.97, 0.1, 111, false, false],
        ["xDivider", 0, 1.2, 0.1, 111, false, false],
        ["multiplier", 0, 111, 0.1, 111, false, false],
        ["ballSize", 0, 1.41, 0, 2, false, false],
        ["contrast", 0, 2.45, 0, 5, false, false],
        ["radius", 0, 13.07, 0, 111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f0"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/(PI*20.));\n  for (float i = 1.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= factor*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 943.691, 0, 1112, false, false],
        ["iterator", 0, 0.727, 0, 2, false, false],
        ["ot", 0, 91.104, 0, 151, false, false],
        ["I", 0, 0.886, 0, 3, false, false],
        ["J", 0, 0.432, 0, 3, false, false],
        ["K", 0, 31.922, 0, 111, false, false],
        ["iterations", 0, 19.474, 0, 22, false, false],
        ["L", 0, 95.451, 0, 222, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 1.015, 0, 4, false, false],
        ["colorOffset", 0, 4.547, 0, 22, false, false],
        ["contrast", 0, 1, 1, 3, false, false],
        ["orbSize", 0, 1.663, 0, 2, false, false],
        ["div", 0, 1, 0, 1, false, false],
        ["radius", 0, 2.561, 0, 11, false, false],
        ["factor", 0, 1.144, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca107"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .5) * orbSize,vec2(radius*tan((-1. + 2. * gl_FragCoord.xy / resolution.xy).x/J), radius*cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y/J)),  col, contrast);\n  }\n            \n}",
    "variants": [
      [
        ["zoom", 0, 9.029, 0, 22, false, false],
        ["iterator", 0, 0.885, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 5.463, 0, 13, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 22.6, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.84, 0, 1, false, false],
        ["colorOffset", 0, 2.283, 0, 3, false, false],
        ["contrast", 0, 1.282, 0, 3, false, false],
        ["orbSize", 0, 0.051, 0, 0.1, false, false],
        ["radius", 0, 0.471, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca10e"
    },
    "shader": "\n\n#define BALLS 5\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.64, 0, 3, false, false],
        ["xMultiplier", 0, 86.71, 0, 200, false, false],
        ["yMultiplier", 0, 49.25, 0, 200, false, false],
        ["ballSize", 0, 2.25, 0, 12, false, false],
        ["colorSpread", 0, 3.36, 0.2, 7, false, false],
        ["colorMultiplier", 0, 115.44, 1, 500, false, false],
        ["shapeMultiplier", 0, 13.45, 0, 210, false, false],
        ["glow", 0, 1862.09, 0, 10000, false, false],
        ["contrast", 0, 5.1, 1, 10, false, false],
        ["rotation", 0, 11.471, 0, 15, false, false],
        ["brightness", 0, 1, 0, 1, false, false],
        ["sides", 0, 11, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7f"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //uv = abs(uv);\n  uv *= k_rotate2d(stream/-18.);\n\n  uv /= dot(uv, uv) * .000051;\n    uv *= k_rotate2d(stream/4.);\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, .7)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 217.11219879518077, 0, 1000, false, false],
        ["xDiv", 0, 11.463, 0, 100, false, false],
        ["yDiv", 0, 122.317, 0, 200, false, false],
        ["xDiv2", 0, 7.522, 0, 200, false, false],
        ["yDiv2", 0, 61.997364457831324, 0, 200, false, false],
        ["xDiv3", 0, 71.2262133177484, 0, 200, false, false],
        ["yDiv3", 0, 172.525, 0, 200, false, false],
        ["multiplier", 0, 1.3139213102409641, 0, 2, false, false],
        ["ballSize", 0, 48.01487198795182, 0, 100, false, false],
        ["contrast", 0, 1.4733810240963858, 0, 2, false, false],
        ["radius", 0, 18.079, 0, 100, false, false],
        ["rotation", 0, 0.00021564382530120485, 0, 0.001, false, false],
        ["xMul", 0, 0.0721009036144579, 0, 20, false, false],
        ["yMul", 0, 11.059770331325304, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f87"
    },
    "shader": "void main () {\n  float stream =time + stream  / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .75)*orbSize/2.,vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.343208772590362, 0, 5, false, false],
        ["iterator", 0, 1.1237387048192773, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 5.251195406626508, 0, 11, false, false],
        ["iterations", 0, 23.76, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false],
        ["orbSize", 0, 0.071, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f80"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / 9.) - cos(uv.x / xDiv2 - stream / 2.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 3.) - sin(uv.y / yDiv2 + stream / -3.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier - sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 11.) - cos(uv.y / yDiv3 - stream / 3.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .7) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 35.244, 0, 500, false, false],
        ["xDiv", 0, 1.575, 0, 10, false, false],
        ["yDiv", 0, 10.112, 0, 100, false, false],
        ["xDiv2", 0, 2.393, 0, 20, false, false],
        ["yDiv2", 0, 2.499, 0, 20, false, false],
        ["xDiv3", 0, 4.24, 0, 20, false, false],
        ["yDiv3", 0, 7.423, 1, 20, false, false],
        ["multiplier", 0, 6.239, 0, 10, false, false],
        ["ballSize", 0, 0.71, 0, 20, false, false],
        ["contrast", 0, 2.763, 0, 3, false, false],
        ["radius", 0, 2.606, 0, 20, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 3.212, 0, 20, false, false],
        ["yMul", 0, 3.85, 0, 20, false, false],
        ["oY", 0, 43.987, 0, 44, false, false],
        ["oX", 0, 7.894, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f91"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / 4.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/5.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 10.) - stream);\n    float y = radius * cos((t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.y * .01 * dist + orbSize* pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.411, 0, 20, false, false],
        ["contrast", 0, 2.19, 0, 4.42, false, false],
        ["orbSize", 0, 0.573, 0, 0.76, false, false],
        ["radius", 0, 2.499, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 3.248, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.388, 0, 0.6, false, false],
        ["sinMul", 0, 6.426, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa9"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 30.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 50.);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 9.75, 0, 19.5, false, false],
        ["contrast", 0, 1.72, 0, 3.44, false, false],
        ["orbSize", 0, 0.54, 0, 1.08, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4, 0, 8, false, false],
        ["x1", 0, 0.22, 0, 0.44, false, false],
        ["x2", 0, 0.38, 0, 0.76, false, false],
        ["y1", 0, 0.22, 0, 0.44, false, false],
        ["y2", 0, 1.03, 0, 2.06, false, false],
        ["center", 0, 3.95, 0, 7.9, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc1"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.);\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 3.;\n    vec2 mouse = vec2(0., 0.);\n    vec2  n       = resolution.xy,\n          i       = (gl_FragCoord.xy+(o-n)*.5)/n.y,\n          m       = mouse.xy/n*2.-1.;\n          \n    for (float a = 0.; a < 100.; a++) {\n        vec3 p = r*vec3(i*.35 - m*.05, 1.);\n        p.xy  *= mat2(cos(r*m.x*.07 + vec4(0,33,11,0)));\n        p.z   += stream*.6; p = abs(fract(p)-.5);            \n        r += t = (p.x + p.y + p.z - .12)*.6;        \n    }\n    tot += mix(.7 - vec3(r*r*2e-4), \n        1.5*cos(r*(vec3(5.7, 5.76, 5.82) + length(i))), \n        exp(-r*.07) * (1.2-length(i))); \n_AA_END \n} ",
    "variants": [[["zoom", 0, 1, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a42"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fdd"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-.9));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2394829.316, 0.01, 4111000, false, false],
        ["ballSize", 0, 15935.47, 0, 36122, false, false],
        ["contrast", 0, 3.19, 0, 5, false, false],
        ["radius", 0, 44172853.06, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 27903685.31, 10000000, 192999999, false, false],
        ["y", 0, 119133112, 0, 119133112, false, false],
        ["rotation", 0, 0.00193, 0, 0.01, false, false],
        ["colorOffset", 0, 120.05, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 18285.392, 1, 100000, false, false],
        ["div2", 0, 12263049.143, 0, 21313311, false, false],
        ["wad", 0, 1.996, 1, 18, false, false],
        ["woot", 0, 0.039, 0, 2, false, false],
        ["wat", 0, 0.085, 0, 0.4, false, false],
        ["wob", 0, 133.457, 0, 160, false, false],
        ["outer", 0, 92.935, 0, 133, false, false],
        ["outer2", 0, 0.759, 0, 132, false, false],
        ["wave", 0, 8.183, 0, 11, false, false],
        ["aWave", 0, 0.0211, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fde"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1276364.983, 0.01, 2111000, false, false],
        ["ballSize", 0, 5163.717, 0, 36122, false, false],
        ["contrast", 0, 2.55, 0, 5, false, false],
        ["radius", 0, 40414465.06, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 41792078.09, 10000000, 192999999, false, false],
        ["y", 0, 19133112, 0, 19133112, false, false],
        ["rotation", 0, 0.00271, 0, 0.01, false, false],
        ["colorOffset", 0, 275.47, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 55552.306, 1, 100000, false, false],
        ["div2", 0, 916935.078, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe9"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / -10.;\n  mat2 rotation = k_rotate2d(stream/(PI- 9.1));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.5)/4. * orbSize, \n                          vec2(radius*abs(cos(stream/.13+uv.x/div)) * L * \n                               sin(stream/-1.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0015747364457831328, 0, 0.1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 1.0034073795180722, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 13.64527014307229, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.7545274849397591, 0, 2, false, false],
        ["colorOffset", 0, 37.88460090361446, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.2960278614457832, 0, 2, false, false],
        ["div", 0, 0.03972143260542169, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6151637801204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 7.6585843373493985, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.07135316265060243, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6268825301204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 8.869992469879518, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.5174934111445784, 0, 3, false, false],
        ["orbSize", 0, 0.732445406626506, 0, 2, false, false],
        ["div", 0, 0.20228308546686752, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff8"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(rotation + stream / PI * abs(fract(uv.x/900.) - .5)); \n  float a = cos(uv.y/yDiv - stream / .5);\n  vec2 p = vec2(xOuter * a * uv.x, 0.);\n  vec3 col = k_rainbow(.1 / orbs, 0., 0.);\n  gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  \n  gl_FragColor.xyz = 1.-pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 9.468664021800219, 0, 21.456, false, false],
        ["ballSize", 0, 0.3929857680722893, 0, 5.808, false, false],
        ["contrast", 0, 0.6583855421686752, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["yOuter", 0, 1.0946844879518074, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 1.5671875000000002, 0, 2, false, false],
        ["rotation", 0, 21.33717149849398, 0, 30.1, false, false],
        ["yDiv", 0, 0.274406061746988, 0.1, 4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ffb"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  \n  float stream = stream / 14.;\n  float dist = length(uv + sin(uv + sin(stream))); \n\n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = pow(abs(1.-(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 10.518, 0, 21.456, false, false],
        ["ballSize", 0, 1.838, 0, 5.808, false, false],
        ["contrast", 0, 1.666, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0.234, 0, 1, false, false],
        ["yOuter", 0, 0.086, 0, 2.32, false, false],
        ["xOuter", 0, 20.4, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 0.19, 0, 2, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca002"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.4)/7.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 16.031951807228918, 0, 62.18, false, false],
        ["ballSize", 0, 0.6445783132530122, 0, 1, false, false],
        ["contrast", 0, 2.8809567326924888, 0, 8.94, false, false],
        ["radius", 0, 0.14869879518072293, 0, 0.66, false, false],
        ["yOuter", 0, 17.969914545633713, 0, 25.42, false, false],
        ["xOuter", 0, 27.03570903824037, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.0018560335090365, 0, 7.36, false, false],
        ["yMultiplier", 0, 19.24, 0, 19.24, false, false],
        ["divider", 0, 6.095766072100905, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00d"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, 1.4)/5000.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 36.947006777108435, 0, 250, false, false],
        ["ballSize", 0, 4.467959337349398, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 47.4550545933735, 0, 250, false, false],
        ["yOuter", 0, 6.027861445783134, -1, 44, false, false],
        ["xOuter", 0, 117.67243975903617, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.8636577560240974, 0, 10, false, false],
        ["yMultiplier", 0, 1.62468561746988, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 94.5881965361446, 0, 110, false, false],
        ["yDiv2", 0, 112, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02b"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 6.47, 0, 15, false, false],
        ["yDivider", 0, 67.32, 0.1, 333, false, false],
        ["xDivider", 0, 0.48, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.101, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 9.38, 0, 12, false, false],
        ["xOuter", 0, 2.47, 0, 11, false, false],
        ["yOuter", 0, 0.21, 0, 1, false, false],
        ["xDiv", 0, 26.512, 0, 111, false, false],
        ["xDiv2", 0, 0.321, 0, 4, false, false],
        ["warp", 0, 321, 0, 321, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca032"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/1000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 25.95, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.3, 0.01, 2, false, false],
        ["radius", 0, 3.77, 0, 14, false, false],
        ["colorShift", 0, 33, 3, 33, false, false],
        ["div", 0, 17.974, 10, 40, false, false],
        ["div2", 0, 27.909, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04e"
    },
    "shader": "#define orbs 12.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t-stream);\n    float y = radius * cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.43, 0, 0.86, false, false],
        ["contrast", 0, 1.17, 0, 2.34, false, false],
        ["orbSize", 0, 0.63, 0, 1.26, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.95, 0, 11.9, false, false],
        ["div", 0, 10.925, 0, 21.85, false, false],
        ["div2", 0, 8.505, 0, 17.01, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca053"
    },
    "shader": "#define BALLS 10\n vec2kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/-80.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.054, 0, 0.108, false, false],
        ["shapeMultiplier", 0, 39.9, 0, 79.8, false, false],
        ["rotation", 0, 0.0195, 0, 0.039, false, false],
        ["xMultiplier", 0, 5.66, 0, 11.32, false, false],
        ["yMultiplier", 0, 535.74, 0, 1071.48, false, false],
        ["colorSpread", 0, 0.000114, 0, 0.000228, false, false],
        ["colorMultiplier", 0, 2, 0, 4, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.23, 0, 4.46, false, false],
        ["ballSize", 0, 42.87, 0, 85.74, false, false],
        ["glow", 0, 3.54, 0, 7.08, false, false],
        ["contrast", 0, 2.13, 0, 4.26, false, false],
        ["radius", 0, 16.47, 0, 32.94, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca068"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * tan(dist*t+stream/20.)*sin(dist);\n    float y = t*radius * cos(dist*t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.46, 0, 4.92, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 2.32, 0, 4.64, false, false],
        ["colorShift", 0, 6.24, 0, 12.48, false, false],
        ["outer", 0, 2.78, 0, 5.56, false, false],
        ["inner", 0, 0.03, 0, 0.06, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06f"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/21.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/21.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .7)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 31.68, 0, 111, false, false],
        ["contrast", 0, 1.03, 0, 2, false, false],
        ["orbSize", 0, 2, 0.01, 2, false, false],
        ["radius", 0, 13, 1, 115, false, false],
        ["colorShift", 0, 7.12, 4, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["rotation", 0, 0, 0, 2, false, false],
        ["sinMul", 0, 2, 0, 2, false, false],
        ["cosMul", 0, 0.94, 0, 3, false, false],
        ["yMul", 0, 0.14, 0, 1, false, false],
        ["xMul", 0, 0.05, 0, 5, false, false],
        ["xSpeed", 0, -0.5, -1, 1, false, false],
        ["ySpeed", 0, 0.5, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.2, 0, 19, false, false],
        ["xDivide", 0, 2.08, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca093"
    },
    "shader": "precision highp float;\n\n\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 p = 2.3 / abs(vec2(.5 / shape));\n  p /= abs(tan(sin((xShape * uv.x)) * (cos(yShape * uv.y))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (colorShape - uv.x/100. - stream/6.)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y + cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.b = .960;\n  gl_FragColor.g *= .4242 + sin(uv.y/2.);\n}",
    "variants": [
      [
        ["zoom", 0, 3.059, 0, 10, false, false],
        ["xShape", 0, 20, 0, 20, false, false],
        ["yShape", 0, 20, 0, 20, false, false],
        ["colorShape", 0, 0.126, 0, 1, false, false],
        ["contrast", 0, 0.575, 0, 1, false, false],
        ["ballSize", 0, 8.842, 0, 13, false, false],
        ["shape", 0, 0.212, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a56"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a0"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *= k_rotate2d(stream / 70.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += xOuter * float(i / 20) * cos(uv.y / yDivider + stream / 21.) + sin(uv.x / 50. - stream / 8.);\n    uv.x += yOuter * float(i) * sin(uv.x / xDivider + stream / 21.) * sin(uv.y / 50. + stream / 5.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 58.06, 0, 116.12, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 345.32, 0, 690.64, false, false],
        ["multiplier", 0, 5.87, 0, 11.74, false, false],
        ["ballSize", 0, 0.2, 0, 0.4, false, false],
        ["contrast", 0, 1.86, 0, 3.72, false, false],
        ["radius", 0, 9.94, 0, 19.88, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a7"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t*radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 8.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a58"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0aa"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length((uv));\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * cos(dist * t) - cos(stream) * cos(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.2, 0, 12.4, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.12, 0, 0.24, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 1.15, 0, 2.3, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.37, 0, 0.74, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a58"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b4"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.26, 0, 0.52, false, false],
        ["contrast", 0, 6.4, 0, 12.8, false, false],
        ["ballSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1.54, 0, 3.08, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0.98, 0, 1.96, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0bc"
    },
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream*2.+abs(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.)*pow(dist, 3.)*pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.63, 0, 1, false, false],
        ["contrast", 0, 2.58, 0, 8, false, false],
        ["ballSize", 0, 0.01, 0, 0.05, false, false],
        ["radius", 0, 131.23, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c3"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.41, 0, 0.82, false, false],
        ["contrast", 0, 5.5, 0, 11, false, false],
        ["ballSize", 0, 0.02, 0, 0.04, false, false],
        ["radius", 0, 221.83, 0, 443.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c9"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.053, 0, 0.13, false, false],
        ["shapeMultiplier", 0, 223.96, 0, 447.92, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 217.723, 0, 3385.88, false, false],
        ["yMultiplier", 0, 157.966, 0, 1223, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.863, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.636, 0, 7.72, false, false],
        ["ballSize", 0, 17.795, 0, 18.74, false, false],
        ["glow", 0, 0.714, 0, 2.32, false, false],
        ["contrast", 0, 2.278, 0, 10, false, false],
        ["radius", 0, 15.459, 0, 23.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0cb"
    },
    "shader": "#define BALLS 15\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  uv *= rotate2d(stream/-3. + length(cos(uv-stream))/1.);\n  uv = zoom * (log(abs(uv)) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.044, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 30.11, 0, 301, false, false],
        ["rotation", 0, 0.0195, 0.009, 0.041, false, false],
        ["xMultiplier", 0, 376.89, 0, 1000, false, false],
        ["yMultiplier", 0, 0, 0, 1000, false, false],
        ["colorSpread", 0, 0.000114, 0, 0.001, false, false],
        ["colorMultiplier", 0, 2, 0, 2, false, false],
        ["brightness", 0, 3.34, 0, 10, false, false],
        ["ballSize", 0, 17.33, 0, 100, false, false],
        ["glow", 0, 2.39, 0, 4, false, false],
        ["contrast", 0, 1.5, 0, 5, false, false],
        ["radius", 0, 10.09, 0, 120, false, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d0"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 44.72, 0, 1000, false, false],
        ["rotation", 0, 0.12, 0, 1, false, false],
        ["xMultiplier", 0, 0, 0, 1500, false, false],
        ["yMultiplier", 0, 196.12, 0, 1000, false, false],
        ["colorSpread", 0, 0.0008, 0, 0.004, false, false],
        ["colorMultiplier", 0, 0.78, 0, 1, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 7.62, 0, 10, false, false],
        ["ballSize", 0, 77.69, 0, 100, false, false],
        ["glow", 0, 0.59, 0, 4, false, false],
        ["contrast", 0, 3.86, 0, 5, false, false],
        ["radius", 0, 25.13, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d9"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .001 * dot(uv, uv) * sin(dot(abs(uv) * .1* sin(uv), uv)/1000.) - stream/5.) + log(uv.x / 1.);// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div + stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * tan(t-stream/16.) * cos(t+stream/22.114) ;\n    float y = radius * cos(t - stream/12.2) * cos(t-stream/PI) * tan(t+stream/13.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 3.)*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 34.88, 0, 69.76, false, false],
        ["contrast", 0, 1.42, 0, 2.84, false, false],
        ["orbSize", 0, 1, 0, 2, false, false],
        ["radius", 0, 6.66, 0, 13.32, false, false],
        ["colorShift", 0, 11.52, 0, 23.04, false, false],
        ["div", 0, 10.803, 0, 21.606, false, false],
        ["div2", 0, 11.573, 0, 23.146, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0de"
    },
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n \nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/30.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, .7)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.41, 0, 22, false, false],
        ["yDivider", 0, 25.18, 0.1, 122, false, false],
        ["xDivider", 0, 3.99, 0.1, 19, false, false],
        ["multiplier", 0, 5.86, 0.01, 11, false, false],
        ["ballSize", 0, 0.19, 0, 1, false, false],
        ["contrast", 0, 0.87, 0, 5, false, false],
        ["radius", 0, 0.09, 0, 11, false, false],
        ["rotation", 0, 0.22587259377776392, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0.18, 0, 1, false, false],
        ["c", 0, 1.61, 0, 8, false, false],
        ["d", 0, 3.05, 1, 13, false, false],
        ["e", 0, 0.34, 0, 2, false, false],
        ["f", 0, 0.95, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e1"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream))/2. + stream/4.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 2.2);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream), radius * sin(sinMul * t + stream));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .25)/2.5 * pow(dist, 1.15) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.466, 0, 15.792, false, false],
        ["contrast", 0, 1.077, 0, 3.02, false, false],
        ["ballSize", 0, 0.39, 0, 1, false, false],
        ["radius", 0, 1.617, 0, 14.4, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, -7.539, -10, 10, false, false],
        ["dotMultiplier", 0, 4.4, 0, 12, false, false],
        ["tanMul", 0, 3.857, 0, 18.7, false, false],
        ["sinMul", 0, 1.239, 0, 5.6, false, false],
        ["shift", 0, 0.845, 0, 1, false, false],
        ["offset", 0, 0.808, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e4"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv = sin(stream*1.+(1.-log(sin(uv))));\n  // uv *= k_rotate2d(stream);\n  uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 1.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 10. + float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t), sinMul * sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.778, 0, 1.556, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 0.1491, 0, 0.2982, false, false],
        ["radius", 0, 2.25, 0, 4.5, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 2.17, 0, 4.34, false, false],
        ["dotMultiplier", 0, 5, 0, 10, false, false],
        ["tanMul", 0, 0.9, 0, 1.8, false, false],
        ["sinMul", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f69"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float radius = radius * pow(volume, .5);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -.7;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t-stream), radius *\ncos(t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (length(uv)/10000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .6)/4.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6455.31160805723, 0, 21622.18, false, false],
        ["ballSize", 0, 11076.110481927713, 0, 12120.2, false, false],
        ["contrast", 0, 1.4018456312432348, 0, 8.94, false, false],
        ["radius", 0, 20278.94704856131, 0, 23223, false, false],
        ["yOuter", 0, 2184.1534747983637, 0, 2225.42, false, false],
        ["xOuter", 0, 115.20098983433736, 0, 302.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.2490805134600906, 0, 7.36, false, false],
        ["yMultiplier", 0, 19.24, 0, 19.24, false, false],
        ["divider", 0, 4.888253012048193, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f6b"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.1)/7.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.467786754929877, 0, 62.18, false, false],
        ["ballSize", 0, 0.31868131868131866, 0, 1, false, false],
        ["contrast", 0, 2.8809567326924888, 0, 8.94, false, false],
        ["radius", 0, 0.4156118107071843, 0, 0.66, false, false],
        ["yOuter", 0, 17.969914545633713, 0, 25.42, false, false],
        ["xOuter", 0, 27.03570903824037, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.0018560335090365, 0, 7.36, false, false],
        ["yMultiplier", 0, 19.24, 0, 19.24, false, false],
        ["divider", 0, 6.095766072100905, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa2"
    },
    "shader": "#define orbs 5.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 11.702141378012051, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 4.165304969879518, 4, 10, false, false],
        ["x1", 0, 1.3229480421686748, 0, 3, false, false],
        ["x2", 0, 1, 0, 1, false, false],
        ["y1", 0, 0.34014495481927715, 0, 1, false, false],
        ["y2", 0, 1.1094926581325302, 0, 5, false, false],
        ["center", 0, 7.340615587349399, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 6.943693524096386, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.35281795933734944, 0.01, 2, false, false],
        ["radius", 0, 1.463413027108434, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0, 0, 1, false, false],
        ["x2", 0, 0.07756023333999278, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 3.9954113328313263, 0, 5, false, false],
        ["center", 0, 9.759704442771085, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.516971009036148, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.6914401355421687, 0.01, 2, false, false],
        ["radius", 0, 1.0743787650602412, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0.006485316265060244, 0, 1, false, false],
        ["x2", 0, 0.39095914909638557, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 0.29673381024096396, 0, 5, false, false],
        ["center", 0, 2.7102409638554223, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 15.777244917168678, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 5.551138930722892, 4, 10, false, false],
        ["x1", 0, 0.30045180722891573, 0, 3, false, false],
        ["x2", 0, 1, 0, 1, false, false],
        ["y1", 0, 0.5074830572289157, 0, 1, false, false],
        ["y2", 0, 3.37050545933735, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fca"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.96, 0, 15, false, false],
        ["contrast", 0, 0.85, 0, 2, false, false],
        ["orbSize", 0, 0.15, 0.01, 1, false, false],
        ["radius", 0, 1.15, 1, 5, false, false],
        ["colorShift", 0, 79.53, 1, 110, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fce"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(cos(sin(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv += (i + 1.) / 10.;\n    uv *= k_rotate2d(i + stream / 4.);\n    uv.x /= abs(dist + distMul * dist * (i + 1.));\n    float t = (i) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.); // / cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 2.); // + sin(t-stream/1.) - cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.39, 0, 4.78, false, false],
        ["contrast", 0, 1.81, 0, 3.62, false, false],
        ["orbSize", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 2.51, 0, 5.02, false, false],
        ["colorShift", 0, 9.12, 0, 18.24, false, false],
        ["distMul", 0, 0.00668, 0, 0.01336, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd2"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(cos(sin(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv += (i+1.)/10.;\n      uv *= rotate(i+stream/4.);\n      uv.x /= abs(dist+distMul* dist*(i+1.));\n      float t = (i) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);// / cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// + sin(t-stream/1.) - cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.39, 0, 4.78, false, false],
        ["contrast", 0, 1.81, 0, 3.62, false, false],
        ["orbSize", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 2.51, 0, 5.02, false, false],
        ["colorShift", 0, 9.12, 0, 18.24, false, false],
        ["distMul", 0, 0.00668, 0, 0.01336, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd1"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= rotate(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= rotate(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.64, 0, 5.28, false, false],
        ["contrast", 0, 1.38, 0, 2.76, false, false],
        ["orbSize", 0, 0.56, 0, 1.12, false, false],
        ["radius", 0, 4.35, 0, 8.7, false, false],
        ["colorShift", 0, 7.26, 0, 14.52, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 2, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe5"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.2);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .14) * _uv.y/div - stream/.2));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.43 - t*PI), radius*tan(t - stream/-.9));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.13- uv.y/(.7*y + .3*y*sin(stream/.7393))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.4  * float(i) / 6.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 896292.749, 0.01, 2111000, false, false],
        ["ballSize", 0, 14111.872, 0, 36122, false, false],
        ["contrast", 0, 3.24, 0, 5, false, false],
        ["radius", 0, 82008340.58, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 155941108.62, 10000000, 192999999, false, false],
        ["y", 0, 10885833.37, 0, 119133112, false, false],
        ["rotation", 0, 0.00231, 0, 0.01, false, false],
        ["colorOffset", 0, 210.34, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 39960.707, 1, 100000, false, false],
        ["div2", 0, 916935.078, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fda"
    },
    "shader": "#define orbs 40.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / -6.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (.3 + .2*sin(6.*cos(_uv.x/div2 + stream / 1.3) * _uv.y/div - stream/2.1));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(.5*sin(t*PI), 1.5*tan(t/PI));\n    p /= sin(stream/1.+PI * sin(uv.x/x)*cos(stream+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 305.431, 0.01, 1000, false, false],
        ["ballSize", 0, 0.013, 0, 0.1, false, false],
        ["contrast", 0, 2.97, 0, 5, false, false],
        ["radius", 0, 65.75, 0, 200, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 10.13, 0, 1100, false, false],
        ["y", 0, 20.69, 0, 1100, false, false],
        ["rotation", 0, 1, 0, 4, false, false],
        ["colorOffset", 0, 470.97, 0, 1110, false, false],
        ["sides", 0, 2, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 834.574, 0, 11200, false, false],
        ["div2", 0, 9681.278, 0, 12001, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe1"
    },
    "shader": "#define orbs 25.\n\nvoid main () {\n  float stream = stream / 5.3;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  // uv *= k_rotate2d(stream / -3.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= .2*sin(.237525*cos(_uv.y/-1000. + stream / -1.) - _uv.y/10000. - stream/2.49);\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (1. + 1.);\n    vec2 p = radius*vec2(1.*sin(t - stream/-.9), 1.5*tan(t - stream/.95));\n    p /= sin(stream/1.+PI * sin(uv.x/x - stream/1.7)*cos(stream/1.8+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.82 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(.8-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2823.331, 0.01, 11143, false, false],
        ["ballSize", 0, 0.13, 0, 2, false, false],
        ["contrast", 0, 2.69, 0, 5, false, false],
        ["radius", 0, 222, 0, 222, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 90.77, 0, 400, false, false],
        ["y", 0, 50.54, 0, 100, false, false],
        ["rotation", 0, 1, 0, 3, false, false],
        ["colorOffset", 0, 496.96, 0, 1110, false, false],
        ["sides", 0, 2, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff4"
    },
    "shader": "\n#define BALLS 10.\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= rotate2d(float(i));\n\t  //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream/10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15)*dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow(volume, 2.)*pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 2, false, false],
        ["contrast", 0, 1.37, 0, 3, false, false],
        ["ballSize", 0, 0.13, 0, 0.2, false, false],
        ["radius", 0, 22.12, 1, 51, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca007"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(.1 * dot(uv, uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * abs(sin(time / 3.)) * (dist / .5) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / 5.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(.5 * uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 13. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.42, 0, 2.84, false, false],
        ["ballSize", 0, 447.757, 0, 895.514, false, false],
        ["contrast", 0, 0.89, 0, 1.78, false, false],
        ["radius", 0, 31.75, 0, 63.5, false, false],
        ["yOuter", 0, 353.18, 0, 706.36, false, false],
        ["xOuter", 0, 141.2, 0, 282.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3795.54, 0, 7591.08, false, false],
        ["yMultiplier", 0, 30.28, 0, 60.56, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, -0.0024, -0.0048, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca010"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  vec2 _uv = uv;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *= rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/2.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4. + .01*uv))*cos(uv.x/xDiv - stream/4.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 53.73293577243752, 0, 117.14, false, false],
        ["yDivider", 0, 2.1694277108433737, 0, 4, false, false],
        ["xDivider", 0, 4.430280496987952, 0, 18, false, false],
        ["multiplier", 0, 1.2283603162650605, 0, 2, false, false],
        ["ballSize", 0, 7.5453642695783145, 0, 33, false, false],
        ["contrast", 0, 0.6708647402108434, 0, 2.38, false, false],
        ["radius", 0, 128.25703125, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 151.80625, 0, 332, false, false],
        ["xDiv2", 0, 15.67018542921687, 0, 33, false, false],
        ["itY", 0, 0.1551346009036145, 0, 0.2, false, false],
        ["itX", 0, 0.09707172439759039, 0, 0.2, false, false],
        ["oS", 0, 0.249378765060241, 0, 2, false, false],
        ["oT", 0, 0.6427899096385543, 0, 2, false, false],
        ["yShape", 0, 4.247590361445784, 0, 32, false, false]
      ],
      [
        ["zoom", 0, 32.46323842243976, 0, 117.14, false, false],
        ["yDivider", 0, 2.951618975903615, 0, 4, false, false],
        ["xDivider", 0, 0.42119728915662663, 0, 18, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 21.58139118975904, 0, 33, false, false],
        ["contrast", 0, 1.1464503012048195, 0, 2.38, false, false],
        ["radius", 0, 165.77595067771088, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 23.026562500000004, 0, 332, false, false],
        ["xDiv2", 0, 33, 0, 33, false, false],
        ["itY", 0, 0.041319008087971405, 0, 0.2, false, false],
        ["itX", 0, 0, 0, 0.2, false, false],
        ["oS", 0, 0, 0, 2, false, false],
        ["oT", 0, 1.8478727409638558, 0, 2, false, false],
        ["yShape", 0, 25.166716867469884, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca019"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 6;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/10.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=100.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =11.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.982, 0, 4, false, false],
        ["size", 0, 2.039, 0, 3, false, false],
        ["offc", 0, 0, 0, 2, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 2.933, 0, 332, false, false],
        ["_x", 0, 0.517, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca026"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (17.1, 311.7)),\n\t\t\t  dot (p, vec2 (29.5, 13.3)));\n\n\treturn -1. + 1021.*fract (sin (p)*43758.5453123 * sin(stream/1000000.) * cos(stream/10000.));\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return abs(uv) * outer * sin(stream/20.) * sin(dot(uv, uv) - stream*3.);//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n} \n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length(sin(uv-34.21*stream));\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + fbm (a*uv + stream)));\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * fbm (b*uv + stream)));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc * (uv.x-log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(tan(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.57, 0, 2, false, false],
        ["thickness", 0, 0.0008, 0, 0.1, false, false],
        ["haze", 0, 723.56, 2, 1100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.007, 0, 0.05, false, false],
        ["a", 0, 4.13, 0, 100, false, false],
        ["b", 0, 4.01, 0, 50, false, false],
        ["c", 0, 38.22, 0, 50, false, false],
        ["outer", 0, 1.1, 0, 5, false, false],
        ["inner", 0, 3.56, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca048"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv - 10.*cos( .005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 21.18, 0, 42.36, false, false],
        ["contrast", 0, 0.8, 0, 1.6, false, false],
        ["orbSize", 0, 0.2, 0, 0.4, false, false],
        ["radius", 0, 6.65, 0, 13.3, false, false],
        ["colorShift", 0, 9.24, 0, 18.48, false, false],
        ["div", 0, 40, 0, 80, false, false],
        ["div2", 0, 40, 0, 80, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04d"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.69, 0, 1.38, false, false],
        ["contrast", 0, 1.3, 0, 2.6, false, false],
        ["orbSize", 0, 0.67, 0, 1.34, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 9.96, 0, 19.92, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0, 0, 0, false, false],
        ["yMul", 0, 1, 0, 2, false, false],
        ["xMul", 0, 4.91, 0, 9.82, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0049, 0, 0.0098, false, false],
        ["yDivide", 0, 5.34, 0, 10.68, false, false],
        ["xDivide", 0, 1.73, 0, 3.46, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca059"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  float stream = stream / 4.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / (i + 1.) / 100.);\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream / 20.) * sin(dist);\n    float y = t * radius * cos(dist * t);\n    vec2 position = vec2(x, y);\n    vec3 color =  cos( vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += pow(volume, .57) * k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.86, 0, 4.92, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 4.64, 0, 4.64, false, false],
        ["colorShift", 0, 6.24, 0, 12.48, false, false],
        ["outer", 0, 2.78, 0, 5.56, false, false],
        ["inner", 0, 0.047, 0, 0.06, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05d"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= outer * sin(inner * dot(uv, 10.1 * uv) - stream);\n  //  uv /= sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * sin(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.4, 0, 6.8, false, false],
        ["contrast", 0, 1.11, 0, 2.22, false, false],
        ["orbSize", 0, 0.08, 0, 0.16, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.35, 0, 10.7, false, false],
        ["outer", 0, 0.61, 0, 1.22, false, false],
        ["inner", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca062"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 20.1 * uv) - stream);\n  uv /= sin(.01 * dot(uv + sin(1. * uv), 20.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.23, 0, 4.46, false, false],
        ["contrast", 0, 1.21, 0, 2.42, false, false],
        ["orbSize", 0, 0.2, 0, 0.4, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06a"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * tan(dist*t+stream/20.)*sin(dist);\n    float y = t*radius * cos(dist*t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.41, 0, 10, false, false],
        ["contrast", 0, 1.32, 0, 2, false, false],
        ["orbSize", 0, 0.36, 0.01, 2, false, false],
        ["radius", 0, 4.94, 1, 5, false, false],
        ["colorShift", 0, 6.24, 4, 10, false, false],
        ["outer", 0, 2.78, 0, 10, false, false],
        ["inner", 0, 0.03, 0, 0.2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07a"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/2.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 21.06, 0, 50, false, false],
        ["yDivider", 0, 818.46, 0.1, 1000, false, false],
        ["xDivider", 0, 656.67, 0.1, 1000, false, false],
        ["multiplier", 0, 111, 0.1, 111, false, false],
        ["ballSize", 0, 0.1, 0, 0.3, false, false],
        ["contrast", 0, 2.03, 0, 5, false, false],
        ["radius", 0, 26.22, 0, 111, false, false],
        ["yOuter", 0, 0.12, 0, 1, false, false],
        ["xOuter", 0, 0.29, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca097"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length((uv));\n  uv *= rotate2d(stream/70.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/20)*cos(uv.y/yDivider + stream/21.) + sin(uv.x/50. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider + stream/21.) * sin(uv.y/50. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 58.06, 0, 111, false, false],
        ["yDivider", 0, 1001, 0.1, 1001, false, false],
        ["xDivider", 0, 345.32, 0.1, 1001, false, false],
        ["multiplier", 0, 5.87, 0.01, 12, false, false],
        ["ballSize", 0, 0.2, 0, 1, false, false],
        ["contrast", 0, 1.86, 0, 5, false, false],
        ["radius", 0, 9.94, 0, 15, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 16.71, 0, 111, false, false],
        ["yDivider", 0, 1001, 0.1, 1001, false, false],
        ["xDivider", 0, 345.32, 0.1, 1001, false, false],
        ["multiplier", 0, 5.87, 0.01, 12, false, false],
        ["ballSize", 0, 0.23, 0, 1, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 2.28, 0, 15, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 58.38, 0, 111, false, false],
        ["yDivider", 0, 1001, 0.1, 1001, false, false],
        ["xDivider", 0, 345.32, 0.1, 1001, false, false],
        ["multiplier", 0, 5.87, 0.01, 12, false, false],
        ["ballSize", 0, 0.23, 0, 1, false, false],
        ["contrast", 0, 2.21, 0, 5, false, false],
        ["radius", 0, 13.17, 0, 15, false, false],
        ["xOuter", 0, 0.5, 0, 1, false, false],
        ["yOuter", 0, 0.5, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0cf"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/-12.);\n  uv *= zoom2;\n  uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-1.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/.3) - sin(uv.y * yMultiplier + stream/-.8));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * ( 1. + uv.y/250. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.7)/3.3*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.009, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 192.45, 0, 300, false, false],
        ["rotation", 0, 0.61129, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 998.27, 0, 1500, false, false],
        ["yMultiplier", 0, 41.66, 0, 1100, false, false],
        ["colorSpread", 0, 0.00012, 0, 0.001, false, false],
        ["colorMultiplier", 0, 4.09, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.18, 0, 10, false, false],
        ["ballSize", 0, 41.18, 0, 100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 2.06, 0, 5, false, false],
        ["radius", 0, 5.93, 0, 120, false, false],
        ["zoom2", 0, 0.2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.006, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 254.58, 0, 300, false, false],
        ["rotation", 0, 0.61129, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 376.84, 0, 1500, false, false],
        ["yMultiplier", 0, 127.2, 0, 1100, false, false],
        ["colorSpread", 0, 0.00012, 0, 0.001, false, false],
        ["colorMultiplier", 0, 4.09, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.18, 0, 10, false, false],
        ["ballSize", 0, 70.45, 0, 100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 2.06, 0, 5, false, false],
        ["radius", 0, 5.93, 0, 120, false, false],
        ["zoom2", 0, 0.5, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.009, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 154.35, 0, 300, false, false],
        ["rotation", 0, 2.62987, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 471.96, 0, 1500, false, false],
        ["yMultiplier", 0, 99.64, 0, 1100, false, false],
        ["colorSpread", 0, 0.000025, 0, 0.001, false, false],
        ["colorMultiplier", 0, 5.02, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.84, 0, 10, false, false],
        ["ballSize", 0, 471.93, 0, 1100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 1.7, 0, 5, false, false],
        ["radius", 0, 16.37, 0, 120, false, false],
        ["zoom2", 0, 0.17, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f2"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 58.326, 0, 122, false, false],
        ["iterator", 0, 1.019, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 22.781, 0, 33, false, false],
        ["L", 0, 3, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.636, 0, 2, false, false],
        ["colorOffset", 0, 25.259, 0, 111, false, false],
        ["contrast", 0, 1.987, 1, 3, false, false],
        ["orbSize", 0, 6.079, 0, 13, false, false],
        ["div", 0, 7.216, 1, 12, false, false],
        ["radius", 0, 26.903, 0, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0fe"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .2716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 122, 0, 122, false, false],
        ["iterator", 0, 1.01, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 1.434, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 33, 0, 33, false, false],
        ["L", 0, 3, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.636, 0, 2, false, false],
        ["colorOffset", 0, 25.259, 0, 111, false, false],
        ["contrast", 0, 1.987, 1, 3, false, false],
        ["orbSize", 0, 6.079, 0, 13, false, false],
        ["div", 0, 7.216, 1, 12, false, false],
        ["radius", 0, 26.903, 0, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca115"
    },
    "shader": "vec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / 3.;\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 0.44, false, false],
        ["xMultiplier", 0, 35.99, 0, 71.98, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 7.81, 0, 15.62, false, false],
        ["colorSpread", 0, 7, 0, 14, false, false],
        ["colorMultiplier", 0, 111.05, 0, 222.1, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 26.92, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 3.17, 0, 6.34, false, false],
        ["rotation", 0, 11.471, 0, 22.942, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5b"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 3.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 3.)); // * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i));\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.051, 0, 0.102, false, false],
        ["shapeMultiplier", 0, 200.17, 0, 400.34, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 69.59, 0, 139.18, false, false],
        ["yMultiplier", 0, 26.63, 0, 53.26, false, false],
        ["colorSpread", 0, 0.006, 0, 0.012, false, false],
        ["colorMultiplier", 0, 0.15, 0, 0.3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.48, 0, 2.96, false, false],
        ["ballSize", 0, 2.22, 0, 4.44, false, false],
        ["glow", 0, 0.76, 0, 1.52, false, false],
        ["contrast", 0, 2.78, 0, 5.56, false, false],
        ["radius", 0, 9.97, 0, 19.94, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5c"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 10.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 2.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.xyz += lightness;\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n  gl_FragColor.r *= r;\n  gl_FragColor.g *= g;\n  gl_FragColor.b *= b;\n}",
    "variants": [
      [
        ["zoom", 0, 0.28, 0, 0.56, false, false],
        ["xMultiplier", 0, 39.33, 0, 78.66, false, false],
        ["yMultiplier", 0, 200, 0, 400, false, false],
        ["ballSize", 0, 1.04, 0, 2.08, false, false],
        ["colorSpread", 0, 0.32, 0, 0.64, false, false],
        ["colorMultiplier", 0, 519.17, 0, 1038.34, false, false],
        ["shapeMultiplier", 0, 163.55, 0, 327.1, false, false],
        ["glow", 0, 1587.64, 0, 3175.28, false, false],
        ["contrast", 0, 4.38, 0, 8.76, false, false],
        ["rotation", 0, 0.051, 0, 0.102, false, false],
        ["brightness", 0, 11100, 0, 22200, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false],
        ["lightness", 0, 0.29, 0, 0.58, false, false],
        ["r", 0, 0.06, 0, 0.12, false, false],
        ["g", 0, 0.61, 0, 1.22, false, false],
        ["b", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f72"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-58.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, 1.6)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 362.832, 0, 1000, false, false],
        ["xDiv", 0, 11.463, 0, 100, false, false],
        ["yDiv", 0, 122.317, 0, 200, false, false],
        ["xDiv2", 0, 7.522, 0, 200, false, false],
        ["yDiv2", 0, 2.89, 0, 200, false, false],
        ["xDiv3", 0, 15.832, 0, 200, false, false],
        ["yDiv3", 0, 172.525, 0, 200, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 70.762, 0, 100, false, false],
        ["contrast", 0, 1.714, 0, 2, false, false],
        ["radius", 0, 18.079, 0, 100, false, false],
        ["rotation", 0, 0.000054, 0, 0.001, false, false],
        ["xMul", 0, 0, 0, 20, false, false],
        ["yMul", 0, 13.037, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f76"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * volume / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 44.43, 0, 200, false, false],
        ["xDiv", 0, 23.574, 0, 200, false, false],
        ["yDiv", 0, 1.501, 0, 20, false, false],
        ["xDiv2", 0, 0.615, 0, 20, false, false],
        ["yDiv2", 0, 5.65, 0, 40, false, false],
        ["xDiv3", 0, 45.225, 0, 400, false, false],
        ["yDiv3", 0, 1.626, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 3.182, 0, 50, false, false],
        ["contrast", 0, 2.483, 0, 3, false, false],
        ["radius", 0, 3.828, 0, 30, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 2.243, 0, 20, false, false],
        ["yMul", 0, 17.975, 0, 20, false, false],
        ["oY", 0, 18.724, 0, 44, false, false],
        ["oX", 0, 9.734, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 39.827, 0, 200, false, false],
        ["xDiv", 0, 18.182, 0, 200, false, false],
        ["yDiv", 0, 1.991, 0, 20, false, false],
        ["xDiv2", 0, 13.074, 0, 20, false, false],
        ["yDiv2", 0, 14.892, 0, 40, false, false],
        ["xDiv3", 0, 122.944, 0, 400, false, false],
        ["yDiv3", 0, 7.251, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 2.32, 0, 50, false, false],
        ["contrast", 0, 2.351, 0, 3, false, false],
        ["radius", 0, 1.948, 0, 30, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 12.294, 0, 20, false, false],
        ["yMul", 0, 4.329, 0, 20, false, false],
        ["oY", 0, 22.667, 0, 44, false, false],
        ["oX", 0, 17.056, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 65.801, 0, 200, false, false],
        ["xDiv", 0, 86.58, 0, 200, false, false],
        ["yDiv", 0, 0.779, 0, 20, false, false],
        ["xDiv2", 0, 3.983, 0, 20, false, false],
        ["yDiv2", 0, 3.463, 0, 40, false, false],
        ["xDiv3", 0, 100.433, 0, 400, false, false],
        ["yDiv3", 0, 7.416, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 1.739, 0, 50, false, false],
        ["contrast", 0, 1.857, 0, 3, false, false],
        ["radius", 0, 4.286, 0, 30, false, false],
        ["rotation", 0, 0.000273, 0, 0.001, false, false],
        ["xMul", 0, 2.338, 0, 20, false, false],
        ["yMul", 0, 5.368, 0, 20, false, false],
        ["oY", 0, 39.81, 0, 44, false, false],
        ["oX", 0, 5.455, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 43.29, 0, 200, false, false],
        ["xDiv", 0, 35.498, 0, 200, false, false],
        ["yDiv", 0, 12.121, 0, 20, false, false],
        ["xDiv2", 0, 0.606, 0, 20, false, false],
        ["yDiv2", 0, 40, 0, 40, false, false],
        ["xDiv3", 0, 72.727, 0, 400, false, false],
        ["yDiv3", 0, 5.524, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 2.639, 0, 50, false, false],
        ["contrast", 0, 2.506, 0, 3, false, false],
        ["radius", 0, 4.935, 0, 30, false, false],
        ["rotation", 0, 0.000429, 0, 0.001, false, false],
        ["xMul", 0, 12.294, 0, 20, false, false],
        ["yMul", 0, 3.636, 0, 20, false, false],
        ["oY", 0, 20.571, 0, 88, false, false],
        ["oX", 0, 5.801, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f77"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) * cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) * sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / -1.), yMul - xMul * tan(t / multiplier - stream / 12.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream /3.) - cos(uv.y / yDiv3 - stream / 3.4));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .8) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 57.137, 0, 200, false, false],
        ["xDiv", 0, 81.385, 0, 200, false, false],
        ["yDiv", 0, 7.619, 0, 20, false, false],
        ["xDiv2", 0, 7.359, 0, 20, false, false],
        ["yDiv2", 0, 4.848, 0, 40, false, false],
        ["xDiv3", 0, 155.844, 0, 400, false, false],
        ["yDiv3", 0, 11.693, 1, 20, false, false],
        ["multiplier", 0, 1.688, 0, 3, false, false],
        ["ballSize", 0, 2.814, 0, 50, false, false],
        ["contrast", 0, 1.669, 0, 3, false, false],
        ["radius", 0, 2.208, 0, 30, false, false],
        ["rotation", 0, 0.000046, 0, 0.001, false, false],
        ["xMul", 0, 5.281, 0, 20, false, false],
        ["yMul", 0, 2.597, 0, 20, false, false],
        ["oY", 0, 23.81, 0, 44, false, false],
        ["oX", 0, 16.017, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 57.137, 0, 200, false, false],
        ["xDiv", 0, 113.42, 0, 200, false, false],
        ["yDiv", 0, 0.866, 0, 20, false, false],
        ["xDiv2", 0, 11.775, 0, 20, false, false],
        ["yDiv2", 0, 24.762, 0, 40, false, false],
        ["xDiv3", 0, 81.385, 0, 400, false, false],
        ["yDiv3", 0, 2.892, 1, 20, false, false],
        ["multiplier", 0, 1.688, 0, 3, false, false],
        ["ballSize", 0, 4.978, 0, 50, false, false],
        ["contrast", 0, 1.597, 0, 3, false, false],
        ["radius", 0, 10, 0, 30, false, false],
        ["rotation", 0, 0.00045, 0, 0.001, false, false],
        ["xMul", 0, 1.126, 0, 20, false, false],
        ["yMul", 0, 1.818, 0, 20, false, false],
        ["oY", 0, 40.19, 0, 44, false, false],
        ["oX", 0, 4.762, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 47.619, 0, 200, false, false],
        ["xDiv", 0, 45.887, 0, 200, false, false],
        ["yDiv", 0, 1.299, 0, 20, false, false],
        ["xDiv2", 0, 1.212, 0, 20, false, false],
        ["yDiv2", 0, 2.251, 0, 40, false, false],
        ["xDiv3", 0, 195.671, 0, 400, false, false],
        ["yDiv3", 0, 3.303, 1, 20, false, false],
        ["multiplier", 0, 1.688, 0, 3, false, false],
        ["ballSize", 0, 3.255, 0, 8, false, false],
        ["contrast", 0, 1.792, 0, 3, false, false],
        ["radius", 0, 5, 0, 5, false, false],
        ["rotation", 0, 0.000046, 0, 0.001, false, false],
        ["xMul", 0, 0.779, 0, 20, false, false],
        ["yMul", 0, 3.636, 0, 20, false, false],
        ["oY", 0, 20.19, 0, 44, false, false],
        ["oX", 0, 15.238, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8f"
    },
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.199, 0, 0.2, false, false],
        ["contrast", 0, 1.262, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 0.825, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.43, 0, 1, false, false],
        ["colorOffset", 0, 0, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.307, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 2.979, 0, 25.38, false, false],
        ["colorShift", 0, 0, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 4.12, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.145, 0, 1, false, false],
        ["contrast", 0, 1.35, 0, 2.92, false, false],
        ["orbSize", 0, 8.789, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 1.277, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 5, 0, 5, false, false],
        ["b", 0, 0.19, 0, 5, false, false],
        ["c", 0, 1.77, 0, 5, false, false],
        ["d", 0, 0.47, 0, 1, false, false],
        ["colorOffset", 0, 2.06, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.994, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.8, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.089, 0, 1, false, false],
        ["contrast", 0, 0.617, 0, 2.92, false, false],
        ["orbSize", 0, 0.993, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.227, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, false, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0, 0, 5, false, false],
        ["c", 0, 0, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa6"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 0.64, 0, 1.28, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0.91, 0, 1.82, false, false],
        ["y1", 0, 0.37, 0, 0.74, false, false],
        ["y2", 0, 1.86, 0, 3.72, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ],
      [
        ["zoom", 0, 24.7, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.204, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 2.6, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 0.394, 0, 3.72, false, false],
        ["center", 0, 13.273, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 11.101, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.003, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 4.625, 0, 8.82, false, false],
        ["x1", 0, 0.053, 0, 0.2, false, false],
        ["x2", 0, 1.82, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 3.72, 0, 3.72, false, false],
        ["center", 0, 3.859, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fee"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/(PI*10.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.049, 0, 1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 4.962735316265062, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.45104942723058306, 0, 2, false, false],
        ["div", 0, 0.10004955760542171, 0.01, 1, false, false],
        ["radius", 0, 3.176, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ffe"
    },
    "shader": "#define orbs 2.\n\nvoid main() { \n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 6.;\n  float dist = length(uv + sin(uv + sin(stream))); \n  for (float i = 0.; i < orbs; i++) {\n    float rot = -rotation * abs(stream + dist / .2);\n    uv *= k_rotate2d(rotation * .12 + rot + stream / PI); \n    float t = i * PI / i * (5. + 1.) / divider; // + stream/50.;\n    float a = cos(uv.y - stream / .5);\n    float b = cos(uv.x * sin(uv.y / 1.)); \n    float c = radius * sin(stream+t) * 20. * b;\n    vec2 p = vec2(xOuter * a * uv.x + c, 0.);\n    vec3 col = k_rainbow(i / orbs, 0., 0.);\n    gl_FragColor += k_orb(uv, ballSize, p, col, contrast);\n  }\n\n  gl_FragColor.xyz = 1.-pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor = k_hue(gl_FragColor, stream + uv.x/5.);\n}",
    "variants": [
      [
        ["zoom", 0, 12.078, 0, 21.456, false, false],
        ["ballSize", 0, 2.904, 0, 5.808, false, false],
        ["contrast", 0, 1.34, 0, 2.5600000000000014, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 10.2, 0, 20.4, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["divider", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.02, 0, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a48"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01b"
    },
    "shader": "// Ether by nimitz 2014 (twitter: @stormoid)\n// https://www.shadertoy.com/view/MsjSW3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define t stream / 5.\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\nfloat map(vec3 p){\n    p.xz*= m(t*.94);p.xy*= m(t*0.3);\n    vec3 q = p*3.+t;\n    return length(p+vec3(sin(t*1.7)))*log(length(p)+1.5) + sin(q.x+cos(q.z+sin(q.y)))*1.05 - 2.;\n}\n\nvoid main(){\t\n\tvec2 p = gl_FragCoord.xy/resolution.y - vec2(.9,.5);\n  p *= zoom;\n\n    vec3 cl = vec3(0.);\n    float d = -2.;\n    for(int i=0; i<=8; i++)\t{\n\t\tvec3 p = vec3(0,-0,5) + normalize(vec3(p,-.5))*d;\n        float rz = map(p);\n\t\tfloat f =  clamp((rz - map(p+.1))*0.5, -2.1, .5 );\n        vec3 l = vec3(0.1,0.3,.04) + vec3(-5., -.5, 3.)*f;\n        cl = cl*l + smoothstep(10.5, .0, rz)*.7*l;\n\t\td += min(rz, 2.);\n\t}\n    gl_FragColor = vec4(cl, 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.822, 0, 16, false, false],
        ["X", 0, 30.043, 0, 121, false, false],
        ["Y", 0, 26.803, 0, 112, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca020"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.52, 0, 2, false, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca031"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 22.15, 0, 41, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 1.09, 0.01, 2, false, false],
        ["radius", 0, 5.14, 1, 14, false, false],
        ["colorShift", 0, 10.07, 3, 16, false, false],
        ["div", 0, 22.037, 0, 100, false, false],
        ["div2", 0, 19.684, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca039"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = zoom * uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 22.15, 0, 41, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 1.09, 0.01, 2, false, false],
        ["radius", 0, 5.14, 1, 14, false, false],
        ["colorShift", 0, 10.07, 3, 16, false, false],
        ["div", 0, 22.037, 0, 100, false, false],
        ["div2", 0, 19.684, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca042"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 67.31, 0, 151, false, false],
        ["contrast", 0, 1.49, 0, 2, false, false],
        ["orbSize", 0, 1.05, 0.01, 2, false, false],
        ["radius", 0, 3.77, 0, 14, false, false],
        ["colorShift", 0, 23.99, 3, 33, false, false],
        ["div", 0, 17.974, 10, 40, false, false],
        ["div2", 0, 27.909, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07d"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04b"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 19.33, 0, 38.66, false, false],
        ["contrast", 0, 1.55, 0, 3.1, false, false],
        ["orbSize", 0, 1.79, 0, 3.58, false, false],
        ["radius", 0, 4.12, 0, 8.24, false, false],
        ["colorShift", 0, 16, 0, 32, false, false],
        ["div", 0, 11.62, 0, 23.24, false, false],
        ["div2", 0, 32.974, 0, 65.948, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a5"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 1, false, false],
        ["yDivider", 0, 825.61, 0.1, 1001, false, false],
        ["xDivider", 0, 794.72, 0.1, 1001, false, false],
        ["multiplier", 0, 3.11, 0.01, 12, false, false],
        ["ballSize", 0, 0.22, 0, 1, false, false],
        ["contrast", 0, 1.96, 0, 5, false, false],
        ["radius", 0, 9.94, 0, 15, false, false],
        ["xOuter", 0, 0.85, 0, 1, false, false],
        ["yOuter", 0, 0.38, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b0"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume * pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["contrast", 0, 4.99, 0, 9.98, false, false],
        ["ballSize", 0, 0.011, 0, 0.022, false, false],
        ["radius", 0, 45.33, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b5"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume * pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.41, 0, 0.82, false, false],
        ["contrast", 0, 5.5, 0, 11, false, false],
        ["ballSize", 0, 0.02, 0, 0.04, false, false],
        ["radius", 0, 221.83, 0, 443.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c0"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.41, 0, 21, false, false],
        ["contrast", 0, 5.5, 0, 8, false, false],
        ["ballSize", 0, 0.02, 0, 0.1, false, false],
        ["radius", 0, 221.83, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c7"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.053, 0, 0.13, false, false],
        ["shapeMultiplier", 0, 223.96, 0, 447.92, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 217.723, 0, 3385.88, false, false],
        ["yMultiplier", 0, 157.966, 0, 1223, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.863, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.636, 0, 7.72, false, false],
        ["ballSize", 0, 17.795, 0, 18.74, false, false],
        ["glow", 0, 0.714, 0, 2.32, false, false],
        ["contrast", 0, 2.278, 0, 10, false, false],
        ["radius", 0, 15.459, 0, 23.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ce"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.028, false, false],
        ["shapeMultiplier", 0, 589.178, 0, 1518.42, false, false],
        ["rotation", 0, 0.012, 0, 0.05134, false, false],
        ["xMultiplier", 0, 251.592, 0, 1469.28, false, false],
        ["yMultiplier", 0, 1549.9, 0, 11111, false, false],
        ["colorSpread", 0, 0.000012, 0, 0.000024, false, false],
        ["colorMultiplier", 0, 0.51, 0, 1.02, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.86, 0, 3.72, false, false],
        ["ballSize", 0, 6.194, 0, 28.78, false, false],
        ["glow", 0, 4.435, 0, 7.58, false, false],
        ["contrast", 0, 3.189, 0, 4.3, false, false],
        ["radius", 0, 10.691, 0, 38.32, false, false],
        ["zoom2", 0, 0.48, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f3"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/21.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * sin(stream - uv.y), radius*cos(stream/1.+(-1. + 2. * gl_FragCoord.xy / resolution.xy).y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 13, 0, 13, false, false],
        ["iterator", 0, 1.061, 0, 2, false, false],
        ["ot", 0, 70.614, 0, 151, false, false],
        ["I", 0, 0.416, 0, 3, false, false],
        ["J", 0, 0.918, 0, 3, false, false],
        ["K", 0, 11, 0, 11, false, false],
        ["iterations", 0, 36, 0, 133, false, false],
        ["L", 0, 5.129, 0, 13, false, false],
        ["M", 0, 6.292, 0, 11, false, false],
        ["colorShift", 0, 0.747, 0, 2, false, false],
        ["colorOffset", 0, 6.72, 0, 111, false, false],
        ["contrast", 0, 1.466, 1, 3, false, false],
        ["orbSize", 0, 0.31, 0, 0.31, false, false],
        ["div", 0, 9.935, 0.01, 12, false, false],
        ["radius", 0, 5.111, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ff"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, .1,vec2(radius*sin(stream/30.+uv.x/div), radius*cos(stream/30.+uv.y/div)),  col, contrast);\n  }\n\n\n  vec3 c = vec3(ot * I + length(uv));\n            \n}",
    "variants": [
      [
        ["zoom", 0, 19.027, 0, 21, false, false],
        ["iterator", 0, 0.935, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 1.152, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 26.455, 0, 33, false, false],
        ["L", 0, 3.908, 0, 13, false, false],
        ["M", 0, 0.149, 0, 11, false, false],
        ["colorShift", 0, 0.572, 0, 1, false, false],
        ["colorOffset", 0, 7.555, 0, 11, false, false],
        ["contrast", 0, 1.747, 1, 3, false, false],
        ["orbSize", 0, 0.645, 0, 1, false, false],
        ["div", 0, 0.183, 0.1, 1, false, false],
        ["radius", 0, 1, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca08d"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs + stream;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 14.56, 0, 29.12, false, false],
        ["contrast", 0, 1.05, 0, 2.1, false, false],
        ["orbSize", 0, 0.38, 0, 0.76, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 11.52, 0, 23.04, false, false],
        ["div", 0, 12.392, 0, 24.784, false, false],
        ["div2", 0, 11.325, 0, 22.65, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca112"
    },
    "shader": "\n\n#define BALLS 5\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n\tuv *= zoom;\n\tfloat dist = length(uv);\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream));\n  float _grid = (cos(uv.x * xMultiplier) - sin(uv.y * yMultiplier + stream));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 4. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.18, 0, 1, false, false],
        ["xMultiplier", 0, 18.25, 0, 200, false, false],
        ["yMultiplier", 0, 93.68, 0, 200, false, false],
        ["ballSize", 0, 4.54, 0, 12, false, false],
        ["colorSpread", 0, 1.88, 0.2, 7, false, false],
        ["colorMultiplier", 0, 147.98, 1, 500, false, false],
        ["shapeMultiplier", 0, 68.34, 0, 210, false, false],
        ["glow", 0, 9407.33, 0, 10000, false, false],
        ["contrast", 0, 5.1, 1, 10, false, false],
        ["rotation", 0, 0.00778, 0, 0.01, false, false],
        ["brightness", 0, 0.82, 0, 1, false, false],
        ["sides", 0, 12, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f66"
    },
    "shader": "\n\n#define BALLS 15\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/10.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist * stream/2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.44, 0, 0.88, false, false],
        ["xMultiplier", 0, 39.33, 0, 78.66, false, false],
        ["yMultiplier", 0, 33.24, 0, 66.48, false, false],
        ["ballSize", 0, 1.31, 0, 2.62, false, false],
        ["colorSpread", 0, 0.27, 0, 0.54, false, false],
        ["colorMultiplier", 0, 554.68, 0, 1109.36, false, false],
        ["shapeMultiplier", 0, 163.55, 0, 327.1, false, false],
        ["glow", 0, 1083.42, 0, 2166.84, false, false],
        ["contrast", 0, 4.3, 0, 8.6, false, false],
        ["rotation", 0, 1.927, 0, 3.854, false, false],
        ["brightness", 0, 11100, 0, 22200, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f68"
    },
    "shader": "\n\n#define BALLS 5\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle),\n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tif (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist - stream/2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream/200.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.14, 1, 115, false, false],
        ["xMultiplier", 0, 63.13, 0, 200, false, false],
        ["yMultiplier", 0, 0, 0, 50, false, false],
        ["ballSize", 0, 1.18, 0, 20, false, false],
        ["colorSpread", 0, 2.77, 0.2, 70, false, false],
        ["colorMultiplier", 0, 282.59, 1, 1500, false, false],
        ["shapeMultiplier", 0, 21.93, 0, 210, false, false],
        ["glow", 0, 10350.68, 0, 102210, false, false],
        ["contrast", 0, 4.57, 1, 10, false, false],
        ["rotation", 0, 4.072, 0, 5, false, false],
        ["brightness", 0, 2311.66, 0, 11100, false, false],
        ["sides", 0, 7, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f79"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 30.303, 0, 200, false, false],
        ["xDiv", 0, 6.061, 0, 200, false, false],
        ["yDiv", 0, 1.126, 0, 20, false, false],
        ["xDiv2", 0, 1.818, 0, 20, false, false],
        ["yDiv2", 0, 2.251, 0, 40, false, false],
        ["xDiv3", 0, 45.225, 0, 400, false, false],
        ["yDiv3", 0, 3.119, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 46.211, 0, 50, false, false],
        ["contrast", 0, 2.483, 0, 3, false, false],
        ["radius", 0, 15.486, 0, 30, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 1.595, 0, 20, false, false],
        ["yMul", 0, 7.948, 0, 20, false, false],
        ["oY", 0, 14.309, 0, 44, false, false],
        ["oX", 0, 10.51, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 65.801, 0, 200, false, false],
        ["xDiv", 0, 86.58, 0, 200, false, false],
        ["yDiv", 0, 0.779, 0, 20, false, false],
        ["xDiv2", 0, 3.983, 0, 20, false, false],
        ["yDiv2", 0, 3.463, 0, 40, false, false],
        ["xDiv3", 0, 100.433, 0, 400, false, false],
        ["yDiv3", 0, 7.416, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 18.615, 0, 50, false, false],
        ["contrast", 0, 1.857, 0, 3, false, false],
        ["radius", 0, 4.286, 0, 30, false, false],
        ["rotation", 0, 0.000273, 0, 0.001, false, false],
        ["xMul", 0, 2.338, 0, 20, false, false],
        ["yMul", 0, 5.368, 0, 20, false, false],
        ["oY", 0, 39.81, 0, 44, false, false],
        ["oX", 0, 5.455, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 43.29, 0, 200, false, false],
        ["xDiv", 0, 35.498, 0, 200, false, false],
        ["yDiv", 0, 12.121, 0, 20, false, false],
        ["xDiv2", 0, 0.606, 0, 20, false, false],
        ["yDiv2", 0, 40, 0, 40, false, false],
        ["xDiv3", 0, 72.727, 0, 400, false, false],
        ["yDiv3", 0, 5.524, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 44.805, 0, 50, false, false],
        ["contrast", 0, 2.506, 0, 3, false, false],
        ["radius", 0, 4.935, 0, 30, false, false],
        ["rotation", 0, 0.000429, 0, 0.001, false, false],
        ["xMul", 0, 12.294, 0, 20, false, false],
        ["yMul", 0, 3.636, 0, 20, false, false],
        ["oY", 0, 20.571, 0, 88, false, false],
        ["oX", 0, 5.801, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7c"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 11.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .4)/4. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 54.545, 0, 200, false, false],
        ["xDiv", 0, 110.823, 0, 200, false, false],
        ["yDiv", 0, 3.203, 0, 20, false, false],
        ["xDiv2", 0, 21.818, 0, 40, false, false],
        ["yDiv2", 0, 6.234, 0, 40, false, false],
        ["xDiv3", 0, 50.216, 0, 400, false, false],
        ["yDiv3", 0, 5.606, 1, 20, false, false],
        ["multiplier", 0, 1.779, 0, 3, false, false],
        ["ballSize", 0, 5.974, 0, 10, false, false],
        ["contrast", 0, 2.117, 0, 3, false, false],
        ["radius", 0, 0.952, 0, 5, false, false],
        ["rotation", 0, 0.000242, 0, 0.001, false, false],
        ["xMul", 0, 30, 0, 30, false, false],
        ["yMul", 0, 2.208, 0, 30, false, false],
        ["oY", 0, 19.81, 0, 44, false, false],
        ["oX", 0, 1.818, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f81"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 90.275, 0, 294.9, false, false],
        ["yDivider", 0, 18.646, 0, 49.4, false, false],
        ["xDivider", 0, 9.294, 0, 14.94, false, false],
        ["multiplier", 0, 1.219, 0, 1.73, false, false],
        ["ballSize", 0, 34.82, 0, 69.64, false, false],
        ["contrast", 0, 1.8, 0, 3.6, false, false],
        ["radius", 0, 76.67, 0, 153.34, false, false],
        ["rotation", 0, 14.858, 0, 15.2, false, false],
        ["yDivide", 0, 307.888, 0, 703.66, false, false],
        ["xDivide", 0, 0.408, 0, 0.64, false, false],
        ["yShape", 0, 200, 0, 200, false, false],
        ["shape", 0, 14.966, 0, 33.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f86"
    },
    "shader": "void main () {\n  float stream =time + stream  / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .575)*orbSize/2.,vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.343208772590362, 0, 5, false, false],
        ["iterator", 0, 1.1237387048192773, 0, 2, false, false],
        ["ot", 0, 63.521, 0, 151, false, false],
        ["I", 0, 2.264, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 5.251195406626508, 0, 11, false, false],
        ["iterations", 0, 23.76, 0, 33, false, false],
        ["L", 0, 0.651, 0, 3, false, false],
        ["M", 0, 9.278, 0, 11, false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false],
        ["orbSize", 0, 0.071, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fac"
    },
    "shader": "#define orbs 5.\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) / color, 1.), vec4(contrast));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = cos(stream + dist) - (i + 1.) * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius / tan(t - stream);\n    float y2 = radius - sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.89, 0, 31.78, false, false],
        ["contrast", 0, 1.02, 0, 2.04, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 3.75, 0, 7.5, false, false],
        ["colorShift", 0, 2.5, 0, 5, false, false],
        ["center", 0, 5.29, 0, 10.58, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fdb"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 18.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 391569.402, 0.01, 2111000, false, false],
        ["ballSize", 0, 58607.908, 0, 99999, false, false],
        ["contrast", 0, 3.38, 0, 5, false, false],
        ["radius", 0, 21822654.66, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 133300768.7, 10000000, 192999999, false, false],
        ["y", 0, 7915426.66, 0, 119133112, false, false],
        ["rotation", 0, 0, 0, 0.01, false, false],
        ["colorOffset", 0, 96.5, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 39960.707, 1, 100000, false, false],
        ["div2", 0, 916935.078, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca018"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 10;\n\n#define PHI   .5*PI-.5*PI*sin(sqrt(PI))\n#define TAU   (PI*PI)\n#define TTIME (stream/2.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=100.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.25 + 0.5*sin(stream/2.-length(p/99.5)));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =11.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.866, 0, 4, false, false],
        ["size", 0, 2.687, 0, 12, false, false],
        ["offc", 0, 1.042, 0, 4, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 2.562, 0, 12, false, false],
        ["_x", 0, 0.266, 0, 1, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ],
      [
        ["zoom", 0, 0.538, 0, 4, false, false],
        ["size", 0, 3.994, 0, 12, false, false],
        ["offc", 0, 0.15, 0, 4, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 1.89, 0, 12, false, false],
        ["_x", 0, 0.434, 0, 1, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ],
      [
        ["zoom", 0, 1.044, 0, 4, false, false],
        ["size", 0, 1.75, 0, 12, false, false],
        ["offc", 0, 2.138, 0, 4, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 4.063, 0, 12, false, false],
        ["_x", 0, 0.63, 0, 1, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01e"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.52, 0, 2, false, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca021"
    },
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(1227.1, 311.7)),\n    dot(p, vec2(269.5, 183.3)));\n\n  return -1. + 102. * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  return uv; //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main() {\n  vec2 uv = mapToScreen(gl_FragCoord.xy / resolution.xy, zoom);\n  float len = length(sin(uv - stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  vec2 _uv = uv;\n  uv = abs(uv);\n\n  vec2 _warp = _uv / dot(uv, uv);\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + abs(fbm(a * uv + stream))));\n  if (warpTween) {\n    if (warp) {\n      uv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n      uv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * abs(fbm(b * uv + stream))));\n\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc / (uv.x + log(uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 50.));\n  if (warpTween) {\n    if (warp) {\n      uv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n      uv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n  col += d2 * size * abs(cos(col2 - stream / 50.));\n  col += d3 * size * col3;\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 2.67, 0, 5.34, false, false],
        ["thickness", 0, 0.0182, 0, 0.0364, false, false],
        ["haze", 0, 2, 0, 4, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.045, 0, 0.09, false, false],
        ["a", 0, 634.37, 0, 1268.74, false, false],
        ["b", 0, 7.61, 0, 15.22, false, false],
        ["c", 0, 2.78, 0, 5.56, false, false],
        ["warp", 1, false, null, null, null, false],
        ["warpZoom", 0, 2, 0, 4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03f"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 25.95, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.3, 0.01, 2, false, false],
        ["radius", 0, 12.89, 0, 14, false, false],
        ["colorShift", 0, 10.54, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca040"
    },
    "shader": "\n#define orbs 18.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2. - stream/10.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 19.33, 0, 151, false, false],
        ["contrast", 0, 1.55, 0, 2, false, false],
        ["orbSize", 0, 1.79, 0.01, 2, false, false],
        ["radius", 0, 1, 0, 14, false, false],
        ["colorShift", 0, 16, 3, 16, false, false],
        ["div", 0, 11.62, 0, 100, false, false],
        ["div2", 0, 32.974, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca067"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv /= sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.4, 0, 6.8, false, false],
        ["contrast", 0, 1.11, 0, 2.22, false, false],
        ["orbSize", 0, 0.08, 0, 0.16, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.35, 0, 10.7, false, false],
        ["outer", 0, 0.61, 0, 1.22, false, false],
        ["inner", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca084"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/13.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/6000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 19.15, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 378.53, 0.1, 1101, false, false],
        ["ballSize", 0, 0.87, 0, 2, false, false],
        ["contrast", 0, 1.77, 0, 5, false, false],
        ["radius", 0, 11.96, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.76, 0, 5, false, false],
        ["_pow", 0, 4.09, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03b"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 11.15, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.3, 0.01, 2, false, false],
        ["radius", 0, 12.89, 0, 14, false, false],
        ["colorShift", 0, 10.54, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b7"
    },
    "shader": "#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.513, 0, 1.026, false, false],
        ["contrast", 0, 2.1, 0, 4.2, false, false],
        ["ballSize", 0, 0.0083, 0, 0.0166, false, false],
        ["radius", 0, 105.45, 0, 210.9, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["dotMultiplier", 0, 2.24, 0, 4.48, false, false],
        ["tanMul", 0, 3.12, 0, 6.24, false, false],
        ["sinMul", 0, 1.61, 0, 3.22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c4"
    },
    "shader": "\n#define orbs 12.\n\n// COLORS  \nconst vec3 POLAR_BEAR = vec3(0.08627450980392157, 0.08627450980392157, 0.9254901960784314);\nconst vec3 LASER_LEMON = vec3(1, 0.08627450980392157, 0.10588235294117647);\nconst vec3 SEA_OF_TRANQUILITY = vec3(0.5058823529411764, 0.08627450980392157, 0.8549019607843137);\nconst vec3 FLIRT_ALERT = vec3(0.7450980392156863, 0.08627450980392157, 0.21568627450980393);\nconst vec3 JUST_A_FAIRYTALE = vec3(0.4235294117647059, 0.08627450980392157, 0.592156862745098);\nconst vec3 DIVA_GLAM = vec3(0.6980392156862745, 0.08627450980392157, 0.4627450980392157);\nconst vec3 FLAME = vec3(0.9098039215686274, 0.08627450980392157, 0.2);\nconst vec3 AZTEC_SKY = vec3(0.30196078431372547, 0.08627450980392157, 0.8431372549019608);\nconst vec3 FOUR_LEAF_CLOVER = vec3(0.7294117647058823, 0.08627450980392157, 0.6196078431372549);\nconst vec3 JOYFUL_ORANGE = vec3(0.9803921568627451, 0.08627450980392157, 0.20784313725490197);\nconst vec3 BATTLECHIP_GRAY = vec3(0.596078431372549, 0.08627450980392157, 0.5529411764705883);\nconst vec3 WISHFUL_GREEN = vec3(0.7843137254901961, 0.08627450980392157, 0.8);\nconst vec3 RIVERDALE = vec3(0.7450980392156863, 0.08627450980392157, 0.7294117647058823);\nconst vec3 BACK_TO_NATURE = vec3(0.7411764705882353, 0.08627450980392157, 0.5607843137254902);\nconst vec3 BETA_FISH = vec3(0.22745098039215686, 0.08627450980392157, 0.4);\nconst vec3 VOYAGE = vec3(0.44313725490196076, 0.08627450980392157, 0.6431372549019608); \nconst vec3 GLASS_SAPPHIRE = vec3(0.34509803921568627, 0.08627450980392157, 0.6078431372549019);\nconst vec3 WAVE_TOP = vec3(0.6862745098039216, 0.08627450980392157, 0.8274509803921568);\nconst vec3 CHARISMATIC_SKY = vec3(0.6039215686274509, 0.08627450980392157, 0.8627450980392157);\nconst vec3 ANGELICO = vec3(0.9176470588235294, 0.08627450980392157, 0.7607843137254902);\nconst vec3 FLOWERPOT = vec3(0.8470588235294118, 0.08627450980392157, 0.6274509803921569);\nconst vec3 DARK_CRIMSON = vec3(0.5176470588235295, 0.08627450980392157, 0.2549019607843137);\nconst vec3 CANYON_DUSK = vec3(0.7647058823529411, 0.08627450980392157, 0.5137254901960784);\nconst vec3 HONIED_WHITE = vec3(0.9882352941176471, 0.08627450980392157, 0.8235294117647058);\nconst vec3 SURFBOARD_YELLOW = vec3(0.9882352941176471, 0.08627450980392157, 0.5372549019607843);\n \n// PALETTES \nconst vec3 TEENAGE_DREAM[6] = vec3[6](SEA_OF_TRANQUILITY,WISHFUL_GREEN,CHARISMATIC_SKY,GLASS_SAPPHIRE,JUST_A_FAIRYTALE,DIVA_GLAM);\nconst vec3 NEVER_REALLY_OVER[6] = vec3[6](LASER_LEMON,JOYFUL_ORANGE,DIVA_GLAM,AZTEC_SKY,CHARISMATIC_SKY,HONIED_WHITE);\nconst vec3 WAKING_UP_IN_VEGAS[6] = vec3[6](FLIRT_ALERT,DARK_CRIMSON,ANGELICO,SURFBOARD_YELLOW,JOYFUL_ORANGE,DIVA_GLAM);\n\n\n vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool t, bool tp, float tps) {\n  return tp\n    ? t ? mix(uv, uv2, tps): mix(uv2, uv, tps)\n    : t ? uv2 : uv;\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n \tconst vec3 palette[6] = NEVER_REALLY_OVER;//_OVER;\n  float dist = length(uv);\n  vec2 _swirl = uv * rotate(sin(dist + stream/21.1) + rotation*stream);\n  vec2 _warp = uv / dot(uv, uv);\n\tuv = swap(uv, _swirl, swirl, swirlTween, swirlTweenProgress);\n  uv = swap(uv, _warp, warp, warpTween, warpTweenProgress);\n  //uv /= dot(uv, uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) { \n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/-1.);\n    uv.y += cos(cosMul *  uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/1.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = palette[int(i)];\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.93, 0, 11, false, false],
        ["contrast", 0, 1.26, 0, 2, false, false],
        ["orbSize", 0, 0.59, 0.01, 1, false, false],
        ["radius", 0, 2.46, 1, 5, false, false],
        ["colorShift", 0, 6.88, 4, 10, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, 0, 1, false, false],
        ["sinMul", 0, 0.19, 0, 1, false, false],
        ["cosMul", 0, 0.11, 0, 1, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 3.12, 0, 5, false, false],
        ["xSpeed", 0, -0.34, -1, 1, false, false],
        ["ySpeed", 0, 0.26, 0, 1, false, false],
        ["gloop", 0, 0.0036, 0.001, 0.01, false, false],
        ["yDivide", 0, 2, 0, 2, false, false],
        ["xDivide", 0, 2, 0, 2, false, false],
        ["swirl", 1, false, null, null, null, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f5"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 64.691, 0, 313, false, false],
        ["iterator", 0, 0.528, 0, 2, false, false],
        ["ot", 0, 66.673, 0, 151, false, false],
        ["I", 0, 0.62, 0, 3, false, false],
        ["J", 0, 2.201, 0, 3, false, false],
        ["K", 0, 50.17, 0, 111, false, false],
        ["iterations", 0, 19.738, 0, 33, false, false],
        ["L", 0, 35.129, 0, 213, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 1.457, 0, 2, false, false],
        ["colorOffset", 0, 54.805, 0, 111, false, false],
        ["contrast", 0, 1.633, 1, 3, false, false],
        ["orbSize", 0, 1.601, 0, 13, false, false],
        ["div", 0, 3.113, 0, 14, false, false],
        ["radius", 0, 2.044, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5d"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 1.23, 0, 2.46, false, false],
        ["xMultiplier", 0, 29.96, 0, 59.92, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 1.68, 0, 3.36, false, false],
        ["colorSpread", 0, 1.79, 0, 3.58, false, false],
        ["colorMultiplier", 0, 383.24, 0, 766.48, false, false],
        ["shapeMultiplier", 0, 13.45, 0, 26.9, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 5.1, 0, 10.2, false, false],
        ["rotation", 0, 11.628, 0, 23.256, false, false],
        ["brightness", 0, 8078.46, 0, 16156.92, false, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f64"
    },
    "shader": "#define BALLS 20\n vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01*sin(shapeMultiplier*dot(uv, uv)/dist - stream/2.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/3.));\n  float _grid = (cos(uv.x * xMultiplier - stream/3.));// * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.051, 0, 0.102, false, false],
        ["shapeMultiplier", 0, 200.17, 0, 400.34, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 69.59, 0, 139.18, false, false],
        ["yMultiplier", 0, 26.63, 0, 53.26, false, false],
        ["colorSpread", 0, 0.006, 0, 0.012, false, false],
        ["colorMultiplier", 0, 0.15, 0, 0.3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.48, 0, 2.96, false, false],
        ["ballSize", 0, 2.22, 0, 4.44, false, false],
        ["glow", 0, 0.76, 0, 1.52, false, false],
        ["contrast", 0, 2.78, 0, 5.56, false, false],
        ["radius", 0, 9.97, 0, 19.94, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f65"
    },
    "shader": "#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = hue(gl_FragColor, stream/50.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.124, false, false],
        ["shapeMultiplier", 0, 203.13, 0, 406.26, false, false],
        ["rotation", 0, 0.05, 0, 0.1, false, false],
        ["xMultiplier", 0, 59.27, 0, 118.54, false, false],
        ["yMultiplier", 0, 88, 0, 176, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.81, 0, 1.62, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 3.86, 0, 7.72, false, false],
        ["ballSize", 0, 36.72, 0, 73.44, false, false],
        ["glow", 0, 1.22, 0, 2.44, false, false],
        ["contrast", 0, 2.72, 0, 5.44, false, false],
        ["radius", 0, 16.24, 0, 32.48, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9faf"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}  \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= rotate(stream/3.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/15.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t+stream/10.);\n    float y = radius * cos(t-stream/-10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 5.)*orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 21.43, 0, 42.86, false, false],
        ["contrast", 0, 1.62, 0, 3.24, false, false],
        ["orbSize", 0, 1.25, 0, 2.5, false, false],
        ["radius", 0, 7.86, 0, 15.72, false, false],
        ["colorShift", 0, 5.09, 0, 10.18, false, false],
        ["x1", 0, 0.23, 0, 0.46, false, false],
        ["x2", 0, 0.61, 0, 1.22, false, false],
        ["y1", 0, 0.27, 0, 0.54, false, false],
        ["y2", 0, 1.06, 0, 2.12, false, false],
        ["center", 0, 6.59, 0, 13.18, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fbc"
    },
    "shader": "\n  #define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  uv = kale(uv, vec2(0), sides);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 40.43, 0, 111, false, false],
        ["contrast", 0, 1.65, 0, 4, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 14.08, 1, 115, false, false],
        ["colorShift", 0, 7.65, 1, 40, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 50, 0, 50, false, false],
        ["sinMul", 0, 0, 0, 5, false, false],
        ["cosMul", 0, 3, 0, 3, false, false],
        ["yMul", 0, 0, 0, 1, false, false],
        ["xMul", 0, 0.4, 0, 5, false, false],
        ["xSpeed", 0, -22, -1, 1, false, false],
        ["ySpeed", 0, -2, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 5.89, 1, 12, false, false],
        ["xDivide", 0, 5.89, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fcc"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= rotate(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= rotate(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < 20.; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.64, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 4.35, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fcf"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 2.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress);\n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv *= k_rotate2d(stream / 1.);\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x *= abs(dist + .001 * dist * (i) * (uv.x));\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 1.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.64, 0, 5.28, false, false],
        ["contrast", 0, 1.38, 0, 2.76, false, false],
        ["orbSize", 0, 0.56, 0, 1.12, false, false],
        ["radius", 0, 4.35, 0, 8.7, false, false],
        ["colorShift", 0, 7.26, 0, 14.52, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 2, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd0"
    },
    "shader": "  #define orbs 013.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -4. + 8.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= rotate(stream/8.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\t//uv *= rotate(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 15, 0, 30, false, false],
        ["contrast", 0, 1.06, 0, 2.12, false, false],
        ["orbSize", 0, 0.56, 0, 1.12, false, false],
        ["radius", 0, 50, 0, 100, false, false],
        ["colorShift", 0, 8.14, 0, 16.28, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 2, false, false],
        ["sides", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca008"
    },
    "shader": "void main() {\n  float t = stream;\n  vec2 r = resolution.xy;\n  vec2 uv = gl_FragCoord.xy - r;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 10.);\n\n  uv = vec2(length(uv) / r.y - 0.05, atan(uv.x, uv.y));\n  uv *= twist;\n  vec3 s = cos(1.0 * vec3(0, 1, 2) + t + uv.y / 2. + sin(uv.y / yMul) * cos(t)) / 5.0;\n  vec3 e = s.zxy;\n  vec3 f = min(uv.x - s, e - uv.x);\n  gl_FragColor.rgb = dot(clamp(f * r.y, 0., 1.), 50. * (s - e)) * (s - .1) + f;\n  gl_FragColor = k_hue(gl_FragColor, stream / 100.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.0932335, 0, 0.186467, false, false],
        ["twist", 0, 2.5, 0, 5, false, false],
        ["kale1", 0, 1, 0, 2, false, false],
        ["kale2", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca009"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(-rotation*(dist/5.)+stream/4.+float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter*(atan(uv.x-stream/.1))*uv.x+radius*tan(t+xMultiplier) * 20.*cos(uv.x + sin(uv.y/100.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.03, 0, 0.06, false, false],
        ["ballSize", 0, 52.577, 0, 105.154, false, false],
        ["contrast", 0, 4.44, 0, 8.88, false, false],
        ["radius", 0, 1.23, 0, 2.46, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 24, 0, 48, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 100, 0, 200, false, false],
        ["yMultiplier", 0, 72.3, 0, 144.6, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca013"
    },
    "shader": "// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 5.;\nconst float shell = .3;\nconst float carve = .3;\nconst float falloff = 1.8;\nconst float blend = .02;\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 100.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 3.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -= stream * a;\n        d = smin(d, abs(dot(sin(p),cos(p.yzx))/scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += sin(p.z*10.+stream*20.)*0.002;\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid main()\n{\n    // coordinates\n    vec2 uv = k_uv();\n    float dither = hash12(gl_FragCoord.xy);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 20.;\n    const float count = 17.;\n    for (float index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*dither;\n        pos += ray*dist;\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-stream);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    gl_FragColor = vec4(color, 1.);\n}",
    "variants": [[["zoom", 0, 1.283, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca03a"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 19.33, 0, 151, false, false],
        ["contrast", 0, 1.55, 0, 2, false, false],
        ["orbSize", 0, 1.79, 0.01, 2, false, false],
        ["radius", 0, 4.12, 0, 14, false, false],
        ["colorShift", 0, 16, 3, 16, false, false],
        ["div", 0, 11.62, 0, 100, false, false],
        ["div2", 0, 32.974, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04c"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = zoom * uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 22.15, 0, 44.3, false, false],
        ["contrast", 0, 1.21, 0, 2.42, false, false],
        ["orbSize", 0, 1.09, 0, 2.18, false, false],
        ["radius", 0, 5.14, 0, 10.28, false, false],
        ["colorShift", 0, 10.07, 0, 20.14, false, false],
        ["div", 0, 22.037, 0, 44.074, false, false],
        ["div2", 0, 19.684, 0, 39.368, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca046"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = abs(uv);\n  uv = uv * outer*cos( .00001 * dot(uv, uv) - stream/4.) + uv.x / 1110. * sin(11.01 * dot(uv, uv)-stream/1.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.x/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t - stream/1.);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/20. - stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize * pow(volume, 3.5), position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 91.91, 0, 183.82, false, false],
        ["contrast", 0, 1.26, 0, 2.52, false, false],
        ["orbSize", 0, 0.51, 0, 1.02, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 8.07, 0, 16.14, false, false],
        ["div", 0, 18.147, 0, 36.294, false, false],
        ["div2", 0, 16.837, 0, 33.674, false, false],
        ["warp", 1, false, null, null, null, false],
        ["outer", 0, 0.448, 0, 0.896, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05e"
    },
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.14 * dot(uv, 20.1 * uv) - stream);\n  uv /= sin(.005 * dot(uv + sin(1. * uv), 20.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t) * sin(dist);\n    float y = t * radius * cos(dist * t - stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.23, 0, 4.46, false, false],
        ["contrast", 0, 1.11, 0, 2.22, false, false],
        ["orbSize", 0, 0.08, 0, 0.16, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca074"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 42.58, 0, 85.16, false, false],
        ["contrast", 0, 1.08, 0, 2.16, false, false],
        ["orbSize", 0, 2.35, 0, 4.7, false, false],
        ["radius", 0, 22.85, 0, 45.7, false, false],
        ["colorShift", 0, 8.85, 0, 17.7, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0.67, 0, 1.34, false, false],
        ["cosMul", 0, 1.64, 0, 3.28, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, 0, -2, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09f"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 65.91, 0, 131.82, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a3"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n//  uv = abs(uv);\n//  uv /= dot(uv, uv);\n  float dist = length(abs(uv));\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/2)*cos(uv.y/yDivider + stream/201.) + sin(uv.x/10. - stream/20.);\n    uv.x += yOuter*float(i/1)*sin(uv.x/xDivider + stream/201.) * sin(uv.y/20. + stream/30.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/20.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 35.05, 0, 70.1, false, false],
        ["yDivider", 0, 1001, 0, 2002, false, false],
        ["xDivider", 0, 320.51, 0, 641.02, false, false],
        ["multiplier", 0, 5.87, 0, 11.74, false, false],
        ["ballSize", 0, 0.17, 0, 0.34, false, false],
        ["contrast", 0, 1.63, 0, 3.26, false, false],
        ["radius", 0, 13.43, 0, 26.86, false, false],
        ["xOuter", 0, 0.83, 0, 1.66, false, false],
        ["yOuter", 0, 0.52, 0, 1.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b1"
    },
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 1.58, false, false],
        ["contrast", 0, 3.03, 0, 6.06, false, false],
        ["ballSize", 0, 0.016, 0, 0.032, false, false],
        ["radius", 0, 45.33, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 3.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d1"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/-80.);\n  uv = zoom * (log(uv) + 1.5*cos(uv));//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/14.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist + stream/2.));\n  float _grid = (cos(uv.x * xMultiplier - stream/5.) - sin(uv.y * yMultiplier + stream/30.));\n  uv /= colorSpread * thing * _grid;\n  uv*=.1*dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream/140.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y/850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.054, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 39.9, 0, 301, false, false],
        ["rotation", 0, 0.0195, 0.009, 0.041, false, false],
        ["xMultiplier", 0, 5.66, 0, 1500, false, false],
        ["yMultiplier", 0, 535.74, 0, 1000, false, false],
        ["colorSpread", 0, 0.000114, 0, 0.001, false, false],
        ["colorMultiplier", 0, 2, 0, 2, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.23, 0, 10, false, false],
        ["ballSize", 0, 42.87, 0, 100, false, false],
        ["glow", 0, 3.54, 0, 4, false, false],
        ["contrast", 0, 2.13, 0, 5, false, false],
        ["radius", 0, 16.47, 0, 120, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e2"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(length(cos(uv-stream))/2. + stream/4.);\n  float dist = length(log(abs(uv)));\n  uv *= k_rotate2d(dist - rotation - stream / 2.5);\n  uv *= cos(dotMultiplier * (cos(stream + dot(abs(uv), log(abs(uv))))) - stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(radius * cos(tanMul * t - stream), radius * sin(sinMul * t + stream));\n    vec3 col = k_rainbow(i / BALLS, shift, offset);\n    gl_FragColor += vec4(col * pow(volume, .5)/3.5 * pow(dist, 1.15) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =  pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.466, 0, 15.792, false, false],
        ["contrast", 0, 1.421, 0, 3.02, false, false],
        ["ballSize", 0, 0.509, 0, 1, false, false],
        ["radius", 0, 3.976, 0, 14.4, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, -7.539, -10, 10, false, false],
        ["dotMultiplier", 0, 4.4, 0, 12, false, false],
        ["tanMul", 0, 3.857, 0, 18.7, false, false],
        ["sinMul", 0, 0.653, 0, 5.6, false, false],
        ["shift", 0, 0.845, 0, 1, false, false],
        ["offset", 0, 0.808, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ec"
    },
    "shader": "#define BALLS 10.\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *= rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.896, 0, 5.792, false, false],
        ["contrast", 0, 1.51, 0, 3.02, false, false],
        ["ballSize", 0, 0.1211, 0, 0.2422, false, false],
        ["radius", 0, 2.2, 0, 4.4, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 0, 2, false, false],
        ["tanMul", 0, 4.35, 0, 8.7, false, false],
        ["sinMul", 0, 2.8, 0, 5.6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f7"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, .1,vec2(radius*sin(stream/30.+(-1. + 2. * gl_FragCoord.xy / resolution.xy).x/div), radius*cos(stream/30.+(-1. + 2. * gl_FragCoord.xy / resolution.xy).y/div)),  col, contrast);\n  }\n\n\n  vec3 c = vec3(ot * I + length(uv));\n            \n}",
    "variants": [
      [
        ["zoom", 0, 21, 0, 21, false, false],
        ["iterator", 0, 1.04, 0, 2, false, false],
        ["ot", 0, 99.773, 0, 151, false, false],
        ["I", 0, 1.152, 0, 3, false, false],
        ["J", 0, 1.356, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 26.455, 0, 33, false, false],
        ["L", 0, 7.436, 0, 13, false, false],
        ["M", 0, 4.34, 0, 11, false, false],
        ["colorShift", 0, 0.911, 0, 1, false, false],
        ["colorOffset", 0, 3.651, 0, 11, false, false],
        ["contrast", 0, 1.413, 1, 3, false, false],
        ["orbSize", 0, 0.259, 0, 1, false, false],
        ["div", 0, 0.676, 0.1, 1, false, false],
        ["radius", 0, 0.384, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca10f"
    },
    "shader": "\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n\tfloat i = (uv.x/10.);\n    float t = float(i) * PI / 3.;\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 1, false, false],
        ["xMultiplier", 0, 35.99, 0, 200, false, false],
        ["yMultiplier", 0, 49.25, 0, 200, false, false],
        ["ballSize", 0, 7.81, 0, 12, false, false],
        ["colorSpread", 0, 7, 0.2, 7, false, false],
        ["colorMultiplier", 0, 111.05, 1, 500, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 210, false, false],
        ["glow", 0, 1862.09, 0, 10000, false, false],
        ["contrast", 0, 3.17, 1, 10, false, false],
        ["rotation", 0, 11.471, 0, 15, false, false],
        ["brightness", 0, 1, 0, 1, false, false],
        ["sides", 0, 11, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca111"
    },
    "shader": "#define BALLS 3\n\nvoid main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 15.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream / .1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  uv = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 20.));\n  float _grid = (cos(uv.x * xMultiplier - stream / .5) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = (uv.x / 10.);\n  float t = float(i) * PI / float(BALLS);\n  vec2 p = vec2(sin(t), cos(t));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n  gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 2.94, 0, 5.88, false, false],
        ["xMultiplier", 0, 35.99, 0, 71.98, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 8.09, 0, 16.18, false, false],
        ["colorSpread", 0, 7, 0, 14, false, false],
        ["colorMultiplier", 0, 111.05, 0, 222.1, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 26.92, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 3.17, 0, 6.34, false, false],
        ["rotation", 0, 11.471, 0, 22.942, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5a"
    },
    "shader": "#define orbs 5.\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) / color, 1.), vec4(contrast));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x3 = radius * sin(t - stream);\n    float y3 = radius * tan(t + stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    if (warp2Tween) {\n      if (warp2) {\n        x = mix(x1, x3, warp2TweenProgress);\n        y = mix(y1, y3, warp2TweenProgress);\n      } else {\n        x = mix(x3, x1, warp2TweenProgress);\n        y = mix(y3, y1, warp2TweenProgress);\n      }\n    } else if (warp2) {\n      x = x3;\n      y = y3;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["contrast", 0, 0.88, 0, 1.76, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.87, 0, 1.74, false, false],
        ["colorShift", 0, 2.5, 0, 5, false, false],
        ["center", 0, 1.73, 0, 3.46, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false],
        ["warp2", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5e"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 10.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist * stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.44, 0, 0.88, false, false],
        ["xMultiplier", 0, 39.33, 0, 78.66, false, false],
        ["yMultiplier", 0, 33.24, 0, 66.48, false, false],
        ["ballSize", 0, 1.31, 0, 2.62, false, false],
        ["colorSpread", 0, 0.27, 0, 0.54, false, false],
        ["colorMultiplier", 0, 554.68, 0, 1109.36, false, false],
        ["shapeMultiplier", 0, 163.55, 0, 327.1, false, false],
        ["glow", 0, 1083.42, 0, 2166.84, false, false],
        ["contrast", 0, 4.3, 0, 8.6, false, false],
        ["rotation", 0, 1.927, 0, 3.854, false, false],
        ["brightness", 0, 11100, 0, 22200, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f7b"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 5.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 3.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 3.), yMul * sin(t / multiplier + stream / 2.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 50. * ballSize * pow(volume, .6) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 275.018, 0, 500, false, false],
        ["xDiv", 0, 11.484, 0, 100, false, false],
        ["yDiv", 0, 151.304, 0, 200, false, false],
        ["xDiv2", 0, 29.942, 0, 200, false, false],
        ["yDiv2", 0, 3.656, 0, 200, false, false],
        ["xDiv3", 0, 11.46, 0, 200, false, false],
        ["yDiv3", 0, 123.108, 0, 200, false, false],
        ["multiplier", 0, 0.738, 0, 2, false, false],
        ["ballSize", 0, 25.963, 0, 100, false, false],
        ["contrast", 0, 1.714, 0, 2, false, false],
        ["radius", 0, 10.804, 0, 100, false, false],
        ["rotation", 0, 0.00011, 0, 0.001, false, false],
        ["xMul", 0, 6.025, 0, 20, false, false],
        ["yMul", 0, 1.936, 0, 20, false, false],
        ["oY", 0, 3.738, 0, 9, false, false],
        ["oX", 0, 0.927, 0, 9, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f85"
    },
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.5;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv *= k_rotate2d(stream/3.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x += float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 4.);\n    vec2 p = radius * vec2(xMul * cos(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 1.) * cos(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .6)/5. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 558.036, 0, 1000, false, false],
        ["xDiv", 0, 13.393, 0, 1000, false, false],
        ["yDiv", 0, 1848.214, 0, 2000, false, false],
        ["xDiv2", 0, 108.036, 0, 200, false, false],
        ["yDiv2", 0, 90.179, 0, 200, false, false],
        ["xDiv3", 0, 26.786, 0, 2000, false, false],
        ["yDiv3", 0, 419.643, 0, 2000, false, false],
        ["multiplier", 0, 17.768, 0, 20, false, false],
        ["ballSize", 0, 100, 0, 100, false, false],
        ["contrast", 0, 2.089, 0, 4, false, false],
        ["radius", 0, 74.777, 0, 250, false, false],
        ["rotation", 0, 0.049107, 0, 11, false, false],
        ["xMul", 0, 4.911, 0, 20, false, false],
        ["yMul", 0, 2.946, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f8a"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/2. + sin(i+stream/10.));\n    uv = abs(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume*I,vec2(sin(uv.x), cos(uv.y)),  col, contrast);\n  }         \n}",
    "variants": [
      [
        ["zoom", 0, 0.855, 0, 5, false, false],
        ["iterator", 0, 1.156, 0, 2, false, false],
        ["ot", 0, 92.023, 0, 151, false, false],
        ["I", 0, 0.056, 0, 0.1, false, false],
        ["J", 0, 2.267, 0, 3, false, false],
        ["K", 0, 7.852, 0, 11, false, false],
        ["iterations", 0, 23.555, 0, 33, false, false],
        ["L", 0, 0.795, 0, 3, false, false],
        ["M", 0, 6.933, 0, 11, false, false],
        ["colorShift", 0, 0.756, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f9e"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb0"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 1.2967;\n  float dist = length(uv);\n  uv *= rotate(stream/20.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .7)*orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 26.54, 0, 53.08, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 5.39, 0, 10.78, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb5"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(stream/3.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 22, false, false],
        ["contrast", 0, 1.19, 1, 5, false, false],
        ["orbSize", 0, 0.64, 0.01, 2, false, false],
        ["radius", 0, 4.02, 1, 15, false, false],
        ["colorShift", 0, 4.41, 4, 10, false, false],
        ["x1", 0, 0.1, 0, 1, false, false],
        ["x2", 0, 0.91, 0, 1, false, false],
        ["y1", 0, 0.37, 0, 1, false, false],
        ["y2", 0, 1.86, 0, 5, false, false],
        ["center", 0, 6.97, 0, 11, false, false],
        ["sides", 0, 3, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb7"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/20.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 26.54, 0, 115, false, false],
        ["contrast", 0, 1.37, 1, 5, false, false],
        ["orbSize", 0, 1.39, 0.01, 2, false, false],
        ["radius", 0, 4.02, 1, 15, false, false],
        ["colorShift", 0, 5.37, 4, 10, false, false],
        ["x1", 0, 0.57, 0, 1, false, false],
        ["x2", 0, 0.3, 0, 1, false, false],
        ["y1", 0, 0.63, 0, 1, false, false],
        ["y2", 0, 0.53, 0, 5, false, false],
        ["center", 0, 5.39, 0, 11, false, false],
        ["sides", 0, 1, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fbb"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(stream/3.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= x1*sin(x2*uv.y);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 6.)*orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 17.35, 0, 34.7, false, false],
        ["contrast", 0, 1.47, 0, 2.94, false, false],
        ["orbSize", 0, 0.98, 0, 1.96, false, false],
        ["radius", 0, 5.52, 0, 11.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.09, 0, 0.18, false, false],
        ["x2", 0, 0.42, 0, 0.84, false, false],
        ["y1", 0, 0.24, 0, 0.48, false, false],
        ["y2", 0, 2.22, 0, 4.44, false, false],
        ["center", 0, 11, 0, 22, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fcb"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 4.89, 0, 15, false, false],
        ["contrast", 0, 0.85, 0, 2, false, false],
        ["orbSize", 0, 0.15, 0.01, 1, false, false],
        ["radius", 0, 1.15, 1, 5, false, false],
        ["colorShift", 0, 79.53, 1, 110, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa1"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = 2. * time + stream  /2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .75) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.509076148343374, 0, 2.74, false, false],
        ["orbSize", 0, 0.5489348644578315, 0, 2.78, false, false],
        ["radius", 0, 4.144187123493976, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd8"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .3) * _uv.y/div - stream/-.8));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/1. - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 947824.569, 0.01, 2111000, false, false],
        ["ballSize", 0, 7592.894, 0, 36122, false, false],
        ["contrast", 0, 2, 0, 5, false, false],
        ["radius", 0, 12686504.54, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 108522415.87, 10000000, 192999999, false, false],
        ["y", 0, 14648788.88, 0, 19133112, false, false],
        ["rotation", 0, 0.00066, 0, 0.01, false, false],
        ["colorOffset", 0, 95.3, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 28453.413, 1, 100000, false, false],
        ["div2", 0, 889304.153, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fdc"
    },
    "shader": "#define orbs 30.\n\nvoid main () {\n  float stream = stream / 10.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 2.2);\n  vec2 _uv = uv;\n  float a = woot * cos(_uv.x / div2 + stream / .14);\n  float b = w00t * sin(a * _uv.y / div - stream / .2);\n  uv *= (outer + outer2 * b);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / orbs * (2. + 1.);\n    float a = radius * tan(stream / .43 - t * PI);\n    float b = radius * tan(t - stream/-.9);\n    vec2 p = vec2(a, b);\n    float c = cos(wad * cos(stream / .3 - uv.x / x));\n    float d = .3 * y *sin(stream / .37393);\n    float e = .85*cos(stream / -.13 - uv.y / (.7 * y + d));\n    p /= (e * c);\n    p /=  (c - (c - e));\n    vec3 base = vec3(0, 1, -1) * PI * 2. / 3.;\n    float offset = (brightness  * float(i) / 6.) * 0.5;\n    vec3 col = cos(colorOffset + base + PI * offset + 0.5);\n    float size = float(i) * ballSize / length(uv  - p * 0.9);\n    gl_FragColor += vec4(intensity * size * col, contrast);\n  }\n  vec3 inverted = .5 * log(abs(gl_FragColor.xyz));\n  gl_FragColor.xyz = pow(1.-inverted, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 606351.071, 0.01, 2111000, false, false],
        ["ballSize", 0, 27876.048, 0, 136122, false, false],
        ["contrast", 0, 2.22, 0, 5, false, false],
        ["radius", 0, 1065459.5, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 64084773.64, 10000000, 192999999, false, false],
        ["y", 0, 18031783.24, 0, 119133112, false, false],
        ["rotation", 0, 0, 0, 0.01, false, false],
        ["colorOffset", 0, 1102.3, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 22692.642, 1, 100000, false, false],
        ["div2", 0, 18649.316, 0, 1313311, false, false],
        ["wad", 0, 14.664, 1, 18, false, false],
        ["woot", 0, 0.11, 0, 0.2, false, false],
        ["wat", 0, 0.091, 0, 0.4, false, false],
        ["wob", 0, 18.085, 0, 160, false, false],
        ["outer", 0, 130.069, 0, 133, false, false],
        ["outer2", 0, 0, 0, 21, false, false],
        ["wave", 0, 0.947, 0, 11, false, false],
        ["aWave", 0, 0.2746, 0, 1, false, false],
        ["intensity", 0, 38.944, 0, 2000, false, false],
        ["brightness", 0, 1.345, 1, 2, false, false],
        ["w00t", 0, 4.201, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false],
        ["intensity", 0, 1, 0, 2, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["w00t", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe7"
    },
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.00987, 0, 1, false],
        ["iterator", 0, 4.63524, 0, 13, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.98477, 0, 33, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.24399, 0, 2, false],
        ["colorOffset", 0, 12.50333, 0, 111, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.46552, 0, 2, false],
        ["div", 0, 0.02173, 0.01, 1, false],
        ["radius", 0, 1.57716, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 4,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fec"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / -6.;\n  mat2 rotation = k_rotate2d(stream/(PI*2.));\n  for (float i = 0.; i < 13.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,.720) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.049, 0, 1, false, false],
        ["iterator", 0, 1.989, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 4.962735316265062, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.5863422439759036, 0, 2, false, false],
        ["colorOffset", 0, 9.61846762048193, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.2960278614457832, 0, 2, false, false],
        ["div", 0, 0.12494399472891568, 0.01, 1, false, false],
        ["radius", 0, 1.8993411144578316, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.019743034638554223, 0, 1, false, false],
        ["iterator", 0, 1.6151637801204821, 0, 2, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 7.6585843373493985, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.9093279367469881, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.9242046310240968, 0, 3, false, false],
        ["orbSize", 0, 0.31844879518072294, 0, 2, false, false],
        ["div", 0, 0.07135316265060243, 0.01, 1, false, false],
        ["radius", 0, 2.93386671686747, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00a"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 36.947006777108435, 0, 250, false, false],
        ["ballSize", 0, 58.014457831325316, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 136.74698795180726, 0, 250, false, false],
        ["yOuter", 0, 6.027861445783134, -1, 44, false, false],
        ["xOuter", 0, 117.67243975903617, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.8636577560240974, 0, 10, false, false],
        ["yMultiplier", 0, 1.62468561746988, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 94.5881965361446, 0, 110, false, false],
        ["yDiv2", 0, 112, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00c"
    },
    "shader": "void main () {\n  float stream = stream/2. + pow(stream, 1.4)/5000.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/40.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/11.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/1.14)), radius*\n                  cos(stream/10. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 36.947006777108435, 0, 250, false, false],
        ["ballSize", 0, 4.467959337349398, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 47.4550545933735, 0, 250, false, false],
        ["yOuter", 0, 6.027861445783134, -1, 44, false, false],
        ["xOuter", 0, 117.67243975903617, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.8636577560240974, 0, 10, false, false],
        ["yMultiplier", 0, 1.62468561746988, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 94.5881965361446, 0, 110, false, false],
        ["yDiv2", 0, 112, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01f"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.52, 0, 2, false, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ],
      [
        ["zoom", 0, 2, 0, 2, false, false],
        ["thickness", 0, 0.0009, 0, 0.1, false, false],
        ["haze", 0, 107.21, 2, 1100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.006, 0, 0.05, false, false],
        ["a", 0, 1.12, 0, 100, false, false],
        ["b", 0, 3.33, 0, 50, false, false],
        ["c", 0, 3.05, 0, 50, false, false]
      ],
      [
        ["zoom", 0, 0.69, 0, 2, false, false],
        ["thickness", 0, 0.0009, 0, 0.1, false, false],
        ["haze", 0, 486.2, 2, 1100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.003, 0, 0.05, false, false],
        ["a", 0, 9.65, 0, 100, false, false],
        ["b", 0, 3.33, 0, 50, false, false],
        ["c", 0, 3.05, 0, 50, false, false]
      ],
      [
        ["zoom", 0, 0.9, 0, 2, false, false],
        ["thickness", 0, 0.0241, 0, 0.1, false, false],
        ["haze", 0, 1.57, 1, 2, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.016, 0, 0.05, false, false],
        ["a", 0, 0.45, 0, 2, false, false],
        ["b", 0, 8.16, 0, 50, false, false],
        ["c", 0, 3.24, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01a"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 2;\n\n#define PHI   .25*PI-.25*PI+abs(.1*sin(PI-sqrt(PI)))\n#define TAU   (PI+PI)\n#define TTIME (stream/10.)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n2); if (t>0.0) { z-=.0*t*n1; }\n  t=dot(z,-n1); if (t>0.0) { z-=120.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(.1/_z, _x) * dot(z-vec3(size,0.,.1*length(z.zy/10.)),plnormal);\n        \n  dmin = abs(dmin) -width-0.105*(0.025 + 0.025/sin(stream/9. - .001*length(p) -.2*p.x/2.-atan(p.y/100.*PI)));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(01. *sin(stream/10.+length(p/PI)));\n  for (int i = -2; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)-TAU-float(rep)/1.2);\n    ip -= vec2(2.*sin(length(p/20.) - stream/3.)+ offc*size, 0.);\n    vec2 cp = 1./ip;\n    rot(ip, TTIME/1.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2( .25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, .025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = .5;\n  float d = sin(r - length(p));\n  col *= vec3(1.0 - .09*exp(-2.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =11.*(q - 0.5) * zoom;\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 0.667, 0, 2, false, false],
        ["size", 0, 5.11, 0, 122, false, false],
        ["offc", 0, 0, 0, 2, false, false],
        ["width", 0, 0, 0, 1, false, false],
        ["_z", 0, 5.085, 0, 22, false, false],
        ["_x", 0, 0.425, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca024"
    },
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(17.1, 311.7)),\n    dot(p, vec2(29.5, 13.3)));\n\n  return -1. + 1021. * fract(sin(p) * 43758.5453123 * sin(stream / 1000000.) * cos(stream / 10000.));\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  return uv; //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main()\n{\n  vec2 uv = mapToScreen(gl_FragCoord.xy / resolution.xy, zoom);\n  float len = length(sin(uv - stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + fbm(a * uv + stream)));\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * fbm(b * uv + stream)));\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc / (uv.x + (uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 20.));\n  col += d2 * size * abs(tan(col2 - stream / 20.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.16, false, false],
        ["thickness", 0, 0.0021, 0, 0.0042, false, false],
        ["haze", 0, 366.96, 0, 733.92, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.012, 0, 0.024, false, false],
        ["a", 0, 2.87, 0, 5.74, false, false],
        ["b", 0, 1.94, 0, 3.88, false, false],
        ["c", 0, 1.57, 0, 3.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca029"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream /3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/2. + length(uv/warp));\n  uv.x += sin(uv.y/4. - stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i/50)*sin(uv.y/yDivider) + sin(uv.x/xDiv - stream/4.05);\n    uv.x += yOuter*float(i/1)*cos(uv.y/xDivider) * cos(uv.x/xDiv2 - stream/-11.95);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.x/1. + stream/3.)*cos(uv.y/4. - stream));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.1)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.75, 0, 33, false, false],
        ["yDivider", 0, 4390.12, 0.1, 11001, false, false],
        ["xDivider", 0, 0.44, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.089, 0, 0.3, false, false],
        ["contrast", 0, 1.08, 0, 5, false, false],
        ["radius", 0, 12, 0, 12, false, false],
        ["xOuter", 0, 1.84, 0, 11, false, false],
        ["yOuter", 0, 0.23, 0, 1, false, false],
        ["xDiv", 0, 98.024, 0, 111, false, false],
        ["xDiv2", 0, 0.905, 0, 4, false, false],
        ["warp", 0, 3.571, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca02f"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  float div = 25.;\n  const float radius = 1000.;\n  vec2 warped = uv / dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/20. - stream);\n    uv.y += cos((i+1.)*uv.x/20. + stream);\n    float t = i * PI / orbs;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/2.1);\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, 1.1, position, color, 1.2);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 30, 0, 30, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 0.65, 0.01, 2, false, false],
        ["colorShift", 0, 13.76, 3, 15, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca003"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/1.6), radius *\ncos(.1 * dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 1.24)/5.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 16.031951807228918, 0, 62.18, false, false],
        ["ballSize", 0, 0.6445783132530122, 0, 1, false, false],
        ["contrast", 0, 2.8809567326924888, 0, 8.94, false, false],
        ["radius", 0, 0.14869879518072293, 0, 0.66, false, false],
        ["yOuter", 0, 17.969914545633713, 0, 25.42, false, false],
        ["xOuter", 0, 27.03570903824037, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.0018560335090365, 0, 7.36, false, false],
        ["yMultiplier", 0, 19.24, 0, 19.24, false, false],
        ["divider", 0, 6.095766072100905, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca044"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 41, 0, 41, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 1.09, 0.01, 2, false, false],
        ["radius", 0, 3.98, 1, 214, false, false],
        ["colorShift", 0, 10.07, 3, 16, false, false],
        ["div", 0, 10.273, 0, 100, false, false],
        ["div2", 0, 45.223, 0, 200, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca075"
    },
    "shader": "  #define orbs 10.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n\t    uv.x += .15*sin(uv.y+stream) + .1*cos(uv.x);\n      uv.y -= .9*cos(uv.x-stream) - .1*sin(uv.y);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 2.*sin(t-stream/2.);\n      float y = radius * cos(t+stream) + 2.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n\t\tgl_FragColor = hue(gl_FragColor, stream/3.);\t\n    for (float i = 0.; i < orbs; i++) {\n      uv.x += .05*sin(.1*uv.y+stream/2.) + .01*(uv.x);\n      uv.y += .2*cos(.1*uv.x-stream/2.) - .01*sin(uv.y);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.) + 10.*tan(t-stream/12.);\n      float y = radius * cos(t+stream/5.) + 1.*cos(t-stream/12.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor -= orb(uv, orbSize*.75, position, color, contrast);\n    }\n    gl_FragColor = hue(gl_FragColor, stream/5.);\n  }\n",
    "variants": [
      [
        ["zoom", 0, 3.4, 0, 6.8, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.79, 0, 1.58, false, false],
        ["radius", 0, 2.13, 0, 4.26, false, false],
        ["colorShift", 0, 7.31, 0, 14.62, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07b"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 13.61, 0, 23, false, false],
        ["contrast", 0, 1.13, 1, 5, false, false],
        ["orbSize", 0, 0.4, 0.01, 2, false, false],
        ["radius", 0, 2.38, 1, 5, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.04, 0, 0.1, false, false],
        ["sinMul", 0, 0.25, 0, 2, false, false],
        ["cosMul", 0, 0.2, 0, 1, false, false],
        ["yMul", 0, 0.9, 0, 5, false, false],
        ["xMul", 0, 1.27, 0, 5, false, false],
        ["xSpeed", 0, -0.71, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca082"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/13.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/11.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/6000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, _pow) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 19.15, 0, 38.3, false, false],
        ["yDivider", 0, 187.19, 0, 374.38, false, false],
        ["xDivider", 0, 130.77, 0, 261.54, false, false],
        ["multiplier", 0, 378.53, 0, 757.06, false, false],
        ["ballSize", 0, 0.87, 0, 1.74, false, false],
        ["contrast", 0, 1.77, 0, 3.54, false, false],
        ["radius", 0, 11.96, 0, 23.92, false, false],
        ["yOuter", 0, 0.42, 0, 0.84, false, false],
        ["xOuter", 0, 0.42, 0, 0.84, false, false],
        ["rotation", 0, 0.76, 0, 1.52, false, false],
        ["_pow", 0, 4.09, 0, 8.18, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca09b"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c2"
    },
    "shader": "\n#define BALLS 20.\n  \nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 2, false, false],
        ["contrast", 0, 3.03, 0, 8, false, false],
        ["ballSize", 0, 0.016, 0, 0.05, false, false],
        ["radius", 0, 45.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0df"
    },
    "shader": "#define BALLS 12\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / 1.5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *= rotate2d(stream/15.);\n  uv = abs(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += itY *float(i)*cos(uv.y/yDivider - stream) - 2.*sin(uv.x/xDiv - stream/3.);\n    uv.x += itX *float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider - stream /4.) - sin(uv.y/yDiv-stream/2.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t- uv.x/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 211. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 30.19243806475904, 0, 117.14, false, false],
        ["yDivider", 0, 3.157021837349398, 0, 4, false, false],
        ["xDivider", 0, 13.953981551204821, 0, 18, false, false],
        ["multiplier", 0, 0.23878953313253018, 0, 2, false, false],
        ["ballSize", 0, 33, 0, 33, false, false],
        ["contrast", 0, 0.7774875753012048, 0, 2.38, false, false],
        ["radius", 0, 99.06938064759036, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 16.12448230421687, 1, 111, false, false],
        ["yDiv", 0, 29.392187500000006, 0, 332, false, false],
        ["xDiv2", 0, 60.20790662650604, 0, 112, false, false],
        ["itY", 0, 0.0981174698795181, 0, 1, false, false],
        ["itX", 0, 0.18025790662650606, 0, 0.2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e6"
    },
    "shader": "\n\n#define BALLS 15\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle),\n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(time/200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/30.);\n\tif (warpTween) {\n   \tif (warp) {\n    \tuv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n   \tif (kaleidoscope) {\n    \tuv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    } \n  } else if (kaleidoscope) {\n    uv = kale(uv, vec2(0.), sides);\n  }\n  uv *= rotate2d(rotation * (dist - stream/200.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/15.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.21, 1, 8, false, false],
        ["xMultiplier", 0, 49.77, 0, 200, false, false],
        ["yMultiplier", 0, 0, 0, 200, false, false],
        ["ballSize", 0, 1.37, 0, 2, false, false],
        ["colorSpread", 0, 1.21, 0.2, 7, false, false],
        ["colorMultiplier", 0, 500, 1, 500, false, false],
        ["shapeMultiplier", 0, 17.27, 0, 210, false, false],
        ["glow", 0, 2080.32, 0, 10000, false, false],
        ["contrast", 0, 4.53, 1, 10, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["brightness", 0, 6430.09, 0, 11100, false, false],
        ["sides", 0, 9, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 1.1, 0, 8, false, false],
        ["xMultiplier", 0, 200, 0, 200, false, false],
        ["yMultiplier", 0, 167.38, 0, 200, false, false],
        ["ballSize", 0, 0.6, 0, 2, false, false],
        ["colorSpread", 0, 0.27, 0.2, 7, false, false],
        ["colorMultiplier", 0, 256.75, 1, 500, false, false],
        ["shapeMultiplier", 0, 65.06, 0, 210, false, false],
        ["glow", 0, 8509.81, 0, 10000, false, false],
        ["contrast", 0, 4.52, 1, 10, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["brightness", 0, 5636, 0, 11100, false, false],
        ["sides", 0, 10, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 1.09, 1, 8, false, false],
        ["xMultiplier", 0, 63.13, 0, 200, false, false],
        ["yMultiplier", 0, 77.92, 0, 200, false, false],
        ["ballSize", 0, 0.52, 0, 2, false, false],
        ["colorSpread", 0, 1.71, 0.2, 7, false, false],
        ["colorMultiplier", 0, 256.75, 1, 500, false, false],
        ["shapeMultiplier", 0, 65.06, 0, 210, false, false],
        ["glow", 0, 8509.81, 0, 10000, false, false],
        ["contrast", 0, 4.52, 1, 10, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["brightness", 0, 5636, 0, 11100, false, false],
        ["sides", 0, 10, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.45, 0.1, 8, false, false],
        ["xMultiplier", 0, 24.23, 0, 200, false, false],
        ["yMultiplier", 0, 13.15, 0, 200, false, false],
        ["ballSize", 0, 0.6, 0, 2, false, false],
        ["colorSpread", 0, 1.71, 0.2, 7, false, false],
        ["colorMultiplier", 0, 256.75, 1, 500, false, false],
        ["shapeMultiplier", 0, 65.06, 0, 210, false, false],
        ["glow", 0, 8509.81, 0, 10000, false, false],
        ["contrast", 0, 4.52, 1, 10, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["brightness", 0, 5636, 0, 11100, false, false],
        ["sides", 0, 10, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f70"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x + stream)) * uv.x + radius * sin(t + xMultiplier + stream), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.08, 0, 2.16, false, false],
        ["ballSize", 0, 0.099, 0, 0.198, false, false],
        ["contrast", 0, 4.47, 0, 8.94, false, false],
        ["radius", 0, 1.91, 0, 3.82, false, false],
        ["yOuter", 0, 45.35, 0, 90.7, false, false],
        ["xOuter", 0, 15.27, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.68, 0, 7.36, false, false],
        ["yMultiplier", 0, 9.62, 0, 19.24, false, false],
        ["divider", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f73"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 30.12751317771085, 0, 151, false, false],
        ["contrast", 0, 1.42, 0, 2, false, false],
        ["orbSize", 0, 0.7, 0.01, 2, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 11.5300734186747, 10, 40, false, false],
        ["div2", 0, 10, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f92"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream);\n    float y = radius * cos(sin(t + stream / 10.) + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, uv.x * .02 * dist + orbSize * volume, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.831, 0, 20, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 0.685, 0, 0.76, false, false],
        ["radius", 0, 2.435, 0, 3.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa5"
    },
    "shader": "#define orbs 10.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}  \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n\n  uv *= rotate(stream/13.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/115.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/3.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 22.345463102409646, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0.64, 0, 1, false, false],
        ["x2", 0, 0.34, 0, 1, false, false],
        ["y1", 0, 0.41, 0, 1, false, false],
        ["y2", 0, 1.06, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb1"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(stream/3.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 0.64, 0, 1.28, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0.91, 0, 1.82, false, false],
        ["y1", 0, 0.37, 0, 0.74, false, false],
        ["y2", 0, 1.86, 0, 3.72, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc8"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= rotate(stream/2.);\n\t\tif (mirrorTween) {\n      if (mirror) {\n\t\t\t\tuv = mix(uv, abs(uv), mirrorTweenProgress);        \n      } else {\n       \tuv = mix(abs(uv), uv, mirrorTweenProgress); \n      }\n    } else if (mirror) {\n     \tuv = abs(uv); \n    }\n    vec2 _kale = kale(uv, vec2(center), sides);\n\t\tif (kaleidoscopeTween) {\n      if (kaleidoscope) {\n\t\t\t\tuv = mix(uv, _kale, kaleidoscopeTweenProgress);        \n      } else {\n       \tuv = mix(_kale, uv, kaleidoscopeTweenProgress); \n      }\n    } else if (kaleidoscope) {\n     \tuv = _kale; \n    }\n\t\tuv *= rotate(stream/1.);\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/1.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/1.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 2.64, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 4.35, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 30.99, 0, 61, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fcd"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x *= abs(dist + .009 * dist * (i + 1.) * (uv.x));\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 3.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.88, 0, 3.76, false, false],
        ["contrast", 0, 1.75, 0, 3.5, false, false],
        ["orbSize", 0, 0.55, 0, 1.1, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 8.84, 0, 17.68, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fa3"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 5.;\n  uv *= k_rotate2d(stream/2.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x-stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t-stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  }",
    "variants": [
      [
        ["zoom", 0, 22.345463102409646, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 2.404405120481928, 0, 3, false, false],
        ["x2", 0, 0.8480045180722893, 0, 1, false, false],
        ["y1", 0, 0.41, 0, 1, false, false],
        ["y2", 0, 1.06, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 6.943693524096386, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.35281795933734944, 0.01, 2, false, false],
        ["radius", 0, 1.463413027108434, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0, 0, 1, false, false],
        ["x2", 0, 0.07756023333999278, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 3.9954113328313263, 0, 5, false, false],
        ["center", 0, 9.759704442771085, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 20.516971009036148, 0, 221, false, false],
        ["contrast", 0, 1.6040850903614459, 1, 5, false, false],
        ["orbSize", 0, 0.6914401355421687, 0.01, 2, false, false],
        ["radius", 0, 1.0743787650602412, 0, 2, false, false],
        ["colorShift", 0, 7.42, 4, 10, false, false],
        ["x1", 0, 0.006485316265060244, 0, 1, false, false],
        ["x2", 0, 0.39095914909638557, 0, 1, false, false],
        ["y1", 0, 0.5479049740494154, 0, 1, false, false],
        ["y2", 0, 0.29673381024096396, 0, 5, false, false],
        ["center", 0, 2.7102409638554223, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 15.777244917168678, 0, 221, false, false],
        ["contrast", 0, 1.08, 1, 5, false, false],
        ["orbSize", 0, 1.1566663215361448, 0.01, 2, false, false],
        ["radius", 0, 4.044220632530121, 1, 115, false, false],
        ["colorShift", 0, 5.551138930722892, 4, 10, false, false],
        ["x1", 0, 0.30045180722891573, 0, 3, false, false],
        ["x2", 0, 1, 0, 1, false, false],
        ["y1", 0, 0.5074830572289157, 0, 1, false, false],
        ["y2", 0, 3.37050545933735, 0, 5, false, false],
        ["center", 0, 7.7, 0, 22, false, false],
        ["sides", 0, 5, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fd5"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.009* dist*(i+1.) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 1.88, 0, 3.76, false, false],
        ["contrast", 0, 1.75, 0, 3.5, false, false],
        ["orbSize", 0, 0.55, 0, 1.1, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 8.84, 0, 17.68, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00b"
    },
    "shader": "void main () {\n  float stream = stream/1. + pow(stream, .9)/1.;\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(-stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 4.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(.5);// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/1.))*uv.x/yMultiplier*PI+radius\n                  * yMultiplier*cos(stream/1. -uv.x/xDiv * sin(uv.y/yDiv-stream/3.14)), radius*\n                  cos(stream/4. - yOuter*uv.x/xDiv+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/yDiv2-stream/4.45)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (1.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 33.30431099397591, 0, 250, false, false],
        ["ballSize", 0, 4.467959337349398, 2, 120, false, false],
        ["contrast", 0, 2.5764307228915664, 0, 15, false, false],
        ["radius", 0, 47.4550545933735, 0, 250, false, false],
        ["yOuter", 0, 6.027861445783134, -1, 44, false, false],
        ["xOuter", 0, 117.67243975903617, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.8636577560240974, 0, 10, false, false],
        ["yMultiplier", 0, 1.62468561746988, 0.2, 12, false, false],
        ["divider", 0, 1.2380176957831328, 0, 2, false, false],
        ["rotation", 0, 0, 0, 5, false, false],
        ["yDiv", 0, 94.5881965361446, 0, 110, false, false],
        ["yDiv2", 0, 112, 0, 112, false, false],
        ["xDiv", 0, 5.729734563253014, 0, 42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca00f"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / 1.5;\n  \n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  vec2 _uv = uv;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n\n  float dist = length(uv);\n  uv *= rotate2d(stream/10.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\t uv.y += itY * float(i) * cos(uv.y/yDivider - stream/2.) - sin(uv.x/xDiv - stream/2.);\n    uv.x += itX * float(i) * cos(uv.y/xDivider) - length(sin(stream/4. + .01*uv))*cos(uv.x/xDiv - stream/4.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream);\n    vec2 p = radius*vec2(oS*cos(t - stream), oT*sin(stream/3. + t- uv.x/multiplier));\n    p /= 1.1 +sin(PI * sin(uv.y/yShape- stream)*cos(stream/2.+uv.x/xDiv2));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 53.73293577243752, 0, 117.14, false, false],
        ["yDivider", 0, 2.1694277108433737, 0, 4, false, false],
        ["xDivider", 0, 4.430280496987952, 0, 18, false, false],
        ["multiplier", 0, 1.2283603162650605, 0, 2, false, false],
        ["ballSize", 0, 7.5453642695783145, 0, 33, false, false],
        ["contrast", 0, 0.6708647402108434, 0, 2.38, false, false],
        ["radius", 0, 128.25703125, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 151.80625, 0, 332, false, false],
        ["xDiv2", 0, 15.67018542921687, 0, 33, false, false],
        ["itY", 0, 0.1551346009036145, 0, 0.2, false, false],
        ["itX", 0, 0.09707172439759039, 0, 0.2, false, false],
        ["oS", 0, 0.249378765060241, 0, 2, false, false],
        ["oT", 0, 0.6427899096385543, 0, 2, false, false],
        ["yShape", 0, 4.247590361445784, 0, 32, false, false]
      ],
      [
        ["zoom", 0, 32.46323842243976, 0, 117.14, false, false],
        ["yDivider", 0, 2.951618975903615, 0, 4, false, false],
        ["xDivider", 0, 0.42119728915662663, 0, 18, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 21.58139118975904, 0, 33, false, false],
        ["contrast", 0, 1.1464503012048195, 0, 2.38, false, false],
        ["radius", 0, 165.77595067771088, 0, 333, false, false],
        ["rotation", 0, 0.12331758283132532, 0, 0.46, false, false],
        ["xDiv", 0, 29.762142319277114, 1, 111, false, false],
        ["yDiv", 0, 23.026562500000004, 0, 332, false, false],
        ["xDiv2", 0, 33, 0, 33, false, false],
        ["itY", 0, 0.041319008087971405, 0, 0.2, false, false],
        ["itX", 0, 0, 0, 0.2, false, false],
        ["oS", 0, 0, 0, 2, false, false],
        ["oT", 0, 1.8478727409638558, 0, 2, false, false],
        ["yShape", 0, 25.166716867469884, 0, 32, false, false]
      ],
      [
        ["zoom", 0, 25.434176863704824, 0, 117.14, false, false],
        ["yDivider", 0, 2.951618975903615, 0, 4, false, false],
        ["xDivider", 0, 0.42119728915662663, 0, 18, false, false],
        ["multiplier", 0, 2, 0, 2, false, false],
        ["ballSize", 0, 17.750080007530123, 0, 33, false, false],
        ["contrast", 0, 1.1464503012048195, 0, 2.38, false, false],
        ["radius", 0, 182.8381259412651, 0, 333, false, false],
        ["rotation", 0, 0.2845297439759037, 0, 0.46, false, false],
        ["xDiv", 0, 1, 1, 111, false, false],
        ["yDiv", 0, 0, 0, 332, false, false],
        ["xDiv2", 0, 33, 0, 33, false, false],
        ["itY", 0, 0, 0, 0.2, false, false],
        ["itX", 0, 0, 0, 0.2, false, false],
        ["oS", 0, 0, 0, 2, false, false],
        ["oT", 0, 0.9522213855421688, 0, 2, false, false],
        ["yShape", 0, 17.82530120481928, 0, 32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca015"
    },
    "shader": "// License: CC0\n//  Results after some random coding while listening to online concert\n\n// Experiment with these parameters for variants\n\nconst int   rep   = 13 ;\n\n#define PHI   ((1./sqrt(PI)))\n#define TAU   (1.0*PI)\n#define TTIME (TAU*stream)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*0.5*(0.05 + 0.05*sin(1.0*length(p) - 0.5*p.y + TTIME/2.0));\n        \n  return dmin;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat df(vec2 p) {\n  float d = 100.0;\n  float off = 0.7  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p =1.6*(q - 0.5);\n  p.x *= resolution.x/resolution.y;\n  float d = df(p);\n\n  float fuzzy = 0.0025;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(1.0, 1.0, 1.0)); \n  col *= 1.0 - tan(0.05+length(8.0*d));\n\n  float phase = TAU/8.0*(-length(p) - 0.5*p.y) + TTIME/16.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 8.25);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(2.25, 2.5, 2.75));\n  col = postProcess(col, q, p);\n\n  gl_FragColor = vec4(col, 1.0);\n}",
    "variants": [
      [
        ["zoom", 0, 5.871, 0, 12, false, false],
        ["size", 0, 3.76, 0, 12, false, false],
        ["offc", 0, 0.135, 0, 0.5, false, false],
        ["width", 0, 0, 0, 0.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca01d"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.84553, 0, 21, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 5,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca022"
    },
    "shader": "mat2 r2d(in float degree)\n{\n  float rad = radians(degree);\n  float c = cos(rad);\n  float s = sin(rad);\n  return mat2(vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash(in vec2 p)\n{\n  p = vec2(dot(p, vec2(17.1, 311.7)),\n    dot(p, vec2(29.5, 13.3)));\n\n  return -1. + 1021. * fract(sin(p) * 43758.5453123 * sin(stream / 1000000.) * cos(stream / 10000.));\n}\n\nfloat noise(in vec2 p)\n{\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2. * K2;\n\n  vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash(i + .0)),\n    dot(b, hash(i + o)),\n    dot(c, hash(i + 1.)));\n\n  return dot(n, vec3(3.));\n}\n\nfloat fbm(in vec2 p)\n{\n  mat2 rot = r2d(11111111.5);\n  float d = noise(p); p *= rot;\n  d += 1.5 * noise(p); p *= rot;\n  d += .25 * noise(p); p *= rot;\n  d += .125 * noise(p); p *= rot;\n  d += .625 * noise(p);\n  d /= (1. + .5 + .25 + .125 + .0625);\n  return d;\n}\n\nvec2 mapToScreen(in vec2 p, in float scale)\n{\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  return abs(uv);\n  return abs(uv) * outer * sin(stream / 20.) * sin(dot(uv, uv) - stream * 3.); //- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar(in vec2 cart)\n{\n  float r = length(cart);\n  float phi = atan(cart.y, cart.x);\n  return vec2(r, phi);\n}\n\nvec2 polar2cart(in vec2 polar)\n{\n  float x = polar.x;\n  float y = polar.y;\n  vec2 fuck = vec2(x, y);\n  return vec2(fuck);\n}\n\nvoid main()\n{\n  vec2 uv = mapToScreen(gl_FragCoord.xy / resolution.xy, zoom);\n  float len = length(sin(uv - 34.21 * stream));\n  float thicc = thickness * length(abs(uv)) * length(sin(uv + stream));\n  float d1 = size * abs(sin(stream + uv.x * haze) * thicc * (cos(uv.x + stream) + fbm(a * uv + stream)));\n  float d2 = size * abs(sin(stream - uv.y * haze) * thicc * (sin(uv.y - stream) * fbm(b * uv + stream)));\n  float d3 = size * abs(cos(stream + uv.x * uv.y / haze) * thicc * (uv.x - log(uv.y) + fbm(c * uv + stream)));\n  vec3 col = vec3(.0);\n  col += d1 * size * abs(sin(col1 - stream / 20.));\n  col += d2 * size * abs(tan(col2 - stream / 20.));\n  col += d3 * size * col3;\n\n  gl_FragColor = vec4(.5 - 1. * sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.36, 0, 0.72, false, false],
        ["thickness", 0, 0.0391, 0, 0.0782, false, false],
        ["haze", 0, 1100, 0, 2200, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.007, 0, 0.014, false, false],
        ["a", 0, 31.29, 0, 62.58, false, false],
        ["b", 0, 4.01, 0, 8.02, false, false],
        ["c", 0, 1.14, 0, 2.28, false, false],
        ["outer", 0, 2.62, 0, 5.24, false, false],
        ["inner", 0, 3.13, 0, 6.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca035"
    },
    "shader": "\n#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .00005 * dot(uv, uv) + stream/3.) * sin(.0001 * dot(uv, uv)-stream/6.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/2.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 91.99, 0, 151, false, false],
        ["contrast", 0, 1.25, 0, 2, false, false],
        ["orbSize", 0, 1.11, 0.01, 2, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 23.45, 3, 33, false, false],
        ["div", 0, 45.722, 10, 40, false, false],
        ["div2", 0, 63.807, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca049"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/5000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 25.95, 0, 51.9, false, false],
        ["contrast", 0, 0.82, 0, 1.64, false, false],
        ["orbSize", 0, 0.3, 0, 0.6, false, false],
        ["radius", 0, 12.89, 0, 25.78, false, false],
        ["colorShift", 0, 10.54, 0, 21.08, false, false],
        ["div", 0, 40, 0, 80, false, false],
        ["div2", 0, 40, 0, 80, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05a"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv / dot(uv, uv), warpTweenProgress);\n    } else {\n      uv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n    uv /= dot(uv, uv);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / .5 * PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10. / dist) / t * radius * sin(stream / 3. + dist * t) * cos(uv.y * dist - stream) * sin(dist - stream / 2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.47, 0, 4.94, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["orbSize", 0, 0.51, 0, 1.02, false, false],
        ["radius", 0, 5.46, 0, 10.92, false, false],
        ["colorShift", 0, 7.8, 0, 15.6, false, false],
        ["center", 0, 2.76, 0, 5.52, false, false],
        ["sides", 0, 15, 0, 30, false, false],
        ["shape", 0, 0.18, 0, 0.36, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca05b"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 19.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv / dot(uv, uv), warpTweenProgress);\n    } else {\n      uv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n    uv /= dot(uv, uv);\n  }\n  vec2 kale_ = sin(k_kale(uv, vec2(center), sides) - stream);\n  if (kkkTween) {\n    if (kkk) {\n      uv = mix(uv, (kale_), kkkTweenProgress);\n    } else {\n      uv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n    uv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / .5 * PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base / dist) / t * radius * sin(stream / 3. + dist * t) * cos(uv.y * dist - stream) * sin(dist - stream / 2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.33, 0, 8.66, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 6.4, 0, 12.8, false, false],
        ["colorShift", 0, 5.57, 0, 11.14, false, false],
        ["center", 0, 2.71, 0, 5.42, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.18, 0, 0.36, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kkk", 1, false, null, null, null, false],
        ["base", 0, 7.16, 0, 14.32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06e"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 55.74, false, false],
        ["contrast", 0, 0.89, 0, 1.78, false, false],
        ["orbSize", 0, 0.66, 0, 1.32, false, false],
        ["radius", 0, 12.33, 0, 24.66, false, false],
        ["colorShift", 0, 9.55, 0, 19.1, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.7, 0, 1.4, false, false],
        ["cosMul", 0, 0.98, 0, 1.96, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.57, 0, 1.14, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0048, 0, 0.0096, false, false],
        ["yDivide", 0, 4.98, 0, 9.96, false, false],
        ["xDivide", 0, 19, 0, 38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca099"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\n  float dist = length(uv);\n  //  uv *= sin(uv.y/20.)+k_rotate2d(dist/10.-stream/20.);\n\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .362 * float(i) * cos(uv.y / yDivider - stream / 111.) + sin(uv.x / 21. - stream / 112.);\n    uv.x += .152 * float(i) * cos(uv.y / xDivider) + sin(uv.x / xDivider - stream / 111.) - sin(uv.y / 210. + stream / 112.);\n    float t = .005 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 415. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5 + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 52.32, 0, 104.64, false, false],
        ["yDivider", 0, 472.4, 0, 944.8, false, false],
        ["xDivider", 0, 377.14, 0, 754.28, false, false],
        ["multiplier", 0, 58.37, 0, 116.74, false, false],
        ["ballSize", 0, 0.57, 0, 1.14, false, false],
        ["contrast", 0, 1.78, 0, 3.56, false, false],
        ["radius", 0, 7.86, 0, 15.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a6"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.22, 0, 5.22, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.203, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a58"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ab"
    },
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 1.58, false, false],
        ["contrast", 0, 3.03, 0, 6.06, false, false],
        ["ballSize", 0, 0.016, 0, 0.032, false, false],
        ["radius", 0, 45.33, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 3.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ae"
    },
    "shader": "\n#define BALLS 20.\n  \nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz =pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.79, 0, 2, false, false],
        ["contrast", 0, 3.03, 0, 8, false, false],
        ["ballSize", 0, 0.016, 0, 0.05, false, false],
        ["radius", 0, 45.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 1.83, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0bd"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 2, false, false],
        ["contrast", 0, 4.99, 0, 8, false, false],
        ["ballSize", 0, 0.011, 0, 0.05, false, false],
        ["radius", 0, 45.33, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c5"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream * 2. + abs(uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5) * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow(dist, 3.) * pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.63, 0, 1.26, false, false],
        ["contrast", 0, 2.58, 0, 5.16, false, false],
        ["ballSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 131.23, 0, 262.46, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c6"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.028, false, false],
        ["shapeMultiplier", 0, 589.178, 0, 1518.42, false, false],
        ["rotation", 0, 0.012, 0, 0.05134, false, false],
        ["xMultiplier", 0, 251.592, 0, 1469.28, false, false],
        ["yMultiplier", 0, 1549.9, 0, 11111, false, false],
        ["colorSpread", 0, 0.000012, 0, 0.000024, false, false],
        ["colorMultiplier", 0, 0.51, 0, 1.02, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.86, 0, 3.72, false, false],
        ["ballSize", 0, 6.194, 0, 28.78, false, false],
        ["glow", 0, 4.435, 0, 7.58, false, false],
        ["contrast", 0, 3.189, 0, 4.3, false, false],
        ["radius", 0, 10.691, 0, 38.32, false, false],
        ["zoom2", 0, 0.48, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0c8"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.028, false, false],
        ["shapeMultiplier", 0, 589.178, 0, 1518.42, false, false],
        ["rotation", 0, 0.012, 0, 0.05134, false, false],
        ["xMultiplier", 0, 251.592, 0, 1469.28, false, false],
        ["yMultiplier", 0, 1549.9, 0, 11111, false, false],
        ["colorSpread", 0, 0.000012, 0, 0.000024, false, false],
        ["colorMultiplier", 0, 0.51, 0, 1.02, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.86, 0, 3.72, false, false],
        ["ballSize", 0, 6.194, 0, 28.78, false, false],
        ["glow", 0, 4.435, 0, 7.58, false, false],
        ["contrast", 0, 3.189, 0, 4.3, false, false],
        ["radius", 0, 10.691, 0, 38.32, false, false],
        ["zoom2", 0, 0.48, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0dd"
    },
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/15.);  \n\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider + stream / -2.) + cos(uv.x/c + stream/-3.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * tan(uv.y/300.)*cos(uv.y/106.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, 2.04)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 7.44, 0, 22, false, false],
        ["yDivider", 0, 3.95, 0.1, 122, false, false],
        ["xDivider", 0, 0.43, 0.1, 19, false, false],
        ["multiplier", 0, 0.57, 0.01, 11, false, false],
        ["ballSize", 0, 0.56, 0, 1, false, false],
        ["contrast", 0, 1.64, 0, 5, false, false],
        ["radius", 0, 1.54, 0, 11, false, false],
        ["rotation", 0, 0.19, 0, 1, false, false],
        ["a", 0, 0.03, 0, 0.1, false, false],
        ["b", 0, 0.13, 0, 1, false, false],
        ["c", 0, 2.23, 0, 8, false, false],
        ["d", 0, 2.2, 1, 13, false, false],
        ["e", 0, 0.34, 0, 2, false, false],
        ["f", 0, 0.95, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0e3"
    },
    "shader": "\n#define BALLS 10.\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  //uv /= dot(uv, uv);\n  float dist = length(sin(2.*stream/3.+log(.1*abs(uv))));\n  uv *= rotate2d(dist-rotation-stream/.5);\n  uv *= cos(dotMultiplier*(cos(stream+dot(abs(uv), log(abs(uv)))) - stream/.5)-stream);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(radius*cos(t), sin(radius*t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 21. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(col * pow(volume, .5)*pow(dist, 2.)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 4.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.896, 0, 115, false, false],
        ["contrast", 0, 1.51, 0, 5, false, false],
        ["ballSize", 0, 0.1211, 0, 1, false, false],
        ["radius", 0, 2.2, 0, 110, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["dotMultiplier", 0, 1, 1, 5, false, false],
        ["tanMul", 0, 4.35, 0, 10, false, false],
        ["sinMul", 0, 2.8, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca113"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 15.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream / .1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  uv = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 20.));\n  float _grid = (cos(uv.x * xMultiplier - stream / .5) - sin(uv.y * yMultiplier + stream / 1500.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 3.06, 0, 6.12, false, false],
        ["xMultiplier", 0, 35.99, 0, 71.98, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 1.25, 0, 2.5, false, false],
        ["colorSpread", 0, 3.36, 0, 6.72, false, false],
        ["colorMultiplier", 0, 114.55, 0, 229.1, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 26.92, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 3.17, 0, 6.34, false, false],
        ["rotation", 0, 11.471, 0, 22.942, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f78"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-18.);\n  //uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 15; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * rotation);\n    uv.y -= float(i) / oY * cos(uv.y / yDiv + stream / .9) - cos(uv.x / xDiv2 - stream / 10.);\n    uv.x += float(i) / oX * sin(uv.x / xDiv + stream / 4.) - sin(uv.y / yDiv2 + stream / -4.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius * vec2(xMul * cos(t / multiplier + stream / 4.), yMul * sin(t / multiplier + stream / 5.));\n    p /= sin(PI * sin(uv.x / xDiv3 + stream / 3.) - cos(uv.y / yDiv3 - stream / 31.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .364)/7. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 176.593, 0, 200, false, false],
        ["xDiv", 0, 192.407, 0, 200, false, false],
        ["yDiv", 0, 4.196, 0, 20, false, false],
        ["xDiv2", 0, 1.126, 0, 20, false, false],
        ["yDiv2", 0, 5.65, 0, 40, false, false],
        ["xDiv3", 0, 45.225, 0, 400, false, false],
        ["yDiv3", 0, 3.119, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 46.211, 0, 50, false, false],
        ["contrast", 0, 2.483, 0, 3, false, false],
        ["radius", 0, 15.486, 0, 30, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["xMul", 0, 1.595, 0, 20, false, false],
        ["yMul", 0, 7.948, 0, 20, false, false],
        ["oY", 0, 14.309, 0, 44, false, false],
        ["oX", 0, 10.51, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 39.827, 0, 200, false, false],
        ["xDiv", 0, 135.065, 0, 200, false, false],
        ["yDiv", 0, 4.069, 0, 20, false, false],
        ["xDiv2", 0, 3.117, 0, 20, false, false],
        ["yDiv2", 0, 4.848, 0, 40, false, false],
        ["xDiv3", 0, 335.931, 0, 400, false, false],
        ["yDiv3", 0, 11.775, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 22.294, 0, 50, false, false],
        ["contrast", 0, 2.468, 0, 3, false, false],
        ["radius", 0, 3.377, 0, 30, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["xMul", 0, 12.641, 0, 20, false, false],
        ["yMul", 0, 3.55, 0, 20, false, false],
        ["oY", 0, 38.286, 0, 44, false, false],
        ["oX", 0, 1.905, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 65.801, 0, 200, false, false],
        ["xDiv", 0, 86.58, 0, 200, false, false],
        ["yDiv", 0, 0.779, 0, 20, false, false],
        ["xDiv2", 0, 3.983, 0, 20, false, false],
        ["yDiv2", 0, 3.463, 0, 40, false, false],
        ["xDiv3", 0, 100.433, 0, 400, false, false],
        ["yDiv3", 0, 7.416, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 18.615, 0, 50, false, false],
        ["contrast", 0, 1.857, 0, 3, false, false],
        ["radius", 0, 4.286, 0, 30, false, false],
        ["rotation", 0, 0.000273, 0, 0.001, false, false],
        ["xMul", 0, 2.338, 0, 20, false, false],
        ["yMul", 0, 5.368, 0, 20, false, false],
        ["oY", 0, 39.81, 0, 44, false, false],
        ["oX", 0, 5.455, 0, 20, false, false]
      ],
      [
        ["zoom", 0, 43.29, 0, 200, false, false],
        ["xDiv", 0, 35.498, 0, 200, false, false],
        ["yDiv", 0, 12.121, 0, 20, false, false],
        ["xDiv2", 0, 0.606, 0, 20, false, false],
        ["yDiv2", 0, 40, 0, 40, false, false],
        ["xDiv3", 0, 72.727, 0, 400, false, false],
        ["yDiv3", 0, 5.524, 1, 20, false, false],
        ["multiplier", 0, 1.065, 0, 3, false, false],
        ["ballSize", 0, 44.805, 0, 50, false, false],
        ["contrast", 0, 2.506, 0, 3, false, false],
        ["radius", 0, 4.935, 0, 30, false, false],
        ["rotation", 0, 0.000429, 0, 0.001, false, false],
        ["xMul", 0, 12.294, 0, 20, false, false],
        ["yMul", 0, 3.636, 0, 20, false, false],
        ["oY", 0, 20.571, 0, 88, false, false],
        ["oX", 0, 5.801, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f82"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  vec2 mirrored = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _dotted = uv * sin(.0001 * dot(uv, uv) - stream / 10.);\n  if (mirrorTween) {\n    if (dotted) {\n      uv = mix(uv, mirrored, dottedTweenProgress);\n    } else {\n      uv = mix(mirrored, uv, dottedTweenProgress);\n    }\n  } else if (mirror) {\n    uv = mirrored;\n  }\n  if (dottedTween) {\n    if (dotted) {\n      uv = mix(uv, _dotted, dottedTweenProgress);\n    } else {\n      uv = mix(_dotted, uv, dottedTweenProgress);\n    }\n  } else if (dotted) {\n    uv = _dotted;\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 116.00066318094458, 0, 383.44, false, false],
        ["yDivider", 0, 2.0108340560372664, 0, 4.04, false, false],
        ["xDivider", 0, 19.66732405775273, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 26.2977033459619, 0, 52.7, false, false],
        ["contrast", 0, 3.1896125184039077, 0, 6.38, false, false],
        ["radius", 0, 51.601894147360014, 0, 51.76, false, false],
        ["rotation", 0, 10.745, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 1.485310136543849, 0, 2.98, false, false],
        ["yShape", 0, 14.65960528313752, 0, 29.46, false, false],
        ["shape", 0, 71.5548653767282, 0, 142.16, false, false],
        ["dotted", 1, false, null, null, null, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 113.869, 0, 383.44, false, false],
        ["yDivider", 0, 0.648, 0, 4.04, false, false],
        ["xDivider", 0, 4.401, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 18.522, 0, 52.7, false, false],
        ["contrast", 0, 3.132, 0, 6.38, false, false],
        ["radius", 0, 28.094, 0, 51.76, false, false],
        ["rotation", 0, 10.745, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 0.788, 0, 2.98, false, false],
        ["yShape", 0, 4.193, 0, 29.46, false, false],
        ["shape", 0, 142.16, 0, 142.16, false, false],
        ["dotted", 1, false, null, null, null, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.717Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f60"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 200.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 30.);\n  if (warpTween) {\n    if (warp) {\n      uv = mix(uv, uv * uv, float(warpTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, float(warpTweenProgress));\n    }\n  } else if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, float(kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, float(kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 200.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 20.) - sin(uv.y * yMultiplier + stream / 15.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 229. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 3.21, 0, 6.42, false, false],
        ["xMultiplier", 0, 49.77, 0, 99.54, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["ballSize", 0, 1.37, 0, 2.74, false, false],
        ["colorSpread", 0, 1.21, 0, 2.42, false, false],
        ["colorMultiplier", 0, 500, 0, 1000, false, false],
        ["shapeMultiplier", 0, 17.27, 0, 34.54, false, false],
        ["glow", 0, 2080.32, 0, 4160.64, false, false],
        ["contrast", 0, 4.53, 0, 9.06, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["brightness", 0, 6430.09, 0, 12860.18, false, false],
        ["sides", 0, 9, 0, 18, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fb8"
    },
    "shader": "\n#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/30.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/50.);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 9.75, 0, 15, false, false],
        ["contrast", 0, 1.72, 1, 5, false, false],
        ["orbSize", 0, 0.54, 0.01, 2, false, false],
        ["radius", 0, 1, 1, 5, false, false],
        ["colorShift", 0, 4, 4, 10, false, false],
        ["x1", 0, 0.22, 0, 1, false, false],
        ["x2", 0, 0.38, 0, 1, false, false],
        ["y1", 0, 0.22, 0, 1, false, false],
        ["y2", 0, 1.03, 0, 5, false, false],
        ["center", 0, 3.95, 0, 11, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc9"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/162.);\n    float dist = length(sin(cos(uv+stream) + stream/1.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-5.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.96, 0, 15, false, false],
        ["contrast", 0, 0.85, 0, 2, false, false],
        ["orbSize", 0, 0.15, 0.01, 1, false, false],
        ["radius", 0, 1.15, 1, 5, false, false],
        ["colorShift", 0, 79.53, 1, 110, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.720Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fe6"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-60.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,1.1) * orbSize, vec2(radius*abs(tan(stream/11.3+uv.x/div)) * L *\n                                                              sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)), \n                          col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.03338, 0, 1, false],
        ["iterator", 0, 1.42433, 0, 2, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.139, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 20, 0, 33, false, false],
        ["L", 0, 1.457, 1, 2, false, false],
        ["M", 0, 0.358, 0, 1, false, false],
        ["colorShift", 0, 0.572, 0, 2, false, false],
        ["colorOffset", 0, 23.207, 0, 111, false, false],
        ["contrast", 0, 1.392, 0, 3, false, false],
        ["orbSize", 0, 0.647, 0, 2, false, false],
        ["div", 0, 0.16863, 0.01, 12, false],
        ["radius", 0, 7.992, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca025"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main () {\n  vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n  float len = length (sin(uv-stream));\n  float thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n  vec2 _uv = uv;\n   uv = abs(uv);\n\n  vec2 _warp = _uv / dot(uv, uv);\n  float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n  if (warpTween) {\n   \tif (warp) {\n    \tuv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n\t\t\tuv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\n  float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n\n  float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n  vec3 col = vec3 (.0);\n  col += d1*size*abs(sin(col1-stream/50.));\n if (warpTween) {\n   \tif (warp) {\n    \tuv = mix(_uv, _warp, warpTweenProgress);\n      uv *= warpZoom;\n    } else {\n\t\t\tuv = mix(_warp, uv, warpTweenProgress);\n      uv *= warpZoom;\n    }\n  } else {\n    if (warp) {\n      uv = _warp;\n      uv *= warpZoom;\n    }\n  }\n\tcol += d2*size*abs(cos(col2-stream/50.));\n\tcol += d3*size*col3;\n  gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.67, 0, 5, false, false],
        ["thickness", 0, 0.0182, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col2", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["col3", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["size", 0, 0.045, 0, 0.05, false, false],
        ["a", 0, 634.37, 0, 2100, false, false],
        ["b", 0, 7.61, 0, 50, false, false],
        ["c", 0, 2.78, 0, 50, false, false],
        ["warp", 1, false, null, null, null, false],
        ["warpZoom", 0, 2, 0.01, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca030"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 11.15, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.3, 0.01, 2, false, false],
        ["radius", 0, 12.89, 0, 14, false, false],
        ["colorShift", 0, 10.54, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.723Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca057"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom;\n\n  for (float i = 0.; i <5.; i++) {\n    uv += uv * k_rotate2d(rotation / (i + 1.))* k_rotate2d(.001*stream/(PI/.125/(i+1.)));;\n    float t = float(i) * PI / float(i);\n    vec2 p = vec2(xOuter-(radius*cos(stream-xMultiplier*uv.x))*uv.x/yMultiplier*PI*radius\n                  * yMultiplier*cos(stream/-31. + uv.x/xDiv * sin(stream/31.24-uv.y/yDiv/PI)), radius*\n                  cos(yOuter*uv.x/xDiv+t+yMultiplier));\n    vec3 col = cos(uv.x/xDiv2*sin(10.11*uv.y*yDiv2+stream/-12.01*PI)+vec3(-2, 0, -1) * PI * 2. / 50. \n                   + PI * (2.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * .8) * col, contrast);\n  }\n  gl_FragColor.xyz = (1.-pow(abs(1.-abs(-.5*log(abs(gl_FragColor.xyz)))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 1646.1309740181432, 0, 3544, false, false],
        ["ballSize", 0, 163.83789158097235, 2, 358, false, false],
        ["contrast", 0, 31.105512504118035, 0, 33, false, false],
        ["radius", 0, 0.7008733769042019, -1, 3, false, false],
        ["yOuter", 0, 1.8334986675216494, 0, 4, false, false],
        ["xOuter", 0, 19.315167898155124, 1, 66, false, false],
        ["xMultiplier", 0, 0.03616945565464986, 0, 0.2, false, false],
        ["yMultiplier", 0, 7.551691396322596, 0.2, 22, false, false],
        ["divider", 0, 0.76852540165545, 0, 2, false, false],
        ["rotation", 0, 5.062753576255707, 0, 21, false, false],
        ["yDiv", 0, 88.92895783573749, 0, 310, false, false],
        ["yDiv2", 0, 0.40368724271475553, 0, 3, false, false],
        ["xDiv", 0, 108.5551214011319, 0, 222, false, false],
        ["xDiv2", 0, 30197.249208942096, 0, 333772, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a51"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca052"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .00001 * dot(uv, uv) + stream/1.) * sin(.001 * dot(uv, uv)+stream/.5);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/1.);\n    float y = radius * cos(t+stream/-1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 79.62, 0, 159.24, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.61, 0, 1.22, false, false],
        ["radius", 0, 6.7, 0, 13.4, false, false],
        ["colorShift", 0, 23.39, 0, 46.78, false, false],
        ["div", 0, 40, 0, 80, false, false],
        ["div2", 0, 40, 0, 80, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca073"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 31.68, 0, 63.36, false, false],
        ["contrast", 0, 1.03, 0, 2.06, false, false],
        ["orbSize", 0, 2, 0, 4, false, false],
        ["radius", 0, 13, 0, 26, false, false],
        ["colorShift", 0, 7.12, 0, 14.24, false, false],
        ["sides", 0, 4, 0, 8, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 2, 0, 4, false, false],
        ["cosMul", 0, 0.94, 0, 1.88, false, false],
        ["yMul", 0, 0.14, 0, 0.28, false, false],
        ["xMul", 0, 0.05, 0, 0.1, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.006, 0, 0.012, false, false],
        ["yDivide", 0, 3.2, 0, 6.4, false, false],
        ["xDivide", 0, 2.08, 0, 4.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca077"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/2.) + sin(uv.x/3. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/2210.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*cos(t*multiplier), radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 16.1, 0, 32.2, false, false],
        ["yDivider", 0, 332.97, 0, 665.94, false, false],
        ["xDivider", 0, 377.39, 0, 754.78, false, false],
        ["multiplier", 0, 61.62, 0, 123.24, false, false],
        ["ballSize", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 3.52, 0, 7.04, false, false],
        ["radius", 0, 31.84, 0, 63.68, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca07c"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a54"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca094"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a57"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0a9"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / 1.5) * 1. * sin(dist + stream / 3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.22, 0, 5.22, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.203, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a58"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0af"
    },
    "shader": "\n#define BALLS 20.\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(abs(uv))); \n  uv *= sin(dotMultiplier*(dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(20.*dist*rotation*dist+stream/1.);\n  for (float i = 0.; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul*tan(t), sinMul*sin(t));\n   // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.513, 0, 1, false, false],
        ["contrast", 0, 2.1, 0, 30, false, false],
        ["ballSize", 0, 0.0083, 0, 0.1, false, false],
        ["radius", 0, 105.45, 1, 500, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 10, false, false],
        ["dotMultiplier", 0, 2.24, 0, 5, false, false],
        ["tanMul", 0, 3.12, 0, 10, false, false],
        ["sinMul", 0, 1.61, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b2"
    },
    "shader": "#define BALLS 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (abs(uv)));\n  uv *= sin(dotMultiplier * (dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(20. * dist * rotation * dist + stream / 1.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / BALLS;\n    vec2 p = vec2(tanMul * tan(t), sinMul * sin(t));\n    // p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.513, 0, 1.026, false, false],
        ["contrast", 0, 2.1, 0, 4.2, false, false],
        ["ballSize", 0, 0.0083, 0, 0.0166, false, false],
        ["radius", 0, 105.45, 0, 210.9, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["dotMultiplier", 0, 2.24, 0, 4.48, false, false],
        ["tanMul", 0, 3.12, 0, 6.24, false, false],
        ["sinMul", 0, 1.61, 0, 3.22, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b8"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(abs(uv));\n  float dist = length(uv);\n  uv = sin(stream*2.+abs(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .5)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.)*pow(dist, 3.)*pow(((gl_FragColor.xyz)), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.63, 0, 1.26, false, false],
        ["contrast", 0, 2.58, 0, 5.16, false, false],
        ["ballSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 131.23, 0, 262.46, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0dc"
    },
    "shader": "#define BALLS 16\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  float stream = stream / .5;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI + stream/130.);\n  for (int i = 0; i < BALLS; i++) {\n    uv = abs(uv);\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider) + cos(uv.x/c + stream/-2.);\n    uv.x += b*float(i)*cos(uv.y/xDivider)+atan(uv.x/xDivider) - f*sin(uv.y/d);\n    float t = .015*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(radius * cos(t), radius * e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/300.)*cos(uv.y/16.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 40. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(33.1/dist*((pow(volume, 1.)/1.*ballSize)) / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6.67, 0, 22, false, false],
        ["yDivider", 0, 81.88, 0.1, 122, false, false],
        ["xDivider", 0, 1.01, 0.1, 19, false, false],
        ["multiplier", 0, 5.86, 0.01, 11, false, false],
        ["ballSize", 0, 0.77, 0, 1, false, false],
        ["contrast", 0, 0.87, 0, 5, false, false],
        ["radius", 0, 1.73, 0, 11, false, false],
        ["rotation", 0, 0.22587259377776392, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0.18, 0, 1, false, false],
        ["c", 0, 1.61, 0, 8, false, false],
        ["d", 0, 3.05, 1, 13, false, false],
        ["e", 0, 0.34, 0, 2, false, false],
        ["f", 0, 0.95, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.61354989366002, 0, 111, false, false],
        ["yDivider", 0, 1.9712829910422611, 0.1, 22, false, false],
        ["xDivider", 0, 5.017385253372832, 0.1, 19, false, false],
        ["multiplier", 0, 10528.643868617806, 0.01, 22224, false, false],
        ["ballSize", 0, 1.0898527291689468, 0, 3.613661036159282, false, false],
        ["contrast", 0, 1.8993169481920358, 0, 5, false, false],
        ["radius", 0, 3.461095054074759, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.0640341525903982, 0, 1, false, false],
        ["b", 0, 0.061613661036159284, 0, 1, false, false],
        ["c", 0, 1.4230565591203275, 0, 8, false, false],
        ["d", 0, 6.6857779104421, 1, 13, false, false],
        ["e", 0, 1.8910778800592485, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 17.54, 0, 111, false, false],
        ["yDivider", 0, 10.19, 0.1, 22, false, false],
        ["xDivider", 0, 2.85, 0.1, 19, false, false],
        ["multiplier", 0, 11094.65, 0.01, 22224, false, false],
        ["ballSize", 0, 0.36, 0, 2, false, false],
        ["contrast", 0, 1.98, 0, 5, false, false],
        ["radius", 0, 0, 0, 151, false, false],
        ["rotation", 0, 0.38, 0, 1, false, false],
        ["a", 0, 0.05, 0, 1, false, false],
        ["b", 0, 0.5, 0, 1, false, false],
        ["c", 0, 1.44, 0, 8, false, false],
        ["d", 0, 7.09, 1, 13, false, false],
        ["e", 0, 2, 0, 2, false, false],
        ["f", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ef"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/100. * PI);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    vec3 col = k_rainbow(i * iterations, colorShift, colorOffset);\n    uv -= .621*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 44.466, 0, 1121, false, false],
        ["iterator", 0, 0.737, 0, 2, false, false],
        ["ot", 0, 66.673, 0, 151, false, false],
        ["I", 0, 2.876, 0, 3, false, false],
        ["J", 0, 2.574, 0, 3, false, false],
        ["K", 0, 41.562, 0, 111, false, false],
        ["iterations", 0, 16.81, 0, 33, false, false],
        ["L", 0, 91.488, 0, 2113, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 0.831, 0, 2, false, false],
        ["colorOffset", 0, 66.971, 0, 111, false, false],
        ["contrast", 0, 1.09, 1, 3, false, false],
        ["orbSize", 0, 5.062, 0, 13, false, false],
        ["div", 0, 2.042, 0, 12, false, false],
        ["radius", 0, 3.651, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f1"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/20.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= .61*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 247.892, 0, 1121, false, false],
        ["iterator", 0, 0.319, 0, 2, false, false],
        ["ot", 0, 66.673, 0, 151, false, false],
        ["I", 0, 2.876, 0, 3, false, false],
        ["J", 0, 2.574, 0, 3, false, false],
        ["K", 0, 41.562, 0, 111, false, false],
        ["iterations", 0, 4.305, 0, 33, false, false],
        ["L", 0, 91.488, 0, 2113, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 0.383, 0, 2, false, false],
        ["colorOffset", 0, 71.375, 0, 111, false, false],
        ["contrast", 0, 1.09, 1, 3, false, false],
        ["orbSize", 0, 2.838, 0, 13, false, false],
        ["div", 0, 1.906, 0, 12, false, false],
        ["radius", 0, 1.054, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f4"
    },
    "shader": "void main () {\n  float stream = stream / volumeDivider;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  uv *= k_rotate2d(stream/-1.);\n\n  mat2 rotation = k_rotate2d(length((-1. + 2. * gl_FragCoord.xy / resolution.xy)/12.)+ stream/3.);\n  uv *= k_rotate2d(stream/21.);\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - .2;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float x = radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y);\n    float y = radius*cos(stream/1.+uv.y/div);\n    vec2 position = vec2(x, y);\n    gl_FragColor += k_orb(uv, 1./length(uv) * pow(volume, reactivity)/6. * orbSize * gl_FragCoord.z, position,  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 321.999, 0, 1100, false, false],
        ["iterator", 0, 0.432, 0, 2, false, false],
        ["ot", 0, 151, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.987, 0, 3, false, false],
        ["K", 0, 58.378, 0, 111, false, false],
        ["iterations", 0, 7, 0, 33, false, false],
        ["L", 0, 117.24, 0, 213, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 0.813, 0, 2, false, false],
        ["colorOffset", 0, 2.629, 0, 12, false, false],
        ["contrast", 0, 0.644, 0, 5, false, false],
        ["orbSize", 0, 2, 0, 2, false, false],
        ["div", 0, 0.364, 0.1, 2, false, false],
        ["radius", 0, 0.678, 0, 1, false, false],
        ["sides", 0, 8, 0, 12, false, false],
        ["reactivity", 0, 1.188, 0, 2, false, false],
        ["volumeDivider", 0, 8.243, 0, 13, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca089"
    },
    "shader": "\n#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs + stream;\n    float x = radius * tan(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 14.56, 0, 151, false, false],
        ["contrast", 0, 1.05, 0, 2, false, false],
        ["orbSize", 0, 0.38, 0.01, 2, false, false],
        ["radius", 0, 0, 0, 14, false, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 12.392, 10, 40, false, false],
        ["div2", 0, 11.325, 10, 40, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f59"
    },
    "shader": "#define BALLS 25\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv *= zoom;\n  uv *= log(dot(uv, uv));\n  uv = normalize(uv) * length(uv);\n  uv *= k_rotate2d(-rotation/30.*-stream/3.);\n  uv *= a * (.15 + .525 * sin(b * dot(uv, uv) - stream/7.));\n  float dist = length(uv * log(abs(uv)));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n  uv *= k_rotate2d(rotation + (log(1./dist) - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/20.) - sin(uv.y * yMultiplier + stream/2.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) + stream/1651.;\n    vec2 p = vec2(c * sin(e + t), c * cos(d * t));\n    p += cos(stream/3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (false) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.134, 0, 1, false, false],
        ["xMultiplier", 0, 412.109, 0, 2100, false, false],
        ["yMultiplier", 0, 435.908, 0, 1200, false, false],
        ["ballSize", 0, 22.031, 0, 122, false, false],
        ["colorSpread", 0, 0.002, 0.001, 0.01, false, false],
        ["colorMultiplier", 0, 1250.438, 1, 31500, false, false],
        ["shapeMultiplier", 0, 496.378, 0, 1210, false, false],
        ["glow", 0, 9132.468, 0, 10000, false, false],
        ["contrast", 0, 4.843, 3, 5, false, false],
        ["rotation", 0, -2.824, -100, 115, false, false],
        ["brightness", 0, 3916.284, 0, 11100, false, false],
        ["sides", 0, 22.551, 2, 48, false, false],
        ["a", 0, 0.093, 0, 0.1, false, false],
        ["b", 0, 0.911, 0, 1, false, false],
        ["c", 0, 20.433, 0, 25, false, false],
        ["d", 0, 22.362, 0, 111, false, false],
        ["e", 0, 3.479, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.715Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1c"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(cul * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.14, 0, 0.28, false, false],
        ["contrast", 0, 0.168, 0, 0.336, false, false],
        ["orbSize", 0, 2.97, 0, 5.94, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 9.54, 0, 19.08, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.1, 0, 0.2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.93, 0, 1.86, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 1.31, 0, 2.62, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, -1, -2, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 3.47, 0, 6.94, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["cul", 0, 0.08, 0, 0.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f1d"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 59900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 5.33, 0, 10.66, false, false],
        ["radius", 0, 36.25, 0, 72.5, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 4.89, 0, 9.78, false, false],
        ["xDivide", 0, 7.14, 0, 14.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.713Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a39"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f62"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  float dist = distance(sin(uv), vec2(0));\n  float thing = 1. / dist * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  vec2 _kale = k_kale(uv, vec2(0.), 6.);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x / .5 * xMultiplier - stream / 1.) * sin(uv.y * yMultiplier + stream / 150.));\n  uv /= (colorSpread * thing * _grid) - abs(_kale);\n  uv /= 20.01 * sin(dist);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) - stream / 4.;\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 1.87, 0, 3.74, false, false],
        ["shapeMultiplier", 0, 38.43, 0, 76.86, false, false],
        ["rotation", 0, 0.14, 0, 0.28, false, false],
        ["xMultiplier", 0, 10, 0, 20, false, false],
        ["yMultiplier", 0, 23.62, 0, 47.24, false, false],
        ["colorSpread", 0, 0.884, 0, 1.768, false, false],
        ["colorMultiplier", 0, 0.2, 0, 0.4, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 0.19, 0, 0.38, false, false],
        ["ballSize", 0, 0.01, 0, 0.02, false, false],
        ["glow", 0, 0.01, 0, 0.02, false, false],
        ["contrast", 0, 3.69, 0, 7.38, false, false],
        ["radius", 0, 0.18, 0, 0.36, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f67"
    },
    "shader": "#define BALLS 20\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .01*sin(shapeMultiplier*dot(uv, uv)/dist - stream/2.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/3.));\n  float _grid = (cos(uv.x * xMultiplier - stream/3.));// * sin(uv.y * yMultiplier + stream/1.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.051, 0, 0.3, false, false],
        ["shapeMultiplier", 0, 200.17, 0, 1000, false, false],
        ["rotation", 0, 0, 0, 1, false, false],
        ["xMultiplier", 0, 69.59, 0, 500, false, false],
        ["yMultiplier", 0, 26.63, 0, 100, false, false],
        ["colorSpread", 0, 0.006, 0, 0.04, false, false],
        ["colorMultiplier", 0, 0.15, 0, 1, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.48, 0, 10, false, false],
        ["ballSize", 0, 2.22, 0, 3, false, false],
        ["glow", 0, 0.76, 0, 1, false, false],
        ["contrast", 0, 2.78, 0, 5, false, false],
        ["radius", 0, 9.97, 0, 115, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f98"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(center), sides);\n  uv *= rotate(stream/23.);\n  uv += sin(dotMul*dot(uv + sinMul*sin(uv-stream/5.), uv));\n  uv *= rotate(stream/-21.);\n  uv /= dot(tan(uv), cos(uv));\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t-stream/5.)-stream/9.);\n    float y = radius * cos(sin(t+stream/5.)+stream)/4.;\n    vec2 position = vec2(x, y);\n    vec3 color = col + cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, uv.x*.02*dist+orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 7.95, 0, 15.9, false, false],
        ["contrast", 0, 2.93, 0, 5.86, false, false],
        ["orbSize", 0, 0.56, 0, 1.12, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["colorShift", 0, 7.05, 0, 14.1, false, false],
        ["center", 0, 2.13, 0, 4.26, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["dotMul", 0, 0.2, 0, 0.4, false, false],
        ["sinMul", 0, 10, 0, 20, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.718Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9f5f"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(time / 2000.)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 330.);\n  if (warp) {\n    uv = uv * uv;\n  }\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (kaleidoscope) {\n    uv = k_kale(uv, vec2(0.), sides);\n  }\n  uv *= k_rotate2d(rotation * (dist - stream / 2000.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 200.) - sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += cos(stream / 3001. + float(i) * PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 3.14, 0, 6.28, false, false],
        ["xMultiplier", 0, 63.13, 0, 126.26, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["ballSize", 0, 1.18, 0, 2.36, false, false],
        ["colorSpread", 0, 2.77, 0, 5.54, false, false],
        ["colorMultiplier", 0, 282.59, 0, 565.18, false, false],
        ["shapeMultiplier", 0, 21.93, 0, 43.86, false, false],
        ["glow", 0, 10350.68, 0, 20701.36, false, false],
        ["contrast", 0, 4.57, 0, 9.14, false, false],
        ["rotation", 0, 4.072, 0, 8.144, false, false],
        ["brightness", 0, 2311.66, 0, 4623.32, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.716Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fad"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a40"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc2"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2 i = k_uv() * zoom;\ni *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      [
        ["zoom", 0, 0.033, 0, 0.1, false, false],
        ["mul", 0, 0.46, 0, 1, false, false],
        ["rot", 0, 489.87, 0, 1112, false, false],
        ["sub", 0, 42.73, 0, 112, false, false],
        ["A", 0, 2.34, 0, 4, false, false],
        ["B", 0, 5.57, 0, 43, false, false],
        ["C", 0, 10.18, 0, 34, false, false],
        ["D", 0, 3.59, 0, 14, false, false],
        ["dep", 0, 0.11, 0, 1, false, false],
        ["wap", 0, 0.7, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a42"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9fc4"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream) + stream/3.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/2.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 7.14, 0, 15, false, false],
        ["contrast", 0, 1.51, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 2.37, 1, 50, false, false],
        ["colorShift", 0, 6.05, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 30.99, 0, 61, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.719Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfc9ff0"
    },
    "shader": "#define BALLS 10.\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(abs(uv)) + stream / 2.);\n  for (float i = 0.; i < BALLS; i++) {\n    //uv *= k_rotate2d(float(i));\n    //uv.x -= cos(log(abs(abs(uv.x*.1)-float(i+1))+stream));\n    float t = stream / 10. + float(i) * PI / BALLS;\n    vec2 p = vec2(tan(t), sin(t));\n    p += radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .15) * dist * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(volume, 2.) * pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 0.84, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["ballSize", 0, 0.13, 0, 0.26, false, false],
        ["radius", 0, 22.12, 0, 44.24, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a46"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca004"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 2. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / .8;\n    vec2 p = vec2(xOuter * uv.x + radius * tan(t + xMultiplier + stream/.8), radius *\ncos(.1 * dist * yOuter * uv.x / 3.5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .21)/3.*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.467786754929877, 0, 62.18, false, false],
        ["ballSize", 0, 0.17738216905708776, 0, 0.2, false, false],
        ["contrast", 0, 2.8809567326924888, 0, 8.94, false, false],
        ["radius", 0, 0.4156118107071843, 0, 0.66, false, false],
        ["yOuter", 0, 17.969914545633713, 0, 25.42, false, false],
        ["xOuter", 0, 27.03570903824037, 0, 30.54, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 4.0018560335090365, 0, 7.36, false, false],
        ["yMultiplier", 0, 5.055801225041768, 0, 19.24, false, false],
        ["divider", 0, 6.095766072100905, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca005"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * (dist / 5.) + stream / 4. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.03, 0, 0.06, false, false],
        ["ballSize", 0, 52.577, 0, 105.154, false, false],
        ["contrast", 0, 4.44, 0, 8.88, false, false],
        ["radius", 0, 1.23, 0, 2.46, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 24, 0, 48, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 100, 0, 200, false, false],
        ["yMultiplier", 0, 72.3, 0, 144.6, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca006"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.1 * (dist / 5.) + stream / 4. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2, 0, 4, false, false],
        ["ballSize", 0, 2.829, 0, 5.658, false, false],
        ["contrast", 0, 2.16, 0, 4.32, false, false],
        ["radius", 0, 0.02, 0, 0.04, false, false],
        ["yOuter", 0, 715.01, 0, 1430.02, false, false],
        ["xOuter", 0, 22.38, 0, 44.76, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 0, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["divider", 0, 2, 0, 4, false, false],
        ["rotation", 0, 111, 0, 222, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.722Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a49"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca034"
    },
    "shader": "\n#define orbs 12.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 + stream);\n    float t = i * PI / orbs * 200.;\n    float x = radius * sin(t-stream);\n    float y = radius * cos(t+stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.43, 0, 51, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.63, 0.01, 2, false, false],
        ["radius", 0, 1, 1, 14, false, false],
        ["colorShift", 0, 5.95, 3, 16, false, false],
        ["div", 0, 10.925, 0, 111, false, false],
        ["div2", 0, 8.505, 0, 11, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca04a"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv = uv * cos( .0005 * dot(uv, uv) - stream) * sin(.0001 * dot(uv, uv)+stream/2.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= sin((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.);\n    float y = radius * cos(t+stream/-8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/1000.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 25.95, 0, 51.9, false, false],
        ["contrast", 0, 0.82, 0, 1.64, false, false],
        ["orbSize", 0, 0.3, 0, 0.6, false, false],
        ["radius", 0, 3.77, 0, 7.54, false, false],
        ["colorShift", 0, 33, 0, 66, false, false],
        ["div", 0, 17.974, 0, 35.948, false, false],
        ["div2", 0, 27.909, 0, 55.818, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.724Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a50"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca061"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= .5 * sin(.005 * dot(uv + sin(2. * uv), 9.1 * uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 2.;\n    float x = radius * tan(dist * t + stream) * sin(dist);\n    float y = radius * cos(dist * t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15, 0, 30, false, false],
        ["contrast", 0, 1.01, 0, 2.02, false, false],
        ["orbSize", 0, 0.2, 0, 0.4, false, false],
        ["radius", 0, 2.58, 0, 5.16, false, false],
        ["colorShift", 0, 7.56, 0, 15.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.725Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca063"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= sin(.04 * dot(uv, 2.1 * uv) - stream);\n  //  uv /= sin(.01*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t / radius * tan(dist * t + stream) * sin(dist);\n    float y = t * radius * cos(dist * t - stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.45, 0, 6.9, false, false],
        ["contrast", 0, 1.71, 0, 3.42, false, false],
        ["orbSize", 0, 0.19, 0, 0.38, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.35, 0, 10.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06b"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv += outer*sin(inner*dot(uv, 10.1*uv) - stream);\n//  uv = sin(1.91*dot(uv + sin(1.*uv), .1*uv) - stream);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(stream/(i+1.)/100.);\n    float t = i / PI / orbs * 10.;\n    float x = t/radius * sin(dist*t+stream)*sin(dist);\n    float y = t*radius * cos(dist*t-stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 6.7, 0, 10, false, false],
        ["contrast", 0, 1.53, 0, 2, false, false],
        ["orbSize", 0, 0.97, 0.01, 2, false, false],
        ["radius", 0, 5, 1, 5, false, false],
        ["colorShift", 0, 7.15, 4, 10, false, false],
        ["outer", 0, 4.79, 0, 10, false, false],
        ["inner", 0, 0.02, 0, 0.2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a52"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca06d"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 1.);\n    float y = radius * cos(t + stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 42.58, 0, 85.16, false, false],
        ["contrast", 0, 1.08, 0, 2.16, false, false],
        ["orbSize", 0, 2.35, 0, 4.7, false, false],
        ["radius", 0, 22.85, 0, 45.7, false, false],
        ["colorShift", 0, 8.85, 0, 17.7, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0.67, 0, 1.34, false, false],
        ["cosMul", 0, 1.64, 0, 3.28, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca072"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n \n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/3.);\n    float y = radius * cos(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 29.27, 0, 111, false, false],
        ["contrast", 0, 1.44, 0, 2, false, false],
        ["orbSize", 0, 2.57, 0.01, 5, false, false],
        ["radius", 0, 25.16, 1, 115, false, false],
        ["colorShift", 0, 8.53, 4, 10, false, false],
        ["sides", 0, 2, 0, 12, false, false],
        ["rotation", 0, 0.4, 0, 2, false, false],
        ["sinMul", 0, 1.03, 0, 2, false, false],
        ["cosMul", 0, 2.31, 0, 5, false, false],
        ["yMul", 0, 0.36, 0, 5, false, false],
        ["xMul", 0, 0.16, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false],
        ["gloop", 0, 0.0092, 0.001, 0.01, false, false],
        ["yDivide", 0, 9.77, 0, 19, false, false],
        ["xDivide", 0, 1.52, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca079"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 42.58, 0, 111, false, false],
        ["contrast", 0, 1.08, 0, 2, false, false],
        ["orbSize", 0, 2.35, 0.01, 5, false, false],
        ["radius", 0, 22.85, 1, 115, false, false],
        ["colorShift", 0, 8.85, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0.67, 0, 2, false, false],
        ["cosMul", 0, 1.64, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.727Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a53"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca086"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 1.7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 24.95, 0, 151, false, false],
        ["contrast", 0, 0.82, 0, 2, false, false],
        ["orbSize", 0, 0.32, 0.01, 2, false, false],
        ["radius", 0, 4.75, 0, 14, false, false],
        ["colorShift", 0, 12.71, 3, 33, false, false],
        ["div", 0, 10, 1, 10, false, false],
        ["div2", 0, 10, 1, 10, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca090"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * sin(t + stream/10.);\n    float y = radius * cos(t - stream/2.2);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 18.41, 0, 36.82, false, false],
        ["contrast", 0, 1.42, 0, 2.84, false, false],
        ["orbSize", 0, 0.7, 0, 1.4, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 11.52, 0, 23.04, false, false],
        ["div", 0, 10.119, 0, 20.238, false, false],
        ["div2", 0, 10, 0, 20, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca091"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n // uv = uv * cos( .0001 * dot(uv, uv) - stream/18.) + uv.x / 1111. * sin(.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.74772, 0, 100, false, false],
        ["contrast", 0, 0.82, 0, 1.64, false, false],
        ["orbSize", 0, 0.32, 0, 0.64, false, false],
        ["radius", 0, 4.75, 0, 9.5, false, false],
        ["colorShift", 0, 22.22298, 0, 25.42, false, false],
        ["div", 0, 10, 0, 20, false, false],
        ["div2", 0, 10, 0, 20, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.728Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a55"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b3"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream * 2. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / 2.);\n  uv *= k_rotate2d(rotation * dist + stream / 1.);\n  for (int i = 0; i < BALLS; i++) {\n    //uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream / 15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.19, 0, 2.38, false, false],
        ["contrast", 0, 4.95, 0, 9.9, false, false],
        ["ballSize", 0, 0.08, 0, 0.16, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.729Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0b6"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/15. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = volume*pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["contrast", 0, 4.99, 0, 9.98, false, false],
        ["ballSize", 0, 0.011, 0, 0.022, false, false],
        ["radius", 0, 45.33, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0ba"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = sin(stream*2.+(uv));\n//  uv *= cos(log(uv) + stream/1.);\n  uv -= sin((dot(uv, uv)) - stream/2.);\n  uv *= rotate2d(rotation*dist+stream/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\t//uv.x -= cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = stream/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(radius*tan(t), radius*sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, 3.)*pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.26, 0, 0.52, false, false],
        ["contrast", 0, 6.4, 0, 12.8, false, false],
        ["ballSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1.54, 0, 3.08, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0.98, 0, 1.96, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a59"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0cc"
    },
    "shader": "#define BALLS 10\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= rotate2d(stream/-12.);\n  uv *= zoom2;\n  uv = zoom * (log(abs(uv)) + 2.5*cos(uv));//(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/-1.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation);\n  float _grid = (cos(uv.x * xMultiplier - stream/.3) - sin(uv.y * yMultiplier + stream/-.8));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * ( 100. + uv.y/2505. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)/3.3*ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.009, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 192.45, 0, 300, false, false],
        ["rotation", 0, 0.61129, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 998.27, 0, 1500, false, false],
        ["yMultiplier", 0, 41.66, 0, 1100, false, false],
        ["colorSpread", 0, 0.00012, 0, 0.001, false, false],
        ["colorMultiplier", 0, 4.09, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.18, 0, 10, false, false],
        ["ballSize", 0, 70.45, 0, 100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 2.06, 0, 5, false, false],
        ["radius", 0, 5.93, 0, 120, false, false],
        ["zoom2", 0, 0.2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.006, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 254.58, 0, 300, false, false],
        ["rotation", 0, 0.61129, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 376.84, 0, 1500, false, false],
        ["yMultiplier", 0, 127.2, 0, 1100, false, false],
        ["colorSpread", 0, 0.00012, 0, 0.001, false, false],
        ["colorMultiplier", 0, 4.09, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 2.18, 0, 10, false, false],
        ["ballSize", 0, 70.45, 0, 100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 2.06, 0, 5, false, false],
        ["radius", 0, 5.93, 0, 120, false, false],
        ["zoom2", 0, 0.5, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 0.009, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 154.35, 0, 300, false, false],
        ["rotation", 0, 2.62987, 0.009, 10.041, false, false],
        ["xMultiplier", 0, 471.96, 0, 1500, false, false],
        ["yMultiplier", 0, 99.64, 0, 1100, false, false],
        ["colorSpread", 0, 0.000025, 0, 0.001, false, false],
        ["colorMultiplier", 0, 5.02, 0, 7, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.84, 0, 10, false, false],
        ["ballSize", 0, 471.93, 0, 1100, false, false],
        ["glow", 0, 1.16, 0, 4, false, false],
        ["contrast", 0, 1.7, 0, 5, false, false],
        ["radius", 0, 16.37, 0, 120, false, false],
        ["zoom2", 0, 0.17, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.730Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0d7"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 64.73, 0, 129.46, false, false],
        ["contrast", 0, 1.42, 0, 2.84, false, false],
        ["orbSize", 0, 1.05, 0, 2.1, false, false],
        ["radius", 0, 4.58, 0, 9.16, false, false],
        ["colorShift", 0, 11.52, 0, 23.04, false, false],
        ["div", 0, 17.328, 0, 34.656, false, false],
        ["div2", 0, 14.483, 0, 28.966, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.731Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca0f6"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  uv *= k_rotate2d(stream/-2.);\n  mat2 rotation = k_rotate2d(length((-1. + 2. * gl_FragCoord.xy / resolution.xy)/2.)+ stream/3.);\n  float ot = ot;\n  uv = k_kale(uv, vec2(0.), 12.);\n  uv *= k_rotate2d(stream/3.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator - 1.;\n    ot = dot(uv, uv) - cos(length(uv) / L + stream/1.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .792716175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 7763.719, 0, 33222, false, false],
        ["iterator", 0, 0.259, 0, 2, false, false],
        ["ot", 0, 99.903, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.987, 0, 3, false, false],
        ["K", 0, 58.378, 0, 111, false, false],
        ["iterations", 0, 17.327, 0, 33, false, false],
        ["L", 0, 187.608, 0, 213, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 1.01, 0, 2, false, false],
        ["colorOffset", 0, 35.208, 0, 111, false, false],
        ["contrast", 0, 1.687, 0, 2, false, false],
        ["orbSize", 0, 0.53, 0, 2, false, false],
        ["div", 0, 0.564, 0.1, 2, false, false],
        ["radius", 0, 0.055, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca103"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/10.);\n  uv = abs(uv);\n  for (float i = 1.; i < 20.; i++) {\n    uv *= rotation;\n    uv =(uv) * iterator - 1.;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    uv -= factor*abs(fract(uv) - .5);\n    gl_FragColor += k_orb(uv, pow(volume, .92716175) * orbSize, vec2(radius*abs(tan(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.924, 0, 11, false, false],
        ["iterator", 0, 0.319, 0, 2, false, false],
        ["ot", 0, 151, 0, 151, false, false],
        ["I", 0, 0.886, 0, 3, false, false],
        ["J", 0, 0.432, 0, 3, false, false],
        ["K", 0, 31.922, 0, 111, false, false],
        ["iterations", 0, 3.054, 0, 22, false, false],
        ["L", 0, 95.451, 0, 222, false, false],
        ["M", 0, 5.211, 0, 11, false, false],
        ["colorShift", 0, 1.912, 0, 4, false, false],
        ["colorOffset", 0, 0.873, 0, 22, false, false],
        ["contrast", 0, 1.361, 1, 3, false, false],
        ["orbSize", 0, 2, 0, 2, false, false],
        ["div", 0, 0.275, 0, 1, false, false],
        ["radius", 0, 0.436, 0, 11, false, false],
        ["factor", 0, 0.539, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca10b"
    },
    "shader": "\n\n#define BALLS 5\n\n\n\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.06, 0, 23, false, false],
        ["xMultiplier", 0, 35.99, 0, 200, false, false],
        ["yMultiplier", 0, 49.25, 0, 200, false, false],
        ["ballSize", 0, 1.25, 0, 12, false, false],
        ["colorSpread", 0, 3.36, 0.2, 7, false, false],
        ["colorMultiplier", 0, 114.55, 1, 500, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 210, false, false],
        ["glow", 0, 1862.09, 0, 10000, false, false],
        ["contrast", 0, 3.17, 1, 10, false, false],
        ["rotation", 0, 11.471, 0, 15, false, false],
        ["brightness", 0, 1, 0, 1, false, false],
        ["sides", 0, 11, 2, 48, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14c"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 1, false, false],
        ["yDivider", 0, 4.3, 0.1, 10, false, false],
        ["xDivider", 0, 117.73, 0.1, 1000, false, false],
        ["multiplier", 0, 0.51, 0.1, 1, false, false],
        ["ballSize", 0, 0.1, 0, 0.3, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 0, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca150"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation + stream / 8.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.02 * uv.y - stream / 2.)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 5.) * (.4201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(color * log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 4.1, 0, 8.2, false, false],
        ["ballSize", 0, 590.219, 0, 1180.438, false, false],
        ["contrast", 0, 1.08, 0, 2.16, false, false],
        ["radius", 0, 527.24, 0, 1054.48, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 73.89, 0, 147.78, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 202, false, false],
        ["yMultiplier", 0, 33.47, 0, 66.94, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.0008, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca119"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(1. - uv) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv -= .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 26.24, 0, 52.48, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.62, 0, 1.24, false, false],
        ["radius", 0, 4.92, 0, 9.84, false, false],
        ["colorShift", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a61"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11c"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / .02;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv /= dot(uv, uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/90.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 1000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*orbSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.141, 0, 21.76, false, false],
        ["contrast", 0, 1.22, 0, 3.26, false, false],
        ["orbSize", 0, 1.25, 0, 0.52, false, false],
        ["radius", 0, 5.247, 0, 14.3, false, false],
        ["colorShift", 0, 19.007, 0, 36.86, false, false],
        ["rotation", 0, 0, 0, 50.6, false, false],
        ["sinMul", 0, 0.381, 0, 1.3, false, false],
        ["x", 0, 10.75, null, null, false, false],
        ["y", 0, 7.11, null, null, false, false],
        ["colorOffset", 0, 1, null, null, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca144"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 35.88, 0, 71.76, false, false],
        ["yDivider", 0, 818.46, 0, 1636.92, false, false],
        ["xDivider", 0, 656.67, 0, 1313.34, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 1.15, 0, 2.3, false, false],
        ["radius", 0, 26.22, 0, 52.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca122"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  float stream = stream / .1;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream / 100.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 1.1 * sin(t + stream / 100.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 50. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 300. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(1. - log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0, 0.068, false, false],
        ["ballSize", 0, 7.06, 0, 14.12, false, false],
        ["contrast", 0, 2.05, 0, 4.1, false, false],
        ["radius", 0, 51.36, 0, 102.72, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 100, false, false],
        ["y", 0, 29.17, 0, 58.34, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["colorOffset", 0, 1.91, 0, 3.82, false, false],
        ["sides", 0, 4, 0, 8, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12b"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (.004 / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n    }\n}",
    "variants": [
      [
        ["zoom", 0, 0.334, 0, 1, false, false],
        ["iterator", 0, 4.787, 0, 12, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 1, 0, 33, false, false],
        ["L", 0, 1.372, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.077, 0, 2, false, false],
        ["colorOffset", 0, 14.399, 0, 111, false, false],
        ["contrast", 0, 1.57, 0, 3, false, false],
        ["orbSize", 0, 0.891, 0, 2, false, false],
        ["div", 0, 0.112, 0.01, 1, false, false],
        ["radius", 0, 3.567, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.032, 0, 0.1, false, false],
        ["iterator", 0, 1.405, 0, 2, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 6, 0, 33, false, false],
        ["L", 0, 1.358, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.689, 0, 2, false, false],
        ["colorOffset", 0, 13.519, 0, 111, false, false],
        ["contrast", 0, 1.736, 0, 3, false, false],
        ["orbSize", 0, 0.546, 0, 2, false, false],
        ["div", 0, 0.307, 0.01, 1, false, false],
        ["radius", 0, 4.767, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.574, 0, 1, false, false],
        ["iterator", 0, 1.144, 0, 2, false, false],
        ["ot", 0, 107.664, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 10.753, 0, 11, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.54, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.372, 0, 3, false, false],
        ["orbSize", 0, 0.443, 0, 2, false, false],
        ["div", 0, 0.135, 0.01, 1, false, false],
        ["radius", 0, 3.176, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca146"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *= rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 69.87, 0, 501, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 2.98, 0.1, 111, false, false],
        ["ballSize", 0, 0.22, 0, 1, false, false],
        ["contrast", 0, 3.01, 0, 15, false, false],
        ["radius", 0, 20.48, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca124"
    },
    "shader": "#define orbs 5.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = test-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.16, false, false],
        ["ballSize", 0, 11.1, 0, 22.2, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["radius", 0, 93.39, 0, 186.78, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 23.47, 0, 46.94, false, false],
        ["y", 0, 15.14, 0, 30.28, false, false],
        ["rotation", 0, 0.1, 0, 0.2, false, false],
        ["colorOffset", 0, 4.57, 0, 9.14, false, false],
        ["test", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca134"
    },
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.50;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .6)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 406.25, 0, 1000, false, false],
        ["xDiv", 0, 370.536, 0, 1000, false, false],
        ["yDiv", 0, 348.214, 0, 2000, false, false],
        ["xDiv2", 0, 31.25, 0, 200, false, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 44.643, 0, 2000, false, false],
        ["yDiv3", 0, 62.5, 0, 2000, false, false],
        ["multiplier", 0, 17.768, 0, 20, false, false],
        ["ballSize", 0, 25.446, 0, 100, false, false],
        ["contrast", 0, 1.554, 0, 4, false, false],
        ["radius", 0, 99.33, 0, 250, false, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 1.875, 0, 20, false, false],
        ["yMul", 0, 2.411, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a64"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca135"
    },
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.5;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 2.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 11.) * cos(uv.y / yDiv3 - stream / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (11125. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, 1.19)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 513.393, 0, 1000, false, false],
        ["xDiv", 0, 370.536, 0, 1000, false, false],
        ["yDiv", 0, 348.214, 0, 2000, false, false],
        ["xDiv2", 0, 31.25, 0, 200, false, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 44.643, 0, 2000, false, false],
        ["yDiv3", 0, 62.5, 0, 2000, false, false],
        ["multiplier", 0, 17.768, 0, 20, false, false],
        ["ballSize", 0, 38.839, 0, 100, false, false],
        ["contrast", 0, 2.268, 0, 4, false, false],
        ["radius", 0, 65.848, 0, 250, false, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 12.054, 0, 20, false, false],
        ["yMul", 0, 2.411, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a64"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca139"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *= rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 69.87, 0, 501, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 2.98, 0.1, 111, false, false],
        ["ballSize", 0, 0.22, 0, 1, false, false],
        ["contrast", 0, 3.01, 0, 15, false, false],
        ["radius", 0, 20.48, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12d"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    float stream = stream / 1.24;\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv = abs(uv);\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n   \n      uv.x *= tan(dist+.000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5 + uv.x/40.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.5) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.01, false, false],
        ["contrast", 0, 2.09, 0, 4, false, false],
        ["orbSize", 0, 0.68, 0.01, 2, false, false],
        ["radius", 0, 2.9, 0, 6, false, false],
        ["colorShift", 0, 5.26, 1, 13, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca130"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= tan(dist+.0000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5;\n      float x = radius * tan(t);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, .009/dist*pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.004, 0, 0.01, false, false],
        ["contrast", 0, 2.53, 0, 4, false, false],
        ["orbSize", 0, 616.6, 0.01, 1111, false, false],
        ["radius", 0, 5.76, 0, 212, false, false],
        ["colorShift", 0, 6.49, 1, 13, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13d"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 55.34, 0, 110.68, false, false],
        ["contrast", 0, 0.89, 0, 1.78, false, false],
        ["orbSize", 0, 2, 0, 4, false, false],
        ["radius", 0, 34.66, 0, 69.32, false, false],
        ["colorShift", 0, 9.55, 0, 19.1, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.7, 0, 1.4, false, false],
        ["cosMul", 0, 0.98, 0, 1.96, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.57, 0, 1.14, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.0048, 0, 0.0096, false, false],
        ["yDivide", 0, 4.98, 0, 9.96, false, false],
        ["xDivide", 0, 19, 0, 38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca141"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 18.5, 0, 37, false, false],
        ["yDivider", 0, 332.97, 0, 665.94, false, false],
        ["xDivider", 0, 377.39, 0, 754.78, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.08, 0, 0.16, false, false],
        ["contrast", 0, 4.82, 0, 9.64, false, false],
        ["radius", 0, 12.6, 0, 25.2, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 0.47, 0, 0.94, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14b"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 0.44, false, false],
        ["yDivider", 0, 4.3, 0, 8.6, false, false],
        ["xDivider", 0, 117.73, 0, 235.46, false, false],
        ["multiplier", 0, 0.51, 0, 1.02, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11a"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x -= dist+.009* dist*(i+1.) * (uv.y);\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 11, 0, 22, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.23, 0, 0.46, false, false],
        ["radius", 0, 3.68, 0, 7.36, false, false],
        ["colorShift", 0, 7.05, 0, 14.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a61"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca120"
    },
    "shader": "\n#define orbs 5.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = test-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.08, 0.01, 0.1, false, false],
        ["ballSize", 0, 11.1, 0, 15, false, false],
        ["contrast", 0, 2.21, 0, 5, false, false],
        ["radius", 0, 93.39, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 23.47, 0, 50, false, false],
        ["y", 0, 15.14, 0, 50, false, false],
        ["rotation", 0, 0.1, 0, 0.1, false, false],
        ["colorOffset", 0, 4.57, 0, 10, false, false],
        ["test", 0, 1, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12c"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  mat2 rotation = k_rotate2d(stream/ (PI*12.));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .9) * orbSize, vec2(radius*abs(cos(stream/-1.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/-1.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.112, 0, 1, false, false],
        ["iterator", 0, 1.371, 0, 2, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 7, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.689, 0, 2, false, false],
        ["colorOffset", 0, 37.77, 0, 111, false, false],
        ["contrast", 0, 1.83, 0, 3, false, false],
        ["orbSize", 0, 0.564, 0, 2, false, false],
        ["div", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 4.731, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.032, 0, 0.1, false, false],
        ["iterator", 0, 1.405, 0, 2, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 6, 0, 33, false, false],
        ["L", 0, 1.358, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.689, 0, 2, false, false],
        ["colorOffset", 0, 13.519, 0, 111, false, false],
        ["contrast", 0, 1.736, 0, 3, false, false],
        ["orbSize", 0, 0.546, 0, 2, false, false],
        ["div", 0, 0.307, 0.01, 1, false, false],
        ["radius", 0, 4.767, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.574, 0, 1, false, false],
        ["iterator", 0, 1.144, 0, 2, false, false],
        ["ot", 0, 107.664, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 10.753, 0, 11, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.54, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.372, 0, 3, false, false],
        ["orbSize", 0, 0.443, 0, 2, false, false],
        ["div", 0, 0.135, 0.01, 1, false, false],
        ["radius", 0, 3.176, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13a"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom / 5.;\n  vec2 uv3 = uv * zoom / 15.;\n  uv = mix(uv2, uv3, abs(.1 * sin(stream)));\n  uv = abs(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = 1. / dist * .1 * sin(shapeMultiplier * dot(uv2, uv3) / dist - stream / 1.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 1.));\n  float _grid = (cos(uv.x / .5 * xMultiplier - stream / 1.) * sin(uv.y * yMultiplier + stream / 150.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i));\n    float t = float(i) * PI / float(BALLS) - stream / 4.;\n    vec2 p = vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2290. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}",
    "variants": [
      [
        ["zoom", 0, 0.66, 0, 1.32, false, false],
        ["shapeMultiplier", 0, 301.19, 0, 602.38, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 27.57, 0, 55.14, false, false],
        ["yMultiplier", 0, 23.65, 0, 47.3, false, false],
        ["colorSpread", 0, 0.02, 0, 0.04, false, false],
        ["colorMultiplier", 0, 0.08, 0, 0.16, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 0.19, 0, 0.38, false, false],
        ["ballSize", 0, 0.16, 0, 0.32, false, false],
        ["glow", 0, 0.29, 0, 0.58, false, false],
        ["contrast", 0, 2.78, 0, 5.56, false, false],
        ["radius", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14d"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 1, false, false],
        ["yDivider", 0, 4.3, 0.1, 10, false, false],
        ["xDivider", 0, 117.73, 0.1, 1000, false, false],
        ["multiplier", 0, 0.51, 0.1, 1, false, false],
        ["ballSize", 0, 0.1, 0, 0.3, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca152"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(20.1*(.001*dot(uv, uv)));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(.001*length(uv)-rotation*(dist)+stream/5.+float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream/-50.;\n    vec2 p = vec2(xOuter*(atan(uv.x))*5.*uv.x+radius*tan(t+xMultiplier) * 5.*cos(uv.x + sin(uv.y/100.-stream/-50.-dist/10.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 43.33, 0, 86.66, false, false],
        ["ballSize", 0, 503.852, 0, 1007.704, false, false],
        ["contrast", 0, 5.07, 0, 10.14, false, false],
        ["radius", 0, 1051.65, 0, 2103.3, false, false],
        ["yOuter", 0, 401.47, 0, 802.94, false, false],
        ["xOuter", 0, 347.95, 0, 695.9, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 10111, 0, 20222, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, -0.02, 0, -0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11d"
    },
    "shader": "#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n\n\nvec4 k_ue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n\n\n\n\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv)) / dist + (tatumStream + beatStream) / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < 20.; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor += barVolume * vec4(pow(tatumVolume, 1.5) * orbsize / length(uv + p * (spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor = vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.032, 0, 0.064, false, false],
        ["shapeMultiplier", 0, 124.545, 0, 249.09, false, false],
        ["spreadMultiplier", 0, 2.494, 0, 4.988, false, false],
        ["rotation", 0, 103.636, 0, 207.272, false, false],
        ["xMultiplier", 0, 113.422, 0, 226.844, false, false],
        ["yMultiplier", 0, -208, -416, 0, false, false],
        ["colorSpread", 0, 0.000197800000000001, 0, 0.000395600000000002, false, false],
        ["invert", 1, false, null, null, null, false],
        ["orbsize", 0, 585.455, 0, 1170.91, false, false],
        ["contrast", 0, 1.12136, 0, 2.24272, false, false],
        ["radius", 0, 26, 0, 52, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["aSpeed", 0, -15, -30, 0, false, false],
        ["bSpeed", 0, -5, -10, 0, false, false],
        ["sinMul", 0, 0.102, 0, 0.204, false, false],
        ["cosMul", 0, 0.312, 0, 0.624, false, false],
        ["rippleSpeed", 0, -20, -40, 0, false, false],
        ["wobbleSpeed", 0, -200, -400, 0, false, false],
        ["swirl", 0, 0.121, 0, 0.242, false, false],
        ["energy", 0, 1.1, 0, 2.2, false, false],
        ["punch", 0, 1, 0, 2, false, false],
        ["borderSpeed", 0, 2000, 0, 4000, false, false],
        ["hueShift", 0, -97.745, -195.49, 0, false, false],
        ["colorMultiplier", 0, 0.0034, 0, 0.0068, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca127"
    },
    "shader": "#define orbs 5.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv /= dot(uv, uv);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t-stream/50.), .1*sin(t+stream/5.));\n    p /= sin(stream/10.+PI * sin(uv.x/x)*cos(stream/5.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.16, false, false],
        ["ballSize", 0, 11.1, 0, 22.2, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["radius", 0, 93.39, 0, 186.78, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 18.76, 0, 37.52, false, false],
        ["y", 0, 50, 0, 100, false, false],
        ["rotation", 0, 0.1, 0, 0.2, false, false],
        ["colorOffset", 0, 4.57, 0, 9.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca138"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 13.61, 0, 23, false, false],
        ["contrast", 0, 1.13, 1, 5, false, false],
        ["orbSize", 0, 0.4, 0.01, 2, false, false],
        ["radius", 0, 2.38, 1, 5, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.04, 0, 0.1, false, false],
        ["sinMul", 0, 0.25, 0, 2, false, false],
        ["cosMul", 0, 0.2, 0, 1, false, false],
        ["yMul", 0, 0.9, 0, 5, false, false],
        ["xMul", 0, 1.27, 0, 5, false, false],
        ["xSpeed", 0, -0.71, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca145"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *= rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 69.87, 0, 139.74, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 2.98, 0, 5.96, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 3.01, 0, 6.02, false, false],
        ["radius", 0, 20.48, 0, 40.96, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca151"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) {  \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.9, 0, 11.8, false, false],
        ["ballSize", 0, 193.249, 0, 386.498, false, false],
        ["contrast", 0, 2.55, 0, 5.1, false, false],
        ["radius", 0, 151.82, 0, 303.64, false, false],
        ["yOuter", 0, 27.3, 0, 54.6, false, false],
        ["xOuter", 0, 21.98, 0, 43.96, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 202, false, false],
        ["yMultiplier", 0, 33.47, 0, 66.94, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.0008, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca154"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.9, 0, 15, false, false],
        ["ballSize", 0, 193.249, 0, 1111, false, false],
        ["contrast", 0, 2.55, 0, 15, false, false],
        ["radius", 0, 151.82, 0, 1105, false, false],
        ["yOuter", 0, 27.3, 0, 100, false, false],
        ["xOuter", 0, 21.98, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 33.47, 0, 101, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.001, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca155"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist*t+radius * (i/div) * tan(dist*t-stream/2.)*mul*sin(dist+stream/15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 6.52, 0, 10, false, false],
        ["contrast", 0, 0.55, 0, 2, false, false],
        ["orbSize", 0, 0.01, 0.01, 0.1, false, false],
        ["radius", 0, 0.08, 0, 2, false, false],
        ["colorShift", 0, 6.04, 0, 10, false, false],
        ["center", 0, 2.92, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 2.86, 0, 20, false, false],
        ["mul", 0, 5.19, 0, 15, false, false],
        ["div", 0, 7.42, 0, 30, false, false]
      ],
      [
        ["zoom", 0, 6.52, 0, 10, false, false],
        ["contrast", 0, 0.77, 0, 2, false, false],
        ["orbSize", 0, 0.03, 0.01, 0.1, false, false],
        ["radius", 0, 2, 0, 2, false, false],
        ["colorShift", 0, 6.04, 0, 10, false, false],
        ["center", 0, 2.92, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 2.39, 0, 20, false, false],
        ["mul", 0, 0, 0, 15, false, false],
        ["div", 0, 30, 0, 30, false, false]
      ],
      [
        ["zoom", 0, 9.36, 0, 110, false, false],
        ["contrast", 0, 0.8, 0, 2, false, false],
        ["orbSize", 0, 0.11, 0.01, 0.5, false, false],
        ["radius", 0, 2, 0, 2, false, false],
        ["colorShift", 0, 6.04, 0, 10, false, false],
        ["center", 0, 2.92, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 7.69, 0, 20, false, false],
        ["mul", 0, 0.17, 0, 15, false, false],
        ["div", 0, 0.6, 0, 30, false, false]
      ],
      [
        ["zoom", 0, 2, 0, 2, false, false],
        ["contrast", 0, 0.81, 0, 2, false, false],
        ["orbSize", 0, 0.02, 0.01, 0.1, false, false],
        ["radius", 0, 0.1, 0, 2, false, false],
        ["colorShift", 0, 6.04, 0, 10, false, false],
        ["center", 0, 2.92, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 7.69, 0, 20, false, false],
        ["mul", 0, 15, 0, 15, false, false],
        ["div", 0, 5.03, 0, 30, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca117"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv.x -= -14.;\n  float dist = length(sin(cos(uv + stream) + stream / .28));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x -= dist + dis * dist * (i + 1.) * (uv.y);\n    float t = (i + 1.) * PI / orbs * 4.;\n    float x = radius * tan(t + stream / .6);// * cos(t-stream/1.) * sin(t);\n    float y = radius * sin(t - stream / 2.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.313, 0, 22, false, false],
        ["contrast", 0, 1.277, 0, 2, false, false],
        ["orbSize", 0, 0.656, 0, 1, false, false],
        ["radius", 0, 6.407, 0, 7.36, false, false],
        ["colorShift", 0, 15.791, 0, 114.1, false, false],
        ["dis", 0, 0.001, 0, 0.001, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a61"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca133"
    },
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.0;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 8. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 5. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .9)/2. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 513.393, 0, 1000, false, false],
        ["xDiv", 0, 370.536, 0, 1000, false, false],
        ["yDiv", 0, 348.214, 0, 2000, false, false],
        ["xDiv2", 0, 31.25, 0, 200, false, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 44.643, 0, 2000, false, false],
        ["yDiv3", 0, 62.5, 0, 2000, false, false],
        ["multiplier", 0, 17.768, 0, 20, false, false],
        ["ballSize", 0, 72.768, 0, 100, false, false],
        ["contrast", 0, 1.554, 0, 4, false, false],
        ["radius", 0, 36.83, 0, 250, false, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 12.054, 0, 20, false, false],
        ["yMul", 0, 2.411, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a64"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca129"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue); \n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0, 0.068, false, false],
        ["ballSize", 0, 7.06, 0, 14.12, false, false],
        ["contrast", 0, 2.05, 0, 4.1, false, false],
        ["radius", 0, 51.36, 0, 102.72, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 100, false, false],
        ["y", 0, 50, 0, 100, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["colorOffset", 0, 1.91, 0, 3.82, false, false],
        ["sides", 0, 4, 0, 8, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12a"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n \n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (wob / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n  gl_FragColor.g *= .2;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6347062999362257, 0.2, 0.6, false, false],
        ["iterator", 0, 9.545699904913453, 1, 12, false, false],
        ["ot", 0, 63.45670382482259, 0, 151, false, false],
        ["I", 0, 2.004611658162746, 0, 3, false, false],
        ["J", 0, 0.9292826277731768, 0, 3, false, false],
        ["K", 0, 1.7887850816908168, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 1.1279381425603259, 1, 2, false, false],
        ["M", 0, 0.43865731802863905, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 4.816923703081921, 4, 10, false, false],
        ["contrast", 0, 2.172935900983824, 1, 1.5, false, false],
        ["orbSize", 0, 1.3638092748249202, 0.5, 2, false, false],
        ["div", 0, 0.18712700275218697, 0.01, 0.5, false, false],
        ["radius", 0, 4.478964174125304, 3, 10, false, false],
        ["wob", 0, 0.027189022299892483, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.252383, 0.2, 0.6, false, false],
        ["iterator", 0, 7.569259349233938, 1, 12, false, false],
        ["ot", 0, 77.22702061398316, 0, 151, false, false],
        ["I", 0, 2.5421969305949066, 0, 3, false, false],
        ["J", 0, 2.3204582724811766, 0, 3, false, false],
        ["K", 0, 10.66774605644863, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.4078496791886295, 1, 2, false, false],
        ["M", 0, 0.49353160809578367, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 5.7879599494522385, 4, 10, false, false],
        ["contrast", 0, 1.72852776965142, 1, 1.5, false, false],
        ["orbSize", 0, 2, 0.5, 2, false, false],
        ["div", 0, 0.08027884559708552, 0.01, 0.5, false, false],
        ["radius", 0, 3.306594, 3, 10, false, false],
        ["wob", 0, 0.09822452407689686, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.5518645466466255, 0.2, 0.6, false, false],
        ["iterator", 0, 9.345306061754322, 1, 12, false, false],
        ["ot", 0, 76.95672847031916, 0, 151, false, false],
        ["I", 0, 2.0299764684706196, 0, 3, false, false],
        ["J", 0, 0.5775865735935444, 0, 3, false, false],
        ["K", 0, 4.5782725349372235, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.5327226221179027, 1, 2, false, false],
        ["M", 0, 0.9855923008127525, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 7.124793907730577, 4, 10, false, false],
        ["contrast", 0, 1.8673261085401902, 1, 1.5, false, false],
        ["orbSize", 0, 1.6922743948115222, 0.5, 2, false, false],
        ["div", 0, 0.06848968434306733, 0.01, 0.5, false, false],
        ["radius", 0, 3.145716, 3, 10, false, false],
        ["wob", 0, 0.003, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.380322, 0.2, 0.6, false, false],
        ["iterator", 0, 9.218471677489154, 1, 12, false, false],
        ["ot", 0, 131.63249519716393, 0, 151, false, false],
        ["I", 0, 1.3802125534214826, 0, 3, false, false],
        ["J", 0, 1.395041179704047, 0, 3, false, false],
        ["K", 0, 2.951226237343881, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.974272682393624, 1, 2, false, false],
        ["M", 0, 0.8482203936410846, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 8.985077800486769, 4, 10, false, false],
        ["contrast", 0, 1.87270215686231, 1, 1.5, false, false],
        ["orbSize", 0, 0.8984214901639822, 0.5, 2, false, false],
        ["div", 0, 0.07098858854079364, 0.01, 0.5, false, false],
        ["radius", 0, 7.968495755292857, 3, 10, false, false],
        ["wob", 0, 0.012046381298866725, 0.003, 0.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13b"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= abs(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/10.);\n    float y = radius * sin(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 10.77, 0, 111, false, false],
        ["contrast", 0, 1.39, 0, 4, false, false],
        ["orbSize", 0, 3.81, 0.01, 5, false, false],
        ["radius", 0, 33.43, 1, 115, false, false],
        ["colorShift", 0, 7.65, 1, 40, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["rotation", 0, 50, 0, 50, false, false],
        ["sinMul", 0, 2.23, 0, 5, false, false],
        ["cosMul", 0, 1.53, 0, 3, false, false],
        ["yMul", 0, 0.11, 0, 1, false, false],
        ["xMul", 0, 0.29, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 19, 0, 19, false, false],
        ["xDivide", 0, 19, 0, 19, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca140"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 5.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) * sin(uv.y / 3. + stream / 7.);\n    // uv *= k_rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius * -1. * tan(t - multiplier), radius * sin(t - multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 69.87, 0, 139.74, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 2.98, 0, 5.96, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 3.01, 0, 6.02, false, false],
        ["radius", 0, 20.48, 0, 40.96, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca132"
    },
    "shader": "#define BALLS 50\n\nvoid main() {\n  float stream = stream / 1.67950;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/10.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 30; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .58)/4. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 334.821, 0, 1000, false, false],
        ["xDiv", 0, 218.75, 0, 1000, false, false],
        ["yDiv", 0, 1205.357, 0, 2000, false, false],
        ["xDiv2", 0, 129.464, 0, 200, false, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 26.786, 0, 2000, false, false],
        ["yDiv3", 0, 26.786, 0, 2000, false, false],
        ["multiplier", 0, 5.982, 0, 20, false, false],
        ["ballSize", 0, 50.446, 0, 100, false, false],
        ["contrast", 0, 1.304, 0, 4, false, false],
        ["radius", 0, 50.223, 0, 250, false, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 3.482, 0, 20, false, false],
        ["yMul", 0, 4.196, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a64"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca147"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 1, false, false],
        ["yDivider", 0, 4.3, 0.1, 10, false, false],
        ["xDivider", 0, 117.73, 0.1, 1000, false, false],
        ["multiplier", 0, 0.51, 0.1, 1, false, false],
        ["ballSize", 0, 0.1, 0, 0.3, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 0, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 0.49, 0, 1, false, false],
        ["yDivider", 0, 210.95, 0.1, 1000, false, false],
        ["xDivider", 0, 144.58, 0.1, 1000, false, false],
        ["multiplier", 0, 0.34, 0.1, 1, false, false],
        ["ballSize", 0, 0.06, 0, 1, false, false],
        ["contrast", 0, 1.23, 0, 5, false, false],
        ["radius", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca118"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(sin(cos(uv + stream) + stream / .5));\n  for (float i = 0.; i < 20.; i++) {\n    uv.x -= dist + .009 * dist * (i + 1.) * (uv.y);\n    float t = (i + 1.) * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.); //* cos(t-stream/1.) / sin(t);\n    float y = radius * sin(t - stream / 3.); // / sin(t-stream/1.) / cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i + 100.) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 11, 0, 22, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.23, 0, 0.46, false, false],
        ["radius", 0, 3.68, 0, 7.36, false, false],
        ["colorShift", 0, 7.05, 0, 14.1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a61"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11e"
    },
    "shader": "#define orbs 20.\n#define barStream stream\n#define tatumStream stream\n#define beatStream stream\n#define barVolume volume\n#define tatumVolume volume\n#define beatVolume volume\n\n\n\n\n\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n\n\n\n\n\n\nvoid main() {\n  float stream = pow(stream, 1.3);\n  float volume = pow(barVolume * beatVolume * pow(tatumVolume, 1.), punch);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv += sinMul * sin(dot(uv, uv) - barStream / aSpeed) + cosMul * cos(dot(uv, uv) + barStream / bSpeed);\n  uv *= zoom;\n  float dist = distance(uv, vec2(0));\n  uv *= k_rotate2d((barStream + tatumStream) / rotation + dist / swirl);\n  uv = k_swap(uv, abs(uv), invert, invertTween, invertTweenProgress);\n  vec2 kale = k_kale(uv, vec2(0.), sides);\n  uv = k_swap(uv, kale, kaleidoscope, kaleidoscopeTween, kaleidoscopeTweenProgress);\n  uv *= k_rotate2d((stream) / rotation);\n  float a = colorMultiplier * sin(shapeMultiplier * sin(dot(uv, uv)) / dist + (tatumStream + beatStream) / rippleSpeed);\n  float b = cos(uv.x * xMultiplier - tatumStream / wobbleSpeed);\n  float c = sin(uv.y * yMultiplier + tatumStream / wobbleSpeed);\n  uv /= colorSpread * a * (b * c);\n  uv *= dist;\n  for (float i = 0.; i < 20.; i++) {\n    float t = i + PI / orbs + barStream / borderSpeed;\n    uv *= k_rotate2d(t + float(i));\n    vec2 p = radius * vec2(radius * tan(t - i * PI), radius * cos(t + i * PI));\n    vec3 col = barVolume * pow(tatumVolume, 1.5) * cos(barStream / hueShift + vec3(0, 1, -1) * PI * 2. / 3. + PI * i * 0.5 + 0.5);\n    gl_FragColor += barVolume * vec4(pow(tatumVolume, 1.5) * orbsize / length(uv + p * (spreadMultiplier)) * col, 1.0);\n  }\n  gl_FragColor = vec4(pow(gl_FragColor.xyz, vec3(contrast)), 1.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.012, false, false],
        ["shapeMultiplier", 0, 1583.68, 0, 3167.36, false, false],
        ["spreadMultiplier", 0, 1.913, 0, 3.826, false, false],
        ["rotation", 0, 50, 0, 100, false, false],
        ["xMultiplier", 0, 369.731, 0, 739.462, false, false],
        ["yMultiplier", 0, 403.636, 0, 807.272, false, false],
        ["colorSpread", 0, 0.00007, 0, 0.00014, false, false],
        ["invert", 1, false, null, null, null, false],
        ["orbsize", 0, 35.636, 0, 71.272, false, false],
        ["contrast", 0, 1.258, 0, 2.516, false, false],
        ["radius", 0, 9.636, 0, 19.272, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["aSpeed", 0, -10, -20, 0, false, false],
        ["bSpeed", 0, 8.3, 0, 16.6, false, false],
        ["sinMul", 0, -0.109, -0.218, 0, false, false],
        ["cosMul", 0, 0.055, 0, 0.11, false, false],
        ["rippleSpeed", 0, -20, -40, 0, false, false],
        ["wobbleSpeed", 0, 4.145, 0, 8.29, false, false],
        ["swirl", 0, -0.5, -1, 0, false, false],
        ["energy", 0, 1.1, 0, 2.2, false, false],
        ["punch", 0, 1, 0, 2, false, false],
        ["borderSpeed", 0, 616.364, 0, 1232.728, false, false],
        ["hueShift", 0, -31.964, -63.928, 0, false, false],
        ["colorMultiplier", 0, 0.0034, 0, 0.0068, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11f"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0.01, 0.05, false, false],
        ["ballSize", 0, 7.06, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 29.17, 0, 50, false, false],
        ["rotation", 0, 0, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.034, 0.01, 0.05, false, false],
        ["ballSize", 0, 7.06, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 50, 0, 50, false, false],
        ["rotation", 0, 0, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.014, 0.01, 0.05, false, false],
        ["ballSize", 0, 15.51, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 50, 0, 50, false, false],
        ["rotation", 0, 0.102, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.026, 0.01, 0.05, false, false],
        ["ballSize", 0, 15.51, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 50, 0, 50, false, false],
        ["rotation", 0, 0.102, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14a"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x -= sin(uv.x / xDivider - stream / 8.) * sin(uv.y / 3. + stream / 2.);\n\n    float t = dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x - stream / 2.);\n    vec2 p = radius * vec2(-1. * cos(t * multiplier - stream / 5.), 1. * sin(t / multiplier + stream));\n    p -= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 0.44, false, false],
        ["yDivider", 0, 4.3, 0, 8.6, false, false],
        ["xDivider", 0, 117.73, 0, 235.46, false, false],
        ["multiplier", 0, 0.51, 0, 1.02, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12e"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    float stream = stream / 1.24;\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv = abs(uv);\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n   \n      uv.x *= tan(dist+.0000000000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * 10.5 + uv.x/40.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/20.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*20.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.01, false, false],
        ["contrast", 0, 2.09, 0, 4, false, false],
        ["orbSize", 0, 0.42, 0.01, 2, false, false],
        ["radius", 0, 2.9, 0, 6, false, false],
        ["colorShift", 0, 4.96, 1, 13, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca12f"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 15.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (.005 / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.8) * orbSize, position, color, contrast);\n    }\n}",
    "variants": [
      [
        ["zoom", 0, 0.301, 0, 1, false, false],
        ["iterator", 0, 2.105, 0, 12, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 4, 0, 33, false, false],
        ["L", 0, 1.372, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 1.006, 0, 12, false, false],
        ["colorOffset", 0, 7.654, 0, 111, false, false],
        ["contrast", 0, 2.083, 0, 3, false, false],
        ["orbSize", 0, 0.753, 0, 2, false, false],
        ["div", 0, 0.214, 0.01, 1, false, false],
        ["radius", 0, 0.639, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.032, 0, 0.1, false, false],
        ["iterator", 0, 1.405, 0, 2, false, false],
        ["ot", 0, 39.026, 0, 151, false, false],
        ["I", 0, 0.259, 0, 3, false, false],
        ["J", 0, 0.36, 0, 3, false, false],
        ["K", 0, 1.669, 0, 11, false, false],
        ["iterations", 0, 6, 0, 33, false, false],
        ["L", 0, 1.358, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.689, 0, 2, false, false],
        ["colorOffset", 0, 13.519, 0, 111, false, false],
        ["contrast", 0, 1.736, 0, 3, false, false],
        ["orbSize", 0, 0.546, 0, 2, false, false],
        ["div", 0, 0.307, 0.01, 1, false, false],
        ["radius", 0, 4.767, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.574, 0, 1, false, false],
        ["iterator", 0, 1.144, 0, 2, false, false],
        ["ot", 0, 107.664, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 10.753, 0, 11, false, false],
        ["iterations", 0, 13, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.54, 0, 2, false, false],
        ["colorOffset", 0, 26.661, 0, 111, false, false],
        ["contrast", 0, 1.372, 0, 3, false, false],
        ["orbSize", 0, 0.443, 0, 2, false, false],
        ["div", 0, 0.135, 0.01, 1, false, false],
        ["radius", 0, 3.176, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca136"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = abs(normalize(uv) * length(uv));\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/5.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) * sin(uv.y/3. + stream/7.);\n   // uv *= rotate2d(.001*length(uv)+float(i) + stream/100.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = vec2(radius*-1.*tan(t-multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 69.87, 0, 501, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 2.98, 0.1, 111, false, false],
        ["ballSize", 0, 0.22, 0, 1, false, false],
        ["contrast", 0, 3.01, 0, 15, false, false],
        ["radius", 0, 20.48, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 10.75, 0, 50, false, false],
        ["yDivider", 0, 60.01, 0.1, 1000, false, false],
        ["xDivider", 0, 53.56, 0.1, 1000, false, false],
        ["multiplier", 0, 3.06, 0.1, 111, false, false],
        ["ballSize", 0, 0.11, 0, 1, false, false],
        ["contrast", 0, 1.58, 0, 15, false, false],
        ["radius", 0, 14.86, 0, 111, false, false],
        ["yOuter", 0, 0, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 82.81, 0, 501, false, false],
        ["yDivider", 0, 60.01, 0.1, 1000, false, false],
        ["xDivider", 0, 53.56, 0.1, 1000, false, false],
        ["multiplier", 0, 3.06, 0.1, 111, false, false],
        ["ballSize", 0, 0.29, 0, 1, false, false],
        ["contrast", 0, 4.67, 0, 15, false, false],
        ["radius", 0, 45.97, 0, 111, false, false],
        ["yOuter", 0, 0, 0, 1, false, false],
        ["xOuter", 0, 0, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 17.6, 0, 501, false, false],
        ["yDivider", 0, 60.01, 0.1, 1000, false, false],
        ["xDivider", 0, 53.56, 0.1, 1000, false, false],
        ["multiplier", 0, 3.06, 0.1, 111, false, false],
        ["ballSize", 0, 0.08, 0, 1, false, false],
        ["contrast", 0, 1.69, 0, 15, false, false],
        ["radius", 0, 13.89, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 20.51, 0, 501, false, false],
        ["yDivider", 0, 60.01, 0.1, 1000, false, false],
        ["xDivider", 0, 360.08, 0.1, 1000, false, false],
        ["multiplier", 0, 3.06, 0.1, 111, false, false],
        ["ballSize", 0, 0.14, 0, 1, false, false],
        ["contrast", 0, 5.62, 0, 15, false, false],
        ["radius", 0, 18.25, 0, 111, false, false],
        ["yOuter", 0, 0, 0, 1, false, false],
        ["xOuter", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13e"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += (sinMul * sin(stream / 5. + uv.y * yMul)); // + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream / 10. + uv.x * xMul)); // + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 20.) + sin(t);\n    float y = radius * cos(t + stream / 20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.61, 0, 27.22, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.4, 0, 0.8, false, false],
        ["radius", 0, 2.38, 0, 4.76, false, false],
        ["colorShift", 0, 10, 0, 20, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.04, 0, 0.08, false, false],
        ["sinMul", 0, 0.25, 0, 0.5, false, false],
        ["cosMul", 0, 0.2, 0, 0.4, false, false],
        ["yMul", 0, 0.9, 0, 1.8, false, false],
        ["xMul", 0, 1.27, 0, 2.54, false, false],
        ["xSpeed", 0, -0.71, -1.42, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13f"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 21.06, 0, 42.12, false, false],
        ["yDivider", 0, 818.46, 0, 1636.92, false, false],
        ["xDivider", 0, 656.67, 0, 1313.34, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 2.03, 0, 4.06, false, false],
        ["radius", 0, 26.22, 0, 52.44, false, false],
        ["yOuter", 0, 0.12, 0, 0.24, false, false],
        ["xOuter", 0, 0.29, 0, 0.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca142"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 1.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 16.1, 0, 32.2, false, false],
        ["yDivider", 0, 332.97, 0, 665.94, false, false],
        ["xDivider", 0, 377.39, 0, 754.78, false, false],
        ["multiplier", 0, 61.62, 0, 123.24, false, false],
        ["ballSize", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 3.52, 0, 7.04, false, false],
        ["radius", 0, 31.84, 0, 63.68, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca149"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 4.) + sin(uv.x / 3. - stream / 2.);\n    uv.x -= sin(uv.x / xDivider - stream / 8.) * sin(uv.y / 3. + stream / 2.);\n\n    float t = dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x - stream / 2.);\n    vec2 p = radius * vec2(-1. * cos(t * multiplier - stream / 5.), 1. * sin(t / multiplier + stream));\n    p -= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 0.44, false, false],
        ["yDivider", 0, 4.3, 0, 8.6, false, false],
        ["xDivider", 0, 117.73, 0, 235.46, false, false],
        ["multiplier", 0, 0.51, 0, 1.02, false, false],
        ["ballSize", 0, 0.1, 0, 0.2, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14f"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.9, 0, 15, false, false],
        ["ballSize", 0, 193.249, 0, 1111, false, false],
        ["contrast", 0, 2.55, 0, 15, false, false],
        ["radius", 0, 151.82, 0, 1105, false, false],
        ["yOuter", 0, 27.3, 0, 100, false, false],
        ["xOuter", 0, 21.98, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 33.47, 0, 101, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.001, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ],
      [
        ["zoom", 0, 2.33, 0, 15, false, false],
        ["ballSize", 0, 99.135, 0, 1111, false, false],
        ["contrast", 0, 3.3, 0, 15, false, false],
        ["radius", 0, 50.08, 0, 1105, false, false],
        ["yOuter", 0, 30.31, 0, 100, false, false],
        ["xOuter", 0, 8.89, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 12.61, 0, 101, false, false],
        ["divider", 0, 0, 0, 10, false, false],
        ["rotation", 0, 0.0002, 0, 0.001, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ],
      [
        ["zoom", 0, 3.51, 0, 15, false, false],
        ["ballSize", 0, 642.44, 0, 1111, false, false],
        ["contrast", 0, 1.41, 0, 15, false, false],
        ["radius", 0, 539.23, 0, 1105, false, false],
        ["yOuter", 0, 12, 0, 100, false, false],
        ["xOuter", 0, 86.53, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 12.61, 0, 101, false, false],
        ["divider", 0, 0, 0, 10, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ],
      [
        ["zoom", 0, 2.2, 0, 15, false, false],
        ["ballSize", 0, 642.44, 0, 1111, false, false],
        ["contrast", 0, 1.41, 0, 15, false, false],
        ["radius", 0, 34.39, 0, 1105, false, false],
        ["yOuter", 0, 64.48, 0, 100, false, false],
        ["xOuter", 0, 100, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 0, 0, 101, false, false],
        ["divider", 0, 0, 0, 10, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca121"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0.01, 0.05, false, false],
        ["ballSize", 0, 7.06, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 29.17, 0, 50, false, false],
        ["rotation", 0, 0, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca125"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue); \n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0.01, 0.05, false, false],
        ["ballSize", 0, 7.06, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 50, 0, 50, false, false],
        ["rotation", 0, 0, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca14e"
    },
    "shader": "#define BALLS 50.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv.x +=11.1*sin(uv.y/yDivider) + sinMul*sin(uv.x*x1 - stream/1.);\n  uv.y *= xMul*cos(stream)+(uv.y/yDivider + 11.*sin(x2*uv.x-stream));\n  uv.x += xMul2*sin(.1*uv.y);\n  uv.y += yMul2*cos(.1*uv.x);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*s in(t)*xMul, i * uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 23.14, 0, 46.28, false, false],
        ["contrast", 0, 1.85, 0, 3.7, false, false],
        ["ballSize", 0, 2.29, 0, 4.58, false, false],
        ["x1", 0, 0.45, 0, 0.9, false, false],
        ["x2", 0, 0.74, 0, 1.48, false, false],
        ["ballMul", 0, 3.59, 0, 7.18, false, false],
        ["xMul", 0, 18.24, 0, 36.48, false, false],
        ["yDivider", 0, 1.06, 0, 2.12, false, false],
        ["sinMul", 0, 7, 0, 14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca153"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5.9, 0, 11.8, false, false],
        ["ballSize", 0, 193.249, 0, 386.498, false, false],
        ["contrast", 0, 2.55, 0, 5.1, false, false],
        ["radius", 0, 151.82, 0, 303.64, false, false],
        ["yOuter", 0, 27.3, 0, 54.6, false, false],
        ["xOuter", 0, 21.98, 0, 43.96, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 202, false, false],
        ["yMultiplier", 0, 33.47, 0, 66.94, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.0008, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a67"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca116"
    },
    "shader": "\n\n#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.06, 0, 6.12, false, false],
        ["xMultiplier", 0, 35.99, 0, 71.98, false, false],
        ["yMultiplier", 0, 49.25, 0, 98.5, false, false],
        ["ballSize", 0, 1.25, 0, 2.5, false, false],
        ["colorSpread", 0, 3.36, 0, 6.72, false, false],
        ["colorMultiplier", 0, 114.55, 0, 229.1, false, false],
        ["shapeMultiplier", 0, 13.46, 0, 26.92, false, false],
        ["glow", 0, 1862.09, 0, 3724.18, false, false],
        ["contrast", 0, 3.17, 0, 6.34, false, false],
        ["rotation", 0, 11.471, 0, 22.942, false, false],
        ["brightness", 0, 1, 0, 2, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["invert", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca148"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/4.) + sin(uv.x/3. - stream/2.);\n    uv.x -= sin(uv.x/xDivider - stream/8.) * sin(uv.y/3. + stream/2.);\n\n    float t = dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x-stream/2.);\n    vec2 p = radius*vec2(-1.*cos(t*multiplier-stream/5.), 1.*sin(t/multiplier+stream));\n    p -= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 1, false, false],
        ["yDivider", 0, 4.3, 0.1, 10, false, false],
        ["xDivider", 0, 117.73, 0.1, 1000, false, false],
        ["multiplier", 0, 0.51, 0.1, 1, false, false],
        ["ballSize", 0, 0.1, 0, 0.3, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a66"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca11b"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n\t\t\n\n\n    float dist = length(sin(cos(uv+stream) + stream/.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x -= dist+.009* dist*(i+1.) * (uv.y);\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t-stream/3.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 11, 0, 11, false, false],
        ["contrast", 0, 1, 1, 5, false, false],
        ["orbSize", 0, 0.23, 0.01, 1, false, false],
        ["radius", 0, 3.68, 1, 50, false, false],
        ["colorShift", 0, 7.05, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a61"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca128"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue); \n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/1.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.016, 0, 0.032, false, false],
        ["ballSize", 0, 11.57, 0, 23.14, false, false],
        ["contrast", 0, 4.53, 0, 9.06, false, false],
        ["radius", 0, 93.39, 0, 186.78, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 100, false, false],
        ["y", 0, 50, 0, 100, false, false],
        ["rotation", 0, 0.055, 0, 0.11, false, false],
        ["colorOffset", 0, 4.7, 0, 9.4, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca131"
    },
    "shader": "#define orbs 30.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= (.01/ dot(uv, uv));\n    uv *= k_rotate2d(stream/-6.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= tan(dist+.0000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / orbs * PI * .5;\n      float x = radius * tan(t);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*.1) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, .03/dist*pow(volume, 1.2) * orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 0.01, 0, 0.1, false, false],
        ["contrast", 0, 1.84, 0, 4, false, false],
        ["orbSize", 0, 5.37, 0.01, 51, false, false],
        ["radius", 0, 12, 0, 12, false, false],
        ["colorShift", 0, 5.58, 1, 11, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a63"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca137"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += (sinMul * sin(stream/5.+uv.y * yMul));// + (sinMul * cos(uv.y + stream*xSpeed));\n    uv.y += (cosMul * cos(-stream/10.+uv.x * xMul));// + (cosMul * cos(uv.x * xMul - stream*ySpeed));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/20.) + sin(t);\n    float y = radius * cos(t+stream/20.) * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 13.61, 0, 23, false, false],
        ["contrast", 0, 1.13, 1, 5, false, false],
        ["orbSize", 0, 0.4, 0.01, 2, false, false],
        ["radius", 0, 2.38, 1, 5, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.04, 0, 0.1, false, false],
        ["sinMul", 0, 0.25, 0, 2, false, false],
        ["cosMul", 0, 0.2, 0, 1, false, false],
        ["yMul", 0, 0.9, 0, 5, false, false],
        ["xMul", 0, 1.27, 0, 5, false, false],
        ["xSpeed", 0, -0.71, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 34.22, 0, 123, false, false],
        ["contrast", 0, 1, 1, 5, false, false],
        ["orbSize", 0, 1.29, 0.01, 2, false, false],
        ["radius", 0, 8.17, 1, 15, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false],
        ["sinMul", 0, 0.04, 0, 2, false, false],
        ["cosMul", 0, 1, 0, 1, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.81, 0, 5, false, false],
        ["xSpeed", 0, 1, 0, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 3.14, 0, 23, false, false],
        ["contrast", 0, 1.24, 1, 5, false, false],
        ["orbSize", 0, 0.57, 0.01, 2, false, false],
        ["radius", 0, 1.73, 1, 5, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.04, 0, 0.1, false, false],
        ["sinMul", 0, 0.25, 0, 2, false, false],
        ["cosMul", 0, 0.41, 0, 1, false, false],
        ["yMul", 0, 0.9, 0, 5, false, false],
        ["xMul", 0, 1.27, 0, 5, false, false],
        ["xSpeed", 0, -0.71, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 71.22, 0, 123, false, false],
        ["contrast", 0, 1.13, 1, 5, false, false],
        ["orbSize", 0, 3.65, 0.01, 4, false, false],
        ["radius", 0, 15, 1, 15, false, false],
        ["colorShift", 0, 4.72, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false],
        ["sinMul", 0, 2, 0, 2, false, false],
        ["cosMul", 0, 1, 0, 1, false, false],
        ["yMul", 0, 0.35, 0, 5, false, false],
        ["xMul", 0, 1.19, 0, 5, false, false],
        ["xSpeed", 0, 1, 0, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 46.57, 0, 123, false, false],
        ["contrast", 0, 1.13, 1, 5, false, false],
        ["orbSize", 0, 3.65, 0.01, 4, false, false],
        ["radius", 0, 15, 1, 15, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.01, 0, 0.1, false, false],
        ["sinMul", 0, 2, 0, 2, false, false],
        ["cosMul", 0, 0, 0, 1, false, false],
        ["yMul", 0, 0.62, 0, 5, false, false],
        ["xMul", 0, 1.19, 0, 5, false, false],
        ["xSpeed", 0, 1, 0, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca13c"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 3.);\n    float y = radius * cos(t + stream / 3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 71.67, 0, 143.34, false, false],
        ["contrast", 0, 1.49, 0, 2.98, false, false],
        ["orbSize", 0, 4.57, 0, 9.14, false, false],
        ["radius", 0, 25.16, 0, 50.32, false, false],
        ["colorShift", 0, 8.53, 0, 17.06, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["rotation", 0, 0.4, 0, 0.8, false, false],
        ["sinMul", 0, 0.3, 0, 0.6, false, false],
        ["cosMul", 0, 1.88, 0, 3.76, false, false],
        ["yMul", 0, 0.36, 0, 0.72, false, false],
        ["xMul", 0, 0.16, 0, 0.32, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0057, 0, 0.0114, false, false],
        ["yDivide", 0, 4.98, 0, 9.96, false, false],
        ["xDivide", 0, 7.79, 0, 15.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca143"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. - stream / 2.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 3.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 2210.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * cos(t * multiplier), radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 33.59, 0, 67.18, false, false],
        ["yDivider", 0, 332.97, 0, 665.94, false, false],
        ["xDivider", 0, 377.39, 0, 754.78, false, false],
        ["multiplier", 0, 48.3, 0, 96.6, false, false],
        ["ballSize", 0, 0.16, 0, 0.32, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 15.87, 0, 31.74, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a65"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca123"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides) * k_rotate2d(stream / 100.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 1.1 * sin(t + stream / 100.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 50. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(1. - log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0, 0.068, false, false],
        ["ballSize", 0, 7.06, 0, 14.12, false, false],
        ["contrast", 0, 2.05, 0, 4.1, false, false],
        ["radius", 0, 51.36, 0, 102.72, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 100, false, false],
        ["y", 0, 29.17, 0, 58.34, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["colorOffset", 0, 1.91, 0, 3.82, false, false],
        ["sides", 0, 4, 0, 8, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca126"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(0.), sides) * rotate(stream/100.);\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  \n\tif (kaleidoscopeTween) {\n   \tif (kaleidoscope) { \n    \tuv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius*vec2(-.5*cos(t), .5+1.1*sin(t+stream/100.));\n    p /= sin(stream/300.+PI * sin(uv.x/x)*cos(stream/50.+uv.y/y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(1.-log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.034, 0.01, 0.05, false, false],
        ["ballSize", 0, 7.06, 0, 115, false, false],
        ["contrast", 0, 2.05, 0, 5, false, false],
        ["radius", 0, 51.36, 0, 1000, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 50, 0, 50, false, false],
        ["y", 0, 29.17, 0, 50, false, false],
        ["rotation", 0, 0, 0, 0.5, false, false],
        ["colorOffset", 0, 1.91, 0, 10, false, false],
        ["sides", 0, 4, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.733Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a62"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca171"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(.15*stream-dist/rotateDiv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/50.) * tan(dist*t-stream/8.7)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.52, 0, 3.04, false, false],
        ["contrast", 0, 0.75, 0, 1.5, false, false],
        ["orbSize", 0, 0.005, 0, 0.01, false, false],
        ["radius", 0, 2.21, 0, 4.42, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 0.53, 0, 1.06, false, false],
        ["rotateDiv", 0, 1.85, 0, 3.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca174"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t*radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 8.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17e"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(-stream/2.5);\n  float dist = length(uv);\n  uv *= rotate(stream/4.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t+stream/.769195)*shape*sin(dist+stream/.69045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 7.23, 0, 11, false, false],
        ["contrast", 0, 0.66, 0, 2, false, false],
        ["orbSize", 0, 0.01, 0.01, 0.02, false, false],
        ["radius", 0, 0.2, 0, 1, false, false],
        ["colorShift", 0, 4.38, 4, 10, false, false],
        ["sides", 0, 13, 0, 18, false, false],
        ["shape", 0, 29.41, 0, 115, false, false],
        ["distDiv", 0, 14.05, 0, 111, false, false],
        ["mul", 0, 6.06, 0, 111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17f"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.06, 0, 1, false, false],
        ["contrast", 0, 1.59, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 18.4, 1, 115, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.14, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.62, 0, 1, false, false],
        ["contrast", 0, 1.5, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 10.4, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0059, 0.001, 0.01, false, false],
        ["yDivide", 0, 0.43, 0, 19, false, false],
        ["xDivide", 0, 12.45, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.05, 0, 1, false, false],
        ["contrast", 0, 1.68, 0, 2, false, false],
        ["orbSize", 0, 6.95, 0.01, 15, false, false],
        ["radius", 0, 55.15, 1, 115, false, false],
        ["colorShift", 0, 7.11, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18d"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15d"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t + radius * cos(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 8.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca166"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape + sin(dist + stream / .25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.84, 0, 13.68, false, false],
        ["contrast", 0, 0.99, 0, 1.98, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1.17, 0, 2.34, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.53, 0, 1.06, false, false],
        ["distDiv", 0, 4.36, 0, 8.72, false, false],
        ["mul", 0, 4.47, 0, 8.94, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false],
        ["center", 0, 2.72, 0, 5.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca100"
    },
    "shader": "void main () {\n  float stream = stream / 1.5;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/3.);\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    vec2 position = vec2(radius*abs(tan(stream/2.+uv.x/div)) * L * (sin(stream - uv.y)), radius*-(cos(stream/21.10+uv.y/div)));\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .96175) * orbSize, position,  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 32.989, 0, 221, false, false],
        ["iterator", 0, 1.019, 0, 2, false, false],
        ["I", 0, 167.101, 0, 231, false, false],
        ["J", 0, 6.434, 0, 23, false, false],
        ["K", 0, 60.598, 0, 111, false, false],
        ["iterations", 0, 24.216, 0, 33, false, false],
        ["L", 0, 22.901, 0, 213, false, false],
        ["M", 0, 3.077, 0, 11, false, false],
        ["colorShift", 0, 0.466, 0, 2, false, false],
        ["colorOffset", 0, 56.543, 0, 111, false, false],
        ["contrast", 0, 1.747, 1, 3, false, false],
        ["orbSize", 0, 0.886, 0, 3, false, false],
        ["div", 0, 238.717, 1, 2212, false, false],
        ["radius", 0, 1.642, 0, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca187"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide + stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(col * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .665 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.14, 0, 0.28, false, false],
        ["contrast", 0, 0.168, 0, 0.336, false, false],
        ["orbSize", 0, 4.15, 0, 8.3, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 10.64, 0, 21.28, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.1, 0, 0.2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.93, 0, 1.86, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.46, 0, 0.92, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, -1, -2, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 3.01, 0, 6.02, false, false],
        ["xDivide", 0, 6.97, 0, 13.94, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["col", 0, 0.07, 0, 0.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18c"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["contrast", 0, 1.46, 0, 2.92, false, false],
        ["orbSize", 0, 2.7, 0, 5.4, false, false],
        ["radius", 0, 12.69, 0, 25.38, false, false],
        ["colorShift", 0, 4.31, 0, 8.62, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.09, 0, 2.18, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, 0, -2, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca157"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv *= k_rotate2d(-stream);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = dist + pow(volume, 6.) * t * radius * cos(dist * t - stream / .29195) * shape + sin(dist + stream / -1.25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 6.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.26, 0, 8.52, false, false],
        ["contrast", 0, 0.99, 0, 1.98, false, false],
        ["orbSize", 0, 0.014, 0, 0.028, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 8.02, 0, 16.04, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 0.42, 0, 0.84, false, false],
        ["distDiv", 0, 19.55, 0, 39.1, false, false],
        ["mul", 0, 3.12, 0, 6.24, false, false],
        ["rotateSpeed", 0, 0, 0, 0, false, false],
        ["center", 0, 0.19, 0, 0.38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca172"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);;\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul - shape;\n    float x = t*radius * cos(dist*t+stream/2.69195)*shape*sin(dist+stream/.9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.43, 0, 8.86, false, false],
        ["contrast", 0, 0.87, 0, 1.74, false, false],
        ["orbSize", 0, 0.012, 0, 0.024, false, false],
        ["radius", 0, 0.36, 0, 0.72, false, false],
        ["colorShift", 0, 4.82, 0, 9.64, false, false],
        ["sides", 0, 9, 0, 18, false, false],
        ["shape", 0, 2.82, 0, 5.64, false, false],
        ["distDiv", 0, 111, 0, 222, false, false],
        ["mul", 0, 11, 0, 22, false, false],
        ["center", 0, 2.78, 0, 5.56, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca175"
    },
    "shader": "#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length((uv));\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius * cos(dist*t)*cos(uv.x*dist-stream)*sin(dist-stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.19, 0, 6.38, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.12, 0, 0.24, false, false],
        ["radius", 0, 2.64, 0, 5.28, false, false],
        ["colorShift", 0, 4.54, 0, 9.08, false, false],
        ["center", 0, 2.76, 0, 5.52, false, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["shape", 0, 0.25, 0, 0.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca185"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 1.);\n    float y = radius * cos(t + stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.35, 0, 2.7, false, false],
        ["orbSize", 0, 2.7, 0, 5.4, false, false],
        ["radius", 0, 21.66, 0, 43.32, false, false],
        ["colorShift", 0, 8.85, 0, 17.7, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.09, 0, 2.18, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca188"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 18900.01 * uv.x + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.058, 0, 0.116, false, false],
        ["contrast", 0, 0.14, 0, 0.28, false, false],
        ["orbSize", 0, 2.38, 0, 4.76, false, false],
        ["radius", 0, 6.38, 0, 12.76, false, false],
        ["colorShift", 0, 5.43, 0, 10.86, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, -1, -2, 0, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.08, 0, 2.16, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -1.5, -3, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 3.56, 0, 7.12, false, false],
        ["xDivide", 0, 5, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18e"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .12;\n  float b = stream * .5;\n  float ot =.1;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 10; i++) {\n    p *= rot;\n    p = (abs(p) * 1.5 - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  ot = max(0., .1 - ot) / .1; //orbit trap \n  if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * 4. + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * .25, color, 2.); // saturation adjustment\n  color *= 1. - pow(l * .1, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/11. * sin(.01*length(-1. + 2. * gl_FragCoord.xy / resolution.xy)/1.1));\n}",
    "variants": [
      [
        ["zoom", 0, 0.366, 0, 3, false, false],
        ["A", 0, 1, 0, 1, false, false],
        ["B", 0, 3, 0, 3, false, false],
        ["C", 0, 0.6359954038787592, 0, 1, false, false],
        ["D", 0, 0.41622989513690534, 0, 1, false, false],
        ["E", 0, 0.4048123309829358, 0, 1, false, false],
        ["F", 0, 0.5604462168821562, 0, 1, false, false],
        ["G", 0, 0.1933471163590238, 0, 1, false, false],
        ["H", 0, 0.7424808632786761, 0, 1, false, false],
        ["I", 0, 0.8936912598741336, 0, 1, false, false],
        ["J", 0, 3.3570565776680446, 0, 11, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca165"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  uv *= k_rotate2d(0. * 115. * stream - (length(uv)) / rotateDiv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 1.;\n    float x = dist * t + radius * (i / iDiv) * tan(dist * t - i * stream / tanSpeed) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, volume * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.48, 0, 4.96, false, false],
        ["contrast", 0, 1.06, 0, 2.12, false, false],
        ["orbSize", 0, 0.005, 0, 0.01, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 13.19, 0, 26.38, false, false],
        ["rotateDiv", 0, 9.89, 0, 19.78, false, false],
        ["tanSpeed", 0, 66.61, 0, 133.22, false, false],
        ["iDiv", 0, 57.88, 0, 115.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16d"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * 1. * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.21, 0, 14.42, false, false],
        ["contrast", 0, 0.8, 0, 1.6, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["center", 0, 0.81, 0, 1.62, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false],
        ["distDiv", 0, 30, 0, 60, false, false],
        ["mul", 0, 8.45, 0, 16.9, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16e"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center * dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t * radius * cos(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 8.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca170"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist*t+radius * (i/10.) * tan(dist*t-stream/2.7)*1.*sin(dist-stream/5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, dist*orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.44, 0, 4.88, false, false],
        ["contrast", 0, 1.24, 0, 2.48, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 6.91, 0, 13.82, false, false],
        ["center", 0, 3.65, 0, 7.3, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["shape", 0, 0.13, 0, 0.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca182"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca162"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 2.5);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t + stream / .769195) * shape * sin(dist + stream / .69045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.23, 0, 14.46, false, false],
        ["contrast", 0, 0.66, 0, 1.32, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.2, 0, 0.4, false, false],
        ["colorShift", 0, 4.38, 0, 8.76, false, false],
        ["sides", 0, 13, 0, 26, false, false],
        ["shape", 0, 29.41, 0, 58.82, false, false],
        ["distDiv", 0, 14.05, 0, 28.1, false, false],
        ["mul", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16b"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 10.) * tan(dist * t - stream / 1.7) * 1. * sin(dist + stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.62, 0, 11.24, false, false],
        ["contrast", 0, 0.9, 0, 1.8, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 1.58, 0, 3.16, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.13, 0, 0.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca180"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.234, 0, 2.78, false, false],
        ["orbSize", 0, 2.298, 0, 6, false, false],
        ["radius", 0, 20.95, 0, 41.9, false, false],
        ["colorShift", 0, 5.41, 0, 10.82, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.56, 0, 1.12, false, false],
        ["cosMul", 0, 0.88, 0, 1.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.56, 0, 1.12, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.65, 0, 7.3, false, false],
        ["xDivide", 0, 32.82, 0, 65.64, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca186"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) - cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) * sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 5.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 0.62, false, false],
        ["contrast", 0, 1.46, 0, 2.92, false, false],
        ["orbSize", 0, 2.7, 0, 5.4, false, false],
        ["radius", 0, 12.69, 0, 25.38, false, false],
        ["colorShift", 0, 4.31, 0, 8.62, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.09, 0, 2.18, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca159"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(.15 * stream - dist / rotateDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist * t + radius * (i / 50.) * tan(dist * t - stream / 8.7) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.53, 0, 7.06, false, false],
        ["contrast", 0, 0.7, 0, 1.4, false, false],
        ["orbSize", 0, 0.005, 0, 0.01, false, false],
        ["radius", 0, 2.21, 0, 4.42, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["shape", 0, 1, 0, 2, false, false],
        ["rotateDiv", 0, 3.88, 0, 7.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15e"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length((uv));\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * cos(dist * t) * cos(uv.x * dist - stream) * sin(dist - stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.19, 0, 6.38, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.12, 0, 0.24, false, false],
        ["radius", 0, 2.64, 0, 5.28, false, false],
        ["colorShift", 0, 4.54, 0, 9.08, false, false],
        ["center", 0, 2.76, 0, 5.52, false, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["shape", 0, 0.25, 0, 0.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca160"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.84, 0, 9.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 3, 0, 6, false, false],
        ["colorShift", 0, 7.96, 0, 15.92, false, false],
        ["center", 0, 2.46, 0, 4.92, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca169"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * .8 * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.75, 0, 1.5, false, false],
        ["contrast", 0, 0.95, 0, 1.9, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["center", 0, 0.81, 0, 1.62, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false],
        ["distDiv", 0, 9.86, 0, 19.72, false, false],
        ["mul", 0, 8.45, 0, 16.9, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca184"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = k_kale(uv, vec2(0), sides);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(stream * gloop);\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 10.);\n    float y = radius * cos(t + stream / 5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.25, 0, 0.5, false, false],
        ["contrast", 0, 1.3, 0, 2.6, false, false],
        ["orbSize", 0, 1.03, 0, 2.06, false, false],
        ["radius", 0, 4.74, 0, 9.48, false, false],
        ["colorShift", 0, 5.2, 0, 10.4, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 0.23, 0, 0.46, false, false],
        ["yMul", 0, 1.33, 0, 2.66, false, false],
        ["xMul", 0, 2.44, 0, 4.88, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, 0.5, 0, 1, false, false],
        ["gloop", 0, 0.001, 0, 0.002, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15a"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 1.5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 112.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .69195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.44, 0, 0.88, false, false],
        ["contrast", 0, 0.91, 0, 1.82, false, false],
        ["orbSize", 0, 0.05, 0, 0.1, false, false],
        ["radius", 0, 4.17, 0, 8.34, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.31, 0, 0.62, false, false],
        ["distDiv", 0, 9.79, 0, 19.58, false, false],
        ["mul", 0, 10.7, 0, 21.4, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false],
        ["center", 0, 2.72, 0, 5.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca176"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv *= rotate(stream/10.);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= rotate(rotateSpeed*stream-dist/distDiv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t-stream/.9195)*.8*sin(dist+stream/.5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.75, 0, 1.5, false, false],
        ["contrast", 0, 0.95, 0, 1.9, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["center", 0, 0.81, 0, 1.62, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false],
        ["distDiv", 0, 9.86, 0, 19.72, false, false],
        ["mul", 0, 8.45, 0, 16.9, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca177"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/6.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t+radius * cos(dist*t-stream/1.5)*1.*sin(dist+stream/3.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.61, 0, 5.22, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca191"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y + uv.x);\n}",
    "variants": [
      [
        ["zoom", 0, 0.4850717148852155, 0.2, 1, false, false],
        ["A", 0, 0.5003307097927256, 0, 1, false, false],
        ["B", 0, 0.7402404991801865, 0, 1, false, false],
        ["C", 0, 0.6891870954341921, 0, 1, false, false],
        ["D", 0, 0.8314592178758453, 0, 1, false, false],
        ["E", 0, 0.34211315865608305, 0, 1.1, false, false],
        ["F", 0, 0.3259375489172806, 0, 1, false, false],
        ["G", 0, 0.7566317119359389, 0, 1, false, false],
        ["H", 0, 0.39430978186333754, 0, 1, false, false],
        ["I", 0, 4.712730014375358, 0, 11, false, false],
        ["J", 0, 1.764128620477062, 1.3, 1.8, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca164"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream / 12.2 - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.15, 0, 4.3, false, false],
        ["contrast", 0, 0.99, 0, 1.98, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.95, 0, 1.9, false, false],
        ["distDiv", 0, 15.64, 0, 31.28, false, false],
        ["mul", 0, 10.7, 0, 21.4, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false],
        ["center", 0, 2.72, 0, 5.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca167"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 2.) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.52, 0, 13.04, false, false],
        ["contrast", 0, 0.55, 0, 1.1, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.08, 0, 0.16, false, false],
        ["colorShift", 0, 6.04, 0, 12.08, false, false],
        ["center", 0, 2.92, 0, 5.84, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 2.86, 0, 5.72, false, false],
        ["mul", 0, 5.19, 0, 10.38, false, false],
        ["div", 0, 7.42, 0, 14.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16f"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 1.5) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.48, 0, 8.96, false, false],
        ["contrast", 0, 0.91, 0, 1.82, false, false],
        ["orbSize", 0, 0.02, 0, 0.04, false, false],
        ["radius", 0, 0.1, 0, 0.2, false, false],
        ["colorShift", 0, 6.04, 0, 12.08, false, false],
        ["center", 0, 2.87, 0, 5.74, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 1.55, 0, 3.1, false, false],
        ["mul", 0, 2.24, 0, 4.48, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17a"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius - .7 * atan(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.37, 0, 6.74, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca183"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation+stream/8.);\n    float t = PI / float(BALLS) * (float(i));// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.02*uv.y-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.4201*uv.x + sin(uv.y/.1)), length(.1*(uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = color * pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        [3, 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["zoom", 0, 5.9, 0, 15, false, false],
        ["ballSize", 0, 193.249, 0, 1111, false, false],
        ["contrast", 0, 2.55, 0, 15, false, false],
        ["radius", 0, 151.82, 0, 1105, false, false],
        ["yOuter", 0, 27.3, 0, 100, false, false],
        ["xOuter", 0, 21.98, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["mirrorTween", 1, false, null, null, null, false],
        ["mirrorTweenProgress", 0, 0, null, null, false, false],
        ["xMultiplier", 0, 101, 0, 101, false, false],
        ["yMultiplier", 0, 33.47, 0, 101, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.001, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca194"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.5349397590361449, 0, 111, false, false],
        ["contrast", 0, 1.4188433734939763, 0, 9.98, false, false],
        ["ballSize", 0, 0.8915662650602411, 0, 2, false, false],
        ["radius", 0, 9.612144578313256, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca156"
    },
    "shader": "\n#define orbs 10.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist*t+radius * (i/div) * tan(dist*t-stream/2.)*mul*sin(dist+stream/15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 6.52, 0, 10, false, false],
        ["contrast", 0, 0.55, 0, 2, false, false],
        ["orbSize", 0, 0.01, 0.01, 0.1, false, false],
        ["radius", 0, 0.08, 0, 2, false, false],
        ["colorShift", 0, 6.04, 0, 10, false, false],
        ["center", 0, 2.92, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 2.86, 0, 20, false, false],
        ["mul", 0, 5.19, 0, 15, false, false],
        ["div", 0, 7.42, 0, 30, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16a"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * shape;\n    float x = dist * t + radius * (i / div) * tan(dist * t - stream / 2.) * mul * sin(dist + stream / 15.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.37, 0, 10.74, false, false],
        ["contrast", 0, 0.47, 0, 0.94, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.1, 0, 0.2, false, false],
        ["colorShift", 0, 6.04, 0, 12.08, false, false],
        ["center", 0, 2.92, 0, 5.84, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 20, 0, 40, false, false],
        ["mul", 0, 3.41, 0, 6.82, false, false],
        ["div", 0, 9.59, 0, 19.18, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca179"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= rotate(rotateSpeed*stream/12.2-dist/distDiv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t*radius * cos(dist*t-stream/.9195)*shape*sin(dist+stream/.5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.15, 0, 4.3, false, false],
        ["contrast", 0, 0.99, 0, 1.98, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.95, 0, 1.9, false, false],
        ["distDiv", 0, 15.64, 0, 31.28, false, false],
        ["mul", 0, 10.7, 0, 21.4, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false],
        ["center", 0, 2.72, 0, 5.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17b"
    },
    "shader": "\n#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\tuv = abs(uv);\n  uv *= rotate(stream);\n  float dist = length(uv);\n  uv *= rotate(rotateSpeed*stream/12.2-dist/distDiv);\n  uv *= rotate(-stream);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * mul;\n    float x = dist + pow(volume, 6.) * t*radius * cos(dist*t-stream/.29195)*shape+sin(dist+stream/-1.25);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, 6.)*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.26, 0, 10, false, false],
        ["contrast", 0, 0.99, 0, 2, false, false],
        ["orbSize", 0, 0.014, 0.01, 0.02, false, false],
        ["radius", 0, 5, 1, 5, false, false],
        ["colorShift", 0, 8.02, 4, 10, false, false],
        ["sides", 0, 2, 0, 18, false, false],
        ["shape", 0, 0.42, 0, 1, false, false],
        ["distDiv", 0, 19.55, 0, 30, false, false],
        ["mul", 0, 3.12, 0, 12, false, false],
        ["rotateSpeed", 0, 0, 0, 1, false, false],
        ["center", 0, 0.19, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca190"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .12;\n  float b = stream * 1.5;\n  float ot =.1;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 10; i++) {\n    p *= rot;\n    p = (abs(p) * 1.5 - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  ot = max(0., .1 - ot) / .1; //orbit trap \n  if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * 4. + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * .25, color, 2.); // saturation adjustment\n  color *= 1. - pow(l * .1, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. * sin(.01*length(-1. + 2. * gl_FragCoord.xy / resolution.xy)/1.1));\n}",
    "variants": [
      [
        ["zoom", 0, 0.142, 0, 3, false, false],
        ["A", 0, 1, 0, 1, false, false],
        ["B", 0, 3, 0, 3, false, false],
        ["C", 0, 0.6359954038787592, 0, 1, false, false],
        ["D", 0, 0.41622989513690534, 0, 1, false, false],
        ["E", 0, 0.4048123309829358, 0, 1, false, false],
        ["F", 0, 0.5604462168821562, 0, 1, false, false],
        ["G", 0, 0.1933471163590238, 0, 1, false, false],
        ["H", 0, 0.7424808632786761, 0, 1, false, false],
        ["I", 0, 0.8936912598741336, 0, 1, false, false],
        ["J", 0, 3.3570565776680446, 0, 11, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca168"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream / 2.5);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t + stream / 2.69195) * shape * sin(dist + stream / .9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.93, 0, 3.86, false, false],
        ["contrast", 0, 0.79, 0, 1.58, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.1, 0, 0.2, false, false],
        ["colorShift", 0, 4.38, 0, 8.76, false, false],
        ["sides", 0, 11, 0, 22, false, false],
        ["shape", 0, 10.27, 0, 20.54, false, false],
        ["distDiv", 0, 101.37, 0, 202.74, false, false],
        ["mul", 0, 13.8, 0, 27.6, false, false],
        ["center", 0, 0.65, 0, 1.3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18f"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, C);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 4) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 8; i++) {\n    p *= (rot);\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * F) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - D * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, E); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(col-color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/1. - sin(length(-1. + 2. * gl_FragCoord.xy / resolution.xy)/4.));\n}",
    "variants": [
      [
        ["zoom", 0, 0.395, 0.2, 1, false, false],
        ["A", 0, 0.244, 0, 1, false, false],
        ["B", 0, 0.599, 0, 1, false, false],
        ["C", 0, 8, 8, 8, false, false],
        ["D", 0, -0.553, -1, 1, false, false],
        ["E", 0, 0.106, 0, 3, false, false],
        ["F", 0, 9.958, 0, 13, false, false],
        ["G", 0, 0.38, 0, 1, false, false],
        ["H", 0, 0.369, 0, 1, false, false],
        ["I", 0, 15.777, 0, 122, false, false],
        ["J", 0, 1.523, 1, 2.5, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6a"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15c"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 10.) * tan(dist * t - stream / 2.7) * 1. * sin(dist - stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.44, 0, 4.88, false, false],
        ["contrast", 0, 1.24, 0, 2.48, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 6.91, 0, 13.82, false, false],
        ["center", 0, 3.65, 0, 7.3, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["shape", 0, 0.13, 0, 0.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca189"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.234, 0, 2.78, false, false],
        ["orbSize", 0, 2.298, 0, 6, false, false],
        ["radius", 0, 20.95, 0, 41.9, false, false],
        ["colorShift", 0, 5.41, 0, 10.82, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.56, 0, 1.12, false, false],
        ["cosMul", 0, 0.88, 0, 1.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.56, 0, 1.12, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.65, 0, 7.3, false, false],
        ["xDivide", 0, 32.82, 0, 65.64, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca158"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(.15 * stream - dist / rotateDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist * t + radius * (i / 50.) * tan(dist * t - stream / 8.7) * shape * sin(dist + stream / 8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.52, 0, 3.04, false, false],
        ["contrast", 0, 0.75, 0, 1.5, false, false],
        ["orbSize", 0, 0.005, 0, 0.01, false, false],
        ["radius", 0, 2.21, 0, 4.42, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 0.53, 0, 1.06, false, false],
        ["rotateDiv", 0, 1.85, 0, 3.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15b"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);;\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul - shape;\n    float x = t * radius * cos(dist * t + stream / 2.69195) * shape * sin(dist + stream / .9045);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.43, 0, 8.86, false, false],
        ["contrast", 0, 0.87, 0, 1.74, false, false],
        ["orbSize", 0, 0.012, 0, 0.024, false, false],
        ["radius", 0, 0.36, 0, 0.72, false, false],
        ["colorShift", 0, 4.82, 0, 9.64, false, false],
        ["sides", 0, 9, 0, 18, false, false],
        ["shape", 0, 2.82, 0, 5.64, false, false],
        ["distDiv", 0, 111, 0, 222, false, false],
        ["mul", 0, 11, 0, 22, false, false],
        ["center", 0, 2.78, 0, 5.56, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca163"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotateSpeed * stream - dist / distDiv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * mul;\n    float x = t * radius * cos(dist * t - stream / .9195) * shape * sin(dist + stream / .5);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.78, 0, 7.56, false, false],
        ["contrast", 0, 1.26, 0, 2.52, false, false],
        ["orbSize", 0, 0.06, 0, 0.12, false, false],
        ["radius", 0, 1.52, 0, 3.04, false, false],
        ["colorShift", 0, 4.89, 0, 9.78, false, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["shape", 0, 0.95, 0, 1.9, false, false],
        ["distDiv", 0, 15.64, 0, 31.28, false, false],
        ["mul", 0, 10.7, 0, 21.4, false, false],
        ["rotateSpeed", 0, 0.34, 0, 0.68, false, false],
        ["center", 0, 2.72, 0, 5.44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca173"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t*radius *sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist*hue(orb(uv, orbSize, position, color, contrast), stream/2.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.84, 0, 9.68, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 3, 0, 6, false, false],
        ["colorShift", 0, 7.96, 0, 15.92, false, false],
        ["center", 0, 2.46, 0, 4.92, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca178"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(dist), sides);\n  uv *= rotate(0.*15.*stream-(length(uv))/rotateDiv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/iDiv) * tan(dist*t-i*stream/tanSpeed)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.48, 0, 4.96, false, false],
        ["contrast", 0, 1.06, 0, 2.12, false, false],
        ["orbSize", 0, 0.005, 0, 0.01, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 13.19, 0, 26.38, false, false],
        ["rotateDiv", 0, 9.89, 0, 19.78, false, false],
        ["tanSpeed", 0, 66.61, 0, 133.22, false, false],
        ["iDiv", 0, 57.88, 0, 115.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17c"
    },
    "shader": "\n#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t+radius * cos(dist*t-stream/.5)*1.*sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 10, false, false],
        ["contrast", 0, 1.13, 0, 2, false, false],
        ["orbSize", 0, 0.09, 0.01, 0.2, false, false],
        ["radius", 0, 1.45, 1, 15, false, false],
        ["colorShift", 0, 4.5, 4, 10, false, false],
        ["center", 0, 0.94, 0, 5, false, false],
        ["sides", 0, 6, 0, 8, false, false],
        ["shape", 0, 0.36, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18a"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(rotation * stream / 2.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(stream / 10. + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .5 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.07, 0, 0.14, false, false],
        ["contrast", 0, 0.59, 0, 1.18, false, false],
        ["orbSize", 0, 13.88, 0, 27.76, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 8.01, 0, 16.02, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.31, 0, 0.62, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.14, 0, 2.28, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.44, 0, 0.88, false, false],
        ["xSpeed", 0, -1, -2, 0, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.08, 0, 6.16, false, false],
        ["xDivide", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca192"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.5349397590361449, 0, 111, false, false],
        ["contrast", 0, 1.4188433734939763, 0, 9.98, false, false],
        ["ballSize", 0, 0.4361445783132531, 0, 2, false, false],
        ["radius", 0, 9.612144578313256, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca15f"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 10.;\n    float x = t * radius - .7 * atan(dist * t - stream / .5) * 1. * sin(dist + stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.37, 0, 6.74, false, false],
        ["contrast", 0, 1.13, 0, 2.26, false, false],
        ["orbSize", 0, 0.09, 0, 0.18, false, false],
        ["radius", 0, 1.45, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca17d"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(stream/10.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist*t+radius * (i/6.) * cos(dist*t-stream/1.7)*1.*sin(dist+stream/5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.07, 0, 10, false, false],
        ["contrast", 0, 1.03, 0, 2, false, false],
        ["orbSize", 0, 0.03, 0.01, 0.2, false, false],
        ["radius", 0, 1, 1, 2, false, false],
        ["colorShift", 0, 4.5, 4, 10, false, false],
        ["center", 0, 1.58, 0, 5, false, false],
        ["sides", 0, 3, 0, 8, false, false],
        ["shape", 0, 0.13, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca18b"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/1.);\n    float y = radius * cos(t+stream/1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.35, 0, 2.7, false, false],
        ["orbSize", 0, 2.7, 0, 5.4, false, false],
        ["radius", 0, 21.66, 0, 43.32, false, false],
        ["colorShift", 0, 8.85, 0, 17.7, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0.66, 0, 1.32, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.09, 0, 2.18, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.26, 0, 0.52, false, false],
        ["xSpeed", 0, -1, 0, -2, false, false],
        ["ySpeed", 0, 1, 0, 2, false, false],
        ["gloop", 0, 0.0022, 0, 0.0044, false, false],
        ["yDivide", 0, 3.33, 0, 6.66, false, false],
        ["xDivide", 0, 3.33, 0, 6.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca195"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= rotate(0.*15.*stream-(length(uv))/rotateDiv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 3.;\n    float x = dist*t+radius * (i/iDiv) * tan(dist*t-i*stream/tanSpeed)*shape*sin(dist+stream/8.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += hue(orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.7746965361445785, 0, 4.96, false, false],
        ["contrast", 0, 0.9976212349397593, 0, 2.12, false, false],
        ["orbSize", 0, 0.01, 0, 0.01, false, false],
        ["radius", 0, 2, 0, 2, false, false],
        ["colorShift", 0, 5.13, 0, 10.26, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 2, 0, 4, false, false],
        ["shape", 0, 13.19, 0, 26.38, false, false],
        ["rotateDiv", 0, 9.89, 0, 19.78, false, false],
        ["tanSpeed", 0, 66.61, 0, 133.22, false, false],
        ["iDiv", 0, 57.88, 0, 115.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca161"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 20.) * tan(dist * t + stream / 2.7) * 3. * sin(dist - stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, dist * orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.16, 0, 4.32, false, false],
        ["contrast", 0, 1.11, 0, 2.22, false, false],
        ["orbSize", 0, 0.04, 0, 0.08, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 6.91, 0, 13.82, false, false],
        ["center", 0, 1.58, 0, 3.16, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.13, 0, 0.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.735Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca16c"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = dist * t + radius * (i / 6.) * cos(dist * t - stream / 1.7) * 1. * sin(dist + stream / 5.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), 10.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.07, 0, 6.14, false, false],
        ["contrast", 0, 1.03, 0, 2.06, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 1.58, 0, 3.16, false, false],
        ["sides", 0, 3, 0, 6, false, false],
        ["shape", 0, 0.13, 0, 0.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a68"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca193"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n\n  float dist = length(uv);\nuv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/22.);\n  uv -= .06*abs(fract(uv) - .5);\n    float t = stream / 3. + float(i) * PI / float(BALLS) /.5;\n    vec2 p = vec2(volume*radius*sin(t),radius*tan(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 15. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.5349397590361449, 0, 111, false, false],
        ["contrast", 0, 1.4188433734939763, 0, 9.98, false, false],
        ["ballSize", 0, 0.4361445783132531, 0, 2, false, false],
        ["radius", 0, 9.612144578313256, 0, 90.66, false, false],
        ["col", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a3"
    },
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(1.);\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.0;\n    float t = (shape + (i * 2.) * PI / orbs + rotation) + sin(stream / 10.);\n    float x = (radius * tan(t - stream) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * sin(t) - tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_hue(k_orb(uv, orbSize * 3., position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1, 0, 2, false, false],
        ["contrast", 0, 1.46, 0, 2.92, false, false],
        ["orbSize", 0, 0.153, 0, 0.306, false, false],
        ["radius", 0, 1.51, 0, 3.02, false, false],
        ["colorShift", 0, 17.69, 0, 35.38, false, false],
        ["rotation", 0, 188.09, 0, 376.18, false, false],
        ["shape", 0, 94.51, 0, 189.02, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1aa"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);// + .5*sin(1.1*uv.x-stream/5.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);// + cos(.01*uv.y+stream/6.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 93.83, 0, 187.66, false, false],
        ["yDivider", 0, 628.39, 0, 1256.78, false, false],
        ["xDivider", 0, 679.91, 0, 1359.82, false, false],
        ["multiplier", 0, 79.47, 0, 158.94, false, false],
        ["ballSize", 0, 0.09, 0, 0.18, false, false],
        ["contrast", 0, 1.43, 0, 2.86, false, false],
        ["radius", 0, 21.73, 0, 43.46, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c4"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 90.275, 0, 294.9, false, false],
        ["yDivider", 0, 18.646, 0, 49.4, false, false],
        ["xDivider", 0, 9.294, 0, 14.94, false, false],
        ["multiplier", 0, 1.219, 0, 1.73, false, false],
        ["ballSize", 0, 34.82, 0, 69.64, false, false],
        ["contrast", 0, 1.8, 0, 3.6, false, false],
        ["radius", 0, 76.67, 0, 153.34, false, false],
        ["rotation", 0, 14.858, 0, 15.2, false, false],
        ["yDivide", 0, 307.888, 0, 703.66, false, false],
        ["xDivide", 0, 0.408, 0, 0.64, false, false],
        ["yShape", 0, 200, 0, 200, false, false],
        ["shape", 0, 14.966, 0, 33.76, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d5"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/4.) * .09*cos(uv.y/yShape + stream/2.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t);// + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 166.94, 0, 333.88, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 520.47, 0, 1040.94, false, false],
        ["xDivide", 0, 0.56, 0, 1.12, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 24.95, 0, 49.9, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e3"
    },
    "shader": "  #define orbs 15.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(uv);\n    uv *= 1.1*sin(.01*dot(uv, uv) - stream/5.);\n    uv /= abs(fract(uv) - .5); \n    for (float i = 0.; i < orbs; i++) {\n      uv *= rotate(i);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream);\n      float y = radius * cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 6.92, 0, 13.84, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 1, 0, 2, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e4"
    },
    "shader": "  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(sin(uv+stream) + tan(cos(uv-stream) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 7.4, 0, 14.8, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.99, 0, 1.98, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["colorShift", 0, 9.77, 0, 19.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca213"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.005 * sin(uv + stream), cos(shape * uv + stream)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.85, 0, 5.7, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 997.79, 0, 1995.58, false, false],
        ["ballSize", 0, 2.45, 0, 4.9, false, false],
        ["contrast", 0, 1.86, 0, 3.72, false, false],
        ["radius", 0, 66.39, 0, 132.78, false, false],
        ["yOuter", 0, 2, 0, 4, false, false],
        ["xOuter", 0, 2, 0, 4, false, false],
        ["rotation", 0, 13.26, 0, 26.52, false, false],
        ["shape", 0, 1.63, 0, 3.26, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca215"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20. * (uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002 * sin(uv + stream / 5.), 2. * cos(shape * uv + stream / 5.)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 2.69, 0, 5.38, false, false],
        ["contrast", 0, 3.6, 0, 7.2, false, false],
        ["radius", 0, 28.41, 0, 56.82, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22d"
    },
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n // uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 15, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 476.91, 0.1, 1101, false, false],
        ["ballSize", 0, 2.5, 0, 3, false, false],
        ["contrast", 0, 2.63, 0, 5, false, false],
        ["radius", 0, 12.73, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["shape", 0, 0.79, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19d"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * rotate(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.73, 0, 15, false, false],
        ["contrast", 0, 1.36, 1, 5, false, false],
        ["orbSize", 0, 0.51, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 3.21, 1, 5, false, false],
        ["colorShift", 0, 4, 4, 20, false, false],
        ["center", 0, 0, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 5.26, 0, 15, false, false],
        ["contrast", 0, 1.78, 1, 5, false, false],
        ["orbSize", 0, 0.31, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 1, 1, 5, false, false],
        ["colorShift", 0, 12.03, 4, 20, false, false],
        ["center", 0, 2.02, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 6.31, 0, 15, false, false],
        ["contrast", 0, 1, 1, 5, false, false],
        ["orbSize", 0, 0.26, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 3.01, 1, 5, false, false],
        ["colorShift", 0, 12.03, 4, 20, false, false],
        ["center", 0, 1.28, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 2.27, 0, 15, false, false],
        ["contrast", 0, 2.1, 1, 5, false, false],
        ["orbSize", 0, 0.38281263306543034, 0.01, 1.3493301810627194, false, false],
        ["radius", 0, 2.538399385459133, 1, 9.912505208679217, false, false],
        ["colorShift", 0, 16.71, 4, 20, false, false],
        ["center", 0, 1.7565130473989226, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a0"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress);\n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.); // * k_rotate2d(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress);\n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n      uv = glooped;\n    }\n  }\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i - stream / 500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 100.);\n    float y = radius * cos(t - stream / 100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.73, 0, 9.46, false, false],
        ["contrast", 0, 1.36, 0, 2.72, false, false],
        ["orbSize", 0, 0.51, 0, 1.02, false, false],
        ["radius", 0, 3.21, 0, 6.42, false, false],
        ["colorShift", 0, 4, 0, 8, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 9.36, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0.001, 0, 0.002, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b3"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .005 * dot(uv + 1. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 10.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.012, false, false],
        ["contrast", 0, 0.12, 0, 0.24, false, false],
        ["orbSize", 0, 17.09, 0, 34.18, false, false],
        ["radius", 0, 10.09, 0, 20.18, false, false],
        ["colorShift", 0, 7.95, 0, 15.9, false, false],
        ["sides", 0, 12, 0, 24, false, false],
        ["rotation", 0, 0.6, 0, 1.2, false, false],
        ["sinMul", 0, 4, 0, 8, false, false],
        ["cosMul", 0, 3.16, 0, 6.32, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.57, 0, 1.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b9"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n//  uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.005*dot(uv + 1.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/10.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.01, false, false],
        ["contrast", 0, 0.12, 0, 1, false, false],
        ["orbSize", 0, 17.09, 0.01, 111, false, false],
        ["radius", 0, 10.09, 0, 111, false, false],
        ["colorShift", 0, 7.95, 4, 22, false, false],
        ["sides", 0, 12, 0, 12, false, false],
        ["rotation", 0, 0.6, -2, 2, false, false],
        ["sinMul", 0, 4, 0, 4, false, false],
        ["cosMul", 0, 3.16, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 11, 0, 11, false, false],
        ["xDivide", 0, 15, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.57, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c2"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x); //-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream) * cosMul * cos(uv.x / yShape + stream / 3.) * cosMul * sin(stream / 10.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t) + stream / 100.;\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, 6.) * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 363.69, 0, 727.38, false, false],
        ["yDivider", 0, 665.49, 0, 1330.98, false, false],
        ["xDivider", 0, 9.32, 0, 18.64, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 55.94, 0, 111.88, false, false],
        ["contrast", 0, 3.57, 0, 7.14, false, false],
        ["radius", 0, 26.89, 0, 53.78, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["yDivide", 0, 1000, 0, 2000, false, false],
        ["xDivide", 0, 0.05, 0, 0.1, false, false],
        ["yShape", 0, 16.92, 0, 33.84, false, false],
        ["shape", 0, 14.28, 0, 28.56, false, false],
        ["cosMul", 0, 0.21, 0, 0.42, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c8"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = tan(t - stream / 42.); // + stream/100.);\n    float y = sin(t / multiplier + stream / 7.); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 500, 0, 1000, false, false],
        ["yDivider", 0, 177.2, 0, 354.4, false, false],
        ["xDivider", 0, 70.49, 0, 140.98, false, false],
        ["multiplier", 0, 2.0479, 0, 4.0958, false, false],
        ["ballSize", 0, 78.79, 0, 157.58, false, false],
        ["contrast", 0, 2.18, 0, 4.36, false, false],
        ["radius", 0, 35.96, 0, 71.92, false, false],
        ["rotation", 0, 55.39, 0, 110.78, false, false],
        ["yDivide", 0, 401.76, 0, 803.52, false, false],
        ["xDivide", 0, 0.57, 0, 1.14, false, false],
        ["yShape", 0, 69.29, 0, 138.58, false, false],
        ["shape", 0, 100, 0, 200, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d4"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= rotate2d(stream/10.);\n  vec2 _dotted = uv * sin(.0001*dot(uv, uv) - stream/10.);\n  if (dottedTween) {\n    \n  }\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/2.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/5.) * .4229*cos(uv.y/yShape + stream/1.5);\n    float t = 1.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/90.;\n    float x = -1.*tan(t-stream/10.);// + stream/100.);\n    float y = sin(t*multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02*float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 92.31, 0, 184.62, false, false],
        ["yDivider", 0, 2.02, 0, 4.04, false, false],
        ["xDivider", 0, 19.77, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 26.35, 0, 52.7, false, false],
        ["contrast", 0, 3.19, 0, 6.38, false, false],
        ["radius", 0, 25.88, 0, 51.76, false, false],
        ["rotation", 0, 89.48, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 1.49, 0, 2.98, false, false],
        ["yShape", 0, 14.73, 0, 29.46, false, false],
        ["shape", 0, 71.08, 0, 142.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f3"
    },
    "shader": "#define BALLS 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv.x += sin(stream / 4.) * 11.1 * sin(stream) + uv.y / .2 + 20. * sin(uv.x * x1 - stream / 1.);\n  uv.y *= .1 * cos(stream) + (uv.y / .2 + 11. * sin(x2 * uv.x - stream));\n  uv.x += .1 * sin(.1 * uv.y);\n  uv.y += .1 * cos(.1 * uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.35, 0, 26.7, false, false],
        ["contrast", 0, 0.48, 0, 0.96, false, false],
        ["ballSize", 0, 607.64, 0, 1215.28, false, false],
        ["x1", 0, 0.41, 0, 0.82, false, false],
        ["x2", 0, 0, 0, 0, false, false],
        ["ballMul", 0, 35.51, 0, 71.02, false, false],
        ["xMul", 0, 110, 0, 220, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca201"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(atan(dist/uv.x+stream))*uv.x+radius*sin(t+xMultiplier), radius*sin(dist*yOuter*uv.x/.5+t+yMultiplier+3.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.46, 0, 1, false, false],
        ["ballSize", 0, 0.004, 0, 0.01, false, false],
        ["contrast", 0, 4.47, 0, 15, false, false],
        ["radius", 0, 0.12, 0, 5, false, false],
        ["yOuter", 0, 29.89, 0, 100, false, false],
        ["xOuter", 0, 0.88, 0, 24, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.82, 0, 10, false, false],
        ["yMultiplier", 0, 0, 0, 10, false, false],
        ["divider", 0, 1, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21f"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n // uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 7.66, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 2.5, 0, 5, false, false],
        ["contrast", 0, 2.63, 0, 5.26, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca223"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.41, 0, 6.82, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 1.15, 0, 2.3, false, false],
        ["contrast", 0, 3, 0, 6, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23f"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50. * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream / 52.;\n    vec2 p = vec2(xOuter * uv.y * 2.1 / uv.x * 3. + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.24, 0, 0.48, false, false],
        ["ballSize", 0, 1111, 0, 2222, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["radius", 0, 224.63, 0, 449.26, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 39.66, 0, 79.32, false, false],
        ["yMultiplier", 0, 41.44, 0, 82.88, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca240"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 30.)) * (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50000.;\n    float x = xOuter * (tan(.01 * uv.x * -20. - stream)) * uv.y + radius * cos(t + xMultiplier + stream / 1.) * 100. / cos(.1 * uv.y + tan(stream / 50. + uv.x / 10.) - stream / 50.);\n    float y = radius * cos((.01 * cos(.001 * uv.y + uv.x) / t + yMultiplier) + stream / 30.);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.06, 0, 6.12, false, false],
        ["ballSize", 0, 1111, 0, 2222, false, false],
        ["contrast", 0, 10.27, 0, 20.54, false, false],
        ["radius", 0, 81.48, 0, 162.96, false, false],
        ["yOuter", 0, 114.28, 0, 228.56, false, false],
        ["xOuter", 0, 1320.01, 0, 2640.02, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 10.34, 0, 20.68, false, false],
        ["yMultiplier", 0, 39.83, 0, 79.66, false, false],
        ["divider", 0, 10, 0, 20, false, false],
        ["rotation", 0, 0.0066, 0, 0.0132, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19a"
    },
    "shader": "#define orbs 10.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream) + 2. * sin(t - stream / 2.);\n    float y = radius * cos(t + stream) + 2. * cos(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream) + 1. * tan(t - stream / 2.);\n    float y = radius * cos(t + stream) + 1. * cos(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_orb(uv, orbSize * .5, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.48, 0, 8.96, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.43, 0, 0.86, false, false],
        ["radius", 0, 1.03, 0, 2.06, false, false],
        ["colorShift", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a6"
    },
    "shader": "#define BALLS 20\n\n\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * 2. * PI / float(BALLS);\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(color * PI * (float(i) / PI)); //* 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 0.84, false, false],
        ["ballSize", 0, 0.004, 0, 0.008, false, false],
        ["contrast", 0, 0.39, 0, 0.78, false, false],
        ["radius", 0, 0.1, 0, 0.2, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b1"
    },
    "shader": "\n#define BALLS 30\n  \nmat2 rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius*tan(t * multiplier + stream);\n    float y = radius*sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.11, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 352.09, 0.1, 1101, false, false],
        ["ballSize", 0, 0.05, 0, 0.2, false, false],
        ["contrast", 0, 2.73, 0, 5, false, false],
        ["radius", 0, 1, 0, 1, false, false],
        ["yOuter", 0, 1.16, 0, 2, false, false],
        ["xOuter", 0, 0.91, 0, 2, false, false],
        ["rotation", 0, 0.07, 0, 1, false, false],
        ["shape", 0, 1.54, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b6"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.16, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 6.32, 0, 12.64, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1bb"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n//  uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 5.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.13, 0, 0.5, false, false],
        ["contrast", 0, 0.14, 0, 1, false, false],
        ["orbSize", 0, 1.88, 0.01, 111, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 12.27, 4, 22, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 11, 0, 11, false, false],
        ["xDivide", 0, 15, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.56, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d6"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/4.) * .09*cos(uv.y/yShape + stream/2.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t);// + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 166.94, 0, 500, false, false],
        ["yDivider", 0, 885.36, 0.1, 1191, false, false],
        ["xDivider", 0, 74.88, 0.1, 1001, false, false],
        ["multiplier", 0, 3.5795, 0.01, 5, false, false],
        ["ballSize", 0, 27.44, 0, 112, false, false],
        ["contrast", 0, 1.88, 0, 5, false, false],
        ["radius", 0, 27.16, 0, 115, false, false],
        ["rotation", 0, 2.6, 0, 11, false, false],
        ["yDivide", 0, 520.47, 0, 1000, false, false],
        ["xDivide", 0, 0.56, 0, 10, false, false],
        ["yShape", 0, 100, 0, 100, false, false],
        ["shape", 0, 24.95, 0, 100, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f6"
    },
    "shader": "#define orbs 25.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 5.*uv.x+radius * tan(t+stream);\n    float y = .1*sin(uv.y/.01) * uv.x*sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["contrast", 0, 1.73, 0, 3.46, false, false],
        ["orbSize", 0, 0.24, 0, 0.48, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["colorShift", 0, 6.37, 0, 12.74, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f8"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*tan(t*xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t*yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.3, 0, 4.6, false, false],
        ["ballSize", 0, 0.076, 0, 0.152, false, false],
        ["contrast", 0, 4.36, 0, 8.72, false, false],
        ["radius", 0, 1.44, 0, 2.88, false, false],
        ["yOuter", 0, 0.71, 0, 1.42, false, false],
        ["xOuter", 0, 4.15, 0, 8.3, false, false],
        ["rotation", 0, 0.46, 0, 0.92, false, false],
        ["shape", 0, 5.17, 0, 10.34, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.38, 0, 4.76, false, false],
        ["yMultiplier", 0, 4.84, 0, 9.68, false, false],
        ["divider", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1fe"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*cos(t+xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t+yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.27, 0, 1, false, false],
        ["ballSize", 0, 0.021, 0, 0.1, false, false],
        ["contrast", 0, 3.98, 0, 15, false, false],
        ["radius", 0, 0.97, 0, 5, false, false],
        ["yOuter", 0, 1.98, 0, 20, false, false],
        ["xOuter", 0, 20, 0, 20, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.39, 0, 10, false, false],
        ["yMultiplier", 0, 3.46, 0, 10, false, false],
        ["divider", 0, 2, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca209"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.602, 0, 0.7, false, false],
        ["radius", 0, 1.82, 0, 3.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 7.68, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 2.982958668830698, 0, 5.965917337661396, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ],
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 1.535, 0, 22, false, false],
        ["radius", 0, 5.629, 0, 113.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 5.341, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 1.211, 0, 5.965917337661396, false, false],
        ["yDot", 0, 0.554, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 6.332, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21b"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * sin(uv) + stream / .5)) * 20.1 * tan(uv + stream);\n  uv *= k_rotate2d(rotation * stream / .8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 1.) / 1. * sin(uv.x / 1. - stream / 1.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 1.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier + stream / 5.), 2. * radius * sin(t * multiplier - stream / 5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.56, 0, 5.12, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 0.1, 0, 0.2, false, false],
        ["ballSize", 0, 3.68, 0, 7.36, false, false],
        ["contrast", 0, 2.09, 0, 4.18, false, false],
        ["radius", 0, 32.48, 0, 64.96, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0.55, 0, 1.1, false, false],
        ["shape", 0, 5.39, 0, 10.78, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca226"
    },
    "shader": "\n#define BALLS 20\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.01, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 352.09, 0.1, 1101, false, false],
        ["ballSize", 0, 4.53, 0, 21, false, false],
        ["contrast", 0, 4.42, 0, 5, false, false],
        ["radius", 0, 40.55, 0, 111, false, false],
        ["yOuter", 0, 1.16, 0, 2, false, false],
        ["xOuter", 0, 0.91, 0, 2, false, false],
        ["rotation", 0, 0.07, 0, 1, false, false],
        ["shape", 0, 1.54, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca233"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(20.1 * (.001 * dot(uv, uv)));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.001 * length(uv) - rotation * (dist) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -50.;\n    vec2 p = vec2(xOuter * (atan(uv.x)) * 5. * uv.x + radius * tan(t + xMultiplier) * 5. * cos(uv.x + sin(uv.y / 100. - stream / -50. - dist / 10.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 43.33, 0, 86.66, false, false],
        ["ballSize", 0, 503.852, 0, 1007.704, false, false],
        ["contrast", 0, 5.07, 0, 10.14, false, false],
        ["radius", 0, 1051.65, 0, 2103.3, false, false],
        ["yOuter", 0, 401.47, 0, 802.94, false, false],
        ["xOuter", 0, 347.95, 0, 695.9, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 10111, 0, 20222, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, -0.02, -0.04, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca242"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*3.1+radius*cos(t+xMultiplier+stream/1.) * 20./cos(uv.x + sin(uv.y/100.)), radius*cos(.1/dist*yOuter*uv.x/.5+t+yMultiplier+2.*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.3, 0, 2.6, false, false],
        ["ballSize", 0, 696.957, 0, 1393.914, false, false],
        ["contrast", 0, 9.7, 0, 19.4, false, false],
        ["radius", 0, 21.61, 0, 43.22, false, false],
        ["yOuter", 0, 21.57, 0, 43.14, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 9.99, 0, 19.98, false, false],
        ["yMultiplier", 0, 36.27, 0, 72.54, false, false],
        ["divider", 0, 2, 0, 4, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a4"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * uv.y + radius * cos(t + xMultiplier + stream), radius * sin(yOuter * uv.x / .1 + t + yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.27, 0, 0.54, false, false],
        ["ballSize", 0, 0.021, 0, 0.042, false, false],
        ["contrast", 0, 3.98, 0, 7.96, false, false],
        ["radius", 0, 0.97, 0, 1.94, false, false],
        ["yOuter", 0, 1.98, 0, 3.96, false, false],
        ["xOuter", 0, 20, 0, 40, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.39, 0, 12.78, false, false],
        ["yMultiplier", 0, 3.46, 0, 6.92, false, false],
        ["divider", 0, 2, 0, 4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ac"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * rotate(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.73, 0, 9.46, false, false],
        ["contrast", 0, 1.36, 0, 2.72, false, false],
        ["orbSize", 0, 0.51, 0, 1.02, false, false],
        ["radius", 0, 3.21, 0, 6.42, false, false],
        ["colorShift", 0, 4, 0, 8, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 9.36, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0.001, 0, 0.002, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b4"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //  uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .05 * dot(uv + 5. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.13, 0, 0.26, false, false],
        ["contrast", 0, 0.14, 0, 0.28, false, false],
        ["orbSize", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 12.27, 0, 24.54, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.56, 0, 1.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b8"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n//  uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 5.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.13, 0, 0.26, false, false],
        ["contrast", 0, 0.14, 0, 0.28, false, false],
        ["orbSize", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 12.27, 0, 24.54, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.56, 0, 1.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1bc"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv = abs(uv);\n\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), mirrorTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist * .05 * dot(uv + 20. * cos(uv - stream / 3.), uv + cos(uv - stream)) + stream / 5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65 - k_orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.16, false, false],
        ["contrast", 0, 0.13, 0, 0.26, false, false],
        ["orbSize", 0, 6.32, 0, 12.64, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["colorShift", 0, 10.32, 0, 20.64, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 0, false, false],
        ["cosMul", 0, 1.28, 0, 2.56, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c9"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00003 * dot(uv, uv) - stream / 20.);\n  //uv *= k_rotate2d(stream/50.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 116.02, 0, 232.04, false, false],
        ["yDivider", 0, 24.7, 0, 49.4, false, false],
        ["xDivider", 0, 7.47, 0, 14.94, false, false],
        ["multiplier", 0, 2.9612, 0, 5.9224, false, false],
        ["ballSize", 0, 20, 0, 40, false, false],
        ["contrast", 0, 2.01, 0, 4.02, false, false],
        ["radius", 0, 40.23, 0, 80.46, false, false],
        ["rotation", 0, 2.22, 0, 4.44, false, false],
        ["yDivide", 0, 555, 0, 1110, false, false],
        ["xDivide", 0, 0.99, 0, 1.98, false, false],
        ["yShape", 0, 6.54, 0, 13.08, false, false],
        ["shape", 0, 24.37, 0, 48.74, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d9"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/30.);\n  uv *= rotate2d(stream/120.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/6.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/5.) * .251*cos(uv.y/yShape + stream/12.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/1000.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/10.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 349.41, 0, 698.82, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 520.47, 0, 1040.94, false, false],
        ["xDivide", 0, 0.56, 0, 1.12, false, false],
        ["yShape", 0, 51.31, 0, 102.62, false, false],
        ["shape", 0, 62.39, 0, 124.78, false, false]
      ],
      [
        ["zoom", 0, 125.177, 0, 698.82, false, false],
        ["yDivider", 0, 1.109, 0, 170.72, false, false],
        ["xDivider", 0, 6.08, 0, 149.76, false, false],
        ["multiplier", 0, 5.96, 0, 7.159, false, false],
        ["ballSize", 0, 6.972, 0, 54.88, false, false],
        ["contrast", 0, 1.763, 0, 3.76, false, false],
        ["radius", 0, 17.255, 0, 54.32, false, false],
        ["rotation", 0, 1.789, 0, 5.2, false, false],
        ["yDivide", 0, 367.524, 0, 1040.94, false, false],
        ["xDivide", 0, 2.36, 0, 8, false, false],
        ["yShape", 0, 1.929, 0, 102.62, false, false],
        ["shape", 0, 24.409, 0, 124.78, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1da"
    },
    "shader": "#define orbs 5.\n\nvoid main() {\n  float stream = stream / 30.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream / 2.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 10.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 1.);\n    float y = radius * cos(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  gl_FragColor.b -= -.2;\n}",
    "variants": [
      [
        ["zoom", 0, 7.452, 0, 82, false, false],
        ["contrast", 0, 2.93, 0, 5.86, false, false],
        ["orbSize", 0, 2.953, 0, 16, false, false],
        ["radius", 0, 6.786, 0, 42.26, false, false],
        ["colorShift", 0, 0.0573, 0.05, 0.07, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca203"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.602, 0, 0.7, false, false],
        ["radius", 0, 1.82, 0, 3.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 7.68, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 2.982958668830698, 0, 5.965917337661396, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ],
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 1.535, 0, 22, false, false],
        ["radius", 0, 5.629, 0, 113.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 5.341, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 1.211, 0, 5.965917337661396, false, false],
        ["yDot", 0, 0.554, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 6.332, 0, 33, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21d"
    },
    "shader": "#define BALLS 20\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.01, 0, 6.02, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 4.53, 0, 9.06, false, false],
        ["contrast", 0, 4.42, 0, 8.84, false, false],
        ["radius", 0, 40.55, 0, 81.1, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19c"
    },
    "shader": "/**\n * Defining some constants. \n * You can't power for loops using uniform variables, hence the `orbs` definition.\n */\n#define orbs 99.\n\n/** \n * Stolen utility function. Warps domain space (ask me what that is) into a kaleidoscope.\n * To make a six-sided kaleidoscope with zero center offset:\n *\n * uv = k_kale(uv, vec2(0.), 6.); \n */\n\n\n/**\n * Stolen utility function... looped hue shifting. Shifts all colors by hue simultaneously. \n * \n * gl_FragColor = k_hue(gl_FragColor, stream);\n */\n\n/*\n * Stolen from neon balls sketch creates a glowing orb. To create a red orb at the center of the screen:\n *\n * gl_FragColor += k_orb(uv, .1, vec2(0., 0.), vec3(1., 0., 0.), 1.);\n */\n/*\n * Rotate the plane (2D).\n *\n * uv *= k_rotate2d(stream);\n */\n/*\n * Main shader function. Decides the color of a single pixel, given the position on the screen.\n */\nvoid main() {\n  // The x/y position on the screen, normalized so that 0,0 is in the center of the viewport, which is from -1 to 1.\n  // vUv is specific to three.js don't worry about it.\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n\n  // This adjusts the domain per the aspect ratio of the screen.\n  uv.x *= resolution.x / resolution.y;\n\n  // Adjust zoom level simply by assigning uv to itself multiplied by any float.\n  uv *= zoom;\n  uv *= k_rotate2d(stream);\n\n  // The distance between the current pixel and the center of the screen.\n  float dist = length(uv);\n\n  // Uncomment the next line to warp domain space into a kaleidoscope.\n  // Try creating a uniform called \"sides\" instead of hard coding the 6. Same for the center offset (0.).\n  //uv = k_kale(uv, vec2(center), sides);\n\n  // I have no idea what a dot product is, but it can do nifty things. Uncomment at will.\n  uv *= atan(dot(uv, uv) - stream);\n  uv /= dot(uv, uv);\n\n  // Create our orbs!\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * -1. * tan(t + stream); // Try `cos` and `tan`. Or comment out and use the next line.\n    //float x = radius * sin(t + stream) * tan(uv.y - stream);\n    float y = radius * tan(t * stream);\n    vec2 position = vec2(x, y);\n    uv *= k_rotate2d(i * 100.);\n\n    // Stolen from the neon balls sketch on ShaderToy. No fucking idea, but we have a rainbow.\n    vec3 color = cos(vec3(-1, 8, 1) * PI * 2. / 8. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n\n    // We're *adding* to gl_FragColor, iteratively, for each orb.\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.149, 0, 2.298, false, false],
        ["contrast", 0, 1.724, 0, 3.448, false, false],
        ["orbSize", 0, 0.131, 0, 0.262, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 10.345, 0, 20.69, false, false],
        ["sides", 0, 0, 0, 0, false, false],
        ["center", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca234"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(20.1 * (.001 * dot(uv, uv)));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(.001 * length(uv) - rotation * (dist) + stream / 5. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / -50.;\n    vec2 p = vec2(xOuter * (atan(uv.x)) * 20. * uv.x + radius * tan(t + xMultiplier) * 10. * cos(uv.x + sin(uv.y / 100. + stream)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 13. + float(i * 2) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 45.14, 0, 90.28, false, false],
        ["ballSize", 0, 447.327, 0, 894.654, false, false],
        ["contrast", 0, 5.07, 0, 10.14, false, false],
        ["radius", 0, 353.04, 0, 706.08, false, false],
        ["yOuter", 0, 401.47, 0, 802.94, false, false],
        ["xOuter", 0, 112.32, 0, 224.64, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 0, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, -0.02, -0.04, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23e"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 10.)) * (dist / .5) + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider + stream / 50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.33, 0, 0.66, false, false],
        ["ballSize", 0, 1111, 0, 2222, false, false],
        ["contrast", 0, 4.78, 0, 9.56, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 1000, 0, 2000, false, false],
        ["xOuter", 0, 226.31, 0, 452.62, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.43, 0, 2.86, false, false],
        ["yMultiplier", 0, 32.67, 0, 65.34, false, false],
        ["divider", 0, 10, 0, 20, false, false],
        ["rotation", 0, -0.0024, -0.0048, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca253"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize((uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 25.38, 0, 30, false, false],
        ["yDivider", 0, 27.34, 0.1, 1000, false, false],
        ["xDivider", 0, 10.17, 0.1, 1000, false, false],
        ["multiplier", 0, 287.12, 0.1, 1101, false, false],
        ["ballSize", 0, 1.72, 0, 2, false, false],
        ["contrast", 0, 1.41, 0, 5, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["yOuter", 0, 0.3, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca199"
    },
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i / 50.);\n    uv *= 1.05;\n    float t = ((.1 * shape) + i * PI / orbs + rotation) * sin(stream / 10.);\n    float x = (radius * cos(t - stream / 10.) * sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * sin(t); // - tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = _uv * k_rotate2d(stream / 1.);\n  uv = k_kale(uv, vec2(1.2), 1.);\n\n  uv *= .2;\n  uv *= abs(dot(uv, uv));\n  uv *= k_rotate2d(dist);\n\n  for (float i = 0.; i < 20. / 4.; i++) {\n    uv = abs(uv);\n    float radius = .15;\n    float t = i * PI / orbs + sin(rotation * stream / 1.);\n    float x = (radius * sin(t - stream / 200.) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.3, 0, 10.6, false, false],
        ["contrast", 0, 1.59, 0, 3.18, false, false],
        ["orbSize", 0, 0.032, 0, 0.064, false, false],
        ["radius", 0, 2, 0, 4, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["rotation", 0, 22, 0, 44, false, false],
        ["shape", 0, 16.75, 0, 33.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19b"
    },
    "shader": "\n#define BALLS 5.\n \n\n\n\n\n\n}\n\nvoid main () {\n  float stream = stream  /2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv *= sin(11./length(uv)*.001*dot(outer2*sin(uv) + uv, uv)-stream/1.5);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation*sin(PI*rotation*dist/9.+stream/29.*dist/100000.));\n    float t = float(i) * PI / BALLS / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(float(i)*dist-1.01*uv.x+sin(PI*1.)))*uv.x/dist*PI+radius*sin(t) * 405.01*cos(uv.x + sin(uv.y/1.1)), radius*cos(dist+yOuter*uv.x/12.5+t+yMultiplier));\n    vec3 col = cos(sin(uv.y/20.-stream)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.  / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 41.69, 0, 144, false, false],
        ["ballSize", 0, 8.197, 0, 22, false, false],
        ["contrast", 0, 2.15, 0, 15, false, false],
        ["radius", 0, 4, 1, 4, false, false],
        ["yOuter", 0, 10, 0, 10, false, false],
        ["xOuter", 0, 1.84, 1, 241, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.68, 0, 10, false, false],
        ["yMultiplier", 0, 0.62, 0, 10, false, false],
        ["divider", 0, 28, 0, 1000, false, false],
        ["rotation", 0, 0.0591, 0, 0.2, false, false],
        ["outer2", 0, 0.765, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c0"
    },
    "shader": "\n#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= rotate(stream/15.);\n  uv = kale(uv, vec2(dist), sides);\n  for (float i = 1.; i < orbs; i++) {\n    uv *= rotate(i*tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t*radius *sin(shape*dist+stream);\n    float y = i/80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist*hue(orb(uv, orbSize, position, color, contrast), stream/2.);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.92, 0, 8, false, false],
        ["contrast", 0, 0.94, 0, 2, false, false],
        ["orbSize", 0, 0.03, 0.01, 0.21, false, false],
        ["radius", 0, 3.55, 1, 15, false, false],
        ["colorShift", 0, 4.02, 4, 10, false, false],
        ["center", 0, 0, 0, 5, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["shape", 0, 3.92, 0, 10, false, false],
        ["shape2", 0, 1.42, 0, 30, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c3"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001 * dot(uv, uv) - stream / 52.);\n\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 200. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 30. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 234.54, 0, 469.08, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.4155, 0, 6.831, false, false],
        ["ballSize", 0, 27.72, 0, 55.44, false, false],
        ["contrast", 0, 2.17, 0, 4.34, false, false],
        ["radius", 0, 44.22, 0, 88.44, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 943.61, 0, 1887.22, false, false],
        ["xDivide", 0, 1.57, 0, 3.14, false, false],
        ["yShape", 0, 61.01, 0, 122.02, false, false],
        ["shape", 0, 24.77, 0, 49.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ca"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / -2.);\n  uv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 2.) * .229 * cos(uv.y / yShape + stream / 2.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.02, 0, 0.04, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 33.47, 0, 66.94, false, false],
        ["contrast", 0, 4.16, 0, 8.32, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 496.23, 0, 992.46, false, false],
        ["xDivide", 0, 0.2, 0, 0.4, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 100, 0, 200, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1cc"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 8000.);\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 814.87, 0, 1629.74, false, false],
        ["yDivider", 0, 174.84, 0, 349.68, false, false],
        ["xDivider", 0, 99.1, 0, 198.2, false, false],
        ["multiplier", 0, 0.5526, 0, 1.1052, false, false],
        ["ballSize", 0, 56.73, 0, 113.46, false, false],
        ["contrast", 0, 1.85, 0, 3.7, false, false],
        ["radius", 0, 30.56, 0, 61.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d8"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/20.);\n  uv *= rotate2d(stream/120.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/14.) * .251*cos(uv.y/yShape + stream/6.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/1000.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/10.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 349.41, 0, 698.82, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 520.47, 0, 1040.94, false, false],
        ["xDivide", 0, 0.56, 0, 1.12, false, false],
        ["yShape", 0, 51.31, 0, 102.62, false, false],
        ["shape", 0, 62.39, 0, 124.78, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f0"
    },
    "shader": "#define BALLS 40.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  //  uv = abs(uv);\n  uv.x += outerX * sin(stream) + uv.y / .2 + loops * sin(uv.x * x1 - stream / 1.);\n  uv.y *= outerY * cos(stream) + (uv.y / .2 + loopSize * sin(x2 * uv.x - stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.) * ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 34.87, 0, 69.74, false, false],
        ["contrast", 0, 2.57, 0, 5.14, false, false],
        ["ballSize", 0, 38.45, 0, 76.9, false, false],
        ["x1", 0, 0.14, 0, 0.28, false, false],
        ["x0", 0, 0, 0, 0, false, false],
        ["y0", 0, 0.85, 0, 1.7, false, false],
        ["ballMul", 0, 9.04, 0, 18.08, false, false],
        ["xMul", 0, 100.56, 0, 201.12, false, false],
        ["yMul", 0, 1.68, 0, 3.36, false, false],
        ["wave1", 0, 44.32, 0, 88.64, false, false],
        ["wave2", 0, 1.62, 0, 3.24, false, false],
        ["loops", 0, 67.96, 0, 135.92, false, false],
        ["outerX", 0, 19.6, 0, 39.2, false, false],
        ["outerY", 0, 33.32, 0, 66.64, false, false],
        ["loopSize", 0, 0, 0, 0, false, false],
        ["x2", 0, 64.85, 0, 129.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f2"
    },
    "shader": "#define BALLS 25\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  vec2 _uv = uv;\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / 1.;\n    vec2 p = length(uv) * outer * vec2(uv.x / uv.y * xMul * uv.y + radius * tan(t * xMultiplier - stream), radius * sin(yMul * uv.x + t * yMultiplier + stream / .2));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.36, 0, 0.72, false, false],
        ["ballSize", 0, 0.009, 0, 0.018, false, false],
        ["contrast", 0, 4.57, 0, 9.14, false, false],
        ["radius", 0, 0.38, 0, 0.76, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 5.15, 0, 10.3, false, false],
        ["yMultiplier", 0, 10, 0, 20, false, false],
        ["xMul", 0, 2.3, 0, 4.6, false, false],
        ["yMul", 0, 20.73, 0, 41.46, false, false],
        ["outer", 0, 0.85, 0, 1.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f7"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n\tuv = abs(uv);\n  float dist = length(uv);\n  uv *= sin(uv.x/10.)+rotate2d(dist/10.-stream/20.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += .162*float(i)*cos(uv.y/yDivider - stream/111.) + sin(uv.x/21. - stream/112.);\n    uv.x += .52*float(i)*cos(uv.y/xDivider)+sin(uv.x/xDivider - stream/111.) - sin(uv.y/210. + stream/112.);\n    float t = .005*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/100.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 4105. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-5+i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.r *= .5;\n}",
    "variants": [
      [
        ["zoom", 0, 22.43, 0, 44.86, false, false],
        ["yDivider", 0, 408.69, 0, 817.38, false, false],
        ["xDivider", 0, 574.25, 0, 1148.5, false, false],
        ["multiplier", 0, 4.47, 0, 8.94, false, false],
        ["ballSize", 0, 0.84, 0, 1.68, false, false],
        ["contrast", 0, 3, 0, 6, false, false],
        ["radius", 0, 23.44, 0, 46.88, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20d"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(uv, vec2(1.), 8.);\n  uv *= 5.15 * sin(.01 * dot(uv, uv) - stream);\n  uv.x = dist * abs(fract(uv.y) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i + stream / 10.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8, 0, 16, false, false],
        ["contrast", 0, 2.1, 0, 4.2, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 4.88, 0, 9.76, false, false],
        ["colorShift", 0, 8.7, 0, 17.4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca211"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 501, 0, 501, false, false],
        ["yDivider", 0, 1, 0.1, 1, false, false],
        ["xDivider", 0, 111, 0.1, 111, false, false],
        ["multiplier", 0, 111, 0.1, 111, false, false],
        ["ballSize", 0, 1.69, 0, 2, false, false],
        ["contrast", 0, 1.66, 0, 5, false, false],
        ["radius", 0, 26.57, 0, 111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca218"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), cos(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.58, 0, 3.16, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 0.93, 0, 1.86, false, false],
        ["contrast", 0, 2.85, 0, 5.7, false, false],
        ["radius", 0, 11.78, 0, 23.56, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.92, 0, 1.84, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca222"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 7.66, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 2.5, 0, 5, false, false],
        ["contrast", 0, 2.63, 0, 5.26, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca225"
    },
    "shader": "#define BALLS 5mat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  vec2 uv2 = uv * zoom/5.;\n  vec2 uv3 = uv * zoom/30.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .1*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/1.);\n  uv *= rotate2d(rotation * (dist - stream/2.));\n  float _grid = (cos(uv.x/.5 * xMultiplier - stream/1.) - sin(uv.y * yMultiplier + stream/150.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    p += log(abs(sin(stream/3. + float(i) * PI)));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.26, 0, 4.52, false, false],
        ["shapeMultiplier", 0, 13.4, 0, 26.8, false, false],
        ["rotation", 0, 0.53, 0, 1.06, false, false],
        ["xMultiplier", 0, 6.77, 0, 13.54, false, false],
        ["yMultiplier", 0, 16.44, 0, 32.88, false, false],
        ["colorSpread", 0, 67.44, 0, 134.88, false, false],
        ["colorMultiplier", 0, 0.12, 0, 0.24, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 39.9, 0, 79.8, false, false],
        ["ballSize", 0, 0.01, 0, 0.02, false, false],
        ["glow", 0, 2.9, 0, 5.8, false, false],
        ["contrast", 0, 3.07, 0, 6.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca24d"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*length(uv)/((stream/20.))/(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 4.87, 0, 11, false, false],
        ["ballSize", 0, 194.683, 0, 1111, false, false],
        ["contrast", 0, 3.34, 0, 15, false, false],
        ["radius", 0, 105.97, 0, 1115, false, false],
        ["yOuter", 0, 457.26, 0, 1000, false, false],
        ["xOuter", 0, 1392.53, 1, 2401, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 8.32, 0, 101, false, false],
        ["yMultiplier", 0, 12.9, 0, 101, false, false],
        ["divider", 0, 8, 0, 10, false, false],
        ["rotation", 0, 0.0049, 0, 0.02, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },

  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1af"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * rotate(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.73, 0, 15, false, false],
        ["contrast", 0, 1.36, 1, 5, false, false],
        ["orbSize", 0, 0.51, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 3.21, 1, 5, false, false],
        ["colorShift", 0, 4, 4, 20, false, false],
        ["center", 0, 0, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1cd"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 10000.);\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 518.74, 0, 1037.48, false, false],
        ["yDivider", 0, 509.34, 0, 1018.68, false, false],
        ["xDivider", 0, 107.89, 0, 215.78, false, false],
        ["multiplier", 0, 0.5526, 0, 1.1052, false, false],
        ["ballSize", 0, 60.31, 0, 120.62, false, false],
        ["contrast", 0, 3.03, 0, 6.06, false, false],
        ["radius", 0, 40.75, 0, 81.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d1"
    },
    "shader": "#define BALLS 20\n\n\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(rotation * stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = tan(t - stream / 42.); // + stream/100.);\n    float y = sin(t / multiplier + stream / 7.); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 376.98, 0, 753.96, false, false],
        ["yDivider", 0, 177.2, 0, 354.4, false, false],
        ["xDivider", 0, 70.49, 0, 140.98, false, false],
        ["multiplier", 0, 2.0479, 0, 4.0958, false, false],
        ["ballSize", 0, 67.06, 0, 134.12, false, false],
        ["contrast", 0, 2.45, 0, 4.9, false, false],
        ["radius", 0, 55.1, 0, 110.2, false, false],
        ["rotation", 0, 1, 0, 2, false, false],
        ["yDivide", 0, 401.76, 0, 803.52, false, false],
        ["xDivide", 0, 0.57, 0, 1.14, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 62.37, 0, 124.74, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1df"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= 1.1 * sin(.01 * dot(uv, uv) - stream / 5.);\n  uv /= abs(fract(uv) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.92, 0, 13.84, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 1, 0, 2, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca220"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.), 2.*cos(shape*uv+stream/5.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 2.69, 0, 5.38, false, false],
        ["contrast", 0, 3.6, 0, 7.2, false, false],
        ["radius", 0, 28.41, 0, 56.82, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca237"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 11.)) * (dist / .5) + stream / 10.);\n    float t = PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * (abs(cos(.06 * uv.y - stream))) * uv.x * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.61, 0, 1.22, false, false],
        ["ballSize", 0, 807.57, 0, 1615.14, false, false],
        ["contrast", 0, 1.54, 0, 3.08, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 715.65, 0, 1431.3, false, false],
        ["xOuter", 0, 389.02, 0, 778.04, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23d"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(stream / 20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream / 52. - float(i) / 10.;\n    vec2 p = vec2(xOuter * uv.y * 2.1 / uv.x * 6. + radius * cos(t + xMultiplier + stream / 5.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + 2.1 * stream) / stream / 5.);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1. / dist * length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 37.46, 0, 74.92, false, false],
        ["ballSize", 0, 6567.026, 0, 13134.052, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 126.63, 0, 253.26, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 814.53, 0, 1629.06, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 29.31, 0, 58.62, false, false],
        ["yMultiplier", 0, 41.44, 0, 82.88, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0059, 0, 0.0118, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b2"
    },
    "shader": "\n  #define orbs 10.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 2.*sin(t-stream/2.);\n      float y = radius * cos(t+stream) + 2.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream) + 1.*tan(t-stream/2.);\n      float y = radius * cos(t+stream) + 1.*cos(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor -= orb(uv, orbSize*.5, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 4.48, 0, 15, false, false],
        ["contrast", 0, 1, 1, 5, false, false],
        ["orbSize", 0, 0.43, 0.01, 1, false, false],
        ["radius", 0, 1.03, 1, 5, false, false],
        ["colorShift", 0, 6, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1bf"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 15.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 1.; i < 20.; i++) {\n    uv *= k_rotate2d(i * tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t * radius * sin(shape * dist + stream);\n    float y = i / 80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.92, 0, 9.84, false, false],
        ["contrast", 0, 0.94, 0, 1.88, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 3.55, 0, 7.1, false, false],
        ["colorShift", 0, 4.02, 0, 8.04, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["shape", 0, 3.92, 0, 7.84, false, false],
        ["shape2", 0, 1.42, 0, 2.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1dd"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(uv) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8.93, 0, 17.86, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.62, 0, 1.24, false, false],
        ["radius", 0, 4.92, 0, 9.84, false, false],
        ["colorShift", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e5"
    },
    "shader": "  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 26.24, 0, 52.48, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.62, 0, 1.24, false, false],
        ["radius", 0, 4.92, 0, 9.84, false, false],
        ["colorShift", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1eb"
    },
    "shader": "\n  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 26.24, 0, 66, false, false],
        ["contrast", 0, 1, 1, 5, false, false],
        ["orbSize", 0, 0.62, 0.01, 3, false, false],
        ["radius", 0, 4.92, 1, 15, false, false],
        ["colorShift", 0, 6.06, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ee"
    },
    "shader": "  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv)-sin(uv) - stream/3.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.);\n      float y = radius * sin(t-stream/10.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 6.15, 0, 12.3, false, false],
        ["contrast", 0, 2.03, 0, 4.06, false, false],
        ["orbSize", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 3.28, 0, 6.56, false, false],
        ["colorShift", 0, 8.91, 0, 17.82, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca210"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50, 0, 50, false, false],
        ["yDivider", 0, 0.73, 0.1, 1000, false, false],
        ["xDivider", 0, 9.13, 0.1, 1000, false, false],
        ["multiplier", 0, 111, 0.1, 111, false, false],
        ["ballSize", 0, 0.23, 0, 0.3, false, false],
        ["contrast", 0, 1.61, 0, 5, false, false],
        ["radius", 0, 38.96, 0, 111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20f"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001*dot(uv, uv) - stream/40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier+stream/50.), radius*sin(t-multiplier+stream/30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 88.11, 0, 176.22, false, false],
        ["yDivider", 0, 1, 0, 2, false, false],
        ["xDivider", 0, 111, 0, 222, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 1.69, 0, 3.38, false, false],
        ["contrast", 0, 1.66, 0, 3.32, false, false],
        ["radius", 0, 26.57, 0, 53.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21e"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n  uv *= rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.63, 0, 5.26, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 3, 0, 6, false, false],
        ["contrast", 0, 4.42, 0, 8.84, false, false],
        ["radius", 0, 20.28, 0, 40.56, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca228"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), cos(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.58, 0, 15, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 476.91, 0.1, 1101, false, false],
        ["ballSize", 0, 0.93, 0, 3, false, false],
        ["contrast", 0, 2.85, 0, 5, false, false],
        ["radius", 0, 11.78, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 0.92, 0, 5, false, false],
        ["shape", 0, 0.79, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22b"
    },
    "shader": "\n#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.41, 0, 15, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 476.91, 0.1, 1101, false, false],
        ["ballSize", 0, 1.15, 0, 3, false, false],
        ["contrast", 0, 3, 0, 5, false, false],
        ["radius", 0, 12.73, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["shape", 0, 0.79, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22e"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.), 2.*cos(shape*uv+stream/5.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 352.09, 0.1, 1101, false, false],
        ["ballSize", 0, 2.69, 0, 21, false, false],
        ["contrast", 0, 3.6, 0, 5, false, false],
        ["radius", 0, 28.41, 0, 111, false, false],
        ["yOuter", 0, 1.16, 0, 2, false, false],
        ["xOuter", 0, 0.91, 0, 2, false, false],
        ["rotation", 0, 0.07, 0, 1, false, false],
        ["shape", 0, 1.54, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22f"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.01*sin(uv+stream), 2.*cos(shape*uv+stream))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.74, 0, 5.48, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 784.55, 0, 1569.1, false, false],
        ["ballSize", 0, 1.36, 0, 2.72, false, false],
        ["contrast", 0, 2.66, 0, 5.32, false, false],
        ["radius", 0, 43.22, 0, 86.44, false, false],
        ["yOuter", 0, 0.82, 0, 1.64, false, false],
        ["xOuter", 0, 0.92, 0, 1.84, false, false],
        ["rotation", 0, 1215, 0, 2430, false, false],
        ["shape", 0, 0.75, 0, 1.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca239"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = uv * uv;\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(-rotation * (dist / 5.) + stream / 10. + float(i));\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (atan(uv.x - stream / .1)) * uv.x + radius * tan(t + xMultiplier) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.22, 0, 0.44, false, false],
        ["ballSize", 0, 8.028, 0, 16.056, false, false],
        ["contrast", 0, 0.48, 0, 0.96, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 24, 0, 48, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 1.35, 0, 2.7, false, false],
        ["yMultiplier", 0, 8.46, 0, 16.92, false, false],
        ["divider", 0, 8, 0, 16, false, false],
        ["rotation", 0, -0.06, -0.12, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca196"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  vec2 _kale = kale(uv, vec2(center), sides);\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, kaleidoscopeTweenProgress); \n    } else {\n      uv = mix(_kale, uv, kaleidoscopeTweenProgress);\n    }\n  } else if (kaleidoscope) {\n    uv = _kale; \n  }\n  vec2 glooped = uv * sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);// * rotate(PI);\n  if (gloopTween) {\n    if (gloop) {\n      uv = mix(uv, glooped, gloopTweenProgress); \n    } else {\n      uv = mix(glooped, uv, gloopTweenProgress);\n    }\n  } else {\n    if (gloop) {\n    \tuv = glooped; \n    }\n  }\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotate(i-stream/500.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/100.);\n    float y = radius * cos(t-stream/100.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.73, 0, 15, false, false],
        ["contrast", 0, 1.36, 1, 5, false, false],
        ["orbSize", 0, 0.51, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 3.21, 1, 5, false, false],
        ["colorShift", 0, 4, 4, 20, false, false],
        ["center", 0, 0, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 4.68, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0.001, 0, 0.001, false, false],
        ["gloop", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a2"
    },
    "shader": "#define orbs 50.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 1.; i < 20.; i++) {\n    uv *= 1.005;\n    float t = i * PI / orbs + rotation * sin(stream / 10.);\n    float x = radius * tan(t - stream) * sin(t - stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.41, 0, 6.82, false, false],
        ["contrast", 0, 1.46, 0, 2.92, false, false],
        ["orbSize", 0, 0.06, 0, 0.12, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 12.95, 0, 25.9, false, false],
        ["rotation", 0, 9.14, 0, 18.28, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a8"
    },
    "shader": "#define BALLS 30\n\n\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius * tan(t * multiplier + stream);\n    float y = radius * sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.11, 0, 4.22, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 2.73, 0, 5.46, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ae"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*cos(t+xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t+yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.27, 0, 0.54, false, false],
        ["ballSize", 0, 0.021, 0, 0.042, false, false],
        ["contrast", 0, 3.98, 0, 7.96, false, false],
        ["radius", 0, 0.97, 0, 1.94, false, false],
        ["yOuter", 0, 1.98, 0, 3.96, false, false],
        ["xOuter", 0, 20, 0, 40, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 6.39, 0, 12.78, false, false],
        ["yMultiplier", 0, 3.46, 0, 6.92, false, false],
        ["divider", 0, 2, 0, 4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b7"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n//  uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.005*dot(uv + 1.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/10.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += base-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.006, 0, 0.012, false, false],
        ["contrast", 0, 0.12, 0, 0.24, false, false],
        ["orbSize", 0, 17.09, 0, 34.18, false, false],
        ["radius", 0, 10.09, 0, 20.18, false, false],
        ["colorShift", 0, 7.95, 0, 15.9, false, false],
        ["sides", 0, 12, 0, 24, false, false],
        ["rotation", 0, 0.6, 0, 1.2, false, false],
        ["sinMul", 0, 4, 0, 8, false, false],
        ["cosMul", 0, 3.16, 0, 6.32, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0, 0, 0, false, false],
        ["xSpeed", 0, 0, 0, 0, false, false],
        ["ySpeed", 0, 0, 0, 0, false, false],
        ["gloop", 0, 0.003, 0, 0.006, false, false],
        ["yDivide", 0, 11, 0, 22, false, false],
        ["xDivide", 0, 15, 0, 30, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["base", 0, 0.57, 0, 1.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c6"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x); //-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream) * cosMul * cos(uv.y / yShape + stream / 3.) * cosMul * sin(stream / 10.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 469.65, 0, 939.3, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 105.78, 0, 211.56, false, false],
        ["contrast", 0, 3.32, 0, 6.64, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["yDivide", 0, 897.27, 0, 1794.54, false, false],
        ["xDivide", 0, 0.18, 0, 0.36, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 100, 0, 200, false, false],
        ["cosMul", 0, 0.86, 0, 1.72, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d2"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _dotted = uv * sin(.0001 * dot(uv, uv) - stream / 10.);\n  if (dottedTween) {\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 92.31, 0, 184.62, false, false],
        ["yDivider", 0, 2.02, 0, 4.04, false, false],
        ["xDivider", 0, 19.77, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 26.35, 0, 52.7, false, false],
        ["contrast", 0, 3.19, 0, 6.38, false, false],
        ["radius", 0, 25.88, 0, 51.76, false, false],
        ["rotation", 0, 89.48, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 1.49, 0, 2.98, false, false],
        ["yShape", 0, 14.73, 0, 29.46, false, false],
        ["shape", 0, 71.08, 0, 142.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1fd"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n//  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*uv.y+radius*tan(t*xMultiplier+stream), radius*sin(yOuter*uv.x/.1+t*yMultiplier+stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.3, 0, 5, false, false],
        ["ballSize", 0, 0.076, 0, 0.1, false, false],
        ["contrast", 0, 4.36, 0, 15, false, false],
        ["radius", 0, 1.44, 0, 5, false, false],
        ["yOuter", 0, 0.71, 0, 20, false, false],
        ["xOuter", 0, 4.15, 0, 20, false, false],
        ["rotation", 0, 0.46, 0, 1, false, false],
        ["shape", 0, 5.17, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.38, 0, 10, false, false],
        ["yMultiplier", 0, 4.84, 0, 10, false, false],
        ["divider", 0, 4, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca231"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 20000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.22, 0, 2.44, false, false],
        ["ballSize", 0, 2071.834, 0, 4143.668, false, false],
        ["contrast", 0, 0.7, 0, 1.4, false, false],
        ["radius", 0, 68.36, 0, 136.72, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 2783.51, 0, 5567.02, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca249"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) * rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.23, 0, 0.46, false, false],
        ["ballSize", 0, 183.349, 0, 366.698, false, false],
        ["contrast", 0, 2.79, 0, 5.58, false, false],
        ["radius", 0, 237.72, 0, 475.44, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 100, 0, 200, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 0, false, false],
        ["yMultiplier", 0, 79.96, 0, 159.92, false, false],
        ["divider", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0.0002, 0, 0.0004, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca255"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.3*(uv + sin(5.*uv))-stream/10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/2. - stream/21.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius*tan(t*multiplier), _radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 7.84, 0, 15.68, false, false],
        ["yDivider", 0, 232, 0, 464, false, false],
        ["xDivider", 0, 77.31, 0, 154.62, false, false],
        ["multiplier", 0, 69.13, 0, 138.26, false, false],
        ["ballSize", 0, 2.31, 0, 4.62, false, false],
        ["contrast", 0, 1.79, 0, 3.58, false, false],
        ["radius", 0, 57.1, 0, 114.2, false, false],
        ["yOuter", 0, 0.73, 0, 1.46, false, false],
        ["xOuter", 0, 0.7, 0, 1.4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1bd"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(20. * uv.y);\n    float y = .1 * sin(uv.y / 2.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 50.28, 0, 100.56, false, false],
        ["contrast", 0, 2.43, 0, 4.86, false, false],
        ["orbSize", 0, 0.36, 0, 0.72, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["colorShift", 0, 6.68, 0, 13.36, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6d"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e1"
    },
    "shader": "#define orbs 30.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\tvec2 _uv = uv;\n  uv /= abs(fract(sin(uv)) - .5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv = _uv;\n    uv /= 1.*sin(dist*dot(uv + sin(uv), uv)+(i*.15));\n    float t = i * PI / orbs + rotation * sin(stream/10.);\n    float x = radius * cos(t-stream) * sin(t-stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.06, 0, 4.12, false, false],
        ["contrast", 0, 1.81, 0, 3.62, false, false],
        ["orbSize", 0, 0.28, 0, 0.56, false, false],
        ["radius", 0, 3.95, 0, 7.9, false, false],
        ["colorShift", 0, 18.43, 0, 36.86, false, false],
        ["rotation", 0, 36.65, 0, 73.3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f1"
    },
    "shader": "#define BALLS 40.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX * sin(stream) + uv.y / .2 + loops * sin(uv.x * x1 - stream / 1.);\n  uv.y *= outerY * cos(stream) + (uv.y / .2 + loopSize * sin(x2 * uv.x - stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(i * sin(t) * xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 55.86, 0, 111.72, false, false],
        ["contrast", 0, 2.57, 0, 5.14, false, false],
        ["ballSize", 0, 101, 0, 202, false, false],
        ["x1", 0, 0.14, 0, 0.28, false, false],
        ["x0", 0, 0, 0, 0, false, false],
        ["y0", 0, 0.85, 0, 1.7, false, false],
        ["ballMul", 0, 9.04, 0, 18.08, false, false],
        ["xMul", 0, 100.56, 0, 201.12, false, false],
        ["yMul", 0, 1.68, 0, 3.36, false, false],
        ["wave1", 0, 44.32, 0, 88.64, false, false],
        ["wave2", 0, 1.62, 0, 3.24, false, false],
        ["loops", 0, 67.96, 0, 135.92, false, false],
        ["outerX", 0, 19.6, 0, 39.2, false, false],
        ["outerY", 0, 33.32, 0, 66.64, false, false],
        ["loopSize", 0, 0, 0, 0, false, false],
        ["x2", 0, 64.85, 0, 129.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20b"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(uv, vec2(1.), 8.);\n  uv *= 5.15 * cos(.01 * dot(uv + shape * sin(uv + stream), uv + fuck * cos(uv - stream)) - stream);\n  uv.x = dist * abs(fract(uv.y) - .5);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i + stream / 10.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8, 0, 16, false, false],
        ["contrast", 0, 2.1, 0, 4.2, false, false],
        ["orbSize", 0, 1.01, 0, 2.02, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 8.7, 0, 17.4, false, false],
        ["shape", 0, 0, 0, 0, false, false],
        ["fuck", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20e"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += cos(uv.y/yDivider + stream/2.) + sin(uv.x/3. / stream/2.);\n    uv.x += sin(uv.x/xDivider - stream/2.) * sin(uv.y/3. + stream/2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/10.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t+multiplier), radius*sin(t-multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 92.286572, 0, 100, false, false],
        ["yDivider", 0, 0.73, 0, 1.46, false, false],
        ["xDivider", 0, 9.13, 0, 18.26, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.23, 0, 0.46, false, false],
        ["contrast", 0, 1.61, 0, 3.22, false, false],
        ["radius", 0, 38.96, 0, 77.92, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21a"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.41, 0, 6.82, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 1.15, 0, 2.3, false, false],
        ["contrast", 0, 3, 0, 6, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22a"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n  uv *= rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.63, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 352.09, 0.1, 1101, false, false],
        ["ballSize", 0, 3, 0, 11, false, false],
        ["contrast", 0, 4.42, 0, 15, false, false],
        ["radius", 0, 20.28, 0, 111, false, false],
        ["yOuter", 0, 1.16, 0, 2, false, false],
        ["xOuter", 0, 0.91, 0, 2, false, false],
        ["rotation", 0, 0.07, 0, 1, false, false],
        ["shape", 0, 1.54, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca238"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation + stream / 8.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.02 * uv.y - stream / 2.)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 5.) * (.4201 * uv.x + sin(uv.y / .1)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(color * log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.37, 0, 6.74, false, false],
        ["ballSize", 0, 590.219, 0, 1180.438, false, false],
        ["contrast", 0, 1.63, 0, 3.26, false, false],
        ["radius", 0, 527.24, 0, 1054.48, false, false],
        ["yOuter", 0, 100, 0, 200, false, false],
        ["xOuter", 0, 73.89, 0, 147.78, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 101, 0, 202, false, false],
        ["yMultiplier", 0, 33.47, 0, 66.94, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0.0004, 0, 0.0008, false, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca245"
    },
    "shader": "#define BALLS 3\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*length(uv)/((stream/2.))*(dist/.5)+stream/9.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*1.1+radius*cos(t+xMultiplier+stream/20.) * .1/cos(.1*uv.x + sin(uv.x/1.)), radius*cos((.01*uv.y*t+yMultiplier)+1.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-abs(log(abs(gl_FragColor.xyz)))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.561, 0, 14.56, false, false],
        ["ballSize", 0, 2006.924, 0, 7512.552, false, false],
        ["contrast", 0, 1.349, 0, 5.44, false, false],
        ["radius", 0, 0.135, 0, 1, false, false],
        ["yOuter", 0, 0, 0, 738.12, false, false],
        ["xOuter", 0, 2523.313, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 3.843, 0, 25.18, false, false],
        ["yMultiplier", 0, 4.397, 0, 32.76, false, false],
        ["divider", 0, 842.935, 0, 1118, false, false],
        ["rotation", 0, 0, 0, 10.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a5"
    },
    "shader": "#define orbs 40.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  vec2 _uv = uv;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.05;\n    float radius = 10.;\n    float t = (i * PI / orbs + rotation) * sin(stream / 10.);\n    float x = (radius * tan(t - stream) * sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = k_kale(uv, vec2(.2), 5.);\n  uv *= k_rotate2d(tan(stream));\n\n  uv *= k_rotate2d(dist);\n\n  for (float i = 1.; i < 20.; i++) {\n    float t = i * PI / orbs + rotation * sin(stream / 10.);\n    float x = (radius * tan(t - stream) / sin(t - stream)) + (.01 * sin(stream));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15, 0, 30, false, false],
        ["contrast", 0, 2.05, 0, 4.1, false, false],
        ["orbSize", 0, 0.073, 0, 0.146, false, false],
        ["radius", 0, 0.06, 0, 0.12, false, false],
        ["colorShift", 0, 8.93, 0, 17.86, false, false],
        ["rotation", 0, 17, 0, 34, false, false],
        ["shape", 0, 110, 0, 220, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a9"
    },
    "shader": "#define orbs 5.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) / color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t-stream);\n    float y1 = radius * sin(t+stream);\n    float x2 = radius * tan(t-stream);\n    float y2 = radius * sin(t-stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n\t\t  \tx = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n     \tx = x2; \n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["contrast", 0, 0.88, 0, 1.76, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.87, 0, 1.74, false, false],
        ["colorShift", 0, 2.5, 0, 5, false, false],
        ["center", 0, 1.73, 0, 3.46, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1b0"
    },
    "shader": "\n#define BALLS 20\n  \nmat2 rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * 2. * PI / float(BALLS);\n    float x = radius*tan(t + stream);\n    float y = radius*cos(t + stream);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(color * PI * (float(i) / PI));//* 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 2, false, false],
        ["ballSize", 0, 0.004, 0, 0.05, false, false],
        ["contrast", 0, 0.39, 0, 5, false, false],
        ["radius", 0, 0.1, 0, 1, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["color", 3, [0.8, 0.2, 0.6], null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ce"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 12000.);\n    uv.y -= float(i) / 50. * cos(uv.y / yDivider + stream / 18.) + sin(uv.x / 100. - stream / 13.);\n    uv.x += float(i) / 2. * sin(uv.x / xDivider + stream / 18.) - cos(uv.y / 1000. + stream / 13.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 41.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1276.85, 0, 2553.7, false, false],
        ["yDivider", 0, 414.6, 0, 829.2, false, false],
        ["xDivider", 0, 40.9, 0, 81.8, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 176, 0, 352, false, false],
        ["contrast", 0, 2.26, 0, 4.52, false, false],
        ["radius", 0, 82.95, 0, 165.9, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1cf"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 2.) * .229 * cos(uv.y / yShape + stream / 2.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 182.83, 0, 365.66, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 496.23, 0, 992.46, false, false],
        ["xDivide", 0, 0.2, 0, 0.4, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 100, 0, 200, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1fa"
    },
    "shader": "#define BALLS 40.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 55.86, 0, 111.72, false, false],
        ["contrast", 0, 2.57, 0, 5.14, false, false],
        ["ballSize", 0, 101, 0, 202, false, false],
        ["x1", 0, 0.14, 0, 0.28, false, false],
        ["x0", 0, 0, 0, 0, false, false],
        ["y0", 0, 0.85, 0, 1.7, false, false],
        ["ballMul", 0, 9.04, 0, 18.08, false, false],
        ["xMul", 0, 100.56, 0, 201.12, false, false],
        ["yMul", 0, 1.68, 0, 3.36, false, false],
        ["wave1", 0, 44.32, 0, 88.64, false, false],
        ["wave2", 0, 1.62, 0, 3.24, false, false],
        ["loops", 0, 67.96, 0, 135.92, false, false],
        ["outerX", 0, 19.6, 0, 39.2, false, false],
        ["outerY", 0, 33.32, 0, 66.64, false, false],
        ["loopSize", 0, 0, 0, 0, false, false],
        ["x2", 0, 64.85, 0, 129.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca207"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n\tuv *= rotate(stream/10.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .001/dist * uv + yDot*cos(uv))-stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, 4.*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.68, 0, 15, false, false],
        ["contrast", 0, 1.67, 1, 5, false, false],
        ["orbSize", 0, 0.07, 0.01, 0.2, false, false],
        ["radius", 0, 1, 1, 5, false, false],
        ["colorShift", 0, 4.96, 4, 10, false, false],
        ["center", 0, 1.15, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 10, 0, 10, false, false],
        ["yDot", 0, 0.63, 0, 10, false, false],
        ["dotMul", 0, 1, 0, 1, false, false],
        ["rotation", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca217"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * uv + stream / 2.)) * 21.1 * tan(uv);\n  uv *= k_rotate2d(rotation * stream / .8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.63, 0, 5.26, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 3, 0, 6, false, false],
        ["contrast", 0, 4.42, 0, 8.84, false, false],
        ["radius", 0, 20.28, 0, 40.56, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23c"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.92, 0, 5.84, false, false],
        ["ballSize", 0, 696.957, 0, 1393.914, false, false],
        ["contrast", 0, 1.54, 0, 3.08, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca246"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*length(uv)/((stream/20.))/(dist/-222.2)+stream/dist/10000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(11./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.22, 0, 2.44, false, false],
        ["ballSize", 0, 204.295, 0, 408.59, false, false],
        ["contrast", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 148.3, 0, 296.6, false, false],
        ["yOuter", 0, 994.06, 0, 1988.12, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 73.02, 0, 146.04, false, false],
        ["yMultiplier", 0, 71.21, 0, 142.42, false, false],
        ["divider", 0, 8, 0, 16, false, false],
        ["rotation", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },

  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19e"
    },
    "shader": "#define orbs 30.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  vec2 _uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= 1.05;\n    float radius = 3.;\n    float t = (shape * i * PI / orbs + rotation) * sin(stream / 20.);\n    float x = (radius * tan(t - stream / 20.) * sin(t - stream / 5.));\n    float y = radius * tan(t) * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize * 3., position, color, contrast);\n  }\n\n  uv = _uv * k_rotate2d(stream / 1.);\n  uv = k_kale(uv, vec2(dist), 1.);\n\n  uv += dot(uv, uv);\n  //  uv *= k_rotate2d(dist);\n\n  for (float i = 0.; i < 20. / 2.; i++) {\n    uv = abs(uv);\n    float radius = .0;\n    float t = i * PI / orbs + rotation + tan(stream / 50.);\n    float x = (radius / sin(t) * sin(t - stream / 20.)) + (.1 * sin(uv.x));\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize / 3., position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.11, 0, 4.22, false, false],
        ["contrast", 0, 1.2, 0, 2.4, false, false],
        ["orbSize", 0, 0.076, 0, 0.152, false, false],
        ["radius", 0, 0, 0, 0, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["rotation", 0, 9.58, 0, 19.16, false, false],
        ["shape", 0, 3.02, 0, 6.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d7"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*(uv.x);//-2.*cos(uv.y/yDivider + stream/.1);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider+stream) * cosMul*cos(uv.x/yShape+stream/3.) * cosMul*sin(stream/10.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/10.;\n    float x = -1.*tan(t) + stream/100.;\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/40. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(volume, 6.)*pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 363.69, 0, 5000, false, false],
        ["yDivider", 0, 665.49, 0.1, 1191, false, false],
        ["xDivider", 0, 9.32, 0.1, 11, false, false],
        ["multiplier", 0, 3.5795, 0.01, 5, false, false],
        ["ballSize", 0, 55.94, 0, 112, false, false],
        ["contrast", 0, 3.57, 0, 5, false, false],
        ["radius", 0, 26.89, 0, 115, false, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["yDivide", 0, 1000, 0, 1000, false, false],
        ["xDivide", 0, 0.05, 0, 10, false, false],
        ["yShape", 0, 16.92, 0, 100, false, false],
        ["shape", 0, 14.28, 0, 100, false, false],
        ["cosMul", 0, 0.21, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e7"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n  uv += sin(.01*dot(tan(uv+stream/20.), (uv)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1. + stream/3.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 22.28, 0, 44.56, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 0.1, 0, 0.2, false, false],
        ["ballSize", 0, 0.54, 0, 1.08, false, false],
        ["contrast", 0, 1.63, 0, 3.26, false, false],
        ["radius", 0, 29.51, 0, 59.02, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f4"
    },
    "shader": "#define orbs 5.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  vec2 dotted = uv / dot(uv, uv);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  if (dottedTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(float(i) + stream / 200.);\n    uv.x += uv.y / yDivider;\n    uv.y -= uv.x / xDivider;\n    float t = twist * dist * (i) * PI / (orbs) * (5. + 1.);\n    vec2 p = radius * vec2(cosMul * cos(t - stream / 30.), 2.5 * sin(t + stream / 31.));\n    p *= pMul * sin(stream / 44. + cos(uv.y / 2. + stream / 50.) * sin(t + uv.x / x3) * cos(t - stream / 44. + uv.y / y3));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 150. + (i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((-5. + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 15, 0, 30, false, false],
        ["contrast", 0, 1.77, 0, 3.54, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["y3", 0, 50, 0, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x3", 0, 11.48, 0, 22.96, false, false],
        ["twist", 0, 0.00132, 0, 0.00264, false, false],
        ["pMul", 0, 1.19, 0, 2.38, false, false],
        ["cosMul", 0, 24.09, 0, 48.18, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["sides", 0, 10, 0, 20, false, false],
        ["yDivider", 0, 42.2, 0, 84.4, false, false],
        ["xDivider", 0, 46.07, 0, 92.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f9"
    },
    "shader": "#define BALLS 40.\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n//  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.)*ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 34.87, 0, 69.74, false, false],
        ["contrast", 0, 2.57, 0, 5.14, false, false],
        ["ballSize", 0, 38.45, 0, 76.9, false, false],
        ["x1", 0, 0.14, 0, 0.28, false, false],
        ["x0", 0, 0, 0, 0, false, false],
        ["y0", 0, 0.85, 0, 1.7, false, false],
        ["ballMul", 0, 9.04, 0, 18.08, false, false],
        ["xMul", 0, 100.56, 0, 201.12, false, false],
        ["yMul", 0, 1.68, 0, 3.36, false, false],
        ["wave1", 0, 44.32, 0, 88.64, false, false],
        ["wave2", 0, 1.62, 0, 3.24, false, false],
        ["loops", 0, 67.96, 0, 135.92, false, false],
        ["outerX", 0, 19.6, 0, 39.2, false, false],
        ["outerY", 0, 33.32, 0, 66.64, false, false],
        ["loopSize", 0, 0, 0, 0, false, false],
        ["x2", 0, 64.85, 0, 129.7, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca227"
    },
    "shader": "\n#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2*sin(uv+stream), atan(shape*uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 15, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 476.91, 0.1, 1101, false, false],
        ["ballSize", 0, 2.5, 0, 3, false, false],
        ["contrast", 0, 2.63, 0, 5, false, false],
        ["radius", 0, 12.73, 0, 111, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false],
        ["shape", 0, 0.79, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca24b"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) * rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.23, 0, 11, false, false],
        ["ballSize", 0, 183.349, 0, 1111, false, false],
        ["contrast", 0, 2.79, 0, 15, false, false],
        ["radius", 0, 237.72, 0, 1105, false, false],
        ["yOuter", 0, 100, 0, 100, false, false],
        ["xOuter", 0, 100, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 101, false, false],
        ["yMultiplier", 0, 79.96, 0, 101, false, false],
        ["divider", 0, 0, 0, 10, false, false],
        ["rotation", 0, 0.0002, 0, 0.001, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca24c"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) { \n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*(dist/.5)+stream/50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.);// - stream/100.;\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), vec2(10.) * rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.06, 0, 1, false, false],
        ["ballSize", 0, 183.349, 0, 1111, false, false],
        ["contrast", 0, 2.79, 0, 15, false, false],
        ["radius", 0, 237.72, 0, 1105, false, false],
        ["yOuter", 0, 0, 0, 100, false, false],
        ["xOuter", 0, 18.72, 1, 100, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 101, false, false],
        ["yMultiplier", 0, 79.96, 0, 101, false, false],
        ["divider", 0, 0, 0, 10, false, false],
        ["rotation", 0, 0, 0, 0.001, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca198"
    },
    "shader": "#define orbs 5.\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) / color, 1.), vec4(contrast));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["contrast", 0, 0.88, 0, 1.76, false, false],
        ["orbSize", 0, 0.01, 0, 0.02, false, false],
        ["radius", 0, 0.87, 0, 1.74, false, false],
        ["colorShift", 0, 2.5, 0, 5, false, false],
        ["center", 0, 1.73, 0, 3.46, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1db"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(tan(cos(uv) - sin(uv) - stream / 3.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 5.);\n    float y = radius * sin(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.15, 0, 12.3, false, false],
        ["contrast", 0, 2.03, 0, 4.06, false, false],
        ["orbSize", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 3.28, 0, 6.56, false, false],
        ["colorShift", 0, 8.91, 0, 17.82, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e6"
    },
    "shader": "  #define orbs 15.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(uv);\n    uv *= 5.1*sin(.1*dot(uv, uv) - stream/5.);\n    uv /= abs(fract(uv) - .5) / .5/dist*rotate(stream/4.); \n    for (float i = 0.; i < orbs; i++) {\n      uv *= rotate(.001*stream/(i+1.));\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t);\n      float y = radius * cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 0.87, 0, 1.74, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 1, 0, 2, false, false],
        ["radius", 0, 1.81, 0, 3.62, false, false],
        ["colorShift", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e9"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n\n    uv /= dot(uv, uv);\n    uv *= rotate(stream/2.);\n    float dist = length(tan(cos(uv-stream) - stream/1.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/6.);\n      float y = radius * sin(t-stream/1.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 2.93, 0, 5.86, false, false],
        ["orbSize", 0, 3, 0, 6, false, false],
        ["radius", 0, 21.13, 0, 42.26, false, false],
        ["colorShift", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ea"
    },
    "shader": "  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(1.-uv+stream) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv -= .001* dist*i * (uv + sin(uv-stream));\n      uv.x += .2*sin(uv.y);\n      uv.y += 1.2*cos(uv.x+stream);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 18.16, 0, 36.32, false, false],
        ["contrast", 0, 1.43, 0, 2.86, false, false],
        ["orbSize", 0, 0.75, 0, 1.5, false, false],
        ["radius", 0, 4.58, 0, 9.16, false, false],
        ["colorShift", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ec"
    },
    "shader": "\n  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv)-sin(uv) - stream/3.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/5.);\n      float y = radius * sin(t-stream/10.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 6.15, 0, 66, false, false],
        ["contrast", 0, 2.03, 1, 5, false, false],
        ["orbSize", 0, 0.84, 0.01, 3, false, false],
        ["radius", 0, 3.28, 1, 15, false, false],
        ["colorShift", 0, 8.91, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ef"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / 2.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 6.);\n    float y = radius * sin(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.41, 0, 0.82, false, false],
        ["contrast", 0, 2.58, 0, 5.16, false, false],
        ["orbSize", 0, 1.71, 0, 3.42, false, false],
        ["radius", 0, 14.42, 0, 28.84, false, false],
        ["colorShift", 0, 8.19, 0, 16.38, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1fc"
    },
    "shader": "\n#define orbs 25.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 5.*uv.x+radius * tan(t+stream);\n    float y = .1*sin(uv.y/.01) * uv.x*sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 5, 0, 5, false, false],
        ["contrast", 0, 1.73, 1, 5, false, false],
        ["orbSize", 0, 0.24, 0.01, 1, false, false],
        ["radius", 0, 15, 1, 15, false, false],
        ["colorShift", 0, 6.37, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca200"
    },
    "shader": "#define BALLS 40.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n//  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, 4.)*ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 34.87, 0, 111, false, false],
        ["contrast", 0, 2.57, 0, 3, false, false],
        ["ballSize", 0, 38.45, 0, 101, false, false],
        ["x1", 0, 0.14, 0, 10, false, false],
        ["x0", 0, 0, 0, 10, false, false],
        ["y0", 0, 0.85, 0, 10, false, false],
        ["ballMul", 0, 9.04, 0, 101, false, false],
        ["xMul", 0, 100.56, 1, 110, false, false],
        ["yMul", 0, 1.68, 1, 10, false, false],
        ["wave1", 0, 44.32, 0, 100, false, false],
        ["wave2", 0, 1.62, 0, 10, false, false],
        ["loops", 0, 67.96, 0, 100, false, false],
        ["outerX", 0, 19.6, 0, 100, false, false],
        ["outerY", 0, 33.32, 0, 100, false, false],
        ["loopSize", 0, 0, 0, 500, false, false],
        ["x2", 0, 64.85, 0, 1111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca202"
    },
    "shader": "#define BALLS 40.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  uv = abs(uv);\n  uv.x += outerX*sin(stream)+uv.y/.2 + loops*sin(uv.x*x1 - stream/1.);\n  uv.y *= outerY*cos(stream)+(uv.y/.2 + loopSize*sin(x2*uv.x-stream));\n  uv = abs(uv);\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n} ",
    "variants": [
      [
        ["zoom", 0, 55.86, 0, 111, false, false],
        ["contrast", 0, 2.57, 0, 3, false, false],
        ["ballSize", 0, 101, 0, 101, false, false],
        ["x1", 0, 0.14, 0, 10, false, false],
        ["x0", 0, 0, 0, 10, false, false],
        ["y0", 0, 0.85, 0, 10, false, false],
        ["ballMul", 0, 9.04, 0, 101, false, false],
        ["xMul", 0, 100.56, 1, 110, false, false],
        ["yMul", 0, 1.68, 1, 10, false, false],
        ["wave1", 0, 44.32, 0, 100, false, false],
        ["wave2", 0, 1.62, 0, 10, false, false],
        ["loops", 0, 67.96, 0, 100, false, false],
        ["outerX", 0, 19.6, 0, 100, false, false],
        ["outerY", 0, 33.32, 0, 100, false, false],
        ["loopSize", 0, 0, 0, 500, false, false],
        ["x2", 0, 64.85, 0, 1111, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca206"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n\tuv *= rotate(stream/20.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/30.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 15, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.35, 0, 0.7, false, false],
        ["radius", 0, 1.82, 0, 3.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 7.68, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 2.982958668830698, 0, 5.965917337661396, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca214"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20. * (uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002 * sin(uv + stream / 5.), cos(shape * uv + stream / 2.)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation * stream / 10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.01, 0, 6.02, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 4.53, 0, 9.06, false, false],
        ["contrast", 0, 4.42, 0, 8.84, false, false],
        ["radius", 0, 40.55, 0, 81.1, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca221"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*sin(uv)+stream/.5))*21.1*tan(uv);\n  uv *= rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/1.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/1.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier+stream/5.), 2.*radius*sin(t*multiplier-stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.88, 0, 7.76, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 0.1, 0, 0.2, false, false],
        ["ballSize", 0, 3.24, 0, 6.48, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 18.53, 0, 37.06, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0.55, 0, 1.1, false, false],
        ["shape", 0, 10, 0, 20, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca235"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.01 * uv.x + sin(uv.x / 1.)), vec2(10.) * k_rotate2d(stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.06, 0, 0.12, false, false],
        ["ballSize", 0, 183.349, 0, 366.698, false, false],
        ["contrast", 0, 2.79, 0, 5.58, false, false],
        ["radius", 0, 237.72, 0, 475.44, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 18.72, 0, 37.44, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 0, false, false],
        ["yMultiplier", 0, 79.96, 0, 159.92, false, false],
        ["divider", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23a"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * length(uv) / ((stream / 20.)) / (dist / -222.2) + stream / dist / 10000.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 20.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(11. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.22, 0, 2.44, false, false],
        ["ballSize", 0, 204.295, 0, 408.59, false, false],
        ["contrast", 0, 0.84, 0, 1.68, false, false],
        ["radius", 0, 148.3, 0, 296.6, false, false],
        ["yOuter", 0, 994.06, 0, 1988.12, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 73.02, 0, 146.04, false, false],
        ["yMultiplier", 0, 71.21, 0, 142.42, false, false],
        ["divider", 0, 8, 0, 16, false, false],
        ["rotation", 0, 0.02, 0, 0.04, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca243"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*length(uv)/((stream/20.))/(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/20.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 4.87, 0, 9.74, false, false],
        ["ballSize", 0, 194.683, 0, 389.366, false, false],
        ["contrast", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 105.97, 0, 211.94, false, false],
        ["yOuter", 0, 457.26, 0, 914.52, false, false],
        ["xOuter", 0, 1392.53, 0, 2785.06, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 8.32, 0, 16.64, false, false],
        ["yMultiplier", 0, 12.9, 0, 25.8, false, false],
        ["divider", 0, 8, 0, 16, false, false],
        ["rotation", 0, 0.0049, 0, 0.0098, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca24e"
    },
    "shader": "\n#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n\n  uv /= dot(uv, uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*tan(uv.x)*atan(dist/-2212.2)-stream/100. -dist/1000.);\n    float t = (PI / float(BALLS) * float(BALLS) / divider) - stream/15.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x/-2.-stream/20.))*uv.y+radius*cos(t+xMultiplier+stream/2.) * cos(sin(uv.y)*uv.y + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/100. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(.01*length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow((gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.02, 0, 1, false, false],
        ["ballSize", 0, 518.629, 0, 1111, false, false],
        ["contrast", 0, 5.13, 0, 15, false, false],
        ["radius", 0, 0, 0, 1115, false, false],
        ["yOuter", 0, 1, 0, 1, false, false],
        ["xOuter", 0, 2401, 1, 1, false, false],
        ["xMultiplier", 0, 33.1, 0, 101, false, false],
        ["yMultiplier", 0, 24.92, 0, 101, false, false],
        ["divider", 0, 188, 0, 1011, false, false],
        ["rotation", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ba"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n //uv = abs(uv);\n  \n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  if (mirrorTween) {\n   \tif (mirror) {\n     \tuv = mix(uv, abs(uv), mirrorTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, mirrorTweenProgress);\n    }\n  } else if (mirror) {\n   \tuv = abs(uv); \n  }\n  uv /= dot(uv, uv);\n  uv *= sin(dist*.05*dot(uv + 20.*cos(uv-stream/3.), uv + cos(uv-stream))+stream/5.);\n  uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/3.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/3.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t+stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02*uv.x+.02*uv.y*vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += .65-orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.08, 0, 0.5, false, false],
        ["contrast", 0, 0.13, 0, 1, false, false],
        ["orbSize", 0, 6.32, 0.01, 11, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["colorShift", 0, 10.32, 4, 22, false, false],
        ["sides", 0, 1, 0, 12, false, false],
        ["rotation", 0, 1, -2, 2, false, false],
        ["sinMul", 0, 0, 0, 4, false, false],
        ["cosMul", 0, 1.28, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0, 0, 5, false, false],
        ["xSpeed", 0, 0, -3, 3, false, false],
        ["ySpeed", 0, 0, -3, 3, false, false],
        ["gloop", 0, 0.003, 0.001, 0.01, false, false],
        ["yDivide", 0, 11, 0, 11, false, false],
        ["xDivide", 0, 15, 0, 15, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1f5"
    },
    "shader": "#define BALLS 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv.x += sin(stream / 4.) * 11.1 * sin(stream) + uv.y / 1.2 + xMul2 * sin(uv.x * x1 - stream / 1.);\n  uv.y *= .1 * cos(stream) + (uv.y / .2 + 1. * sin(x2 * uv.x - stream));\n  uv.x += .1 * sin(.1 * uv.y);\n  uv.y += .1 * cos(.1 * uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = float(i) * PI / BALLS;\n    vec2 p = vec2(sin(t + i) * xMul, uv.x + cos(uv.y - stream + i) * sin(uv.x + stream + i));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.35, 0, 26.7, false, false],
        ["contrast", 0, 0.48, 0, 0.96, false, false],
        ["ballSize", 0, 607.64, 0, 1215.28, false, false],
        ["x1", 0, 0.41, 0, 0.82, false, false],
        ["x2", 0, 0, 0, 0, false, false],
        ["ballMul", 0, 35.51, 0, 71.02, false, false],
        ["xMul", 0, 110, 0, 220, false, false],
        ["size", 0, 15870.35, 0, 31740.7, false, false],
        ["xMul2", 0, 61.45, 0, 122.9, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20a"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv *= cos(.0001 * dot(uv, uv) - stream / 40.);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. / stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 10.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t + multiplier + stream / 50.), radius * sin(t - multiplier + stream / 30.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 88.11, 0, 176.22, false, false],
        ["yDivider", 0, 1, 0, 2, false, false],
        ["xDivider", 0, 111, 0, 222, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 1.69, 0, 3.38, false, false],
        ["contrast", 0, 1.66, 0, 3.32, false, false],
        ["radius", 0, 26.57, 0, 53.14, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca224"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.01, 0, 6.02, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 4.53, 0, 9.06, false, false],
        ["contrast", 0, 4.42, 0, 8.84, false, false],
        ["radius", 0, 40.55, 0, 81.1, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca232"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * length(uv) / ((stream / 20.)) / (dist / .5) + stream / 50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream / 50000.;\n    vec2 p = vec2(xOuter * (cos(.01 * uv.x * -20. - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 20.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 30. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(1. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 4.87, 0, 9.74, false, false],
        ["ballSize", 0, 194.683, 0, 389.366, false, false],
        ["contrast", 0, 3.34, 0, 6.68, false, false],
        ["radius", 0, 105.97, 0, 211.94, false, false],
        ["yOuter", 0, 457.26, 0, 914.52, false, false],
        ["xOuter", 0, 1392.53, 0, 2785.06, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 8.32, 0, 16.64, false, false],
        ["yMultiplier", 0, 12.9, 0, 25.8, false, false],
        ["divider", 0, 8, 0, 16, false, false],
        ["rotation", 0, 0.0049, 0, 0.0098, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca244"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50.*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(stream/20.4567);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.1234) * 20./cos(.1*uv.x + sin(uv.x/100.+stream/20.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3.11 + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.2, 0, 0.4, false, false],
        ["ballSize", 0, 3397.579, 0, 6795.158, false, false],
        ["contrast", 0, 2.19, 0, 4.38, false, false],
        ["radius", 0, 2007.3, 0, 4014.6, false, false],
        ["yOuter", 0, 557.08, 0, 1114.16, false, false],
        ["xOuter", 0, 1451.1, 0, 2902.2, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 23.06, 0, 46.12, false, false],
        ["yMultiplier", 0, 91.45, 0, 182.9, false, false],
        ["divider", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0.0303, 0, 0.0606, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca197"
    },
    "shader": "/**\n * Defining some constants. \n * You can't power for loops using uniform variables, hence the `orbs` definition.\n */\n\n#define orbs 99.\n\n/** \n * Stolen utility function. Warps domain space (ask me what that is) into a kaleidoscope.\n * To make a six-sided kaleidoscope with zero center offset:\n *\n * uv = kale(uv, vec2(0.), 6.); \n */\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) +1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) *atan(sides);\n  angle = -abs(6.0 * angle / - 2.) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\n/**\n * Stolen utility function... looped hue shifting. Shifts all colors by hue simultaneously. \n * \n * gl_FragColor = hue(gl_FragColor, stream);\n */\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\n/*\n * Stolen from neon balls sketch creates a glowing orb. To create a red orb at the center of the screen:\n *\n * gl_FragColor += orb(uv, .1, vec2(0., 0.), vec3(1., 0., 0.), 1.);\n */\nvec4 orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\n/*\n * Rotate the plane (2D).\n *\n * uv *= rotate(stream);\n */\nmat2 rotate(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n/*\n * Main shader function. Decides the color of a single pixel, given the position on the screen.\n */\nvoid main() {\n  // The x/y position on the screen, normalized so that 0,0 is in the center of the viewport, which is from -1 to 1.\n  // vUv is specific to three.js don't worry about it.\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  \n\n  // This adjusts the domain per the aspect ratio of the screen.\n  uv.x *= resolution.x / resolution.y;\n\n  // Adjust zoom level simply by assigning uv to itself multiplied by any float.\n  uv *= zoom;\n  uv *= rotate(stream);\n\n  // The distance between the current pixel and the center of the screen.\n  float dist = length(uv);\n  \n  // Uncomment the next line to warp domain space into a kaleidoscope.\n\t// Try creating a uniform called \"sides\" instead of hard coding the 6. Same for the center offset (0.).\n  //uv = kale(uv, vec2(center), sides); \n \n\n  // I have no idea what a dot product is, but it can do nifty things. Uncomment at will.\n  uv *= atan(dot(uv, uv) - stream);\n  uv /= dot(uv, uv);\n  \n  \n\n  // Create our orbs!\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * -1.*tan(t + stream); // Try `cos` and `tan`. Or comment out and use the next line.\n    //float x = radius * sin(t + stream) * tan(uv.y - stream);\n    float y = radius * tan(t * stream); \n    vec2 position = vec2(x, y);\n    uv *= rotate(i*100.);\n\n    // Stolen from the neon balls sketch on ShaderToy. No fucking idea, but we have a rainbow.\n    vec3 color = cos(vec3(-1, 8, 1) * PI * 2. / 8. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n\n    // We're *adding* to gl_FragColor, iteratively, for each orb. \n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    \n  }\n  \n}",
    "variants": [
      [
        ["zoom", 0, 1.149, 0, 100, false, false],
        ["contrast", 0, 1.724, 0, 5, false, false],
        ["orbSize", 0, 0.131, 0.01, 0.4, false, false],
        ["radius", 0, 5, 1, 5, false, false],
        ["colorShift", 0, 10.345, 0, 100, false, false],
        ["sides", 0, 0, 0, 500, false, false],
        ["center", 0, 0, 0, 100, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca19f"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream);\n    float y = radius * cos(t + stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4, 0, 8, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.125, 0, 0.25, false, false],
        ["radius", 0, 2.5, 0, 5, false, false],
        ["colorShift", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a7"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = distance(uv, vec2(0.));\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter * uv.y + radius * tan(t * xMultiplier + stream), radius * sin(yOuter * uv.x / .1 + t * yMultiplier + stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.3, 0, 4.6, false, false],
        ["ballSize", 0, 0.076, 0, 0.152, false, false],
        ["contrast", 0, 4.36, 0, 8.72, false, false],
        ["radius", 0, 1.44, 0, 2.88, false, false],
        ["yOuter", 0, 0.71, 0, 1.42, false, false],
        ["xOuter", 0, 4.15, 0, 8.3, false, false],
        ["rotation", 0, 0.46, 0, 0.92, false, false],
        ["shape", 0, 5.17, 0, 10.34, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.38, 0, 4.76, false, false],
        ["yMultiplier", 0, 4.84, 0, 9.68, false, false],
        ["divider", 0, 4, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1cb"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist / 12000.);\n    uv.y -= float(i) / 50. * cos(uv.y / yDivider + stream / 81.) + sin(uv.x / 100. - stream / 31.);\n    uv.x += float(i) / 2. * sin(uv.x / xDivider + stream / 85.) - cos(uv.y / 1000. + stream / 31.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 11.);\n    vec2 p = radius * vec2(-11. * cos(t + stream / 410.), 1. * sin(t / multiplier + stream / 410.));\n    p /= sin(PI * sin(uv.x / 100. + stream / 100.) * cos(uv.y / 400. - stream / 100.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1110, 0, 2220, false, false],
        ["yDivider", 0, 300.86, 0, 601.72, false, false],
        ["xDivider", 0, 35.63, 0, 71.26, false, false],
        ["multiplier", 0, 1.3445, 0, 2.689, false, false],
        ["ballSize", 0, 108.3, 0, 216.6, false, false],
        ["contrast", 0, 2.26, 0, 4.52, false, false],
        ["radius", 0, 54.64, 0, 109.28, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d3"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001*dot(uv, uv) - stream/52.);\n\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y -= float(i)/yDivide*sin(uv.y)-cos(uv.y/yDivider + stream/8.);\n    uv.x += float(i)/xDivide*sin(uv.x/xDivider + stream/14.) * .251*cos(uv.y/yShape + stream/6.);\n    float t = 5.1*float(i) * PI / float(BALLS) * (2. + 1.) + stream/100.;\n    float x = -1.*tan(t + stream/100.);\n    float y = sin(t/multiplier);// + stream/401.);\n    vec2 p = radius*vec2(x, y);\n    p /= sin(PI * sin(uv.x/shape+stream/10.));//+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream/200.+vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)/30. *ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 234.54, 0, 469.08, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.4155, 0, 6.831, false, false],
        ["ballSize", 0, 27.72, 0, 55.44, false, false],
        ["contrast", 0, 2.17, 0, 4.34, false, false],
        ["radius", 0, 44.22, 0, 88.44, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 943.61, 0, 1887.22, false, false],
        ["xDivide", 0, 1.57, 0, 3.14, false, false],
        ["yShape", 0, 61.01, 0, 122.02, false, false],
        ["shape", 0, 24.77, 0, 49.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1dc"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= 5.1 * sin(.1 * dot(uv, uv) - stream / 5.);\n  uv /= abs(fract(uv) - .5) / .5 / dist * k_rotate2d(stream / 4.);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(.001 * stream / (i + 1.));\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.87, 0, 1.74, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 1, 0, 2, false, false],
        ["radius", 0, 1.81, 0, 3.62, false, false],
        ["colorShift", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1de"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / 5.);\n  float dist = length(tan(cos(uv - stream) - stream / 1.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 6.);\n    float y = radius * sin(t - stream / 1.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.42, 0, 0.84, false, false],
        ["contrast", 0, 1.26, 0, 2.52, false, false],
        ["orbSize", 0, 1.36, 0, 2.72, false, false],
        ["radius", 0, 6.32, 0, 12.64, false, false],
        ["colorShift", 0, 4.3, 0, 8.6, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e0"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  //\t\tuv = abs(uv);\n  float dist = length(sin(uv + stream) + tan(cos(uv - stream) - stream / 2.));\n  for (float i = 0.; i < 20.; i++) {\n    uv += .005 * dist * i * (uv);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 3.);\n    float y = radius * sin(t - stream / 2.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.4, 0, 14.8, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.99, 0, 1.98, false, false],
        ["radius", 0, 15, 0, 30, false, false],
        ["colorShift", 0, 9.77, 0, 19.54, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1fb"
    },
    "shader": "#define BALLS 30\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider;\n    vec2 p = vec2(xOuter*(atan(dist/uv.x+stream))*uv.x+radius*sin(t+xMultiplier), radius*sin(dist*yOuter*uv.x/.5+t+yMultiplier+3.*stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.46, 0, 0.92, false, false],
        ["ballSize", 0, 0.004, 0, 0.008, false, false],
        ["contrast", 0, 4.47, 0, 8.94, false, false],
        ["radius", 0, 0.12, 0, 0.24, false, false],
        ["yOuter", 0, 29.89, 0, 59.78, false, false],
        ["xOuter", 0, 0.88, 0, 1.76, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 2.82, 0, 5.64, false, false],
        ["yMultiplier", 0, 0, 0, 0, false, false],
        ["divider", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca205"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n\tuv *= rotate(stream/10.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .001/dist * uv + yDot*cos(uv))-stream);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, 4.*orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 3.68, 0, 7.36, false, false],
        ["contrast", 0, 1.67, 0, 3.34, false, false],
        ["orbSize", 0, 0.07, 0, 0.14, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.96, 0, 9.92, false, false],
        ["center", 0, 1.15, 0, 2.3, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 10, 0, 20, false, false],
        ["yDot", 0, 0.63, 0, 1.26, false, false],
        ["dotMul", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca208"
    },
    "shader": "\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = kale(uv, vec2(center), sides);\n\tuv *= rotate(stream/20.);\n  uv *= sin(dotMul * dot(uv + xDot*cos(uv), .1/dist * uv + yDot*cos(uv))-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/30.);\n    float y = radius * cos(t-stream/30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 15, 0, 15, false, false],
        ["contrast", 0, 1.6, 1, 5, false, false],
        ["orbSize", 0, 0.35, 0.01, 0.7210408155162791, false, false],
        ["radius", 0, 1.82, 1, 5, false, false],
        ["colorShift", 0, 17.42, 4, 20, false, false],
        ["center", 0, 7.68, 0, 10, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 2.982958668830698, 0, 10, false, false],
        ["yDot", 0, 2.59, 0, 10, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 10, false, false],
        ["rotation", 0, 0, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca212"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 7.66, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 2.5, 0, 5, false, false],
        ["contrast", 0, 2.63, 0, 5.26, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca216"
    },
    "shader": "#define BALLS 10\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  // uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.2 * sin(uv + stream), atan(shape * uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 3.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.83, 0, 7.66, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 476.91, 0, 953.82, false, false],
        ["ballSize", 0, 2.5, 0, 5, false, false],
        ["contrast", 0, 2.63, 0, 5.26, false, false],
        ["radius", 0, 12.73, 0, 25.46, false, false],
        ["yOuter", 0, 1, 0, 2, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.79, 0, 1.58, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca22c"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(20.*(uv)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*uv+stream/2.))*21.1*tan(uv);\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation * stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.01, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 352.09, 0.1, 1101, false, false],
        ["ballSize", 0, 4.53, 0, 21, false, false],
        ["contrast", 0, 4.42, 0, 5, false, false],
        ["radius", 0, 40.55, 0, 111, false, false],
        ["yOuter", 0, 1.16, 0, 2, false, false],
        ["xOuter", 0, 0.91, 0, 2, false, false],
        ["rotation", 0, 0.07, 0, 1, false, false],
        ["shape", 0, 1.54, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca241"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/50.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider + stream/50000.;\n    vec2 p = vec2(xOuter*(cos(.01*uv.x*-20.-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.92, 0, 5.84, false, false],
        ["ballSize", 0, 696.957, 0, 1393.914, false, false],
        ["contrast", 0, 1.54, 0, 3.08, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca247"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) { \n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(stream/100.+rotation*(dist));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(xOuter*(sin(.01*uv.x-stream))*uv.y*2.1+radius*cos(t+xMultiplier+stream/1.) *(.01*uv.x + sin(uv.x/1.)), 100.*cos(dist-stream/100.));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.1, 0, 0.2, false, false],
        ["ballSize", 0, 155.087, 0, 310.174, false, false],
        ["contrast", 0, 2.79, 0, 5.58, false, false],
        ["radius", 0, 237.72, 0, 475.44, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 18.72, 0, 37.44, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 0, 0, 0, false, false],
        ["yMultiplier", 0, 79.96, 0, 159.92, false, false],
        ["divider", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca24a"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv /= vec2(50.*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(stream/20.);\n    float t = dist * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.24, 0, 0.48, false, false],
        ["ballSize", 0, 1111, 0, 2222, false, false],
        ["contrast", 0, 1.53, 0, 3.06, false, false],
        ["radius", 0, 224.63, 0, 449.26, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 39.66, 0, 79.32, false, false],
        ["yMultiplier", 0, 41.44, 0, 82.88, false, false],
        ["divider", 0, 7, 0, 14, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca254"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 10.36, 0, 20.72, false, false],
        ["yDivider", 0, 27.34, 0, 54.68, false, false],
        ["xDivider", 0, 10.17, 0, 20.34, false, false],
        ["multiplier", 0, 287.12, 0, 574.24, false, false],
        ["ballSize", 0, 1.13, 0, 2.26, false, false],
        ["contrast", 0, 1.41, 0, 2.82, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["yOuter", 0, 0.3, 0, 0.6, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca101"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n  mat2 rotation = k_rotate2d(stream/9.);\n  float ot = ot;\n  \n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(uv) / L + stream/2.);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.175) * orbSize, vec2(radius*abs(sin(stream/1.+uv.x/div)) * L * sin(stream - uv.y), radius*cos(stream/1.+uv.y/div)),  col, contrast);\n  }\n\n  vec3 c = vec3(ot * I + length(uv));\n}",
    "variants": [
      [
        ["zoom", 0, 34.766, 0, 122, false, false],
        ["iterator", 0, 1.071, 0, 2, false, false],
        ["ot", 0, 124.993, 0, 151, false, false],
        ["I", 0, 1.184, 0, 3, false, false],
        ["J", 0, 2.139, 0, 3, false, false],
        ["K", 0, 38.004, 0, 111, false, false],
        ["iterations", 0, 12.332, 0, 33, false, false],
        ["L", 0, 3, 0, 3, false, false],
        ["M", 0, 3.192, 0, 11, false, false],
        ["colorShift", 0, 0.967, 0, 2, false, false],
        ["colorOffset", 0, 29.314, 0, 111, false, false],
        ["contrast", 0, 1.977, 1, 3, false, false],
        ["orbSize", 0, 4.654, 0, 13, false, false],
        ["div", 0, 1.838, 1, 12, false, false],
        ["radius", 0, 23.923, 1, 121, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.732Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a5f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ab"
    },
    "shader": "  #define orbs 15.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    float dist = length(uv);\n    for (float i = 0.; i < orbs; i++) {\n      float t = i * PI / orbs * 2.;\n      float x = radius * sin(t+stream);\n      float y = radius * cos(t+stream);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 4, 0, 8, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.125, 0, 0.25, false, false],
        ["radius", 0, 2.5, 0, 5, false, false],
        ["colorShift", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c5"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00001 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 349.41, 0, 698.82, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 520.47, 0, 1040.94, false, false],
        ["xDivide", 0, 0.56, 0, 1.12, false, false],
        ["yShape", 0, 51.31, 0, 102.62, false, false],
        ["shape", 0, 62.39, 0, 124.78, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1d0"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 20.) * .4229 * cos(uv.y / yShape + stream);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t - stream / 5.); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 212.73, 0, 425.46, false, false],
        ["yDivider", 0, 177.2, 0, 354.4, false, false],
        ["xDivider", 0, 70.49, 0, 140.98, false, false],
        ["multiplier", 0, 2.1035, 0, 4.207, false, false],
        ["ballSize", 0, 38.6, 0, 77.2, false, false],
        ["contrast", 0, 2.68, 0, 5.36, false, false],
        ["radius", 0, 39.41, 0, 78.82, false, false],
        ["rotation", 0, 25.63, 0, 51.26, false, false],
        ["yDivide", 0, 309.81, 0, 619.62, false, false],
        ["xDivide", 0, 0.57, 0, 1.14, false, false],
        ["yShape", 0, 24.51, 0, 49.02, false, false],
        ["shape", 0, 61.37, 0, 122.74, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e2"
    },
    "shader": "#define orbs 30.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\tvec2 _uv = uv;\n  uv /= abs(fract(sin(uv)) - .5);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (float i = 0.; i < orbs; i++) {\n    uv = _uv;\n    uv /= 1.*sin(dist*dot(uv + sin(uv), uv)+(i*.15));\n    float t = i * PI / orbs + rotation * sin(stream/10.);\n    float x = radius * tan(t-stream) * sin(t-stream);\n    float y = radius * cos(t) - sin(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.18, 0, 8.36, false, false],
        ["contrast", 0, 1.92, 0, 3.84, false, false],
        ["orbSize", 0, 0.74, 0, 1.48, false, false],
        ["radius", 0, 5, 0, 10, false, false],
        ["colorShift", 0, 18.43, 0, 36.86, false, false],
        ["rotation", 0, 36.65, 0, 73.3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1e8"
    },
    "shader": "  #define orbs 25.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n//\t\tuv = abs(uv);\n    float dist = length(tan(cos(uv) - stream/2.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/3.);\n      float y = radius * sin(t-stream/2.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 8.93, 0, 17.86, false, false],
        ["contrast", 0, 1, 0, 2, false, false],
        ["orbSize", 0, 0.62, 0, 1.24, false, false],
        ["radius", 0, 4.92, 0, 9.84, false, false],
        ["colorShift", 0, 6.06, 0, 12.12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ed"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n    float angle = atan(uv.y, uv.x);\n    angle = ((angle / PI) + 1.0) * 0.5;\n    angle = mod(angle, 1.0 / sides) * sides;\n    angle = -abs(2.0 * angle - 1.0) + 1.0;\n    angle = angle;\n    float y = length(uv);\n    angle = angle * (y);\n    return vec2(angle, y) - offset;\n  } \n\n  vec4 hue(vec4 color, float shift) {\n    const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n    const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n    const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n    const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n    const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n    const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n    float YPrime = dot(color, kRGBToYPrime);\n    float I = dot(color, kRGBToI);\n    float Q = dot(color, kRGBToQ);\n    float hue = atan(Q, I);\n    float chroma = sqrt(I * I + Q * Q);\n    hue += shift;\n    Q = chroma * sin(hue);\n    I = chroma * cos(hue);\n    vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n    color.r = dot(yIQ, kYIQToR);\n    color.g = dot(yIQ, kYIQToG);\n    color.b = dot(yIQ, kYIQToB);\n    return color;\n  }\n\n  vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * PI * (c * t + d));\n  }\n\n  vec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n  }\n\n  mat2 rotate (float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n  }\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n\n    uv /= dot(uv, uv);\n    uv *= rotate(stream/2.);\n    float dist = length(tan(cos(uv-stream) - stream/1.));\n    for (float i = 0.; i < orbs; i++) {\n      uv += .005* dist*i * (uv);\n      float t = i * PI / orbs * 2.;\n      float x = radius * tan(t+stream/6.);\n      float y = radius * sin(t-stream/1.);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += orb(uv, orbSize, position, color, contrast);\n    }\n  }\n",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 1, false, false],
        ["contrast", 0, 2.93, 1, 5, false, false],
        ["orbSize", 0, 3, 0.01, 3, false, false],
        ["radius", 0, 21.13, 1, 50, false, false],
        ["colorShift", 0, 4, 4, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a70"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ff"
    },
    "shader": "#define BALLS 10.\n\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main() {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv.x += sin(stream/4.)*11.1*sin(stream)+uv.y/.2 + 20.*sin(uv.x*x1 - stream/1.);\n  uv.y *= .1*cos(stream)+(uv.y/.2 + 11.*sin(x2*uv.x-stream));\n  uv.x += .1*sin(.1*uv.y);\n  uv.y += .1*cos(.1*uv.x);\n  uv = abs(uv);\n  uv *= uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t =  float(i) * PI / BALLS;\n    vec2 p = vec2(i*sin(t)*xMul, uv.x);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * ballMul) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.35, 0, 311, false, false],
        ["contrast", 0, 0.48, 0, 3, false, false],
        ["ballSize", 0, 607.64, 0, 1101, false, false],
        ["x1", 0, 0.41, 0, 10, false, false],
        ["x2", 0, 0, 0, 1, false, false],
        ["ballMul", 0, 35.51, 0, 101, false, false],
        ["xMul", 0, 110, 1, 110, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a71"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca204"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 10.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .001 / dist * uv + yDot * cos(uv)) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t);\n    float y = radius * tan(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 4. * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.68, 0, 7.36, false, false],
        ["contrast", 0, 1.67, 0, 3.34, false, false],
        ["orbSize", 0, 0.07, 0, 0.14, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["colorShift", 0, 4.96, 0, 9.92, false, false],
        ["center", 0, 1.15, 0, 2.3, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 10, 0, 20, false, false],
        ["yDot", 0, 0.63, 0, 1.26, false, false],
        ["dotMul", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.740Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a72"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca181"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.234, 0, 2.78, false, false],
        ["orbSize", 0, 2.298, 0, 6, false, false],
        ["radius", 0, 20.95, 0, 41.9, false, false],
        ["colorShift", 0, 5.41, 0, 10.82, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.56, 0, 1.12, false, false],
        ["cosMul", 0, 0.88, 0, 1.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.56, 0, 1.12, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.65, 0, 7.3, false, false],
        ["xDivide", 0, 32.82, 0, 65.64, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.736Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a69"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca21c"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv /= dot(.01 * sin(uv + stream), 2. * cos(shape * uv + stream)) * 21.1 * tan(uv);\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation + stream / 2.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 3.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t * multiplier), 1. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.74, 0, 5.48, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 784.55, 0, 1569.1, false, false],
        ["ballSize", 0, 1.36, 0, 2.72, false, false],
        ["contrast", 0, 2.66, 0, 5.32, false, false],
        ["radius", 0, 43.22, 0, 86.44, false, false],
        ["yOuter", 0, 0.82, 0, 1.64, false, false],
        ["xOuter", 0, 0.92, 0, 1.84, false, false],
        ["rotation", 0, 1215, 0, 2430, false, false],
        ["shape", 0, 0.75, 0, 1.5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca248"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1*dot(uv, .01*uv));\n\tif (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(rotation*abs(sin(stream/1.))*(dist/.5)+stream/25.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider - stream/52.;\n    vec2 p = vec2(xOuter*(cos(.0*uv.x*-20.-stream))*uv.y*2.1/uv.x*3.+radius*cos(t+xMultiplier+stream/1.) * 20./cos(.1*uv.x + sin(uv.x/100.)), radius*cos((.1*uv.y*t+yMultiplier)+.1*stream)/stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10./length(uv)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.85, 0, 3.7, false, false],
        ["ballSize", 0, 646.744, 0, 1293.488, false, false],
        ["contrast", 0, 1.54, 0, 3.08, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1a1"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n\n  if (kaleidoscopeTween) {\n    if (kaleidoscope) {\n      uv = mix(uv, _kale, (kaleidoscopeTweenProgress));\n    } else {\n      uv = mix(_kale, uv, (kaleidoscopeTweenProgress));\n    }\n  } else if (kaleidoscope) {\n    uv = _kale;\n  }\n  uv /= dot(uv, uv);\n  uv = normalize(uv) * length((uv));\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(rotation);\n    float t = float(i) * PI / float(orbs) * (5. + 1.);\n    vec2 p = radius * vec2(-.5 * cos(t), .5 + 11.1 * tan(t + stream / 11.));\n    p /= sin(stream / 300. + PI * sin(uv.x / x) * cos(stream / 5. + uv.y / y));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 3000. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(-colorOffset + i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(abs(gl_FragColor.xyz)), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.0311, 0, 0.0622, false, false],
        ["ballSize", 0, 0.66, 0, 1.32, false, false],
        ["contrast", 0, 5, 0, 10, false, false],
        ["radius", 0, 1.64, 0, 3.28, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 81.64, 0, 163.28, false, false],
        ["y", 0, 128.04, 0, 256.08, false, false],
        ["rotation", 0, 0.5, 0, 1, false, false],
        ["colorOffset", 0, 0.77, 0, 1.54, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["kaleidoscope", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.737Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1ad"
    },
    "shader": "#define BALLS 30\n  \nmat2 rotate2d(float a){ return mat2(cos(a), asin(a), sin(a), cos(a)); }\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float x = radius*tan(t * multiplier + stream);\n    float y = radius*sin(t * multiplier + stream);\n    vec2 p = vec2(x, y);\n    vec3 base = vec3(0, 1, -1);\n    vec3 col = cos(base * PI * 2. / 3. + PI * (float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 2.11, 0, 4.22, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 1000, 0, 2000, false, false],
        ["multiplier", 0, 352.09, 0, 704.18, false, false],
        ["ballSize", 0, 0.05, 0, 0.1, false, false],
        ["contrast", 0, 2.73, 0, 5.46, false, false],
        ["radius", 0, 1, 0, 2, false, false],
        ["yOuter", 0, 1.16, 0, 2.32, false, false],
        ["xOuter", 0, 0.91, 0, 1.82, false, false],
        ["rotation", 0, 0.07, 0, 0.14, false, false],
        ["shape", 0, 1.54, 0, 3.08, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6b"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1be"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < 20.; i++) {\n    uv *= k_rotate2d(i * tan(i));\n    float t = i / PI / orbs * shape2;\n    float x = t * radius * sin(shape * dist + stream);\n    float y = i / 80.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += dist * k_hue(k_orb(uv, orbSize, position, color, contrast), stream / 2.);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5, 0, 10, false, false],
        ["contrast", 0, 1.1, 0, 2.2, false, false],
        ["orbSize", 0, 0.03, 0, 0.06, false, false],
        ["radius", 0, 2.1, 0, 4.2, false, false],
        ["colorShift", 0, 4.35, 0, 8.7, false, false],
        ["center", 0, 2.78, 0, 5.56, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["shape", 0, 5.5, 0, 11, false, false],
        ["shape2", 0, 1.42, 0, 2.84, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6e"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c1"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 4.) * .09 * cos(uv.y / yShape + stream / 2.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 166.94, 0, 333.88, false, false],
        ["yDivider", 0, 885.36, 0, 1770.72, false, false],
        ["xDivider", 0, 74.88, 0, 149.76, false, false],
        ["multiplier", 0, 3.5795, 0, 7.159, false, false],
        ["ballSize", 0, 27.44, 0, 54.88, false, false],
        ["contrast", 0, 1.88, 0, 3.76, false, false],
        ["radius", 0, 27.16, 0, 54.32, false, false],
        ["rotation", 0, 2.6, 0, 5.2, false, false],
        ["yDivide", 0, 520.47, 0, 1040.94, false, false],
        ["xDivide", 0, 0.56, 0, 1.12, false, false],
        ["yShape", 0, 100, 0, 200, false, false],
        ["shape", 0, 24.95, 0, 49.9, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.738Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca1c7"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv = abs(uv);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 20.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / .5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 10.;\n    float x = -1. * tan(t - stream / 5.); // + stream/100.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 161.64, 0, 323.28, false, false],
        ["yDivider", 0, 945.89, 0, 1891.78, false, false],
        ["xDivider", 0, 19.77, 0, 39.54, false, false],
        ["multiplier", 0, 1.4242, 0, 2.8484, false, false],
        ["ballSize", 0, 39.93, 0, 79.86, false, false],
        ["contrast", 0, 2.87, 0, 5.74, false, false],
        ["radius", 0, 31.79, 0, 63.58, false, false],
        ["rotation", 0, 89.48, 0, 178.96, false, false],
        ["yDivide", 0, 81.9, 0, 163.8, false, false],
        ["xDivide", 0, 0.41, 0, 0.82, false, false],
        ["yShape", 0, 14.73, 0, 29.46, false, false],
        ["shape", 0, 71.08, 0, 142.16, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.739Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6f"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca219"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.1 * ((uv)) - stream / 10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 2. - stream / 21.);\n    uv.x += xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.); // + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius * tan(t * multiplier), _radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 12.01, 0, 24.02, false, false],
        ["yDivider", 0, 232, 0, 464, false, false],
        ["xDivider", 0, 77.31, 0, 154.62, false, false],
        ["multiplier", 0, 69.13, 0, 138.26, false, false],
        ["ballSize", 0, 1.56, 0, 3.12, false, false],
        ["contrast", 0, 3.98, 0, 7.96, false, false],
        ["radius", 0, 57.1, 0, 114.2, false, false],
        ["yOuter", 0, 0.73, 0, 1.46, false, false],
        ["xOuter", 0, 0.7, 0, 1.4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca230"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * abs(sin(stream / 1.)) * (dist / .5) + stream / 25.);\n    float t = .02 * PI / float(BALLS) * (5. + 1.) / divider - stream / 52.;\n    vec2 p = vec2(xOuter * (cos(.0 * uv.x * -20. - stream)) * uv.y * 2.1 / uv.x * 3. + radius * cos(t + xMultiplier + stream / 1.) * 20. / cos(.1 * uv.x + sin(uv.x / 100.)), radius * cos((.1 * uv.y * t + yMultiplier) + .1 * stream) / stream);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(10. / length(uv) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.85, 0, 3.7, false, false],
        ["ballSize", 0, 646.744, 0, 1293.488, false, false],
        ["contrast", 0, 1.54, 0, 3.08, false, false],
        ["radius", 0, 115, 0, 230, false, false],
        ["yOuter", 0, 295.45, 0, 590.9, false, false],
        ["xOuter", 0, 2401, 0, 4802, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 74.08, 0, 148.16, false, false],
        ["yMultiplier", 0, 52.27, 0, 104.54, false, false],
        ["divider", 0, 3, 0, 6, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca236"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = PI / float(BALLS) * (float(i)); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.72, 0, 1.44, false, false],
        ["ballSize", 0, 155.087, 0, 310.174, false, false],
        ["contrast", 0, 2.79, 0, 5.58, false, false],
        ["radius", 0, 363.58, 0, 727.16, false, false],
        ["yOuter", 0, 27.3, 0, 54.6, false, false],
        ["xOuter", 0, 21.98, 0, 43.96, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 27.87, 0, 55.74, false, false],
        ["yMultiplier", 0, 33.47, 0, 66.94, false, false],
        ["divider", 0, 5, 0, 10, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca23b"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= vec2(10.1 * dot(uv, .01 * uv));\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * (dist / .5) + stream / 50.);\n    float t = .01 * PI / float(BALLS) * (5. + 1.); // - stream/100.;\n    vec2 p = vec2(xOuter * (sin(.01 * uv.x - stream)) * uv.y * 2.1 + radius * cos(t + xMultiplier + stream / 1.) * (.201 * uv.x + sin(uv.y / .1)), length(.1 * (uv)));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.05, 0, 0.1, false, false],
        ["ballSize", 0, 835.689, 0, 1671.378, false, false],
        ["contrast", 0, 2.79, 0, 5.58, false, false],
        ["radius", 0, 172.51, 0, 345.02, false, false],
        ["yOuter", 0, 27.3, 0, 54.6, false, false],
        ["xOuter", 0, 97.47, 0, 194.94, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["xMultiplier", 0, 27.87, 0, 55.74, false, false],
        ["yMultiplier", 0, 79.96, 0, 159.92, false, false],
        ["divider", 0, 0, 0, 0, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a75"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca252"
    },
    "shader": "void main() {\n  vec2 uv = k_uv(); uv *= zoom;\n  uv = abs(fract(uv) - .5) * 2.1;\n  uv = abs(fract(uv) - .5) * .1;\n  uv *= 2. * cos(uv.x / 50. + stream / 11.) - .1;\n  vec4 result = vec4(0, 0, 0, 1);\n  float t = 1.8;\n  float base = 1000. * length(uv);\n  for (int p = 0; p < 3; p++) {\n    float a = cos((t * base) - stream / 1.);\n    float b = cos(shape * uv.x / .25 - stream /2.);\n    result[p] = 2.52 * a + 1.7 * b + base / 1000.;\n    t += 2.6;\n  }\n  result.xyz *= brightness * result.x;\n  result.xyz = (result.xyz);\n  result.xy *= abs(tan(uv.x*multiplier));\n  gl_FragColor =  2.-log(1.-abs(result));\n  gl_FragColor.r *= red;\n  gl_FragColor.g *= green;\n  gl_FragColor.b *= blue;\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.0039, 0, 0.01, false, false],
        ["brightness", 0, 58.03, 0, 100, false, false],
        ["red", 0, 0.2, 0, 1, false, false],
        ["green", 0, 0.17, 0, 1, false, false],
        ["blue", 0, 0.81, 0, 1, false, false],
        ["shape", 0, 765.37, 0, 1000, false, false],
        ["multiplier", 0, 17.79, 0, 100, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a76"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca20c"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += cos(uv.y / yDivider + stream / 2.) + sin(uv.x / 3. / stream / 2.);\n    uv.x += sin(uv.x / xDivider - stream / 2.) * sin(uv.y / 3. + stream / 2.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream / 10.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -1. * tan(t + multiplier), radius * sin(t - multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50, 0, 100, false, false],
        ["yDivider", 0, 0.73, 0, 1.46, false, false],
        ["xDivider", 0, 9.13, 0, 18.26, false, false],
        ["multiplier", 0, 111, 0, 222, false, false],
        ["ballSize", 0, 0.23, 0, 0.46, false, false],
        ["contrast", 0, 1.61, 0, 3.22, false, false],
        ["radius", 0, 38.96, 0, 77.92, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.741Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a73"
    }
  },
  {
    "_id": {
      "$oid": "66dcff64bf713fefd607ef27"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.02716, 0, 0.1, false],
        ["shapeMultiplier", 0, 35.24037, 0, 2000, false],
        ["rotation", 0, 0.1, 0, 0.1, false],
        ["xMultiplier", 0, 605.52337, 0, 1500, false],
        ["yMultiplier", 0, 396.72118, 0, 1000, false],
        ["colorSpread", 0, 0.00243, 0.001, 0.009, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:35:32.734Z"
    },
    "updated": {
      "$date": "2024-09-08T01:35:32.734Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dcff77bf713fefd607f759"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00692, 0, 0.1, false],
        ["shapeMultiplier", 0, 1043.21, 0, 2000, false],
        ["rotation", 0, 0.1, 0, 0.1, false],
        ["xMultiplier", 0, 605.52337, 0, 1500, false],
        ["yMultiplier", 0, 396.72118, 0, 1000, false],
        ["colorSpread", 0, 0.00243, 0.001, 0.009, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:35:51.023Z"
    },
    "updated": {
      "$date": "2024-09-08T01:35:51.023Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dcfd1389eb98559dc7219f"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:25:39.089Z"
    },
    "updated": {
      "$date": "2024-09-08T01:25:39.090Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd0078bd48cb9e42ad74f2"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:40:08.075Z"
    },
    "updated": {
      "$date": "2024-09-08T01:40:08.075Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca262"
    },
    "shader": "  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n//  uv *= rotate(-stream/10.);\n//  uv = kale(uv, vec2(0.),sides);\n  //uv *= rotate(stream/5.);\n  //uv *= rotate(rotation*stream/5.);\n  \n  uv /= dot(uv, uv);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/50.);\n    float y = radius * cos(t+stream/50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, 1.-color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.39, 0, 2.78, false, false],
        ["orbSize", 0, 3, 0, 6, false, false],
        ["radius", 0, 20.95, 0, 41.9, false, false],
        ["colorShift", 0, 5.41, 0, 10.82, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.56, 0, 1.12, false, false],
        ["cosMul", 0, 0.88, 0, 1.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.56, 0, 1.12, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, -2, 0, -4, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.65, 0, 7.3, false, false],
        ["xDivide", 0, 32.82, 0, 65.64, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a7a"
    }
  },
  {
    "_id": {
      "$oid": "66dcffb5bf713fefd607f75d"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:36:53.699Z"
    },
    "updated": {
      "$date": "2024-09-08T01:36:53.699Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dcffe4bf713fefd607f75f"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.02007, 0, 0.1, false],
        ["shapeMultiplier", 0, 1296.93278, 0, 2000, false],
        ["rotation", 0, 0.04008, 0, 0.1, false],
        ["xMultiplier", 0, 1500, 0, 1500, false],
        ["yMultiplier", 0, 1000, 0, 1000, false],
        ["colorSpread", 0, 0.00165, 0.001, 0.009, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:37:40.071Z"
    },
    "updated": {
      "$date": "2024-09-08T01:37:40.071Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd008762b27cec843af06c"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:40:23.234Z"
    },
    "updated": {
      "$date": "2024-09-08T01:40:23.234Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca25e"
    },
    "shader": "#define orbs 5.\n\nvec4 k_orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) / color, 1.), vec4(contrast));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  uv *= outer * sin(inner * dot(uv, uv) - stream);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n    }\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x1 = radius * cos(t - stream);\n    float y1 = radius * sin(t + stream);\n    float x2 = radius * tan(t - stream);\n    float y2 = radius * sin(t - stream);\n    float x = x1;\n    float y = y1;\n    if (warpTween) {\n      if (warp) {\n        x = mix(x1, x2, warpTweenProgress);\n        y = mix(y1, y2, warpTweenProgress);\n      } else {\n        x = mix(x2, x1, warpTweenProgress);\n        y = mix(y2, y1, warpTweenProgress);\n      }\n    } else if (warp) {\n      x = x2;\n      y = y2;\n    }\n    float dist = length(uv);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor -= k_orb(uv, dist * orbSize, position, log(color), contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.58, 0, 1.16, false, false],
        ["contrast", 0, 0.88, 0, 1.76, false, false],
        ["orbSize", 0, 0.0011, 0, 0.0022, false, false],
        ["radius", 0, 0.44, 0, 0.88, false, false],
        ["colorShift", 0, 2.5, 0, 5, false, false],
        ["center", 0, 1.73, 0, 3.46, false, false],
        ["sides", 0, 7, 0, 14, false, false],
        ["warp", 1, false, null, null, null, false],
        ["inner", 0, 5.19, 0, 10.38, false, false],
        ["outer", 0, 10, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca229"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  vec2 uv1 = normalize((uv)) / length(uv);\n\tif (mirrorTween) {\n   \tif (mirror) {\n    \tuv = mix(uv, abs(uv), float(mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, float(mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  uv /= dot(.002*sin(uv+stream/5.),cos(shape*sin(uv)+stream/.5))*21.1*tan(uv);\n  uv *= rotate2d(rotation * stream/.8);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/1.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/1.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier+stream/5.), 2.*radius*sin(t*multiplier-stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 3.88, 0, 5, false, false],
        ["yDivider", 0, 1000, 0.1, 1000, false, false],
        ["xDivider", 0, 1000, 0.1, 1000, false, false],
        ["multiplier", 0, 0.1, 0.1, 1101, false, false],
        ["ballSize", 0, 3.24, 0, 21, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 18.53, 0, 111, false, false],
        ["yOuter", 0, 0, 0, 2, false, false],
        ["xOuter", 0, 0, 0, 2, false, false],
        ["rotation", 0, 0.55, 0, 1, false, false],
        ["shape", 0, 10, 0, 10, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.742Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a74"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca25b"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10./dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.47, 0, 4.94, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["orbSize", 0, 0.51, 0, 1.02, false, false],
        ["radius", 0, 5.46, 0, 10.92, false, false],
        ["colorShift", 0, 7.8, 0, 15.6, false, false],
        ["center", 0, 2.76, 0, 5.52, false, false],
        ["sides", 0, 15, 0, 30, false, false],
        ["shape", 0, 0.18, 0, 0.36, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca260"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.11, 0, 0.22, false, false],
        ["yDivider", 0, 825.61, 0, 1651.22, false, false],
        ["xDivider", 0, 794.72, 0, 1589.44, false, false],
        ["multiplier", 0, 6.36, 0, 12.72, false, false],
        ["ballSize", 0, 0.46, 0, 0.92, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.94, 0, 19.88, false, false],
        ["xOuter", 0, 0.16, 0, 0.32, false, false],
        ["yOuter", 0, 0.7, 0, 1.4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a7a"
    }
  },
  {
    "_id": {
      "$oid": "66dcff99bf713fefd607f75b"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:36:25.378Z"
    },
    "updated": {
      "$date": "2024-09-08T01:36:25.378Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd02ef227f7b820e8aa374"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00346, 0, 0.1, false],
        ["shapeMultiplier", 0, 119.04997, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 1022.62345, 0, 1500, false],
        ["yMultiplier", 0, 885.86978, 1, 1000, false],
        ["colorSpread", 0, 0.00103, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.78876, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:50:39.687Z"
    },
    "updated": {
      "$date": "2024-09-08T01:50:39.687Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca259"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1. / length(uv) * 20. * uv) - stream / 3.)) * length(uv);\n  //  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv + stream), cos(uv + stream));\n  // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= k_rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n    uv.y += yOuter * sin(uv.y / yDivider + stream / 5.) / 1. * sin(uv.x / 1. - stream / 1.);\n    uv.x -= xOuter * sin(uv.x / xDivider - stream / 5.) / 1. * sin(uv.x / 1.1 + stream / 1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.); // + stream/5000.;\n    float _multiplier = dist * multiplier * sin(uv.x);\n    vec2 p = vec2(radius * -2. * tan(t * multiplier), 2. * radius * sin(t * multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 10.36, 0, 20.72, false, false],
        ["yDivider", 0, 27.34, 0, 54.68, false, false],
        ["xDivider", 0, 10.17, 0, 20.34, false, false],
        ["multiplier", 0, 287.12, 0, 574.24, false, false],
        ["ballSize", 0, 1.13, 0, 2.26, false, false],
        ["contrast", 0, 1.41, 0, 2.82, false, false],
        ["radius", 0, 11, 0, 22, false, false],
        ["yOuter", 0, 0.3, 0, 0.6, false, false],
        ["xOuter", 0, 1, 0, 2, false, false],
        ["rotation", 0, 5, 0, 10, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66dd0307227f7b820e8aabb2"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00271, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 1022.62345, 0, 1500, false],
        ["yMultiplier", 0, 1, 1, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.78876, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:51:03.553Z"
    },
    "updated": {
      "$date": "2024-09-08T01:51:03.553Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca257"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(cos(.3*(uv + sin(5.*uv))-stream/10.)) * length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/2. - stream/21.);\n    uv.x += xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/21.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/2000.;\n    float _radius = radius;\n    vec2 p = vec2(_radius*tan(t*multiplier), _radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = (pow(gl_FragColor.xyz, vec3(contrast)));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 7.84, 0, 150, false, false],
        ["yDivider", 0, 232, 0.1, 1000, false, false],
        ["xDivider", 0, 77.31, 0.1, 1000, false, false],
        ["multiplier", 0, 69.13, 0.1, 111, false, false],
        ["ballSize", 0, 2.31, 0, 7, false, false],
        ["contrast", 0, 1.79, 0, 5, false, false],
        ["radius", 0, 57.1, 0, 1111, false, false],
        ["yOuter", 0, 0.73, 0, 1, false, false],
        ["xOuter", 0, 0.7, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca25a"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/19.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(kale(uv, vec2(center), sides)-stream);\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.21, 0, 28.66, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 6.4, 0, 12.8, false, false],
        ["colorShift", 0, 5.57, 0, 11.14, false, false],
        ["center", 0, 2.71, 0, 5.42, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.18, 0, 0.36, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kkk", 1, false, null, null, null, false],
        ["base", 0, 7.16, 0, 14.32, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca25d"
    },
    "shader": "\n#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (10./dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 2.47, 0, 3, false, false],
        ["contrast", 0, 1.96, 0, 2, false, false],
        ["orbSize", 0, 0.51, 0.01, 1, false, false],
        ["radius", 0, 5.46, 1, 15, false, false],
        ["colorShift", 0, 7.8, 4, 10, false, false],
        ["center", 0, 2.76, 0, 5, false, false],
        ["sides", 0, 15, 0, 22, false, false],
        ["shape", 0, 0.18, 0, 1, false, false],
        ["warp", 1, false, null, null, null, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd01e9227f7b820e8a7224"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.02603, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.01861, 0, 0.1, false],
        ["xMultiplier", 0, 613.11725, 0, 1500, false],
        ["yMultiplier", 0, 238.0321, 1, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.68553, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.00144, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:46:17.271Z"
    },
    "updated": {
      "$date": "2024-09-08T01:46:17.271Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd03e3227f7b820e8ad4f6"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00271, 0, 0.1, false],
        ["shapeMultiplier", 0, 11198.13317, 0, 12000, false],
        ["rotation", 0, 0.0093, 0, 0.1, false],
        ["xMultiplier", 0, 1076.67056, 0, 1500, false],
        ["yMultiplier", 0, 166.57476, 1, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.09682, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 1.25843, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 9.85346, 0, 20, false],
        ["col", 0, 0.1838, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:54:43.966Z"
    },
    "updated": {
      "$date": "2024-09-08T01:54:43.966Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca25c"
    },
    "shader": "\n#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/19.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(kale(uv, vec2(center), sides)-stream);\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i/.5*PI);\n    float t = i / PI / orbs * 10.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist-stream)*sin(dist-stream/2.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 4.33, 0, 9, false, false],
        ["contrast", 0, 1.96, 0, 2, false, false],
        ["orbSize", 0, 0.58, 0.01, 1, false, false],
        ["radius", 0, 6.4, 1, 15, false, false],
        ["colorShift", 0, 5.57, 4, 10, false, false],
        ["center", 0, 2.71, 0, 5, false, false],
        ["sides", 0, 5, 0, 12, false, false],
        ["shape", 0, 0.18, 0, 1, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kkk", 1, false, null, null, null, false],
        ["base", 0, 7.16, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd0261227f7b820e8a8290"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.0048, 0, 0.1, false],
        ["shapeMultiplier", 0, 16.45342, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 163.59483, 0, 1500, false],
        ["yMultiplier", 0, 885.86978, 1, 1000, false],
        ["colorSpread", 0, 0.00103, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.78876, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:48:17.515Z"
    },
    "updated": {
      "$date": "2024-09-08T01:48:17.515Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd0384227f7b820e8ac472"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00271, 0, 0.1, false],
        ["shapeMultiplier", 0, 11198.13317, 0, 12000, false],
        ["rotation", 0, 0.0093, 0, 0.1, false],
        ["xMultiplier", 0, 1076.67056, 0, 1500, false],
        ["yMultiplier", 0, 166.57476, 1, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.09682, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 1.25843, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 9.85346, 0, 20, false],
        ["col", 0, 1.45043, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:53:08.746Z"
    },
    "updated": {
      "$date": "2024-09-08T01:53:08.746Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca256"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation+stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 13.18, 0, 26.36, false, false],
        ["yDivider", 0, 1000, 0, 2000, false, false],
        ["xDivider", 0, 915.81, 0, 1831.62, false, false],
        ["multiplier", 0, 90.94, 0, 181.88, false, false],
        ["ballSize", 0, 0.73, 0, 1.46, false, false],
        ["contrast", 0, 1.62, 0, 3.24, false, false],
        ["radius", 0, 14.78, 0, 29.56, false, false],
        ["yOuter", 0, 0.31, 0, 0.62, false, false],
        ["xOuter", 0, 0.33, 0, 0.66, false, false],
        ["rotation", 0, 3.83, 0, 7.66, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca258"
    },
    "shader": "\n#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(1./length(uv)*20.*uv)-stream/3.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 10.36, 0, 30, false, false],
        ["yDivider", 0, 27.34, 0.1, 1000, false, false],
        ["xDivider", 0, 10.17, 0.1, 1000, false, false],
        ["multiplier", 0, 287.12, 0.1, 1101, false, false],
        ["ballSize", 0, 1.13, 0, 2, false, false],
        ["contrast", 0, 1.41, 0, 5, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["yOuter", 0, 0.3, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a77"
    }
  },
  {
    "_id": {
      "$oid": "66dcfe9849312c93e1e4e112"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:32:08.205Z"
    },
    "updated": {
      "$date": "2024-09-08T01:32:08.205Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dcff2cbf713fefd607e6f7"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:34:36.558Z"
    },
    "updated": {
      "$date": "2024-09-08T01:34:36.558Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd02a6227f7b820e8a9300"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00853, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 1022.62345, 0, 1500, false],
        ["yMultiplier", 0, 885.86978, 1, 1000, false],
        ["colorSpread", 0, 0.00103, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.78876, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:49:26.197Z"
    },
    "updated": {
      "$date": "2024-09-08T01:49:26.197Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd0444227f7b820e8af1e1"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 2.653, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:56:20.058Z"
    },
    "updated": {
      "$date": "2024-09-08T01:56:20.058Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd0033bf713fefd607ff90"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:38:59.297Z"
    },
    "updated": {
      "$date": "2024-09-08T01:38:59.297Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd0100227f7b820e8a5156"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00675, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:42:24.511Z"
    },
    "updated": {
      "$date": "2024-09-08T01:42:24.511Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66d11670577f4e8cedfca261"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)*cos(uv.y/yDivider + stream/11.) + sin(uv.x/21. - stream/8.);\n    uv.x += yOuter*float(i)*sin(uv.x/xDivider - stream/11.) - 2.*sin(uv.y/20. + stream/5.);\n    float t = .01*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist/multiplier * sin(uv.x-stream/1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p /= sin(PI * sin(uv.x/10.)*cos(uv.y/11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 50. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.03, 0, 0.06, false, false],
        ["yDivider", 0, 825.61, 0, 1651.22, false, false],
        ["xDivider", 0, 794.72, 0, 1589.44, false, false],
        ["multiplier", 0, 6.36, 0, 12.72, false, false],
        ["ballSize", 0, 0.37, 0, 0.74, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 2.4, 0, 4.8, false, false],
        ["xOuter", 0, 0.16, 0, 0.32, false, false],
        ["yOuter", 0, 0.7, 0, 1.4, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "updated": {
      "$date": "2024-08-30T00:46:40.743Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a7a"
    }
  },
  {
    "_id": {
      "$oid": "66dd00f74e7cc2277772bfd9"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.02969, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:42:15.387Z"
    },
    "updated": {
      "$date": "2024-09-08T01:42:15.387Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd013d227f7b820e8a598a"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.02539, 0, 0.1, false],
        ["shapeMultiplier", 0, 357.50588, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 163.59483, 0, 1500, false],
        ["yMultiplier", 0, 885.86978, 1, 1000, false],
        ["colorSpread", 0, 0.00103, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.78876, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 35.43942, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 19.60172, 0, 20, false],
        ["col", 0, 0.12518, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:43:25.863Z"
    },
    "updated": {
      "$date": "2024-09-08T01:43:25.863Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd0329227f7b820e8ab3f2"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00271, 0, 0.1, false],
        ["shapeMultiplier", 0, 11198.13317, 0, 12000, false],
        ["rotation", 0, 0.0093, 0, 0.1, false],
        ["xMultiplier", 0, 1076.67056, 0, 1500, false],
        ["yMultiplier", 0, 166.57476, 1, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.09682, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.75866, 0, 10, false],
        ["ballSize", 0, 1.25843, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.61461, 0, 5, false],
        ["radius", 0, 9.85346, 0, 20, false],
        ["col", 0, 0.71116, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:51:37.947Z"
    },
    "updated": {
      "$date": "2024-09-08T01:51:37.947Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dcff72bf713fefd607f757"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00692, 0, 0.1, false],
        ["shapeMultiplier", 0, 1043.21, 0, 2000, false],
        ["rotation", 0, 0.1, 0, 0.1, false],
        ["xMultiplier", 0, 605.52337, 0, 1500, false],
        ["yMultiplier", 0, 396.72118, 0, 1000, false],
        ["colorSpread", 0, 0.00243, 0.001, 0.009, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.22730139307228922, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:35:46.251Z"
    },
    "updated": {
      "$date": "2024-09-08T01:35:46.251Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66dd048c227f7b820e8b0ed3"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01296, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:57:32.895Z"
    },
    "updated": {
      "$date": "2024-09-08T01:57:32.895Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dfce23d8fb699c09593de1"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.1 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 3. * PI);\n    float t = i / PI / orbs * 2.;\n    float a = (base / dist) / t * radius;\n    float b = dist - t + uv.y / yDiv;\n    float c = cos(uv.y / 1.215 - stream / .5);\n    float d = cos(uv.x / 22.5 * dist / 1.125 - stream);\n    float x = a / sin(stream / - 11.5 + b) + c - d;\n    float y = 10. - x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 20.07337, 0, 50, false],
        ["contrast", 0, 1.58057, 0, 3.92, false],
        ["orbSize", 0, 1.65542, 0, 12.16, false],
        ["radius", 0, 0.04126, 0, 0.2, false],
        ["colorShift", 0, 10.65137, 0, 11.14, false],
        ["base", 0, 195.45747, 0, 1122, false],
        ["yDiv", 0, 5, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T04:42:11.123Z"
    },
    "updated": {
      "$date": "2024-09-10T04:42:11.123Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd12ff227f7b820e8b6e89"
    },
    "shader": "void main () {\n  float stream = stream / 4.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -5.);\n  for (float i = 0.; i < 10.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / .5);\n    float b = radius * sin(uv.y + stream / -1.);\n    float c = radius * wave * sin(split * uv.x - stream /11.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume, 1.2)/1.1 * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.42716, 0, 3, false],
        ["iterator", 0, 1.88938, 0.7, 2.5, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 1.24012, 0, 3, false],
        ["orbSize", 0, 0.37995, 0, 1, false],
        ["div", 0, 7.54191, 0.01, 15, false],
        ["radius", 0, 5.73635, 0, 6, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:59:11.248Z"
    },
    "updated": {
      "$date": "2024-09-08T02:59:11.248Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66dfab77d8fb699c0958dd13"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.99628, 0, 50, false],
        ["contrast", 0, 2.45377, 0, 3.92, false],
        ["orbSize", 0, 1.83289, 0, 12.16, false],
        ["radius", 0, 23.19695, 0, 25, false],
        ["colorShift", 0, 10.73398, 0, 11.14, false],
        ["base", 0, 1.07505, 0, 22, false],
        ["yDiv", 0, 1.00273, 0, 5, false]
      ],
      [
        ["zoom", 0, 22.13005, 0, 50, false],
        ["contrast", 0, 2.59269, 0, 3.92, false],
        ["orbSize", 0, 1.33992, 0, 12.16, false],
        ["radius", 0, 0.67056, 0, 7, false],
        ["colorShift", 0, 11.14, 0, 11.14, false],
        ["base", 0, 26.14888, 0, 143.32, false],
        ["yDiv", 0, 5, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T02:14:15.691Z"
    },
    "updated": {
      "$date": "2024-09-10T02:14:15.691Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfdf39d8fb699c09594667"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.99162, 0, 50, false],
        ["contrast", 0, 1.90539, 0, 3.92, false],
        ["orbSize", 0, 2.46341, 0, 12.16, false],
        ["radius", 0, 0.39591, 0, 2, false],
        ["colorShift", 0, 7.70505, 0, 11.14, false],
        ["base", 0, 12.81943, 0, 222, false],
        ["yDiv", 0, 0.99897, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T05:55:05.163Z"
    },
    "updated": {
      "$date": "2024-09-10T05:55:05.163Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd049e227f7b820e8b0ed7"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.00285, 0, 0.1, false],
        ["shapeMultiplier", 0, 2000, 0, 2000, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 1500, 0, 1500, false],
        ["yMultiplier", 0, 973.9949, 0, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 8.116722760819773, 0, 20, false, false],
        ["col", 0, 0.25801, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T01:57:50.194Z"
    },
    "updated": {
      "$date": "2024-09-08T01:57:50.194Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a34"
    }
  },
  {
    "_id": {
      "$oid": "66dd0b28227f7b820e8b40bd"
    },
    "shader": "\n\nvoid main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.00405, 0, 1, false, false],
        ["iterator", 0, 4.01438, 0, 13, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.98477, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.07321, 0, 2, false, false],
        ["colorOffset", 0, 3.28169, 0, 111, false, false],
        ["contrast", 0, 1.5999623493975905, 0, 3, false, false],
        ["orbSize", 0, 0.54407, 0, 2, false, false],
        ["div", 0, 0.02688, 0.01, 1, false, false],
        ["radius", 0, 2.54727, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:25:44.343Z"
    },
    "updated": {
      "$date": "2024-09-08T02:25:44.343Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66df8ccfd8fb699c0958bfaa"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/4.);\n  uv /= dot(uv, uv); \n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.+dist-t + uv.x/1.5)-(cos(uv.x/11.1*dist-stream/2.)*sin(uv.y*dist/11.-stream));\n    float y = 1.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.18736, 0, 2, false],
        ["contrast", 0, 2.48958, 0, 3.92, false],
        ["orbSize", 0, 4.29365, 0, 12.16, false],
        ["radius", 0, 2.95825, 0, 7, false],
        ["colorShift", 0, 4.36198, 0, 11.14, false],
        ["base", 0, 44.43269, 0, 143.32, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T00:03:27.090Z"
    },
    "updated": {
      "$date": "2024-09-10T00:03:27.090Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfd65ad8fb699c09594663"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.2 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 1.2 * PI);\n    float t = i / PI / orbs * .5;\n    float a = radius * (base / dist/2.) / t;\n    float b = dist * fatness + t + uv.y/.5 / yDiv;\n    float c = cos(uv.y * yDiv2 - stream / .5);\n    float d = (c - a / b) - (a * b) - c;\n    float x = b / sin(stream - b) - d;\n    float y = offset - x;\n    vec2 position = vec2(x, y);\n    vec3 base = vec3(-2, 0, -1);\n    vec3 shift = cos(base * PI * 2. / 3. + PI * float(i) / colorShift);\n    vec3 color = shift * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 31.98232, 0, 50, false],
        ["contrast", 0, 2.22911, 0, 3.92, false],
        ["orbSize", 0, 11.05142, 0, 12.16, false],
        ["radius", 0, 0.10555, 0, 0.2, false],
        ["colorShift", 0, 10.0169, 0, 11.14, false],
        ["base", 0, 255.09985, 0, 1122, false],
        ["yDiv", 0, 25, 0, 25, false],
        ["yDiv2", 0, 5.3423, 0, 12, false],
        ["yDiv3", 0, 31.33395, 0, 112, false],
        ["offset", 0, 16.65481, 0, 21, false],
        ["fatness", 0, 0.35498, 0.3, 0.7, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T05:17:14.760Z"
    },
    "updated": {
      "$date": "2024-09-10T05:17:14.760Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfbd71d8fb699c09592053"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-.5 - uv.y/dist*uv.y/yDiv)-(cos(uv.x/20.15+dist-stream/2.5)*cos(uv.x/zoom*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.1146, 0, 50, false],
        ["contrast", 0, 1.88453, 0, 3.92, false],
        ["orbSize", 0, 1.64892, 0, 12.16, false],
        ["radius", 0, 0.23628, 0, 4, false],
        ["colorShift", 0, 9.99002, 0, 11.14, false],
        ["base", 0, 83.54579, 0, 222, false],
        ["yDiv", 0, 0.55807, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T03:30:57.265Z"
    },
    "updated": {
      "$date": "2024-09-10T03:30:57.265Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd1656227f7b820e8b72bf"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}  ",
    "variants": [
      [
        ["zoom", 0, 3.53768, 0, 15, false],
        ["yDivider", 0, 67.32, 0.1, 333, false, false],
        ["xDivider", 0, 0.48, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.101, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 9.38, 0, 12, false, false],
        ["xOuter", 0, 2.47, 0, 11, false, false],
        ["yOuter", 0, 0.21, 0, 1, false, false],
        ["xDiv", 0, 26.512, 0, 111, false, false],
        ["xDiv2", 0, 0.321, 0, 4, false, false],
        ["warp", 0, 321, 0, 321, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T03:13:26.803Z"
    },
    "updated": {
      "$date": "2024-09-08T03:13:26.803Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66dfcb47d8fb699c09593569"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/10.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 16.07471, 0, 50, false],
        ["contrast", 0, 2.45323, 0, 3.92, false],
        ["orbSize", 0, 2.20514, 0, 12.16, false],
        ["radius", 0, 0.02982, 0, 2, false],
        ["colorShift", 0, 6.28168, 0, 11.14, false],
        ["base", 0, 149.73706, 0, 222, false],
        ["yDiv", 0, 0.71914, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T04:29:59.465Z"
    },
    "updated": {
      "$date": "2024-09-10T04:29:59.465Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd058e227f7b820e8b1f7b"
    },
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.05976, 0, 1, false],
        ["iterator", 0, 3.15546, 0, 13, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.27344, 0, 33, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.24399, 0, 2, false],
        ["colorOffset", 0, 3.29047, 0, 111, false],
        ["contrast", 0, 1.85237, 0, 3, false],
        ["orbSize", 0, 0.21935, 0, 2, false],
        ["div", 0, 0.08058, 0.01, 1, false],
        ["radius", 0, 1.75561, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:01:50.214Z"
    },
    "updated": {
      "$date": "2024-09-08T02:01:50.214Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66df8568d8fb699c095891ac"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/-60.);\n  for (float i = 10.; i < 30.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume,1.1) * orbSize, vec2(radius*abs(tan(stream/11.3+uv.x/div)) * L *\n                                                              sin(stream/3.7 - uv.y), radius*cos(stream/1.93+uv.y/div)), \n                          col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.19552, 0, 1, false],
        ["iterator", 0, 1.07394, 0, 2, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 2.139, 0, 3, false, false],
        ["K", 0, 3.881, 0, 11, false, false],
        ["iterations", 0, 19.56624, 0, 33, false],
        ["L", 0, 1.457, 1, 2, false, false],
        ["M", 0, 0.358, 0, 1, false, false],
        ["colorShift", 0, 0.572, 0, 2, false, false],
        ["colorOffset", 0, 23.207, 0, 111, false, false],
        ["contrast", 0, 1.392, 0, 3, false, false],
        ["orbSize", 0, 0.60462, 0, 2, false],
        ["div", 0, 0.04509, 0.01, 12, false],
        ["radius", 0, 12, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-09T23:31:52.163Z"
    },
    "updated": {
      "$date": "2024-09-09T23:31:52.163Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66e0a560e2bae2208f72bc32"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 6.14333, 0, 50, false],
        ["contrast", 0, 2.38222, 0, 3.92, false],
        ["orbSize", 0, 3.82232, 0, 12.16, false],
        ["radius", 0, 0.64054, 0, 2, false],
        ["colorShift", 0, 0.72369, 0, 11.14, false],
        ["base", 0, 6.34386, 0, 222, false],
        ["yDiv", 0, 0.79904, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T20:00:32.222Z"
    },
    "updated": {
      "$date": "2024-09-10T20:00:32.222Z"
    },
    "__v": 3,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd164c227f7b820e8b72bb"
    },
    "shader": "#define BALLS 10\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-34. + length(uv/warp));\n  uv.x += sin(uv.y/30. - stream/100.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += xOuter*float(i)/4.*sin(uv.y/yDivider - stream/9.) * sin(uv.x/xDiv - stream/10.05);\n    uv.x += yOuter*float(i)/1.95*cos(uv.y/xDivider - stream/31.) * cos(uv.x/xDiv2 - stream/-.695);\n    float t = float(i) * PI / float(BALLS) * (1. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), 1.*sin(t/multiplier));\n    p += float(i)*tan(PI * sin(uv.y/15. + stream/5.)*cos(uv.x/15. - stream/5.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4((float(i)*ballSize*pow(volume, 1.0)) / length(uv - p * 0.9) * col * (length(1./uv)), contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 10.38671, 0, 15, false],
        ["yDivider", 0, 67.32, 0.1, 333, false, false],
        ["xDivider", 0, 0.48, 0.1, 1, false, false],
        ["multiplier", 0, 0.57, 0.01, 12, false, false],
        ["ballSize", 0, 0.101, 0, 0.3, false, false],
        ["contrast", 0, 0.7, 0, 5, false, false],
        ["radius", 0, 9.38, 0, 12, false, false],
        ["xOuter", 0, 2.47, 0, 11, false, false],
        ["yOuter", 0, 0.21, 0, 1, false, false],
        ["xDiv", 0, 26.512, 0, 111, false, false],
        ["xDiv2", 0, 0.321, 0, 4, false, false],
        ["warp", 0, 321, 0, 321, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T03:13:16.690Z"
    },
    "updated": {
      "$date": "2024-09-08T03:13:16.690Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a4f"
    }
  },
  {
    "_id": {
      "$oid": "66df9fa4d8fb699c0958bfb4"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 22.13005, 0, 50, false],
        ["contrast", 0, 1.98004, 0, 3.92, false],
        ["orbSize", 0, 2.38453, 0, 12.16, false],
        ["radius", 0, 1.139, 0, 7, false],
        ["colorShift", 0, 7.39311, 0, 11.14, false],
        ["base", 0, 23.31462, 0, 143.32, false],
        ["yDiv", 0, 0.97397, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T01:23:48.504Z"
    },
    "updated": {
      "$date": "2024-09-10T01:23:48.504Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfd23dd8fb699c09593de7"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv() * zoom;\n  float dist = length(uv);\n  uv *= dist * length(.1 * sin(uv - stream / .91));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i / 3. * PI);\n    float t = i / PI / orbs * 2.;\n    float a = (base / dist) / t * radius;\n    float b = dist - t + uv.y / yDiv;\n    float c = cos(uv.y / yDiv2 - stream / .5);\n    float d = cos(uv.x / yDiv3 * dist / 1.125 - stream);\n    float x = a / sin(stream / - .5 + b) + c - d;\n    float y = offset - x;\n    vec2 position = vec2(x, y);\n    vec3 base = vec3(-2, 0, -1);\n    vec3 shift = cos(base * PI * 2. / 3. + PI * float(i) / colorShift);\n    vec3 color = shift * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.29254, 0, 50, false],
        ["contrast", 0, 1.84949, 0, 3.92, false],
        ["orbSize", 0, 2.60649, 0, 12.16, false],
        ["radius", 0, 0.03695, 0, 0.2, false],
        ["colorShift", 0, 9.61595, 0, 11.14, false],
        ["base", 0, 298.50033, 0, 1122, false],
        ["yDiv", 0, 4.13837, 0, 5, false],
        ["yDiv2", 0, 3.82661, 0, 12, false],
        ["yDiv3", 0, 59.96575, 0, 112, false],
        ["offset", 0, 10.99357, 0, 21, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T04:59:41.838Z"
    },
    "updated": {
      "$date": "2024-09-10T04:59:41.838Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd052c227f7b820e8b1725"
    },
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0004, 0, 1, false],
        ["iterator", 0, 4.99078, 0, 13, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.27344, 0, 33, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.24399, 0, 2, false],
        ["colorOffset", 0, 3.29047, 0, 111, false],
        ["contrast", 0, 1.85237, 0, 3, false],
        ["orbSize", 0, 0.3119, 0, 2, false],
        ["div", 0, 0.01, 0.01, 1, false],
        ["radius", 0, 1.83748, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:00:12.040Z"
    },
    "updated": {
      "$date": "2024-09-08T02:00:12.040Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66dd125b227f7b820e8b6e83"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 2.; i < 7.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x / div + stream / -1.5);\n    float b = radius * sin(uv.y / div + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.95) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.00619, 0, 0.1, false],
        ["iterator", 0, 0.99762, 0.7, 1.5, false],
        ["iterations", 0, 12.294084149096387, 0, 33, false, false],
        ["colorShift", 0, 111, 0, 111, false],
        ["colorOffset", 0, 18.446018448795183, 15, 30, false, false],
        ["contrast", 0, 1.16299, 0, 3, false],
        ["orbSize", 0, 171.06751223644582, 0, 1121, false, false],
        ["div", 0, 77.40551, 0.01, 1333, false],
        ["radius", 0, 73.36788403614459, 0, 212, false, false],
        ["wave", 0, 1333, 0, 1333, false],
        ["split", 0, 4.41711, 0, 40, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:56:27.655Z"
    },
    "updated": {
      "$date": "2024-09-08T02:56:27.655Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66dd0557227f7b820e8b172d"
    },
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.0649, 0, 1, false],
        ["iterator", 0, 1.90885, 0, 13, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.27344, 0, 33, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.24399, 0, 2, false],
        ["colorOffset", 0, 3.29047, 0, 111, false],
        ["contrast", 0, 1.85237, 0, 3, false],
        ["orbSize", 0, 0.59197, 0, 2, false],
        ["div", 0, 0.01, 0.01, 1, false],
        ["radius", 0, 1.40083, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:00:55.123Z"
    },
    "updated": {
      "$date": "2024-09-08T02:00:55.123Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66df9f38d8fb699c0958bfb0"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/1.)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 23.71705, 0, 50, false],
        ["contrast", 0, 2.36005, 0, 3.92, false],
        ["orbSize", 0, 2.78708, 0, 12.16, false],
        ["radius", 0, 0.89578, 0, 7, false],
        ["colorShift", 0, 7.39311, 0, 11.14, false],
        ["base", 0, 30.09417, 0, 143.32, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T01:22:00.427Z"
    },
    "updated": {
      "$date": "2024-09-10T01:22:00.427Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfe570d8fb699c09597955"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-12.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.+dist+t +uv.x/yDiv)-(cos(uv.x/.215+dist/2.-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 32.21172, 0, 150, false],
        ["contrast", 0, 1.62484, 0, 3.92, false],
        ["orbSize", 0, 2.69787, 0, 12.16, false],
        ["radius", 0, 0.21512, 0, 2, false],
        ["colorShift", 0, 10.07638, 0, 11.14, false],
        ["base", 0, 114.66802, 0, 222, false],
        ["yDiv", 0, 0.91146, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T06:21:36.274Z"
    },
    "updated": {
      "$date": "2024-09-10T06:21:36.274Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd052f227f7b820e8b1729"
    },
    "shader": "void main () {\n  float stream = stream / 80.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= rotation;\n    uv = (uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, vec2(radius*abs(cos(stream/.3+uv.x/div)) * L * sin(stream/2.7 - uv.y), radius*cos(stream/.293+uv.y/div)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.010728, 0, 1, false, false],
        ["iterator", 0, 4.99078, 0, 13, false, false],
        ["ot", 0, 38.302, 0, 151, false, false],
        ["I", 0, 3, 0, 3, false, false],
        ["J", 0, 0.994, 0, 3, false, false],
        ["K", 0, 0.9497646837349399, 0, 11, false, false],
        ["iterations", 0, 0.27344, 0, 33, false, false],
        ["L", 0, 2, 1, 2, false, false],
        ["M", 0, 0.209, 0, 1, false, false],
        ["colorShift", 0, 0.24399, 0, 2, false, false],
        ["colorOffset", 0, 3.29047, 0, 111, false, false],
        ["contrast", 0, 1.85237, 0, 3, false, false],
        ["orbSize", 0, 0.3119, 0, 2, false, false],
        ["div", 0, 0.01, 0.01, 1, false, false],
        ["radius", 0, 1.83748, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T02:00:15.808Z"
    },
    "updated": {
      "$date": "2024-09-08T02:00:15.808Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a45"
    }
  },
  {
    "_id": {
      "$oid": "66dfbc1ed8fb699c095917e1"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.83412, 0, 50, false],
        ["contrast", 0, 2.91649, 0, 3.92, false],
        ["orbSize", 0, 2.25636, 0, 12.16, false],
        ["radius", 0, 0.55085, 0, 45, false],
        ["colorShift", 0, 7.53763, 0, 11.14, false],
        ["base", 0, 6.41897, 0, 22, false],
        ["yDiv", 0, 0.83058, 0, 5, false]
      ],
      [
        ["zoom", 0, 22.13005, 0, 50, false],
        ["contrast", 0, 2.59269, 0, 3.92, false],
        ["orbSize", 0, 1.33992, 0, 12.16, false],
        ["radius", 0, 0.67056, 0, 7, false],
        ["colorShift", 0, 11.14, 0, 11.14, false],
        ["base", 0, 26.14888, 0, 143.32, false],
        ["yDiv", 0, 5, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T03:25:18.162Z"
    },
    "updated": {
      "$date": "2024-09-10T03:25:18.162Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfbd11d8fb699c095917e5"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-.5 - uv.y/dist*uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 23.75759, 0, 50, false],
        ["contrast", 0, 1.98593, 0, 3.92, false],
        ["orbSize", 0, 2.08202, 0, 12.16, false],
        ["radius", 0, 0.79469, 0, 45, false],
        ["colorShift", 0, 9.99002, 0, 11.14, false],
        ["base", 0, 19.23353, 0, 222, false],
        ["yDiv", 0, 0.82445, 0, 5, false]
      ],
      [
        ["zoom", 0, 22.13005, 0, 50, false],
        ["contrast", 0, 2.59269, 0, 3.92, false],
        ["orbSize", 0, 1.33992, 0, 12.16, false],
        ["radius", 0, 0.67056, 0, 7, false],
        ["colorShift", 0, 11.14, 0, 11.14, false],
        ["base", 0, 26.14888, 0, 143.32, false],
        ["yDiv", 0, 5, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T03:29:21.635Z"
    },
    "updated": {
      "$date": "2024-09-10T03:29:21.635Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfcb43d8fb699c09593565"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  // uv *= k_rotate2d(stream/-2.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 16.07471, 0, 50, false],
        ["contrast", 0, 2.45323, 0, 3.92, false],
        ["orbSize", 0, 2.20514, 0, 12.16, false],
        ["radius", 0, 0.02982, 0, 2, false],
        ["colorShift", 0, 6.28168, 0, 11.14, false],
        ["base", 0, 149.73706, 0, 222, false],
        ["yDiv", 0, 0.71914, 0, 5, false]
      ],
      [
        ["zoom", 0, 22.13005, 0, 50, false],
        ["contrast", 0, 2.59269, 0, 3.92, false],
        ["orbSize", 0, 1.33992, 0, 12.16, false],
        ["radius", 0, 0.67056, 0, 7, false],
        ["colorShift", 0, 11.14, 0, 11.14, false],
        ["base", 0, 26.14888, 0, 143.32, false],
        ["yDiv", 0, 5, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T04:29:55.285Z"
    },
    "updated": {
      "$date": "2024-09-10T04:29:55.285Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfcbf2d8fb699c09593ddd"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  // uv *= k_rotate2d(stream/-2.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.282)) * abs(fract(1.00112901*(abs(.2*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.43789, 0, 50, false],
        ["contrast", 0, 2.0819, 0, 3.92, false],
        ["orbSize", 0, 2.66444, 0, 12.16, false],
        ["radius", 0, 0.01444, 0, 2, false],
        ["colorShift", 0, 8.34327, 0, 11.14, false],
        ["base", 0, 223.62236, 0, 422, false],
        ["yDiv", 0, 1.16459, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T04:32:50.202Z"
    },
    "updated": {
      "$date": "2024-09-10T04:32:50.202Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dd1391227f7b820e8b72b7"
    },
    "shader": "\n\n#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \nmat2 rotate2d(float _angle){\n  return mat2(\n    cos(_angle), \n    -sin(_angle), \n    sin(_angle), \n    cos(_angle)\n  );\n}\n\nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\nvoid main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  vec2 uv2 = uv * zoom/15.;\n  vec2 uv3 = uv * zoom/15.;\n  uv = mix(uv2, uv3, abs(.1*sin(stream/.1)));\n  float dist = distance(uv, vec2(0));\n  float thing = dist * .001*sin(shapeMultiplier*dot(uv2, uv3)/dist - stream/330.);\n\tuv = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/20.));\n  float _grid = (cos(uv.x * xMultiplier - stream/.5) - sin(uv.y * yMultiplier + stream/1500.));\n  uv /= colorSpread * thing  * _grid;\n  uv*=dist;\n  for (int i = 0; i < BALLS; i++) {\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = vec2(sin(t), cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  if (invert) gl_FragColor = 1. - gl_FragColor;\n}\n",
    "variants": [
      [
        ["zoom", 0, 1.33675, 0, 6.12, false],
        ["xMultiplier", 0, 117.55271, 0, 871.98, false],
        ["yMultiplier", 0, 98.5, 0, 98.5, false],
        ["ballSize", 0, 1.25, 0, 2.5, false, false],
        ["colorSpread", 0, 3.47754, 0, 6.72, false],
        ["colorMultiplier", 0, 42.32055, 0, 229.1, false],
        ["shapeMultiplier", 0, 26.92, 0, 26.92, false],
        ["glow", 0, 730.07686, 0, 3724.18, false],
        ["contrast", 0, 3.17, 0, 6.34, false, false],
        ["rotation", 0, 7.7042, 0, 22.942, false],
        ["brightness", 0, 0.96284, 0, 2, false],
        ["sides", 0, 12, 0, 22, true],
        ["warp", 1, false],
        ["kaleidoscope", 1, false],
        ["invert", 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-08T03:01:37.138Z"
    },
    "updated": {
      "$date": "2024-09-08T03:01:37.138Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a60"
    }
  },
  {
    "_id": {
      "$oid": "66dfaa95d8fb699c0958dd0f"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.5*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius * sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/.5+dist-stream/.5)-cos(uv.x/2.5*dist/.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 23.85746, 0, 50, false],
        ["contrast", 0, 1.98004, 0, 3.92, false],
        ["orbSize", 0, 2.38453, 0, 12.16, false],
        ["radius", 0, 1.139, 0, 7, false],
        ["colorShift", 0, 7.39311, 0, 11.14, false],
        ["base", 0, 23.31462, 0, 143.32, false],
        ["yDiv", 0, 0.97397, 0.5, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T02:10:29.935Z"
    },
    "updated": {
      "$date": "2024-09-10T02:10:29.935Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66dfe00bd8fb699c09594ee5"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 17.34629, 0, 50, false],
        ["contrast", 0, 2.38222, 0, 3.92, false],
        ["orbSize", 0, 1.95408, 0, 12.16, false],
        ["radius", 0, 0.1056, 0, 2, false],
        ["colorShift", 0, 9.79726, 0, 11.14, false],
        ["base", 0, 11.12041, 0, 222, false],
        ["yDiv", 0, 0.79904, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T05:58:35.399Z"
    },
    "updated": {
      "$date": "2024-09-10T05:58:35.399Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e0a541e2bae2208f72b3b2"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  float dist = length((uv));\n  uv *= k_rotate2d(stream/-11.);\n  uv = abs(uv);\n  uv += length(sin(uv*1.15)) * abs(fract(.01*(abs(.51*uv))) - .5);\n  uv *= k_rotate2d(stream/21.);\n  \n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.y/1.15+dist/1.-stream/.5)-cos(uv.y/.5*dist/5.125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 48.26468, 0, 50, false],
        ["contrast", 0, 2.79106, 0, 3.92, false],
        ["orbSize", 0, 4.66013, 0, 12.16, false],
        ["radius", 0, 0.43578, 0, 2, false],
        ["colorShift", 0, 9.79726, 0, 11.14, false],
        ["base", 0, 149.46048, 0, 222, false],
        ["yDiv", 0, 0.79904, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-10T20:00:01.336Z"
    },
    "updated": {
      "$date": "2024-09-10T20:00:01.336Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66e0ef2a0a18140c4826f7c2"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y + uv.x);\n}",
    "variants": [
      [
        ["zoom", 0, 4.02347, 0.2, 11, false],
        ["A", 0, 0.10871, 0, 1, false],
        ["B", 0, 0.1038, 0, 1, false],
        ["C", 0, 0.24285, 0, 1, false],
        ["D", 0, 0.34975, 0, 1, false],
        ["E", 0, 0.38016, 0, 1.1, false],
        ["F", 0, 0.56808, 0, 1, false],
        ["G", 0, 0.17096, 0, 1, false],
        ["H", 0, 0.3471, 0, 1, false],
        ["I", 0, 4.712730014375358, 0, 11, false, false],
        ["J", 0, 1.74224, 1.3, 1.8, false],
        ["col", 3, [0, 1, 0.8823529411764706]]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T01:15:22.916Z"
    },
    "updated": {
      "$date": "2024-09-11T01:15:22.916Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66e0ef4cd20ebe14f1041a14"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y + uv.x);\n}",
    "variants": [
      [
        ["zoom", 0, 4.02347, 0.2, 11, false],
        ["A", 0, 0.10871, 0, 1, false],
        ["B", 0, 0.1038, 0, 1, false],
        ["C", 0, 0.24285, 0, 1, false],
        ["D", 0, 0.34975, 0, 1, false],
        ["E", 0, 0.38016, 0, 1.1, false],
        ["F", 0, 0.56808, 0, 1, false],
        ["G", 0, 0.17096, 0, 1, false],
        ["H", 0, 0.3471, 0, 1, false],
        ["I", 0, 4.712730014375358, 0, 11, false, false],
        ["J", 0, 1.74224, 1.3, 1.8, false],
        ["col", 3, [0, 1, 0.8823529411764706]]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T01:15:56.669Z"
    },
    "updated": {
      "$date": "2024-09-11T01:15:56.669Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66e0ef66e4f663ca90417674"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y + uv.x);\n}",
    "variants": [
      [
        ["zoom", 0, 4.02347, 0.2, 11, false],
        ["A", 0, 0.10871, 0, 1, false],
        ["B", 0, 0.1038, 0, 1, false],
        ["C", 0, 0.24285, 0, 1, false],
        ["D", 0, 0.34975, 0, 1, false],
        ["E", 0, 0.38016, 0, 1.1, false],
        ["F", 0, 0.56808, 0, 1, false],
        ["G", 0, 0.17096, 0, 1, false],
        ["H", 0, 0.3471, 0, 1, false],
        ["I", 0, 4.712730014375358, 0, 11, false, false],
        ["J", 0, 1.74224, 1.3, 1.8, false],
        ["col", 3, [0, 1, 0.8823529411764706]]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T01:16:22.835Z"
    },
    "updated": {
      "$date": "2024-09-11T01:16:22.835Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    }
  },
  {
    "_id": {
      "$oid": "66e0ef836d68c45da02089bb"
    },
    "shader": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) {\n  c = mod(c, 7.); // cycle palette\n  int p = 0;\n  vec3 color = vec3(0.);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) { // check loop index against color value\n      color = palette[i]; // store color picked\t\n    }\n  }\n  return color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) {\n  s *= .5;\n  c = mod(c - .5, 7.);\n  vec3 color1 = vec3(0.0), color2 = vec3(0.0);\n  for (int i = 0; i < 7; i++) {\n    if (float(i) - c <= .0) {\n      color1 = palette[i];\n      color2 = palette[(i + 1 > 6) ? 0 : i + 1];\n    }\n  }\n  // smooth mix the two colors\n  return mix(color1, color2, smoothstep(.5 - s, .5 + s, fract(c)));\n}\n\nvoid main() {\n  // define the colors \n  palette[6] = vec3(255, 000, 000) / 255.;\n  palette[5] = vec3(255, 127, 000) / 255.;\n  palette[4] = vec3(255, 255, 000) / 255.;\n  palette[3] = vec3(150, 050, 050) / 255.;\n  palette[2] = vec3(000, 050, 50) / 255.;\n  palette[1] = vec3(075, 000, 130) / 255.;\n  palette[0] = vec3(143, 000, 255) / 255.;\n\n  vec3 color = vec3(0.);\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\nuv.x *= resolution.x/resolution.y;\nuv *= zoom;\n\n  \n  vec2 p = uv;\n\n  float a = stream * .15;\n  float b = stream * 1.;\n  float ot =4.11;\n  mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n  float l = length(p);\n  for (int i = 0; i < 6; i++) {\n    p *= rot;\n    p = (abs(p) * J - 1.) * rot;\n    ot = min(ot, (dot(p, p) - cos(b + l * 2.) * .1015 - length(sin(uv)))); //orbit trap\n  }\n  // ot = max(0., .1 - ot) / .1; //orbit trap \n  // if (length(max(vec2(0.), abs(uv - .5) - vec2(.485, .47))) > 0.0) color *= 0.; // border \t  if (true || length(min(vec2(0.), abs(uv - .5) - vec2(.37, .46))) < 0.01) {\n  color = getsmcolor(ot * I + l * 1. - stream * .5, 1.) * (1. - .14 * step(.5, 1. - 3.*sin(1.1*dot(p, p)))); //get color gradient for orbit trap value\t\n  color = mix(vec3((color)) * B, color, 1.8); // saturation adjustment\n  color *= 1. - pow(l * A, .5);\n  color += pow(max(0., .2 - l) / .2, 3.) * 1.2; // center glow\n  gl_FragColor = vec4(color, 1.0);\n  gl_FragColor = k_hue(gl_FragColor, stream/2. - (-1. + 2. * gl_FragCoord.xy / resolution.xy).y + uv.x);\n}",
    "variants": [
      [
        ["zoom", 0, 4.02347, 0.2, 11, false],
        ["A", 0, 0.10871, 0, 1, false],
        ["B", 0, 0.1038, 0, 1, false],
        ["C", 0, 0.24285, 0, 1, false],
        ["D", 0, 0.34975, 0, 1, false],
        ["E", 0, 0.38016, 0, 1.1, false],
        ["F", 0, 0.56808, 0, 1, false],
        ["G", 0, 0.17096, 0, 1, false],
        ["H", 0, 0.3471, 0, 1, false],
        ["I", 0, 4.712730014375358, 0, 11, false, false],
        ["J", 0, 1.74224, 1.3, 1.8, false],
        ["col", 3, [0, 1, 0.8823529411764706]]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T01:16:51.976Z"
    },
    "updated": {
      "$date": "2024-09-11T01:16:51.977Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6a"
    }
  },
  {
    "_id": {
      "$oid": "66e0fcd40b9954748f6ad665"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/10.);\n\n  float dist = length((uv));\n  uv += length(sin(uv*1.2)) * abs(fract(.01*(abs(.1*uv))) - .5);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/3.*PI);\n    float t = i / PI / orbs * 2.;\n    float x = (base/dist)/t*radius / sin(stream/-1.5+dist+t +uv.y/yDiv)-(cos(uv.x/.15+dist-stream/.5)-cos(uv.x/2.5*dist/.5125-stream));\n    float y = 11.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 16.07471, 0, 50, false],
        ["contrast", 0, 1.79259, 0, 3.92, false],
        ["orbSize", 0, 5.52968, 0, 12.16, false],
        ["radius", 0, 0.06771, 0, 2, false],
        ["colorShift", 0, 2.88353, 0, 11.14, false],
        ["base", 0, 149.73706, 0, 222, false],
        ["yDiv", 0, 0.71914, 0, 5, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T02:13:40.785Z"
    },
    "updated": {
      "$date": "2024-09-11T02:13:40.785Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e0ffd30b9954748f6ad668"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-8.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.5*PI);\n    float t = i / PI / orbs * 3.;\n    float x = (base/dist)/t*radius * sin(stream/-1.+dist+t +uv.y/1.)*(cos(uv.y/1.-stream/1.5)-cos(uv.x/.5*dist/2.125-stream));\n    float y = 12.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .25) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.55236, 0, 50, false],
        ["contrast", 0, 3.54193, 0, 3.92, false],
        ["orbSize", 0, 4.81571, 0, 12.16, false],
        ["radius", 0, 0.44976, 0, 7, false],
        ["colorShift", 0, 1.42293, 0, 11.14, false],
        ["base", 0, 31.42344, 0, 143.32, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T02:26:27.744Z"
    },
    "updated": {
      "$date": "2024-09-11T02:26:27.744Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e1020f0b9954748f6ad66b"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-8.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/1.5*PI);\n    float t = i / PI / orbs * 3.;\n    float x = (base/dist)/t*radius * sin(stream/-.5+dist/11.2+t +uv.y)*(cos(uv.x/.5-dist/.2-stream/1.5)-cos(uv.x/1.5*dist/-1.25-stream));\n    float y = 1.-x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.5128, 0, 50, false],
        ["contrast", 0, 1.34118, 0, 5.92, false],
        ["orbSize", 0, 0.3264, 0, 1, false],
        ["radius", 0, 1.83638, 0, 5, false],
        ["colorShift", 0, 1.56524, 0, 11.14, false],
        ["base", 0, 3.62785, 0, 143.32, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T02:35:59.657Z"
    },
    "updated": {
      "$date": "2024-09-11T02:35:59.657Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e1091fd850b2ae7ea7db42"
    },
    "shader": "void main () {\n  float stream =stream * 1.6;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T03:06:07.617Z"
    },
    "updated": {
      "$date": "2024-09-11T03:06:07.617Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e128a40b9954748f6ad686"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/8.*sin(-uv.y/-.29 - t)-(length(uv/.2))/t*radius * sin(stream/-.9+dist/1.5+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/1.125));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 3.86675, 0, 5, false],
        ["orbSize", 0, 3.84757, 0, 12.16, false],
        ["radius", 0, 0.01948, 0, 1, false],
        ["colorShift", 0, 4.8625, 0, 11.14, false],
        ["base", 0, 1.25086, 0, 3, false],
        ["rad", 0, 0.60245, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T05:20:36.691Z"
    },
    "updated": {
      "$date": "2024-09-11T05:20:36.691Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e129660b9954748f6ad689"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 3.86675, 0, 5, false],
        ["orbSize", 0, 3.84757, 0, 12.16, false],
        ["radius", 0, 0.01948, 0, 1, false],
        ["colorShift", 0, 4.8625, 0, 11.14, false],
        ["base", 0, 1.25086, 0, 3, false],
        ["rad", 0, 0.60245, 0, 2, false]
      ],
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 2.9722, 0, 5, false],
        ["orbSize", 0, 3.89975, 0, 12.16, false],
        ["radius", 0, 0.0016, 0, 1, false],
        ["colorShift", 0, 1.14953, 0, 11.14, false],
        ["base", 0, 0.60715, 0, 3, false],
        ["rad", 0, 0.66992, 0, 2, false],
        ["yDiv", 0, 2, 0.1, 2, false],
        ["uvDiv", 0, 0.07987, 0.01, 1, false],
        ["dDiv", 0, 1.73928, 0, 50, false],
        ["dDiv2", 0, 2.33453, 0, 50, false],
        ["dDiv3", 0, 0.03192, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T05:23:50.117Z"
    },
    "updated": {
      "$date": "2024-09-11T05:23:50.117Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e12ba90b9954748f6ad68c"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 2.95647, 0, 50, false],
        ["contrast", 0, 1.99725, 0, 5, false],
        ["orbSize", 0, 2.09813, 0, 12.16, false],
        ["radius", 0, 0.0719, 0, 1, false],
        ["colorShift", 0, 1.18016, 0, 11.14, false],
        ["base", 0, 0.35383, 0, 3, false],
        ["rad", 0, 0.1215, 0, 2, false],
        ["yDiv", 0, 0.01062, 0.01, 0.2, false],
        ["uvDiv", 0, 0.04953, 0.01, 1, false],
        ["dDiv", 0, 0.32136, 0, 50, false],
        ["dDiv2", 0, 1.03526, 0, 50, false],
        ["dDiv3", 0, 0.10821, 0, 2, false]
      ],
      [
        ["zoom", 0, 7.30516, 0, 50, false],
        ["contrast", 0, 2.59893, 0, 5, false],
        ["orbSize", 0, 2.30734, 0, 12.16, false],
        ["radius", 0, 0.19831, 0, 1, false],
        ["colorShift", 0, 2.85401, 0, 11.14, false],
        ["base", 0, 0.27172, 0, 3, false],
        ["rad", 0, 0.10469, 0, 2, false],
        ["yDiv", 0, 0.02143, 0.01, 0.2, false],
        ["uvDiv", 0, 0.89904, 0.01, 2, false],
        ["dDiv", 0, 0.90367, 0, 2, false],
        ["dDiv2", 0, 0.47482, 0, 2, false],
        ["dDiv3", 0, 2, 0, 2, false]
      ],
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 2.9722, 0, 5, false],
        ["orbSize", 0, 3.89975, 0, 12.16, false],
        ["radius", 0, 0.0016, 0, 1, false],
        ["colorShift", 0, 2.72359, 0, 11.14, false],
        ["base", 0, 0.60715, 0, 3, false],
        ["rad", 0, 0.66992, 0, 2, false],
        ["yDiv", 0, 2, 0.1, 2, false],
        ["uvDiv", 0, 0.07987, 0.01, 1, false],
        ["dDiv", 0, 1.73928, 0, 50, false],
        ["dDiv2", 0, 2.33453, 0, 50, false],
        ["dDiv3", 0, 0.03192, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T05:33:29.167Z"
    },
    "updated": {
      "$date": "2024-09-11T05:33:29.167Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e12c8a0b9954748f6ad68f"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/dDiv3*sin(-uv.y/-yDiv - t)-(length(uv/uvDiv))/t*radius * sin(stream/-.9+dist/dDiv+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/dDiv2));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 7.30516, 0, 50, false],
        ["contrast", 0, 2.59893, 0, 5, false],
        ["orbSize", 0, 2.30734, 0, 12.16, false],
        ["radius", 0, 0.19831, 0, 1, false],
        ["colorShift", 0, 2.85401, 0, 11.14, false],
        ["base", 0, 0.27172, 0, 3, false],
        ["rad", 0, 0.10469, 0, 2, false],
        ["yDiv", 0, 0.02143, 0.01, 0.2, false],
        ["uvDiv", 0, 0.89904, 0.01, 2, false],
        ["dDiv", 0, 0.90367, 0, 2, false],
        ["dDiv2", 0, 0.47482, 0, 2, false],
        ["dDiv3", 0, 2, 0, 2, false]
      ],
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 2.9722, 0, 5, false],
        ["orbSize", 0, 3.89975, 0, 12.16, false],
        ["radius", 0, 0.0016, 0, 1, false],
        ["colorShift", 0, 2.72359, 0, 11.14, false],
        ["base", 0, 0.60715, 0, 3, false],
        ["rad", 0, 0.66992, 0, 2, false],
        ["yDiv", 0, 2, 0.1, 2, false],
        ["uvDiv", 0, 0.07987, 0.01, 1, false],
        ["dDiv", 0, 1.73928, 0, 50, false],
        ["dDiv2", 0, 2.33453, 0, 50, false],
        ["dDiv3", 0, 0.03192, 0, 2, false]
      ],
      [
        ["zoom", 0, 6.08598, 0, 50, false],
        ["contrast", 0, 2.66725, 0, 5, false],
        ["orbSize", 0, 2.79358, 0, 12.16, false],
        ["radius", 0, 0.18184, 0, 1, false],
        ["colorShift", 0, 2.72425, 0, 11.14, false],
        ["base", 0, 1.40101, 0, 3, false],
        ["rad", 0, 0.27049, 0, 2, false],
        ["yDiv", 0, 0.1632, 0.1, 2, false],
        ["uvDiv", 0, 0.13463, 0.01, 1, false],
        ["dDiv", 0, 8.06158, 0, 50, false],
        ["dDiv2", 0, 1.25279, 0, 50, false],
        ["dDiv3", 0, 1.12041, 0, 2, false]
      ],
      [
        ["zoom", 0, 21.32517, 0, 50, false],
        ["contrast", 0, 2.34362, 0, 5, false],
        ["orbSize", 0, 3.14346, 0, 12.16, false],
        ["radius", 0, 0.01887, 0, 1, false],
        ["colorShift", 0, 4.69639, 0, 11.14, false],
        ["base", 0, 0.96003, 0, 3, false],
        ["rad", 0, 1.14201, 0, 2, false],
        ["yDiv", 0, 0.59891, 0.1, 2, false],
        ["uvDiv", 0, 0.13794, 0.01, 1, false],
        ["dDiv", 0, 1.15985, 0, 50, false],
        ["dDiv2", 0, 4.23992, 0, 50, false],
        ["dDiv3", 0, 0.63733, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T05:37:14.833Z"
    },
    "updated": {
      "$date": "2024-09-11T05:37:14.833Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e2184d2db3aaaad31a3fe8"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-9.);\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(i/2.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = t*dist/8.*sin(-uv.y/-.29 - t)-(length(uv/.2))/t*radius * sin(stream/-.9+dist/1.5+t +uv.y/base)*(cos(uv.x-length(uv)-stream)-cos(uv.x/.235*dist/1.125));\n    float y = 11.-x;\n    vec2 position = vec2(rad*x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 13.54836, 0, 50, false],
        ["contrast", 0, 3.86675, 0, 5, false],
        ["orbSize", 0, 3.84757, 0, 12.16, false],
        ["radius", 0, 0.01948, 0, 1, false],
        ["colorShift", 0, 4.8625, 0, 11.14, false],
        ["base", 0, 1.25086, 0, 3, false],
        ["rad", 0, 0.60245, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T22:23:09.904Z"
    },
    "updated": {
      "$date": "2024-09-11T22:23:09.904Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e21b342db3aaaad31a3fed"
    },
    "shader": "void main () {\n  float stream =stream * 1.8;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 8.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-11T22:35:32.202Z"
    },
    "updated": {
      "$date": "2024-09-11T22:35:32.202Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e24a368f9935c9566330c4"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (float i = 1.; i < 10.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 18.717, 0, 22, false],
        ["iterator", 0, 0.843, 0.7, 15, false],
        ["iterations", 0, 91.395, 0, 111, false],
        ["colorShift", 0, 8.102, 0, 44, false],
        ["colorOffset", 0, 189.512, 1, 318, false],
        ["contrast", 0, 1.221, 0, 3, false],
        ["orbSize", 0, 1049.592, 0, 15121, false],
        ["div", 0, 1.698, 0.01, 12, false],
        ["radius", 0, 185.206, 0, 1512, false],
        ["wave", 0, 3073.92, 0, 32222, false],
        ["split", 0, 52.499, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T01:56:06.195Z"
    },
    "updated": {
      "$date": "2024-09-12T01:56:06.195Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e24abc8f9935c9566330c7"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.255, 0, 422, false],
        ["iterator", 0, 0.673, 0.27, 1, false],
        ["iterations", 0, 109.617, 0, 111, false],
        ["colorShift", 0, 17.822, 0, 44, false],
        ["colorOffset", 0, 189.512, 1, 318, false],
        ["contrast", 0, 1.221, 0, 3, false],
        ["orbSize", 0, 1907.207, 0, 15121, false],
        ["div", 0, 8.839, 0.01, 212, false],
        ["radius", 0, 196.658, 0, 1512, false],
        ["wave", 0, 7183.313, 0, 32222, false],
        ["split", 0, 316.917, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T01:58:20.559Z"
    },
    "updated": {
      "$date": "2024-09-12T01:58:20.559Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e24adc8f9935c9566330ca"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/10.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 27.69, 0, 422, false],
        ["iterator", 0, 0.515, 0.27, 1, false],
        ["iterations", 0, 109.617, 0, 111, false],
        ["colorShift", 0, 17.822, 0, 44, false],
        ["colorOffset", 0, 189.512, 1, 318, false],
        ["contrast", 0, 1.221, 0, 3, false],
        ["orbSize", 0, 1907.207, 0, 15121, false],
        ["div", 0, 8.839, 0.01, 212, false],
        ["radius", 0, 196.658, 0, 1512, false],
        ["wave", 0, 7183.313, 0, 32222, false],
        ["split", 0, 316.917, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T01:58:52.347Z"
    },
    "updated": {
      "$date": "2024-09-12T01:58:52.347Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e24e378f9935c9566330cd"
    },
    "shader": "void main () {\n  float stream = stream / 1.9;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= k_rotate2d(stream/5.);\n  uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n  uv *= (i/10. + (i/20.*cos(dot(uv, .005*uv) - stream/5.)));\n    uv *= k_rotate2d(stream/(i*PI/1.5));\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -11.5);\n    float b = radius * sin(uv.y  + stream / 1.);\n    float c = wave * sin(split * uv.x / div - stream / 3.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.591, 0, 122, false],
        ["iterator", 0, 0.918, 0.27, 5, false],
        ["iterations", 0, 109.617, 0, 111, false],
        ["colorShift", 0, 17.822, 0, 44, false],
        ["colorOffset", 0, 189.512, 1, 318, false],
        ["contrast", 0, 1.049, 0, 3, false],
        ["orbSize", 0, 84.707, 0, 550, false],
        ["div", 0, 11.203, 0.01, 212, false],
        ["radius", 0, 141.641, 0, 1512, false],
        ["wave", 0, 2453.274, 0, 32222, false],
        ["split", 0, 340, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T02:13:11.442Z"
    },
    "updated": {
      "$date": "2024-09-12T02:13:11.442Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e24e6d0b9954748f6ad6c0"
    },
    "shader": "#define orbs 15.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\nreturn pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/29.);\n  if (warpTween) {\n    if (warp) {\n     \tuv = mix(uv, uv / dot(uv, uv), warpTweenProgress); \n    } else {\n\t\t\tuv = mix(uv / dot(uv, uv), uv, warpTweenProgress);\n    }\n  } else if (warp) {\n   \tuv /= dot(uv, uv); \n  }\n  vec2 kale_ = sin(stream/1. + kale(uv, vec2(center), sides));\n  if (kkkTween) {\n    if (kkk) {\n     \tuv = mix(uv, (kale_), kkkTweenProgress); \n    } else {\n\t\t\tuv = mix((kale_), uv, kkkTweenProgress);\n    }\n  } else if (kkk) {\n   \tuv = (kale_);\n  }\n  float dist = length((uv));\n  for (float i = 0.; i < orbs; i++) {\n    uv *= rotate(i/1.5*PI);\n    float t = i / PI / orbs * 2. - stream/20.;\n    float x = (base/dist)/t*radius * sin(stream/3.+dist*t)*cos(uv.y*dist)*sin(dist-stream/11.);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.33, 0, 8.66, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["orbSize", 0, 0.58, 0, 1.16, false, false],
        ["radius", 0, 6.4, 0, 12.8, false, false],
        ["colorShift", 0, 5.57, 0, 11.14, false, false],
        ["center", 0, 2.71, 0, 5.42, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.18, 0, 0.36, false, false],
        ["warp", 1, false, null, null, null, false],
        ["kkk", 1, false, null, null, null, false],
        ["base", 0, 7.16, 0, 14.32, false, false]
      ],
      [
        ["zoom", 0, 1.52231, 0, 8.66, false],
        ["contrast", 0, 2.14609, 0, 3.92, false],
        ["orbSize", 0, 0.40594, 0, 1.16, false],
        ["radius", 0, 3.77112, 0, 12.8, false],
        ["colorShift", 0, 10.55752, 0, 11.14, false],
        ["center", 0, 2.71, 0, 5.42, false, false],
        ["sides", 0, 5, 0, 10, false, false],
        ["shape", 0, 0.17086, 0, 0.36, false],
        ["warp", 1, true],
        ["kkk", 1, false, null, null, null, false],
        ["base", 0, 14.32, 0, 14.32, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T02:14:05.853Z"
    },
    "updated": {
      "$date": "2024-09-12T02:14:05.853Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e24f4d718b0f48d56bd730"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  for (float i = 5.; i < 15.; i++) {\n    uv *= k_rotate2d(stream/-15.  - i*PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x  + stream / -1.5);\n    float b = radius * sin(uv.y  + stream / -2.);\n    float c = wave * sin(split * uv.x / div - stream / 1.);\n    float d = wave * cos(split * uv.y / div - stream / 1.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv, pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 15.255, 0, 422, false],
        ["iterator", 0, 0.673, 0.27, 1, false],
        ["iterations", 0, 109.617, 0, 111, false],
        ["colorShift", 0, 17.822, 0, 44, false],
        ["colorOffset", 0, 189.512, 1, 318, false],
        ["contrast", 0, 1.221, 0, 3, false],
        ["orbSize", 0, 1907.207, 0, 15121, false],
        ["div", 0, 8.839, 0.01, 212, false],
        ["radius", 0, 196.658, 0, 1512, false],
        ["wave", 0, 7183.313, 0, 32222, false],
        ["split", 0, 316.917, 0, 340, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T02:17:49.547Z"
    },
    "updated": {
      "$date": "2024-09-12T02:17:49.547Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e37f066a0cab26c3d8d3f2"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.113, 0, 20, false],
        ["contrast", 0, 1.923, 0, 3.92, false],
        ["orbSize", 0, 0.237, 0, 1, false],
        ["radius", 0, 2.646, 0, 7, false],
        ["colorShift", 0, 7.787, 0, 11.14, false],
        ["base", 0, 21.135, 0, 143.32, false],
        ["blob", 0, 3.344, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 0.091, 0, 2, false],
        ["yDiv2", 0, 0.075, 0, 2, false],
        ["xDiv", 0, 0.15, 0, 2, false],
        ["distDiv", 0, 1.524, 0, 2, false]
      ],
      [
        ["zoom", 0, 3.58, 0, 20, false],
        ["contrast", 0, 2.917, 0, 3.92, false],
        ["orbSize", 0, 0.168, 0, 1, false],
        ["radius", 0, 0.445, 0, 7, false],
        ["colorShift", 0, 7.787, 0, 11.14, false],
        ["base", 0, 21.135, 0, 143.32, false],
        ["blob", 0, 3.344, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 0.133, 0, 2, false],
        ["yDiv2", 0, 0.21, 0, 2, false],
        ["xDiv", 0, 0.116, 0, 2, false],
        ["distDiv", 0, 0.804, 0, 2, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-12T23:53:42.642Z"
    },
    "updated": {
      "$date": "2024-09-12T23:53:42.642Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e380c86a0cab26c3d8d3f7"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.245, 0, 20, false],
        ["contrast", 0, 3.273, 0, 3.92, false],
        ["orbSize", 0, 0.17, 0, 1, false],
        ["radius", 0, 1.137, 0, 7, false],
        ["colorShift", 0, 4.599, 0, 11.14, false],
        ["base", 0, 17.544, 0, 143.32, false],
        ["blob", 0, 2.452, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 1.777, 0, 5, false],
        ["yDiv2", 0, 0.013, 0, 12, false],
        ["xDiv", 0, 2, 0, 2, false],
        ["distDiv", 0, 0.697, 0, 12, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-13T00:01:12.686Z"
    },
    "updated": {
      "$date": "2024-09-13T00:01:12.686Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e381386a0cab26c3d8d3fa"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.245, 0, 20, false],
        ["contrast", 0, 3.273, 0, 3.92, false],
        ["orbSize", 0, 0.17, 0, 1, false],
        ["radius", 0, 1.137, 0, 7, false],
        ["colorShift", 0, 4.599, 0, 11.14, false],
        ["base", 0, 17.544, 0, 143.32, false],
        ["blob", 0, 2.452, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 1.777, 0, 5, false],
        ["yDiv2", 0, 0.013, 0, 12, false],
        ["xDiv", 0, 2, 0, 2, false],
        ["distDiv", 0, 0.697, 0, 12, false]
      ],
      [
        ["zoom", 0, 5.245, 0, 20, false],
        ["contrast", 0, 3.689, 0, 3.92, false],
        ["orbSize", 0, 0.17, 0, 1, false],
        ["radius", 0, 1.526, 0, 7, false],
        ["colorShift", 0, 4.599, 0, 11.14, false],
        ["base", 0, 6.043, 0, 143.32, false],
        ["blob", 0, 3.425, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 0.01, 0, 5, false],
        ["yDiv2", 0, 0.244, 0, 12, false],
        ["xDiv", 0, 0.499, 0, 2, false],
        ["distDiv", 0, 2.549, 0, 42, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-13T00:03:04.926Z"
    },
    "updated": {
      "$date": "2024-09-13T00:03:04.926Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e381886a0cab26c3d8d3fd"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 8.218, 0, 20, false],
        ["contrast", 0, 3.92, 0, 3.92, false],
        ["orbSize", 0, 0.212, 0, 1, false],
        ["radius", 0, 1.34, 0, 7, false],
        ["colorShift", 0, 4.599, 0, 11.14, false],
        ["base", 0, 8.398, 0, 143.32, false],
        ["blob", 0, 3.18, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 0.011, 0, 0.5, false],
        ["yDiv2", 0, 0.337, 0, 12, false],
        ["xDiv", 0, 1.912, 0, 2, false],
        ["distDiv", 0, 1.561, 0, 42, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-13T00:04:24.258Z"
    },
    "updated": {
      "$date": "2024-09-13T00:04:24.258Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e382016a0cab26c3d8d400"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = k_uv();\n  uv *= zoom;\n\n  uv *= k_rotate2d(stream/14.);\n\n  float dist = length((uv));\n    // uv = abs(uv);\n\n  for (float i = 1.; i < orbs; i++) {\n  uv *= k_rotate2d(stream/34.);\n    uv += mul * abs(sin(uv.y/i));\n    uv *= k_rotate2d(i/9.*PI);\n    float t = i / PI / orbs * 1.;\n    float x = (base)*t*radius * sin(stream/.5+t +uv.y/yDiv)*(cos(uv.y/yDiv2-stream/1.5)-cos(uv.x/xDiv*dist/distDiv-stream));\n    float y = blob + x;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 11.009, 0, 20, false],
        ["contrast", 0, 3.92, 0, 3.92, false],
        ["orbSize", 0, 0.451, 0, 1, false],
        ["radius", 0, 1.344, 0, 7, false],
        ["colorShift", 0, 4.599, 0, 11.14, false],
        ["base", 0, 80.442, 0, 143.32, false],
        ["blob", 0, 7.829, 0, 30, false],
        ["mul", 0, 0, 0, 1, false],
        ["yDiv", 0, 0.027, 0, 0.5, false],
        ["yDiv2", 0, 8.475, 0, 12, false],
        ["xDiv", 0, 0.767, 0, 12, false],
        ["distDiv", 0, 11.512, 0, 42, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-13T00:06:25.538Z"
    },
    "updated": {
      "$date": "2024-09-13T00:06:25.538Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a78"
    }
  },
  {
    "_id": {
      "$oid": "66e90037a98b47d3ec6e4636"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -14.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 6.);\n    float b = radius * sin(uv.y + stream / -3.);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.937, 0, 6, false],
        ["iterator", 0, 0.853, 0.7, 1.5, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.942, 0, 3, false],
        ["orbSize", 0, 0.033, 0, 1, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 1.583, 0, 20, false],
        ["split", 0, 3.07, 0, 15, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-17T04:06:15.257Z"
    },
    "updated": {
      "$date": "2024-09-17T04:06:15.257Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e9e690e5a883e152ada227"
    },
    "shader": "void main () {\n  float stream =stream * 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -9.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.153, 0, 13, false],
        ["iterator", 0, 0.916, 0.7, 1.5, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.899, 0, 3, false],
        ["orbSize", 0, 0.095, 0, 1, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 6.051, 0, 15, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-17T20:29:04.061Z"
    },
    "updated": {
      "$date": "2024-09-17T20:29:04.061Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66e9e8b4e5a883e152ada22d"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.601, 0, 5, false],
        ["iterator", 0, 1.067, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.218, 0, 3, false],
        ["orbSize", 0, 15, 0, 15, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 14.725, 0, 16, false],
        ["wave", 0, 4.695, 0, 20, false],
        ["split", 0, 53.778, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-17T20:38:12.093Z"
    },
    "updated": {
      "$date": "2024-09-17T20:38:12.093Z"
    },
    "__v": 4,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb1478e5a883e152ada287"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - (stream / -12.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 12.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.976, 0, 6, false],
        ["iterator", 0, 1.045, 0.7, 1.5, false],
        ["iterations", 0, 13.242, 0, 33, false],
        ["colorShift", 0, 0.352, 0, 3, false],
        ["colorOffset", 0, 19.115, 15, 30, false],
        ["contrast", 0, 1.566, 0, 3, false],
        ["orbSize", 0, 0.885, 0, 1, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 3.933, 0, 6, false],
        ["wave", 0, 1.494, 0, 20, false],
        ["split", 0, 45.275, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T17:57:12.964Z"
    },
    "updated": {
      "$date": "2024-09-18T17:57:12.964Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb147ce5a883e152ada28a"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 4.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - (stream / -12.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 12.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.976, 0, 6, false],
        ["iterator", 0, 1.045, 0.7, 1.5, false],
        ["iterations", 0, 13.242, 0, 33, false],
        ["colorShift", 0, 0.352, 0, 3, false],
        ["colorOffset", 0, 19.115, 15, 30, false],
        ["contrast", 0, 1.566, 0, 3, false],
        ["orbSize", 0, 0.885, 0, 1, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 3.933, 0, 6, false],
        ["wave", 0, 1.494, 0, 20, false],
        ["split", 0, 45.275, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T17:57:16.483Z"
    },
    "updated": {
      "$date": "2024-09-18T17:57:16.483Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb65fdab07251a8c3a4917"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.601, 0, 5, false],
        ["iterator", 0, 1.067, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.218, 0, 3, false],
        ["orbSize", 0, 15, 0, 15, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 14.725, 0, 16, false],
        ["wave", 0, 4.695, 0, 20, false],
        ["split", 0, 53.778, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T23:45:01.124Z"
    },
    "updated": {
      "$date": "2024-09-18T23:45:01.124Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb6602ab07251a8c3a491b"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.601, 0, 5, false],
        ["iterator", 0, 1.067, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.218, 0, 3, false],
        ["orbSize", 0, 15, 0, 15, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 14.725, 0, 16, false],
        ["wave", 0, 4.695, 0, 20, false],
        ["split", 0, 53.778, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T23:45:06.069Z"
    },
    "updated": {
      "$date": "2024-09-18T23:45:06.069Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb660eab07251a8c3a491e"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.601, 0, 5, false],
        ["iterator", 0, 1.067, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.218, 0, 3, false],
        ["orbSize", 0, 15, 0, 15, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 14.725, 0, 16, false],
        ["wave", 0, 4.695, 0, 20, false],
        ["split", 0, 53.778, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T23:45:18.102Z"
    },
    "updated": {
      "$date": "2024-09-18T23:45:18.102Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb67e1ab07251a8c3a4d8a"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 8.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.768, 0, 5, false],
        ["iterator", 0, 0.931, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.116, 0, 3, false],
        ["orbSize", 0, 11.147, 0, 50, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 28.317, 0, 50, false],
        ["wave", 0, 8.749, 0, 20, false],
        ["split", 0, 36.831, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T23:53:05.183Z"
    },
    "updated": {
      "$date": "2024-09-18T23:53:05.183Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb68b3ab07251a8c3a4d8d"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.881, 0, 5, false],
        ["iterator", 0, 1.048, 0.17, 2, false],
        ["iterations", 0, 1.872, 0, 3, false],
        ["colorShift", 0, 0.073, 0, 0.3, false],
        ["colorOffset", 0, 16.222, 15, 30, false],
        ["contrast", 0, 1.233, 0, 3, false],
        ["orbSize", 0, 91.667, 0, 150, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 27.637, 0, 50, false],
        ["wave", 0, 7.194, 0, 20, false],
        ["split", 0, 30.011, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-18T23:56:35.151Z"
    },
    "updated": {
      "$date": "2024-09-18T23:56:35.151Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb6b62ab07251a8c3a4da2"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -1.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.695, 0, 5, false],
        ["iterator", 0, 1.064, 0.17, 2, false],
        ["iterations", 0, 1.872, 0, 3, false],
        ["colorShift", 0, 0.073, 0, 0.3, false],
        ["colorOffset", 0, 16.222, 15, 30, false],
        ["contrast", 0, 1.233, 0, 3, false],
        ["orbSize", 0, 12.993, 0, 150, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 27.637, 0, 50, false],
        ["wave", 0, 7.194, 0, 20, false],
        ["split", 0, 30.011, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-19T00:08:02.592Z"
    },
    "updated": {
      "$date": "2024-09-19T00:08:02.592Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eb71e2ab07251a8c3a4dc3"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.75);\n    float b = radius * sin(uv.y + stream / -2.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.881, 0, 5, false],
        ["iterator", 0, 1.048, 0.17, 2, false],
        ["iterations", 0, 1.872, 0, 3, false],
        ["colorShift", 0, 0.073, 0, 0.3, false],
        ["colorOffset", 0, 16.222, 15, 30, false],
        ["contrast", 0, 1.233, 0, 3, false],
        ["orbSize", 0, 91.667, 0, 150, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 27.637, 0, 50, false],
        ["wave", 0, 7.194, 0, 20, false],
        ["split", 0, 30.011, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-19T00:35:46.995Z"
    },
    "updated": {
      "$date": "2024-09-19T00:35:46.995Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef50679f75d84dba139ccf"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.103, 0, 1, false],
        ["iterator", 0, 1.267, 0.7, 1.5, false],
        ["iterations", 0, 2.857, 0, 33, false],
        ["colorShift", 0, 0.118, 0, 3, false],
        ["colorOffset", 0, 21.236, 15, 30, false],
        ["contrast", 0, 0.846, 0, 3, false],
        ["orbSize", 0, 11.503, 0, 21, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 6, 0, 6, false],
        ["wave", 0, 2.759, 0, 20, false],
        ["split", 0, 4.937, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-21T23:01:59.041Z"
    },
    "updated": {
      "$date": "2024-09-21T23:01:59.041Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef582b9f75d84dba139cd2"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n    uv *= k_rotate2d(stream / -6.);\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(wave *uv.y + stream / 4.);\n    float b = radius * sin(wave *uv.y + stream / -5.26);\n    float c = radius *  sin(split * uv.x - (stream / -2.8255));\n    float d = radius * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c * d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(0,x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, length(uv)/2. + stream/20.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007, 0, 0.015, false],
        ["iterator", 0, 0.987, 0, 1.5, false],
        ["iterations", 0, 33, 0, 33, false],
        ["colorShift", 0, 1.429, 0, 3, false],
        ["colorOffset", 0, 5.414, 1, 30, false],
        ["contrast", 0, 0.859, 0, 3, false],
        ["orbSize", 0, 9.488, 0, 55, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 1.894, 0, 6, false],
        ["wave", 0, 0.655, -1, 11, false],
        ["split", 0, 265.051, 0, 3265, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-21T23:35:07.028Z"
    },
    "updated": {
      "$date": "2024-09-21T23:35:07.028Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef59f79f75d84dba139cd5"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n\n  uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.074, 0, 0.12, false],
        ["iterator", 0, 0.961, 0.7, 1.5, false],
        ["iterations", 0, 2.857, 0, 33, false],
        ["colorShift", 0, 0.118, 0, 3, false],
        ["colorOffset", 0, 21.236, 15, 30, false],
        ["contrast", 0, 1.179, 0, 3, false],
        ["orbSize", 0, 6.809, 0, 11, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 5.926, 0, 6, false],
        ["wave", 0, 0.473, 0, 1, false],
        ["split", 0, 33.849, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-21T23:42:47.803Z"
    },
    "updated": {
      "$date": "2024-09-21T23:42:47.803Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef61949f75d84dba139cd8"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n    uv *= k_rotate2d(stream / 7.);\n\n  // uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream / 50. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 3.);\n    float b = radius * sin(uv.y + stream / -2.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -2.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.682, 0, 12, false],
        ["iterator", 0, 1.195, 0.7, 1.5, false],
        ["iterations", 0, 3.518, 0, 33, false],
        ["colorShift", 0, 0.104, 0, 3, false],
        ["colorOffset", 0, 25.291, 15, 30, false],
        ["contrast", 0, 0.978, 0, 3, false],
        ["orbSize", 0, 0.128, 0, 1, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 2.405, 0, 6, false],
        ["wave", 0, 0.118, 0, 1, false],
        ["split", 0, 12.832, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T00:15:16.925Z"
    },
    "updated": {
      "$date": "2024-09-22T00:15:16.925Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef631b9f75d84dba139cdb"
    },
    "shader": "void main () {\n  float stream = stream / 1.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n\n  uv /= dot(uv, uv)* 10.;\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(sin(i/5.)*stream / 10. * PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 1.);\n    float b = radius * sin(uv.y + stream / -1.26);\n    float c = radius * wave * sin(split * uv.x - (stream / -.8255));\n    float d = radius * wave * cos(split * uv.y  - (stream / .75));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.113, 0, 1, false],
        ["iterator", 0, 1.6, 0.7, 3, false],
        ["iterations", 0, 9.419, 0, 33, false],
        ["colorShift", 0, 1.402, 0, 3, false],
        ["colorOffset", 0, 8.55, 0, 30, false],
        ["contrast", 0, 1.17, 0, 3, false],
        ["orbSize", 0, 20.769, 0, 50, false],
        ["div", 0, 2.117, 0.01, 15, false],
        ["radius", 0, 6, 0, 6, false],
        ["wave", 0, 0.208, 0, 1, false],
        ["split", 0, 6.324, 0, 65, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T00:21:47.325Z"
    },
    "updated": {
      "$date": "2024-09-22T00:21:47.325Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef88e51191881f16ade01b"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 16.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-.6));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 15.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.1, false],
        ["shapeMultiplier", 0, 683.015, 0, 2000, false],
        ["rotation", 0, 0.032, 0, 0.1, false],
        ["xMultiplier", 0, 460.913, 0, 1500, false],
        ["yMultiplier", 0, 479.344, 0, 1000, false],
        ["colorSpread", 0, 0.003, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.737, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 5.586078689759038, 0, 10, false, false],
        ["ballSize", 0, 9.584360881024098, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 10.43147590361446, 0, 20, false, false],
        ["col", 0, 0.7912348800524701, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:03:01.388Z"
    },
    "updated": {
      "$date": "2024-09-22T03:03:01.388Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8a061191881f16ade01e"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.01, 0, 0.1, false],
        ["shapeMultiplier", 0, 1062.076, 0, 2000, false],
        ["rotation", 0, 1.969, 0, 7.1, false],
        ["xMultiplier", 0, 196.314, 0, 1500, false],
        ["yMultiplier", 0, 426.424, 0, 1000, false],
        ["colorSpread", 0, 0.001, 0.001, 0.009, false],
        ["colorMultiplier", 0, 0.405, 0, 3, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 1.417, 0, 10, false],
        ["ballSize", 0, 17.331, 0, 55, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 3.202, 0, 5, false],
        ["radius", 0, 20, 0, 20, false],
        ["col", 0, 2.192, 0, 3, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:07:50.240Z"
    },
    "updated": {
      "$date": "2024-09-22T03:07:50.240Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8a291191881f16ade023"
    },
    "shader": "void main() {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/10.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.16);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.1606359186746988, 0, 0.68, false, false],
        ["xMultiplier", 0, 40.74, 0, 40.74, false],
        ["yMultiplier", 0, 14.908, 0, 62.28, false],
        ["ballSize", 0, 44.899672910391565, 0, 319.34, false, false],
        ["colorSpread", 0, 0.012, 0, 5, false],
        ["colorMultiplier", 0, 508.183, 0, 3228.3, false],
        ["shapeMultiplier", 0, 69.613, 0, 226.04, false],
        ["glow", 0, 10250.044, 0, 18444.68, false],
        ["contrast", 0, 3.103421498493976, 0, 7.5, false, false],
        ["brightness", 0, 11.57032793674699, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 8.024077560240965, 0, 44, false, false],
        ["radius", 0, 5.128962725903616, 0, 34, false, false],
        ["sapphire", 3, [0.8, 0.2, 0.6], null, null, null, false],
        ["shape", 0, 0.005611351656626507, 0, 0.1, false, false],
        ["xDiv", 0, 1118.053765060241, 0, 4432, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:08:25.382Z"
    },
    "updated": {
      "$date": "2024-09-22T03:08:25.382Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8ac61191881f16ade028"
    },
    "shader": "void main() {\n  float stream = stream / 8.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  // uv *= k_rotate2d(-stream);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * shape * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.3);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream /-1.1425));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x/xDiv + granularity;\n  vec2 p = vec2(radius * sin(i), radius * cos(i - stream));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3. )) * 0.5 + 0.5;\n  gl_FragColor = vec4(pow(volume, .36) * ballSize / length(uv + p * colorMultiplier-length(uv/3.1-stream)) * col, 1.0);\n  gl_FragColor.xyz = sapphire * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n\n}",
    "variants": [
      [
        ["zoom", 0, 0.029, 0, 0.68, false],
        ["xMultiplier", 0, 91.9, 0, 140.74, false],
        ["yMultiplier", 0, 7.118, 0, 162.28, false],
        ["ballSize", 0, 39.407, 0, 319.34, false],
        ["colorSpread", 0, 0.008, 0, 0.5, false],
        ["colorMultiplier", 0, 357.132, 0, 3228.3, false],
        ["shapeMultiplier", 0, 22.878, 0, 226.04, false],
        ["glow", 0, 4623.298, 0, 18444.68, false],
        ["contrast", 0, 2.52, 0, 7.5, false],
        ["brightness", 0, 6.556, 0, 21.84, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 11.918, 0, 44, false],
        ["radius", 0, 9.757, 0, 34, false],
        ["sapphire", 3, [0.7450980392156863, 0.23529411764705882, 0.4549019607843137]],
        ["shape", 0, 0.005, 0, 0.1, false],
        ["xDiv", 0, 965.246, 0, 4432, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:11:02.316Z"
    },
    "updated": {
      "$date": "2024-09-22T03:11:02.316Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8bce1191881f16ade031"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 6.455, 0, 10, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:15:26.522Z"
    },
    "updated": {
      "$date": "2024-09-22T03:15:26.522Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8bda1191881f16ade036"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.007140436746987954, 0, 0.1, false, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 6.455, 0, 10, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:15:38.605Z"
    },
    "updated": {
      "$date": "2024-09-22T03:15:38.605Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef8be71191881f16ade039"
    },
    "shader": "#define BALLS 5\n\nvoid main () {\n  float stream = stream / 12.;\n  vec2 uv = k_uv() * zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  float dist = distance(uv, vec2(0));\n  float thing = .0005 * sin(shapeMultiplier*dot(uv, uv)/dist - stream/-4.);\n  uv *= k_rotate2d(rotation + .1*(dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/1.) + sin(uv.y * yMultiplier + stream/-2.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (col + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n   gl_FragColor = k_hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.1, false],
        ["shapeMultiplier", 0, 606.1652861445783, 0, 2000, false, false],
        ["rotation", 0, 0.0590643825301205, 0, 0.1, false, false],
        ["xMultiplier", 0, 287.50470632530124, 0, 1500, false, false],
        ["yMultiplier", 0, 253.25677710843374, 0, 1000, false, false],
        ["colorSpread", 0, 0.003169728915662651, 0.001, 0.009, false, false],
        ["colorMultiplier", 0, 1.1984186746987953, 0, 3, false, false],
        ["invert", 1, false, null, null, null, false],
        ["brightness", 0, 6.455, 0, 10, false],
        ["ballSize", 0, 7.444983057228917, 0, 55, false, false],
        ["glow", 0, 4, 0, 4, false, false],
        ["contrast", 0, 5, 0, 5, false, false],
        ["radius", 0, 7.704536897590362, 0, 20, false, false],
        ["col", 0, 1.6711219879518073, 0, 3, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:15:51.468Z"
    },
    "updated": {
      "$date": "2024-09-22T03:15:51.468Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a3a"
    }
  },
  {
    "_id": {
      "$oid": "66ef94771191881f16ade03d"
    },
    "shader": "void main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/4.);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.71));\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/1.);\n    float b = radius * sin(uv.y - stream);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.032, 0, 1, false],
        ["iterator", 0, 0.87, 0.7, 1.5, false],
        ["iterations", 0, 5.98, 0, 33, false],
        ["colorShift", 0, 0.158, 0, 3, false],
        ["colorOffset", 0, 20.786, 15, 30, false],
        ["contrast", 0, 1.393, 0, 3, false],
        ["orbSize", 0, 42.605, 0, 230, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 17.743, 0, 30, false],
        ["wave", 0, 6.791, 0, 20, false],
        ["split", 0, 40.315, 0, 200, false],
        ["inner", 0, 1039.61, 0, 1150, false],
        ["outer", 0, 36.225, 0, 401, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T03:52:23.636Z"
    },
    "updated": {
      "$date": "2024-09-22T03:52:23.636Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef97d01191881f16ade040"
    },
    "shader": "void main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.135, 0, 2, false],
        ["iterator", 0, 1.135, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.117, 0, 3, false],
        ["orbSize", 0, 6.165, 0, 10, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 11.846, 0, 30, false],
        ["wave", 0, 4.026, 0, 20, false],
        ["split", 0, 15.271, 0, 200, false],
        ["inner", 0, 21.846, 0, 100, false],
        ["outer", 0, 10, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T04:06:40.810Z"
    },
    "updated": {
      "$date": "2024-09-22T04:06:40.810Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66ef98501191881f16ade045"
    },
    "shader": "void main () {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.135, 0, 2, false],
        ["iterator", 0, 1.135, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 20.017, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 25.847, 0, 30, false],
        ["wave", 0, 4.026, 0, 20, false],
        ["split", 0, 5.371, 0, 200, false],
        ["inner", 0, 21.846, 0, 100, false],
        ["outer", 0, 10, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T04:08:48.919Z"
    },
    "updated": {
      "$date": "2024-09-22T04:08:48.919Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efaaca1191881f16ade048"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.159, 0, 2, false],
        ["iterator", 0, 1.213, 0.7, 2, false],
        ["iterations", 0, 5.98, 0, 33, false],
        ["colorShift", 0, 0.288, 0, 3, false],
        ["colorOffset", 0, 20.786, 15, 30, false],
        ["contrast", 0, 1.406, 0, 3, false],
        ["orbSize", 0, 22.638, 0, 40, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 9.24, 0, 30, false],
        ["wave", 0, 2.933, 0, 30, false],
        ["split", 0, 8.013, 0, 200, false],
        ["inner", 0, 49082863.243, 0, 93223150, false],
        ["outer", 0, 35608.658, 0, 51221, false],
        ["mul", 0, 0.332, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T05:27:38.675Z"
    },
    "updated": {
      "$date": "2024-09-22T05:27:38.675Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efaad31191881f16ade04b"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.2, false],
        ["iterator", 0, 1.213, 0.7, 2, false],
        ["iterations", 0, 5.98, 0, 33, false],
        ["colorShift", 0, 0.288, 0, 3, false],
        ["colorOffset", 0, 20.786, 15, 30, false],
        ["contrast", 0, 1.406, 0, 3, false],
        ["orbSize", 0, 22.638, 0, 40, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 9.24, 0, 30, false],
        ["wave", 0, 2.933, 0, 30, false],
        ["split", 0, 8.013, 0, 200, false],
        ["inner", 0, 49082863.243, 0, 93223150, false],
        ["outer", 0, 35608.658, 0, 51221, false],
        ["mul", 0, 0.332, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T05:27:47.596Z"
    },
    "updated": {
      "$date": "2024-09-22T05:27:47.596Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efac771191881f16ade04e"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 200.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.09, 0, 0.5, false],
        ["iterator", 0, 1.162, 0.7, 3, false],
        ["iterations", 0, 16.702, 0, 33, false],
        ["colorShift", 0, 1.245, 0, 3, false],
        ["colorOffset", 0, 17.566, 15, 30, false],
        ["contrast", 0, 1.313, 0, 3, false],
        ["orbSize", 0, 99.656, 0, 540, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 16.083, 0, 30, false],
        ["wave", 0, 6.035, 0, 30, false],
        ["split", 0, 8.473, 0, 20, false],
        ["inner", 0, 93223150, 0, 93223150, false],
        ["outer", 0, 47124.698, 0, 51221, false],
        ["mul", 0, 0.332, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T05:34:47.059Z"
    },
    "updated": {
      "$date": "2024-09-22T05:34:47.059Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efac821191881f16ade051"
    },
    "shader": "void main () {\n  float stream = stream / 13.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 300.;\n  uv *= k_rotate2d(stream/.5 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.09, 0, 0.5, false],
        ["iterator", 0, 1.162, 0.7, 3, false],
        ["iterations", 0, 16.702, 0, 33, false],
        ["colorShift", 0, 1.245, 0, 3, false],
        ["colorOffset", 0, 17.566, 15, 30, false],
        ["contrast", 0, 1.313, 0, 3, false],
        ["orbSize", 0, 99.656, 0, 540, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 16.083, 0, 30, false],
        ["wave", 0, 6.035, 0, 30, false],
        ["split", 0, 8.473, 0, 20, false],
        ["inner", 0, 93223150, 0, 93223150, false],
        ["outer", 0, 47124.698, 0, 51221, false],
        ["mul", 0, 0.332, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T05:34:58.030Z"
    },
    "updated": {
      "$date": "2024-09-22T05:34:58.030Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efafdd1191881f16ade05c"
    },
    "shader": "void main () {\n  float stream = stream / 13.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 300.;\n  uv *= k_rotate2d(stream/.25 - abs(uv.x));\n  // uv *= mul * abs(length(uv/.00001));\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.2425));\n  for (float i = 2.; i < 10.; i++) {\n  // uv *= k_rotate2d(float(int(i)) + PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.022, 0, 0.2, false],
        ["iterator", 0, 0.736, 0.7, 3, false],
        ["iterations", 0, 16.702, 0, 33, false],
        ["colorShift", 0, 1.094, 0, 3, false],
        ["colorOffset", 0, 22.86, 15, 30, false],
        ["contrast", 0, 1.088, 0, 3, false],
        ["orbSize", 0, 55.585, 0, 3540, false],
        ["div", 0, 4.623, 0.01, 15, false],
        ["radius", 0, 2.911, 0, 10, false],
        ["wave", 0, 2.057, 0, 30, false],
        ["split", 0, 12.991, 0, 20, false],
        ["inner", 0, 93223150, 0, 93223150, false],
        ["outer", 0, 101338.936, 0, 251221, false],
        ["mul", 0, 13.443, 0, 22, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T05:49:17.175Z"
    },
    "updated": {
      "$date": "2024-09-22T05:49:17.175Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efb3ca1191881f16ade05f"
    },
    "shader": "void main () {\n  float stream = stream / 10.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1000.;\n  uv *= k_rotate2d(stream/.75 - abs(uv.x));\n  uv *= length(fract(abs(uv)/.01));\n  uv *= outer * sin(inner *length(uv) - stream/.423);\n  for (float i = 2.; i < 10.; i++) {\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  // uv *= k_rotate2d(float(int(i)) + PI/20.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.4);\n    float b = radius * sin(uv.y - stream/.5117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.31855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .3195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.001, 0, 0.015, false],
        ["iterator", 0, 1.108, 0.7, 3, false],
        ["iterations", 0, 2.608, 0, 33, false],
        ["colorShift", 0, 0.25, 0, 3, false],
        ["colorOffset", 0, 19.086, 15, 30, false],
        ["contrast", 0, 1.364, 0, 3, false],
        ["orbSize", 0, 799511.488, 0, 955540, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 205.593, 0, 230, false],
        ["wave", 0, 40.198, 0, 130, false],
        ["split", 0, 52.417, 0, 320, false],
        [
          "inner",
          0,
          {
            "$numberLong": "9112232150"
          },
          1,
          {
            "$numberLong": "9112232150"
          },
          false
        ],
        [
          "outer",
          0,
          2753625353.334,
          0,
          {
            "$numberLong": "3821251221"
          },
          false
        ],
        ["mul", 0, 1, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T06:06:02.583Z"
    },
    "updated": {
      "$date": "2024-09-22T06:06:02.583Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efbc701191881f16ade062"
    },
    "shader": "void main () {\n  float stream = stream / 20.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 23200.;\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/.3));\n  uv *= k_rotate2d(stream/.25);\n  for (float i = 2.; i < 15.; i++) {\n  // uv *= zoom*length(uv);\n    // uv -= mul * abs(fract(abs(uv)) - .5);\n  uv *= k_rotate2d(stream/5.  + float(int(i))/20. + PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.1514);\n    float b = radius * sin(uv.y - stream/1.117);\n    float c = radius * wave * sin(split * uv.x - (stream / -.1855));\n    float d = radius * wave * cos(split * uv.y  - (stream / .195));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.331, 0, 5, false],
        ["iterator", 0, 0.736, 0.1, 2, false],
        ["iterations", 0, 12.664, 0, 33, false],
        ["colorShift", 0, 0.362, 0, 3, false],
        ["colorOffset", 0, 17.251, 15, 30, false],
        ["contrast", 0, 2.313, 0, 3, false],
        ["orbSize", 0, 420, 0, 420, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 122.832, 0, 130, false],
        ["wave", 0, 6.322, 0, 30, false],
        ["split", 0, 6.435, 0, 200, false],
        ["inner", 0, 156372.005, 0, 1234931, false],
        ["outer", 0, 525199.083, 0, 3212112, false],
        ["mul", 0, 0.091, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T06:42:56.375Z"
    },
    "updated": {
      "$date": "2024-09-22T06:42:56.375Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efbd011191881f16ade067"
    },
    "shader": "void main () {\n  float stream = stream / 50.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.135, 0, 2, false],
        ["iterator", 0, 1.135, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 20.017, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 25.847, 0, 30, false],
        ["wave", 0, 4.026, 0, 20, false],
        ["split", 0, 5.371, 0, 200, false],
        ["inner", 0, 21.846, 0, 100, false],
        ["outer", 0, 10, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T06:45:21.511Z"
    },
    "updated": {
      "$date": "2024-09-22T06:45:21.511Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efbfd41191881f16ade06c"
    },
    "shader": "void main () {\n  float stream = stream / 16.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 200.;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 2.; i < 12.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.771, 0, 7, false],
        ["iterator", 0, 1.165, 0.7, 2, false],
        ["iterations", 0, 23.693, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 15.535, 15, 30, false],
        ["contrast", 0, 1.292, 0, 3, false],
        ["orbSize", 0, 23.38, 0, 211, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 12.705, 0, 30, false],
        ["wave", 0, 4.719, 0, 50, false],
        ["split", 0, 23.17, 0, 50, false],
        ["inner", 0, 20739.465, 0, 21992, false],
        ["outer", 0, 80.884, 0, 227, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T06:57:24.708Z"
    },
    "updated": {
      "$date": "2024-09-22T06:57:24.708Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efc0f11191881f16ade06f"
    },
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.013, 0, 0.3, false],
        ["iterator", 0, 1.116, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.406, 0, 3, false],
        ["colorOffset", 0, 28.653, 15, 30, false],
        ["contrast", 0, 1.217, 0, 3, false],
        ["orbSize", 0, 1387.16, 0, 1500, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 27.036, 0, 230, false],
        ["wave", 0, 20, 0, 20, false],
        ["split", 0, 1.208, 0, 20, false],
        ["inner", 0, 5015.722, 0, 10000, false],
        ["outer", 0, 272.905, 0, 1000, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T07:02:09.831Z"
    },
    "updated": {
      "$date": "2024-09-22T07:02:09.831Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efc1401191881f16ade074"
    },
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-.75);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.012, 0, 0.03, false],
        ["iterator", 0, 1.111, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.384, 0, 3, false],
        ["colorOffset", 0, 18.713, 15, 30, false],
        ["contrast", 0, 1.303, 0, 3, false],
        ["orbSize", 0, 1217.276, 0, 1500, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 27.036, 0, 230, false],
        ["wave", 0, 20, 0, 20, false],
        ["split", 0, 1.208, 0, 20, false],
        ["inner", 0, 5015.722, 0, 10000, false],
        ["outer", 0, 272.905, 0, 1000, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T07:03:28.499Z"
    },
    "updated": {
      "$date": "2024-09-22T07:03:28.499Z"
    },
    "__v": 3,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efd4dc1191881f16ade07f"
    },
    "shader": "void main () {\n  float stream = stream / 7.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 5000.;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.5)));\n  uv *= k_rotate2d(stream/-.75);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/1.15);\n    float b = radius * sin(uv.y+stream/1.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.2));\n    float d = radius * wave * cos(split * uv.y  - (stream / .2));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.25)* orbSize, vec2(x, log(abs(x))),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.722, 0, 6, false],
        ["iterator", 0, 1.202, 0.7, 2, false],
        ["iterations", 0, 18.883, 0, 33, false],
        ["colorShift", 0, 0.53, 0, 3, false],
        ["colorOffset", 0, 18.732, 15, 30, false],
        ["contrast", 0, 1.237, 0, 3, false],
        ["orbSize", 0, 8.891, 0, 100, false],
        ["div", 0, 6.149, 0.01, 15, false],
        ["radius", 0, 47.569, 0, 150, false],
        ["wave", 0, 10.251, 0, 50, false],
        ["split", 0, 20, 0, 20, false],
        ["inner", 0, 7491644.749, 0, 10000000, false],
        ["outer", 0, 520.517, 0, 1000, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T08:27:08.615Z"
    },
    "updated": {
      "$date": "2024-09-22T08:27:08.615Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efe69f1191881f16ade098"
    },
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.135, 0, 2, false],
        ["iterator", 0, 1.135, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 20.017, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 25.847, 0, 30, false],
        ["wave", 0, 4.026, 0, 20, false],
        ["split", 0, 5.371, 0, 200, false],
        ["inner", 0, 21.846, 0, 100, false],
        ["outer", 0, 10, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T09:42:55.579Z"
    },
    "updated": {
      "$date": "2024-09-22T09:42:55.579Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66eff0b21191881f16ade09c"
    },
    "shader": "void main () {\n  float stream = stream / 222.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1000.;\n  uv *= k_rotate2d(stream/12.1/PI/2.);\n  uv /= sin(stream + abs(outer * cos(stream/.5 - sin(inner*dot(uv, uv) - stream/1.))));\n  for (float i = 5.; i < 20.; i++) {\n    uv *= k_rotate2d(stream/30.1/PI/2.);\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/3.1745);\n    float b = radius * sin(uv.y+stream/1.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -.074255));\n    float d = radius * wave * cos(split * uv.y  - (stream / .3175));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.76, 0, 8, false],
        ["iterator", 0, 0.953, 0.2, 2, false],
        ["iterations", 0, 18.13, 0, 33, false],
        ["colorShift", 0, 0.793, 0, 3, false],
        ["colorOffset", 0, 17.129, 15, 30, false],
        ["contrast", 0, 2.338, 0, 3, false],
        ["orbSize", 0, 579.482, 0, 3342, false],
        ["div", 0, 2.977, 0.01, 15, false],
        ["radius", 0, 170, 0, 170, false],
        ["wave", 0, 835.683, 0, 2120, false],
        ["split", 0, 3078.899, 0, 3300, false],
        ["inner", 0, 349658.518, 0, 521123, false],
        ["outer", 0, 223.574, 0, 512, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T10:25:54.414Z"
    },
    "updated": {
      "$date": "2024-09-22T10:25:54.414Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66efff7e1191881f16ade0a0"
    },
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.023, 0, 0.2, false],
        ["iterator", 0, 1.15, 0.7, 2, false],
        ["iterations", 0, 9.869, 0, 33, false],
        ["colorShift", 0, 0.659, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 20.017, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 25.847, 0, 30, false],
        ["wave", 0, 8.265, 0, 20, false],
        ["split", 0, 26.298, 0, 200, false],
        ["inner", 0, 54.435, 0, 100, false],
        ["outer", 0, 9.7, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T11:29:02.453Z"
    },
    "updated": {
      "$date": "2024-09-22T11:29:02.453Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f00afa1191881f16ade0a5"
    },
    "shader": "void main () {\n  float stream = stream / 250.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1000.;\n  uv *= cos(outer * sin(inner*(abs(dot(uv, uv))) - stream/-1.59953) - stream/2.29953);//+3.25*cos(uv.x/11.1-stream/16.) ;//* .1/k_rotate2d(stream + length(uv)/.000000005);\n  uv *= k_rotate2d(stream/-.120123);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.5);\n    float b = radius * sin(uv.y+stream/1.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.155));\n    float d = radius * wave * cos(split * uv.y  - (stream / .015));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.074, 0, 1, false],
        ["iterator", 0, 1.07, 0.2, 2, false],
        ["iterations", 0, 11.104, 0, 33, false],
        ["colorShift", 0, 0.416, 0, 3, false],
        ["colorOffset", 0, 28.009, 15, 30, false],
        ["contrast", 0, 1.51, 0, 3, false],
        ["orbSize", 0, 3807.526, 0, 14333, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 26.777, 0, 323, false],
        ["wave", 0, 251, 0, 251, false],
        ["split", 0, 33255, 0, 33255, false],
        ["inner", 0, 3221200, 0, 3221200, false],
        ["outer", 0, 95.984, 0, 1123, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:18:02.346Z"
    },
    "updated": {
      "$date": "2024-09-22T12:18:02.346Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f00b521191881f16ade0a8"
    },
    "shader": "void main () {\n  float stream = stream / 15.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.3)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.15);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 1, false],
        ["iterator", 0, 1.202, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 12.541, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 11.461, 0, 20, false],
        ["split", 0, 3.2, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:19:30.826Z"
    },
    "updated": {
      "$date": "2024-09-22T12:19:30.826Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f00d581191881f16ade0ab"
    },
    "shader": "void main () {\n  float stream = stream / 9.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/.93));\n  uv *= k_rotate2d(stream/-.5);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/2.15);\n    float b = radius * sin(uv.y+stream/2.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.002, 0, 0.1, false],
        ["iterator", 0, 1.271, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.72, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 347.359, 0, 3333, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 5.62, 0, 30, false],
        ["wave", 0, 6.193, 0, 20, false],
        ["split", 0, 107.363, 0, 222, false],
        ["inner", 0, 164441.438, 0, 402211, false],
        ["outer", 0, 0.519, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:28:08.633Z"
    },
    "updated": {
      "$date": "2024-09-22T12:28:08.633Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f00ed31191881f16ade0ae"
    },
    "shader": "void main () {\n  float stream = stream / 19.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/.3));\n  uv *= k_rotate2d(stream/-.452435);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.6);\n    float b = radius * sin(uv.y+stream/.5);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / .25));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.002, 0, 0.01, false],
        ["iterator", 0, 1.134, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.72, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.067, 0, 3, false],
        ["orbSize", 0, 2909.578, 0, 3333, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 9.971, 9, 30, false],
        ["wave", 0, 1.763, 0, 20, false],
        ["split", 0, 31.157, 0, 222, false],
        ["inner", 0, 88321.454, 0, 402211, false],
        ["outer", 0, 44.76, 0, 110, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:34:27.721Z"
    },
    "updated": {
      "$date": "2024-09-22T12:34:27.721Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f0108f1191881f16ade0b1"
    },
    "shader": "void main () {\n  float stream = stream / 19.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1000.;\n  uv *= (outer * tan(inner*dot(uv, uv) - stream/1.01));\n  uv *= k_rotate2d(stream/-.2452435);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.16);\n    float b = radius * sin(uv.y+stream/.15);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / .25));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.345, -0.01, 1, false],
        ["iterator", 0, 0.979, 0.7, 3, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.72, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.512, 0, 3, false],
        ["orbSize", 0, 52.622, 0, 173, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 15, 1, 15, false],
        ["wave", 0, 8.009, 0, 150, false],
        ["split", 0, 66.608, 0, 222, false],
        ["inner", 0, 2485681.402, 0, 4333211, false],
        ["outer", 0, 254.776, 0, 2120, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:41:51.969Z"
    },
    "updated": {
      "$date": "2024-09-22T12:41:51.969Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f013141191881f16ade0b4"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.141, 0, 1, false],
        ["iterator", 0, 1.04, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 12.541, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 2.005, 0, 20, false],
        ["split", 0, 50.385, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:52:36.422Z"
    },
    "updated": {
      "$date": "2024-09-22T12:52:36.422Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f0137d1191881f16ade0b7"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.056, 0, 0.2, false],
        ["iterator", 0, 1.201, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.157, 0, 3, false],
        ["orbSize", 0, 19.277, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 1.775, 0, 20, false],
        ["split", 0, 36.146, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:54:21.590Z"
    },
    "updated": {
      "$date": "2024-09-22T12:54:21.590Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f013981191881f16ade0ba"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, .75)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.087, 0, 0.2, false],
        ["iterator", 0, 1.18, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.157, 0, 3, false],
        ["orbSize", 0, 19.277, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 1.775, 0, 20, false],
        ["split", 0, 36.146, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T12:54:48.637Z"
    },
    "updated": {
      "$date": "2024-09-22T12:54:48.637Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f015811191881f16ade0bd"
    },
    "shader": "void main () {\n  float stream = stream / 20.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-.45);\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.2)));\n  uv *= k_rotate2d(stream/-2.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.2415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -.25));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.087, 0, 0.2, false],
        ["iterator", 0, 1.18, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.157, 0, 3, false],
        ["orbSize", 0, 19.277, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 1.775, 0, 20, false],
        ["split", 0, 36.146, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T13:02:57.948Z"
    },
    "updated": {
      "$date": "2024-09-22T13:02:57.948Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f045091191881f16ade0e1"
    },
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.0726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.12);\n    float c = radius * wave * sin(split * uv.x - (stream / -.055));\n    float d = radius * wave * cos(split * uv.y  - (stream / .05));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.345, 0, 3, false],
        ["iterator", 0, 1.095, 0.7, 1.5, false],
        ["iterations", 0, 2.594, 0, 33, false],
        ["colorShift", 0, 0.085, 0, 3, false],
        ["colorOffset", 0, 19.294, 15, 30, false],
        ["contrast", 0, 1.945, 0, 3, false],
        ["orbSize", 0, 0.075, 0, 1, false],
        ["div", 0, 3.891, 0.01, 15, false],
        ["radius", 0, 2.251, 0, 30, false],
        ["wave", 0, 1.124, 0, 20, false],
        ["split", 0, 454.723, 0, 500, false],
        ["inner", 0, 11512120, 0, 11512120, false],
        ["outer", 0, 36.225, 0, 401, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-22T16:25:45.967Z"
    },
    "updated": {
      "$date": "2024-09-22T16:25:45.967Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f0c0921191881f16ade0fc"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.7)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.141, 0, 1, false],
        ["iterator", 0, 1.04, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 12.541, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 2.005, 0, 20, false],
        ["split", 0, 50.385, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-23T01:12:50.795Z"
    },
    "updated": {
      "$date": "2024-09-23T01:12:50.795Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f0c0eb1191881f16ade100"
    },
    "shader": "void main () {\n  float stream = stream / 12.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= (abs(outer * cos(inner*dot(uv, uv) - stream/.39)));\n  uv *= k_rotate2d(stream/-1.);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x-stream/.415);\n    float b = radius * sin(uv.y+stream/.25);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.55));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.5));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.141, 0, 1, false],
        ["iterator", 0, 1.04, 0.7, 2, false],
        ["iterations", 0, 10.504, 0, 33, false],
        ["colorShift", 0, 0.506, 0, 3, false],
        ["colorOffset", 0, 29.656, 15, 30, false],
        ["contrast", 0, 1.095, 0, 3, false],
        ["orbSize", 0, 12.541, 0, 22, false],
        ["div", 0, 10.566, 0.01, 15, false],
        ["radius", 0, 8.423, 0, 30, false],
        ["wave", 0, 2.005, 0, 20, false],
        ["split", 0, 50.385, 0, 200, false],
        ["inner", 0, 100, 0, 100, false],
        ["outer", 0, 4.547, 0, 10, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-23T01:14:19.050Z"
    },
    "updated": {
      "$date": "2024-09-23T01:14:19.050Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f0c3dc1191881f16ade112"
    },
    "shader": "void main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / -7.5);\n  for (float i = 5.; i < 20.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 2.75);\n    float b = radius * sin(uv.y + stream / -3.75);\n    float c = radius * wave * sin(split * uv.x - (stream / -1.58255));\n    float d = radius * wave * cos(split * uv.y  - (stream / 1.275));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.49, 0, 1, false],
        ["iterator", 0, 1.067, 0.17, 2, false],
        ["iterations", 0, 6.162, 0, 33, false],
        ["colorShift", 0, 0.172, 0, 3, false],
        ["colorOffset", 0, 22.793, 15, 30, false],
        ["contrast", 0, 1.218, 0, 3, false],
        ["orbSize", 0, 15, 0, 15, false],
        ["div", 0, 10.462, 0.01, 15, false],
        ["radius", 0, 14.725, 0, 16, false],
        ["wave", 0, 4.695, 0, 20, false],
        ["split", 0, 53.778, 0, 122, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-23T01:26:52.957Z"
    },
    "updated": {
      "$date": "2024-09-23T01:26:52.957Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8c9"
    },
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float stream = stream / 1.2;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream/15.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += x1*sin(x2*uv.y-stream);\n    uv.y -= y1*cos(y2*uv.x+stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t+stream/10.);\n    float y = radius * cos(t-stream/10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .5)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 26.54, 0, 53.08, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 5.39, 0, 10.78, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 53.08, 0, 53.08, false, false],
        ["contrast", 0, 1.475624, 0, 2.74, false, false],
        ["orbSize", 0, 1.812746, 0, 2.78, false, false],
        ["radius", 0, 6.592458, 0, 8.04, false, false],
        ["colorShift", 0, 6.478777, 0, 10.74, false, false],
        ["x1", 0, 0, 0, 1.14, false, false],
        ["x2", 0, 0.26894, 0, 0.6, false, false],
        ["y1", 0, 1.26, 0, 1.26, false, false],
        ["y2", 0, 2.372751, 0, 3, false, false],
        ["center", 0, 30.572182, 0, 133.3, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 69.63853, 0, 153.08, false, false],
        ["contrast", 0, 2.119733, 0, 2.74, false, false],
        ["orbSize", 0, 6.244888, 0, 22.78, false, false],
        ["radius", 0, 10.580402, 0, 18.04, false, false],
        ["colorShift", 0, 6.478777, 0, 10.74, false, false],
        ["x1", 0, 0.84439, 0, 1.14, false, false],
        ["x2", 0, 1.006902, 0, 21, false, false],
        ["y1", 0, 1.525242, 0, 31.26, false, false],
        ["y2", 0, 0.179639, 0, 3, false, false],
        ["center", 0, 6.533354, 0, 133.3, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 30.635108, 0, 153.08, false, false],
        ["contrast", 0, 2.38993, 0, 2.74, false, false],
        ["orbSize", 0, 3.662296, 0, 22.78, false, false],
        ["radius", 0, 10.669814, 0, 18.04, false, false],
        ["colorShift", 0, 2.920201, 0, 10.74, false, false],
        ["x1", 0, 0, 0, 1.14, false, false],
        ["x2", 0, 5.370659, 0, 21, false, false],
        ["y1", 0, 4.792634, 0, 31.26, false, false],
        ["y2", 0, 1.211102, 0, 3, false, false],
        ["center", 0, 6.533354, 0, 133.3, false, false],
        ["sides", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.155Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.155Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8cc"
    },
    "shader": "#define BALLS 15.\n\nvoid main () {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/-4.);\n  // uv *=outer*sin(inner / 500.*dot(uv, uv) - stream/24.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream/2.75);\n  gl_FragColor = vec4(0);\n  for (float i = 0.; i < BALLS; i++) {\n    uv *= k_rotate2d(stream/-5.*PI/20.);\n    float t = float(i) * PI / BALLS * (2. + 1.);\n    float x = xOuter * sin(xInner * t - stream);\n    float y = yOuter * cos(yOuter * t - stream/1.7);\n    vec2 p = vec2(radius*x, radius*y);\n    p /= pDiv * sin(PI * sin(uv.x/shape - stream/2.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume,.5)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 763.232826, 0, 2222, false],
        ["ballSize", 0, 90.045199, 0, 277.78, false],
        ["contrast", 0, 1.865348, 0, 5.04, false],
        ["radius", 0, 4945.528285, 0, 15792.5, false],
        ["shape", 0, 114.095092, 0, 500, false],
        ["sides", 0, 3, 0, 16, true],
        ["center", 0, 817.995185, 0, 2342, false],
        ["xOuter", 0, 0.323888, 0, 2, false],
        ["xInner", 0, 0.198128, 0, 2, false],
        ["yInner", 0, 1.408218, 0, 2, false],
        ["yOuter", 0, 1.670995, 0, 2, false],
        ["pDiv", 0, 22, 0, 22, false],
        ["inner", 0, 0.001367, 0, 0.1, false],
        ["outer", 0, 17.325566, 0, 21, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "__v": 5,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8cd"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= abs(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/6.);\n    float y = radius * sin(t+stream/8.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.04, 0, 0.2, false, false],
        ["bump", 0, 0.2, 0, 0.5, false, false],
        ["zoom", 0, 9.741, 0, 111, false],
        ["contrast", 0, 1.21, 0, 4, false],
        ["orbSize", 0, 4.346, 0.01, 15, false],
        ["radius", 0, 39.769, 1, 115, false],
        ["colorShift", 0, 7.65, 1, 40, false, false],
        ["sides", 0, 4, 0, 12, true, false],
        ["rotation", 0, 50, 0, 50, false, false],
        ["sinMul", 0, 2.23, 0, 5, false, false],
        ["cosMul", 0, 1.53, 0, 3, false, false],
        ["yMul", 0, 0.11, 0, 1, false, false],
        ["xMul", 0, 0.29, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 19, 0, 19, false, false],
        ["xDivide", 0, 19, 0, 19, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ce"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(dist/rotation + stream/50.);\n  //uv /= dot(uv, uv);\n  uv = kale(uv, vec2(0), sides);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/2.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * cos(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .8) * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.1, 0, 0.2, false, false],
        ["bump", 0, 0.5, 0, 0.5, false, false],
        ["zoom", 0, 40.43, 0, 111, false, false],
        ["contrast", 0, 1.202, 0, 4, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 14.079999999999998, 1, 115, false, false],
        ["colorShift", 0, 7.65, 1, 40, false, false],
        ["sides", 0, 1, 0, 12, true, false],
        ["rotation", 0, 50, 0, 50, false, false],
        ["sinMul", 0, 0, 0, 5, false, false],
        ["cosMul", 0, 3, 0, 3, false, false],
        ["yMul", 0, 0, 0, 1, false, false],
        ["xMul", 0, 0.4, 0, 5, false, false],
        ["xSpeed", 0, -22, -1, 1, false, false],
        ["ySpeed", 0, -2, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 5.89, 1, 12, false, false],
        ["xDivide", 0, 5.89, 0, 19, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8cf"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 swap (vec2 uv, vec2 uv2, bool v, bool vT, float vTP) {\n  return vT ? (v ? mix(uv, uv2, vTP) : mix(uv2, uv, vTP)) : (v ? uv2 : uv);\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\n  float stream = stream / .532;\n  float dist = length(uv);\n  vec2 warped = uv / dot(uv, uv);\n  uv = swap(uv, warped, warp, warpTween, warpTweenProgress);\n  uv *= rotate(stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sin((i+1.)*uv.y/div - stream/2.);\n    uv.y += cos((i+1.)*uv.x/div2 + stream/2.);\n    float t = i * PI / orbs * 20.;\n    float x = radius * sin(t);\n    float y = radius * cos(t);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .79)*orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.03, 0, 0.1, false, false],
        ["bump", 0, 0.44, 0, 1, false, false],
        ["zoom", 0, 0.1, 0, 12, false, false],
        ["contrast", 0, 1.55, 0, 2, false, false],
        ["orbSize", 0, 1.79, 0.01, 2, false, false],
        ["radius", 0, 1, 1, 14, false, false],
        ["colorShift", 0, 10.95, 3, 16, false, false],
        ["div", 0, 15.427, 0, 100, false, false],
        ["div2", 0, 32.974, 0, 200, false, false],
        ["warp", 1, true, null, null, false, false]
      ],
      [
        ["speed", 0, 0.03, 0, 0.1, false, false],
        ["bump", 0, 0.44, 0, 1, false, false],
        ["zoom", 0, 10.56, 0, 112, false, false],
        ["contrast", 0, 1.55, 0, 2, false, false],
        ["orbSize", 0, 0.94, 0.01, 2, false, false],
        ["radius", 0, 1, 1, 14, false, false],
        ["colorShift", 0, 8.11, 3, 16, false, false],
        ["div", 0, 90.8, 0, 100, false, false],
        ["div2", 0, 16.276, 0, 200, false, false],
        ["warp", 1, false, null, null, false, false]
      ],
      [
        ["speed", 0, 0.03, 0, 0.1, false, false],
        ["bump", 0, 0.68, 0, 1, false, false],
        ["zoom", 0, 0.43, 0, 1, false, false],
        ["contrast", 0, 1.24, 0, 2, false, false],
        ["orbSize", 0, 1.17, 0.01, 2, false, false],
        ["radius", 0, 14, 1, 14, false, false],
        ["colorShift", 0, 10.95, 3, 16, false, false],
        ["div", 0, 96.668, 0, 100, false, false],
        ["div2", 0, 66.266, 0, 200, false, false],
        ["warp", 1, true, null, null, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d0"
    },
    "shader": "#define BALLS 20\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize((uv) + sin(abs(1./length(uv)*20.*uv)-stream/2.)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n  uv += dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation + stream/15.);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/2.) / 1.*sin(uv.x/1. - stream/1.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.);// + stream/5000.;\n    float _multiplier = dist*multiplier * sin(stream + uv.x);\n    vec2 p = vec2(radius*-1.*tan(t*multiplier), 1.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 10. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .8) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["speed", 0, 0.04, 0, 0.1, false, false],
        ["bump", 0, 0.42, 0, 1, false, false],
        ["zoom", 0, 25.38, 0, 30, false, false],
        ["yDivider", 0, 27.34, 0.1, 1000, false, false],
        ["xDivider", 0, 10.17, 0.1, 1000, false, false],
        ["multiplier", 0, 287.12, 0.1, 1101, false, false],
        ["ballSize", 0, 1.72, 0, 2, false, false],
        ["contrast", 0, 1.41, 0, 5, false, false],
        ["radius", 0, 11, 0, 11, false, false],
        ["yOuter", 0, 0.3, 0, 1, false, false],
        ["xOuter", 0, 1, 0, 1, false, false],
        ["rotation", 0, 5, 0, 5, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d1"
    },
    "shader": "#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= rotate(dist/rotation + stream/20.);\n  //uv /= dot(uv, uv);\n  uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/1.);\n    uv.y -= cosMul * cos(uv.x * xMul + stream*ySpeed) - sin(uv.x/xDivide-stream/1.7);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/11.);\n    float y = radius * sin(t+stream/11.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.06, 0, 0.2, false, false],
        ["bump", 0, 0.37, 0, 0.5, false, false],
        ["zoom", 0, 33.367, 0, 111, false],
        ["contrast", 0, 1.242, 0, 4, false],
        ["orbSize", 0, 1.418, 0.01, 5, false],
        ["radius", 0, 8.08, 1, 115, false, false],
        ["colorShift", 0, 7.65, 1, 40, false, false],
        ["sides", 0, 1, 0, 12, true, false],
        ["rotation", 0, 12.74, 0, 50, false, false],
        ["sinMul", 0, 0, 0, 15, false, false],
        ["cosMul", 0, 2.22, 0, 3, false, false],
        ["yMul", 0, 0.25, 0, 1, false, false],
        ["xMul", 0, 0.42, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 0, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 2.04, 1, 12, false, false],
        ["xDivide", 0, 16.34, 0, 19, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d2"
    },
    "shader": "#define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  //uv *= rotate(rotation*stream/5.);\n  //uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  uv *= rotate(stream/40.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) + cos(uv.y/yDivide-stream/4.);\n    uv.y -= cosMul * cos(uv.x * xMul - stream*ySpeed) - sin(uv.x/xDivide-stream/7.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/4.);\n    float y = radius * sin(t+stream/4.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .8)*orbSize, position, 1.-color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.1, 0, 0.2, false, false],
        ["bump", 0, 0.5, 0, 0.5, false, false],
        ["zoom", 0, 47.434, 0, 111, false],
        ["contrast", 0, 1.167, 0, 2, false],
        ["orbSize", 0, 2.594, 0.01, 6, false],
        ["radius", 0, 10.291, 1, 115, false],
        ["colorShift", 0, 7.12, 4, 10, false, false],
        ["sides", 0, 4, 0, 12, true, false],
        ["rotation", 0, 0, 0, 2, false, false],
        ["sinMul", 0, 2, 0, 2, false, false],
        ["cosMul", 0, 0.94, 0, 3, false, false],
        ["yMul", 0, 0.14, 0, 1, false, false],
        ["xMul", 0, 0.05, 0, 5, false, false],
        ["xSpeed", 0, -0.5, -1, 1, false, false],
        ["ySpeed", 0, 0.5, 0, 1, false, false],
        ["gloop", 0, 0.006, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.2, 0, 19, false, false],
        ["xDivide", 0, 2.08, 0, 19, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d3"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv *= k_rotate2d(stream/20.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += radius * sin((i+1.)*uv.y/yDiv - stream);\n    uv.y += radius * cos((i+1.)*uv.x/xDiv + stream);\n    float t = i * PI / orbs;\n    vec2 position = vec2(0, 0);\n    vec3 color = cos(stream/2.+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 16.)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.882917, 0, 20, false, false],
        ["contrast", 0, 1.21, 0, 2, false, false],
        ["orbSize", 0, 0.071563, 0.01, 2, false, false],
        ["colorShift", 0, 15, 3, 15, false, false],
        ["warp", 1, true, null, null, null, false],
        ["radius", 0, 0.103421, 0, 2, false, false],
        ["yDiv", 0, 0.754, 0, 10, false, false],
        ["xDiv", 0, 2.235, 0, 10, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d4"
    },
    "shader": "precision highp float;\n\n\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv *= rotate2d(1. + stream/35.);\n  vec2 p = shape2 / abs(vec2(.5 / shape));\n  p /= abs(tan(sin(xShape * uv.x-stream) * (cos(yShape * uv.y - stream))));\n  vec3 col = cos(vec3(0, 2, 0) * PI * 2. / 3. + PI * (time / 3.23 + colorShape * uv.x)) * 0.5 + 0.5;\n  float x = sin(uv.x);\n  float y = cos(uv.y - cos(uv.y + uv.x));\n  gl_FragColor += vec4(length(vec2(x, y)) * (pow(1./volume, -.6)) * ballSize / length(uv - p * 0.9) * col, contrast);\n  gl_FragColor.xyz = pow(vec3(1.25) - (gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor.b *= .42;\n}",
    "variants": [
      [
        ["speed", 0, 0.1, 0, 0.3, false, false],
        ["bump", 0, 0.5, 0, 1, false, false],
        ["zoom", 0, 1.443, 0, 4, false],
        ["xShape", 0, 7.238, 0, 11, false],
        ["yShape", 0, 7.275, 0, 11, false],
        ["colorShape", 0, 11, 0, 11, false, false],
        ["contrast", 0, 0.376, 0, 1, false, false],
        ["ballSize", 0, 3.948, 0, 4, false],
        ["shape", 0, 1.34, 0, 3, false],
        ["shape2", 0, 0.284, 0, 2, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d5"
    },
    "shader": "#define orbs 30.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  uv *= k_rotate2d(stream / 20.);\n  uv = uv - cos( .0005 * dot(uv, uv)) * sin(.01 * dot(uv, uv)+stream/12.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x -= cos((i+1.)*uv.y/div - stream);\n    uv.y += cos((i+1.)*uv.x/div2 - stream/2.5);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.);\n    float y = radius * cos(t - stream/6.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(uv.x/200. + uv.y/25500.*stream + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, pow(volume, .7) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.15, 0, 1, false, false],
        ["bump", 0, 0.37, 0, 1, false, false],
        ["zoom", 0, 11.15, 0, 151, false, false],
        ["contrast", 0, 1.094, 0, 2, false],
        ["orbSize", 0, 1.055, 0.01, 2, false],
        ["radius", 0, 12.89, 0, 14, false, false],
        ["colorShift", 0, 10.54, 3, 33, false, false],
        ["div", 0, 40, 10, 40, false, false],
        ["div2", 0, 40, 10, 40, false, false],
        ["warp", 1, true, null, null, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d6"
    },
    "shader": "#define orbs 20.\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nvoid main () {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n\tuv.x = abs(uv.x);\n  uv = uv * cos( .0001 * dot(uv, uv) - stream/5.) + uv.x / 1111.;// * 20.*sin(9.1 * dot(uv, uv)-stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/11.) * sin(t-stream) * cos(t+stream/2.114) ;\n    float y = radius * cos(t - stream/2.2) * cos(t-stream) * tan(t+stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.03, 0, 0.1, false, false],
        ["bump", 0, 0.45, 0, 1, false, false],
        ["zoom", 0, 52.612, 0, 151, false],
        ["contrast", 0, 0.931, 0, 2, false],
        ["orbSize", 0, 0.617, 0.01, 12, false],
        ["radius", 0, 22.221, 0, 24, false],
        ["colorShift", 0, 11.52, 3, 33, false, false],
        ["div", 0, 17.328, 10, 40, false, false],
        ["div2", 0, 14.483, 10, 40, false, false],
        ["warp", 1, true, null, null, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d7"
    },
    "shader": "#define orbs 20.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y; \n  uv *= zoom;\n  for (float i = 0.; i < orbs; i++) {\n    uv.y -= cos((i+1.)*uv.y/div - stream);\n    uv.x += cos((i+1.)*uv.y/div2 - stream/1.5);\n    float t = i * PI / orbs;\n    float x = radius * tan(t + stream/2.);\n    float y = radius * cos(t - stream/2.2) * sin(t-stream/3.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["speed", 0, 0.03, 0, 0.1, false, false],
        ["bump", 0, 0.5, 0, 1, false, false],
        ["zoom", 0, 24.95, 0, 151, false, false],
        ["contrast", 0, 0.902, 0, 2, false, false],
        ["orbSize", 0, 0.682, 0.01, 2, false, false],
        ["radius", 0, 8.159, 0, 20, false, false],
        ["colorShift", 0, 12.71, 3, 33, false, false],
        ["div", 0, 10, 1, 10, false, false],
        ["div2", 0, 10, 1, 10, false, false],
        ["warp", 1, true, null, null, null, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d8"
    },
    "shader": "#define BALLS 20.\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n    uv *= k_rotate2d(stream/2.);\n  uv = sin(stream * 1. + (uv));\n  //  uv += tan(log(uv) + stream/1.);\n  uv *= sin((dot(uv, uv)) - stream / .8);\n  uv *= k_rotate2d(rotation * dist + stream / 1.7);\n  for (float i = 0.; i < BALLS; i++) {\n    // uv.x /= cos(log(abs(uv.x*.1)-float(i+2.)));\n    float t = stream / 7. + float(i) * PI / BALLS;\n    vec2 p = vec2(radius * tan(t), radius * sin(t));\n    //p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(2.7/dist * pow(volume, .9)*ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .6) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.559, 0, 1.58, false],
        ["contrast", 0, 2.733, 0, 6.06, false],
        ["ballSize", 0, 0.034, 0, 0.1, false],
        ["radius", 0, 0.53, 0, 2.66, false],
        ["col", 3, [0.37254901960784315, 0.6509803921568628, 0.9490196078431372], null, null, false, false],
        ["rotation", 0, 0.225, 0, 3.66, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8d9"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv /= dot(uv, uv);\n  float dist = length(uv);\n  // uv += sin(stream*1.+(1.-log(sin(uv))));\n  uv *= k_rotate2d(stream/3.);\n  // uv += sin(dotMultiplier * (cos(dot(abs(uv), log(abs(uv)))) - stream / 11.));\n  // uv *= k_rotate2d(rotation*dist+stream/1.);\n  for (int i = 5; i < BALLS; i++) {\n    // uv.x -= .01*cos(log(abs(uv.x*.1)-float(i+1))-stream);\n    float t = float(i) * PI / float(BALLS);\n    vec2 p = radius * vec2(tanMul * tan(t - stream/2.), sinMul * sin(t + stream/4.));\n    p += radius * tan(stream + float(i) - PI) * sin(t - stream);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (stream / 55. + float(i) / 10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p) * col, 1.0);\n  }\n  gl_FragColor.xyz = pow(dist, .5) * pow((gl_FragColor.xyz), vec3(contrast)) + .2 * col;\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.153, 0, 1.556, false],
        ["contrast", 0, 1.831, 0, 10, false],
        ["ballSize", 0, 0.507, 0, 2, false],
        ["radius", 0, 6.699, 0, 9, false],
        ["col", 3, [0.37254901960784315, 0.6509803921568628, 0.9490196078431372], null, null, false, false],
        ["rotation", 0, 2.17, 0, 4.34, false, false],
        ["dotMultiplier", 0, 5, 0, 10, false, false],
        ["tanMul", 0, 0.9, 0, 1.8, false, false],
        ["sinMul", 0, 0, 0, 0, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.158Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8da"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .45;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / 15. * cos(uv.y / yDivider + stream / 10.) + a * sin(uv.x / 100. - stream / 12.);\n    uv.x += float(i) / 8. * sin(uv.x / xDivider - stream / 15.) - b * cos(uv.y / 100. + stream / 10.);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-11. * tan(t + stream/10.), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 100.) * cos(uv.y / 40.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 239.782, 0, 355.48, false, false],
        ["yDivider", 0, 23.215, 0, 32, false, false],
        ["xDivider", 0, 520.181, 0, 737.44, false, false],
        ["multiplier", 0, 1.895, 0, 2.582, false, false],
        ["ballSize", 0, 50.485, 0, 119.2, false, false],
        ["contrast", 0, 3.054, 0, 6.06, false, false],
        ["radius", 0, 23.28, 0, 73.78, false, false],
        ["a", 0, 1.91, 0, 12, false, false],
        ["b", 0, 8.04, 0, 12, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ca"
    },
    "shader": "#define orbs 15.\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream/9.);\n  float dist = length(uv);\n  uv = k_kale(uv, vec2(center*dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 8.;\n    float x = t * radius * cos(dist*t-stream/1.5)*1.-sin(dist+stream);\n    float y = 0.;\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.34, 0, 8.68, false, false],
        ["contrast", 0, 1.344, 0, 2.26, false],
        ["orbSize", 0, 0.132, 0, 0.18, false],
        ["radius", 0, 2.239, 0, 2.9, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.94, 0, 1.88, false, false],
        ["sides", 0, 8, 0, 16, false, false],
        ["shape", 0, 0.36, 0, 0.72, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.156Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.156Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8dc"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .6;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(abs(uv));\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y += .2 * float(i) * cos(uv.y / yDivider + stream / 11.) + sin(uv.x / 21. - stream / 12.);\n    uv.x += .2 * float(i) * sin(uv.x / xDivider - stream / 11.) - sin(uv.y / 20. + stream / 12.);\n    float t = .01 * dist * float(i) * PI / float(BALLS) * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(-1. * cos(t), 1. * sin(t / multiplier));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) *volume* ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, true, null, null, false, false]
      ],
      [
        ["zoom", 0, 50.47, 0, 100.94, false, false],
        ["yDivider", 0, 397.41, 0, 794.82, false, false],
        ["xDivider", 0, 815.27, 0, 1630.54, false, false],
        ["multiplier", 0, 4.29, 0, 8.58, false, false],
        ["ballSize", 0, 0.22, 0, 0.44, false, false],
        ["contrast", 0, 1.96, 0, 3.92, false, false],
        ["radius", 0, 9.33, 0, 18.66, false, false],
        ["mirror", 1, false, null, null, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8de"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 20.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 21.09, 0, 42.18, false, false],
        ["contrast", 0, 1.37, 0, 2.74, false, false],
        ["orbSize", 0, 1.39, 0, 2.78, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 5.37, 0, 10.74, false, false],
        ["x1", 0, 0.57, 0, 1.14, false, false],
        ["x2", 0, 0.3, 0, 0.6, false, false],
        ["y1", 0, 0.63, 0, 1.26, false, false],
        ["y2", 0, 0.53, 0, 1.06, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 6, 0, 12, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8cb"
    },
    "shader": "#define BALLS 5\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv);//(1.+ProgressBasis/2.);\n  if (invertTween) {\n  \tif (invert) {\n     \tuv = mix(uv, abs(uv), invertTweenProgress); \n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress); \n    }\n  } else if (invert) {\n   \tuv = abs(uv); \n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005*sin(shapeMultiplier*dot(uv, uv)/dist - stream/4.);\n//  vec2 _kale = kale(uv, vec2(0.), sides);\n  uv *= rotate2d(rotation * (dist - stream/1.));\n  float _grid = (cos(uv.x * xMultiplier - stream/4.) + sin(uv.y * yMultiplier + stream/10.));\n  uv /= colorSpread * thing * _grid;\n  uv*=dist;\n  uv.x += uv.y;// / cos(uv.x);//sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= rotate2d(dist*float(i));//-stream/10.);\n    float t = float(i) * PI / float(BALLS);// - stream/4.;\n    vec2 p = radius * vec2(radius*tan(t), radius*cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize  / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n gl_FragColor = hue(gl_FragColor, stream/50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.062, 0, 0.124, false, false],
        ["shapeMultiplier", 0, 203.13, 0, 406.26, false, false],
        ["rotation", 0, 0.05, 0, 0.1, false, false],
        ["xMultiplier", 0, 59.27, 0, 118.54, false, false],
        ["yMultiplier", 0, 88, 0, 176, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.81, 0, 1.62, false, false],
        ["invert", 1, true, null, null, false, false],
        ["brightness", 0, 3.86, 0, 7.72, false, false],
        ["ballSize", 0, 36.72, 0, 73.44, false, false],
        ["glow", 0, 1.22, 0, 2.44, false, false],
        ["contrast", 0, 2.72, 0, 5.44, false, false],
        ["radius", 0, 16.24, 0, 32.48, false, false]
      ],
      [
        ["zoom", 0, 0.02, 0, 0.124, false],
        ["shapeMultiplier", 0, 203.13, 0, 406.26, false, false],
        ["rotation", 0, 0.05, 0, 0.1, false, false],
        ["xMultiplier", 0, 59.27, 0, 118.54, false, false],
        ["yMultiplier", 0, 88, 0, 176, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.81, 0, 1.62, false, false],
        ["invert", 1, false],
        ["brightness", 0, 3.86, 0, 7.72, false, false],
        ["ballSize", 0, 36.72, 0, 73.44, false, false],
        ["glow", 0, 1.22, 0, 2.44, false, false],
        ["contrast", 0, 2.72, 0, 5.44, false, false],
        ["radius", 0, 22.046, 0, 32.48, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.157Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8df"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float stream = stream / .47;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= cos(.00005 * dot(uv, uv) - stream / 20.);\n  uv *= k_rotate2d(stream / 120.);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * sin(uv.y) - cos(uv.y / yDivider + stream / 8.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 14.) * .251 * cos(uv.y / yShape + stream / 6.);\n    float t = 5.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 100.;\n    float x = -1. * tan(t + stream / 1000.);\n    float y = sin(t / multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape + stream / 10.)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(stream / 10. + vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, 1.16)*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 90.275, 0, 294.9, false, false],
        ["yDivider", 0, 18.646, 0, 49.4, false, false],
        ["xDivider", 0, 9.294, 0, 14.94, false, false],
        ["multiplier", 0, 1.219, 0, 1.73, false, false],
        ["ballSize", 0, 34.82, 0, 69.64, false, false],
        ["contrast", 0, 1.8, 0, 3.6, false, false],
        ["radius", 0, 76.67, 0, 153.34, false, false],
        ["rotation", 0, 14.858, 0, 15.2, false, false],
        ["yDivide", 0, 307.888, 0, 703.66, false, false],
        ["xDivide", 0, 0.408, 0, 0.64, false, false],
        ["yShape", 0, 200, 0, 200, false, false],
        ["shape", 0, 14.966, 0, 33.76, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e0"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n\n  uv *= k_rotate2d(stream / 6.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / 5.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += x1 * sin(x2 * uv.y - stream);\n    uv.y -= y1 * cos(y2 * uv.x + stream);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t + stream / 10.);\n    float y = radius * cos(t - stream / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 12.35, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 0.64, 0, 1.28, false, false],
        ["radius", 0, 4.02, 0, 8.04, false, false],
        ["colorShift", 0, 4.41, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0.91, 0, 1.82, false, false],
        ["y1", 0, 0.37, 0, 0.74, false, false],
        ["y2", 0, 1.86, 0, 3.72, false, false],
        ["center", 0, 6.97, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 6, false, false]
      ],
      [
        ["zoom", 0, 24.7, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.204, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 2.6, 0, 8.82, false, false],
        ["x1", 0, 0.1, 0, 0.2, false, false],
        ["x2", 0, 0, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 0.394, 0, 3.72, false, false],
        ["center", 0, 13.273, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ],
      [
        ["zoom", 0, 11.101, 0, 24.7, false, false],
        ["contrast", 0, 1.19, 0, 2.38, false, false],
        ["orbSize", 0, 1.003, 0, 1.28, false, false],
        ["radius", 0, 8.04, 0, 8.04, false, false],
        ["colorShift", 0, 4.625, 0, 8.82, false, false],
        ["x1", 0, 0.053, 0, 0.2, false, false],
        ["x2", 0, 1.82, 0, 1.82, false, false],
        ["y1", 0, 0.74, 0, 0.74, false, false],
        ["y2", 0, 3.72, 0, 3.72, false, false],
        ["center", 0, 3.859, 0, 13.94, false, false],
        ["sides", 0, 3, 0, 3, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e1"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 10.);\n  uv = k_swap(uv, abs(uv), mirror, mirrorTween, mirrorTweenProgress);\n  uv = k_swap(uv, uv * sin(.0001 * dot(uv, uv) + stream/5.), dotted, dottedTween, dottedTweenProgress);\n  for (int i = 0; i < BALLS; i++) {\n    uv.y -= float(i) / yDivide * (uv.x) - cos(uv.y / yDivider + stream / 2.);\n    uv.x += float(i) / xDivide * sin(uv.x / xDivider + stream / 5.) * .4229 * cos(uv.y / yShape + stream / 1.5);\n    float t = 1.1 * float(i) * PI / float(BALLS) * (2. + 1.) + stream / 90.;\n    float x = -1. * tan(t - stream / 10.); // + stream/100.);\n    float y = sin(t * multiplier); // + stream/401.);\n    vec2 p = radius * vec2(x, y);\n    p /= sin(PI * sin(uv.x / shape)); //+cos(uv.x/300.-stream/1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.02 * float(BALLS) + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(float(i) / 40. * pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 116.00066318094458, 0, 383.44, false, false],
        ["yDivider", 0, 2.0108340560372664, 0, 4.04, false, false],
        ["xDivider", 0, 19.66732405775273, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 26.2977033459619, 0, 52.7, false, false],
        ["contrast", 0, 3.1896125184039077, 0, 6.38, false, false],
        ["radius", 0, 51.601894147360014, 0, 51.76, false, false],
        ["rotation", 0, 10.745, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 1.485310136543849, 0, 2.98, false, false],
        ["yShape", 0, 14.65960528313752, 0, 29.46, false, false],
        ["shape", 0, 71.5548653767282, 0, 142.16, false, false],
        ["dotted", 1, true, null, null, false, false],
        ["mirror", 1, true, null, null, false, false]
      ],
      [
        ["zoom", 0, 41.078, 0, 383.44, false],
        ["yDivider", 0, 0.648, 0, 4.04, false, false],
        ["xDivider", 0, 4.401, 0, 39.54, false, false],
        ["multiplier", 0, 5, 0, 10, false, false],
        ["ballSize", 0, 18.522, 0, 52.7, false, false],
        ["contrast", 0, 3.132, 0, 6.38, false, false],
        ["radius", 0, 28.094, 0, 51.76, false, false],
        ["rotation", 0, 10.745, 0, 178.96, false, false],
        ["yDivide", 0, 225.75, 0, 451.5, false, false],
        ["xDivide", 0, 0.788, 0, 2.98, false, false],
        ["yShape", 0, 4.193, 0, 29.46, false, false],
        ["shape", 0, 142.16, 0, 142.16, false, false],
        ["dotted", 1, false, null, null, false, false],
        ["mirror", 1, true, null, null, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e2"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv = abs(uv);\n  //  uv *= k_rotate2d(-stream/10.);\n  //  uv = k_kale(uv, vec2(0.),sides);\n  //uv *= k_rotate2d(stream/5.);\n  //uv *= k_rotate2d(rotation*stream/5.);\n\n  uv /= dot(uv, uv);\n  //uv *= k_rotate2d(rotation*stream/10.);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream * xSpeed) + cos(uv.y / yDivide - stream / 2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream * ySpeed) - sin(uv.x / xDivide - stream / 2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream / 50.);\n    float y = radius * cos(t + stream / 50.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume*orbSize, position, 1. - color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 0.12, 0, 0.24, false, false],
        ["contrast", 0, 1.234, 0, 2.78, false, false],
        ["orbSize", 0, 2.298, 0, 6, false, false],
        ["radius", 0, 20.95, 0, 41.9, false, false],
        ["colorShift", 0, 5.41, 0, 10.82, false, false],
        ["sides", 0, 1, 0, 2, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["sinMul", 0, 0.56, 0, 1.12, false, false],
        ["cosMul", 0, 0.88, 0, 1.76, false, false],
        ["yMul", 0, 0, 0, 0, false, false],
        ["xMul", 0, 0.56, 0, 1.12, false, false],
        ["xSpeed", 0, 1, 0, 2, false, false],
        ["ySpeed", 0, -2, -4, 0, false, false],
        ["gloop", 0, 0.0051, 0, 0.0102, false, false],
        ["yDivide", 0, 3.65, 0, 7.3, false, false],
        ["xDivide", 0, 32.82, 0, 65.64, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e4"
    },
    "shader": "#define orbs 15.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 14.);\n  uv = k_kale(uv, vec2(dist), sides);\n  for (float i = 0.; i < orbs; i++) {\n    float t = i / PI / orbs * 15. - cos(.01*dist*uv.x/2. - stream/10.2) * sin(dist - uv.x/14. - stream/8.);\n    float x = t + radius * cos(dist * t - stream /-3.) * sin(dist + stream / 2.5);\n    float y = 0.;\n    vec2 position = vec2(x + sin(x+stream/2. + dist), y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, volume * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.677086, 0, 15.22, false, false],
        ["contrast", 0, 1.67239, 0, 2.26, false, false],
        ["orbSize", 0, 0.062933, 0, 0.082, false, false],
        ["radius", 0, 0.708866, 0, 2.9, false, false],
        ["colorShift", 0, 4.5, 0, 9, false, false],
        ["center", 0, 0.353764, 0, 1.88, false, false],
        ["sides", 0, 6, 0, 6, true, false],
        ["shape", 0, 0.72, 0, 0.72, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e3"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n float stream =stream / 6.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  float dist = length(uv); \n uv *= k_rotate2d(-.8*stream);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream), uv));\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(cos(t - stream / 10.) - stream/10.);\n    float y = radius * cos(sin(t + stream / 10.) + stream/20.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, (uv.x * .02 * dist + orbSize) * pow(volume, .7), position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 5.831, 0, 20, false, false],
        ["contrast", 0, 2.21, 0, 4.42, false, false],
        ["orbSize", 0, 0.685, 0, 0.76, false, false],
        ["radius", 0, 2.435, 0, 3.52, false, false],
        ["colorShift", 0, 4.69, 0, 9.38, false, false],
        ["center", 0, 2.82, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.3, 0, 0.6, false, false],
        ["sinMul", 0, 7.27, 0, 14.54, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e5"
    },
    "shader": "#define BALLS 20\n\nvoid main() {\n  float stream = stream / .2;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length(uv);\n  uv = zoom * (uv); //(1.+ProgressBasis/2.);\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / 2.);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist - stream / 13.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 8.) + sin(uv.y * yMultiplier + stream / 6.));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  uv.x = uv.y; //sin(uv.y+stream/.1);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS); // - stream/4.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n  gl_FragColor = k_hue(gl_FragColor, stream / 50.);\n}",
    "variants": [
      [
        ["zoom", 0, 0.053, 0, 0.13, false, false],
        ["shapeMultiplier", 0, 223.96, 0, 447.92, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xMultiplier", 0, 217.723, 0, 3385.88, false, false],
        ["yMultiplier", 0, 157.966, 0, 1223, false, false],
        ["colorSpread", 0, 0.001, 0, 0.002, false, false],
        ["colorMultiplier", 0, 0.863, 0, 1.62, false, false],
        ["invert", 1, true, null, null, false, false],
        ["brightness", 0, 1.636, 0, 7.72, false, false],
        ["ballSize", 0, 17.795, 0, 18.74, false, false],
        ["glow", 0, 0.714, 0, 2.32, false, false],
        ["contrast", 0, 2.278, 0, 10, false, false],
        ["radius", 0, 15.459, 0, 23.84, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e6"
    },
    "shader": "#define BALLS 15\n\nvoid main() {\n  float stream = stream / 2.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  if (invertTween) {\n    if (invert) {\n      uv = mix(uv, abs(uv), invertTweenProgress);\n    } else {\n      uv = mix(abs(uv), uv, invertTweenProgress);\n    }\n  } else if (invert) {\n    uv = abs(uv);\n  }\n  uv *= zoom2;\n  uv *= k_rotate2d(stream / -3. + length(.6 * cos(uv - stream / 4.)) / 1.);\n  uv = zoom * (log(abs(uv)) + 1.5 * cos(uv)); //(1.+ProgressBasis/2.);\n  float dist = distance(uv, vec2(0));\n  float thing = .005 * sin(shapeMultiplier * dot(uv, uv) / dist - stream / .2);\n  //  vec2 _kale = k_kale(uv, vec2(0.), sides);\n  uv *= k_rotate2d(rotation * (dist + stream / 2.));\n  float _grid = (cos(uv.x * xMultiplier - stream / 5.) - sin(uv.y * yMultiplier + stream / -10.));\n  uv /= colorSpread * thing * _grid;\n  uv *= .1 * dist;\n\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(dist * float(i)); //-stream/10.);\n    float t = float(i) * PI / float(BALLS) - stream / 140.;\n    vec2 p = radius * vec2(radius * tan(t), radius * cos(t));\n    //p += log(sin(stream/3. + float(i) * PI));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 500. + uv.y / 850. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume * ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  }\n  gl_FragColor.xyz = glow * brightness * pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 0.008, 0, 0.028, false, false],
        ["shapeMultiplier", 0, 589.178, 0, 1518.42, false, false],
        ["rotation", 0, 0.012, 0, 0.05134, false, false],
        ["xMultiplier", 0, 251.592, 0, 1469.28, false, false],
        ["yMultiplier", 0, 1549.9, 0, 11111, false, false],
        ["colorSpread", 0, 0.000012, 0, 0.000024, false, false],
        ["colorMultiplier", 0, 0.51, 0, 1.02, false, false],
        ["invert", 1, false, null, null, false, false],
        ["brightness", 0, 1.86, 0, 3.72, false, false],
        ["ballSize", 0, 6.194, 0, 28.78, false, false],
        ["glow", 0, 4.435, 0, 7.58, false, false],
        ["contrast", 0, 3.189, 0, 4.3, false, false],
        ["radius", 0, 10.691, 0, 38.32, false, false],
        ["zoom2", 0, 0.48, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e7"
    },
    "shader": "void main() {\n  float stream = stream / 5.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(-stream/5.);\n  vec2 _uv = uv;\n  float dist = length(uv);\n  float thing = dist * .001 * sin(shapeMultiplier * dot(uv, uv) / dist - stream/.1);\n  float _grid = (cos(uv.x * xMultiplier - stream) + sin(uv.y * yMultiplier + stream / .5));\n  uv /= colorSpread * thing * _grid;\n  uv *= dist;\n  float i = uv.x / granularity;\n  vec2 p = vec2(sin(i), cos(i));\n  vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (float(i) / 3.)) * 0.5 + 0.5;\n  gl_FragColor = vec4(ballSize / length(uv + p * colorMultiplier) * col, 1.0);\n  gl_FragColor.xyz = volume * (glow * brightness * pow(gl_FragColor.xyz, vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 0.177, 0, 0.68, false, false],
        ["xMultiplier", 0, 20.37, 0, 40.74, false, false],
        ["yMultiplier", 0, 44.741, 0, 62.28, false, false],
        ["ballSize", 0, 2.769, 0, 9.34, false, false],
        ["colorSpread", 0, 1.681, 0, 11.34, false, false],
        ["colorMultiplier", 0, 71.815, 0, 228.3, false, false],
        ["shapeMultiplier", 0, 76.571, 0, 226.04, false, false],
        ["glow", 0, 4786.254, 0, 18444.68, false, false],
        ["contrast", 0, 3.473, 0, 7.5, false, false],
        ["brightness", 0, 10.92, 0, 21.84, false, false],
        ["center", 0, 0, 0, 0, false, false],
        ["granularity", 0, 22, 0, 44, false, false],
        ["radius", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e8"
    },
    "shader": "#define BALLS 5\n\nvoid main() {\n  float stream = stream / 3.2718;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * sin(PI * float(1 + i)) + stream / rotationFactor * dist / rot2);\n    float t = float(i) * PI / float(BALLS) / divider;\n    float a = cos(float(i) * dist - uv.x/xDiv2);\n    float b = radius * sin(t) * sinMul * cos(stream*rotationSpeed + uv.x/wap + sin(uv.y / yDiv2));\n    float c = sin(uv.y / yDiv);\n    float x = xOuter - a * uv.x / dist * PI + b;\n    float y = radius * cos(dist + yOuter * uv.x / xDiv + t + yMultiplier - stream/.251);\n    vec2 p = vec2(x, y);\n    vec3 col = cos(c + vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream/colorSpeed)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz =1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 6.404439730457706, 0, 88, false, false],
        ["ballSize", 0, 1.4751218196831208, 0, 31.538, false, false],
        ["contrast", 0, 2.15, 0, 4.3, false, false],
        ["radius", 0, 4.88, 0, 9.76, false, false],
        ["yOuter", 0, 1.5, 0, 3, false, false],
        ["xOuter", 0, 6.71, 0, 13.42, false, false],
        ["mirror", 1, true, null, null, false, false],
        ["xMultiplier", 0, 0.65, 0, 1.3, false, false],
        ["yMultiplier", 0, 4.84, 0, 9.68, false, false],
        ["divider", 0, 28, 0, 56, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xDiv", 0, 30.19, 0, 32, false, false],
        ["colorSpeed", 0, 64.79, 0, 112, false, false],
        ["rotationSpeed", 0, 1.75, 0, 21, false, false],
        ["yDiv", 0, 28.3, 0, 50, false, false],
        ["sinMul", 0, 330.32, 20, 600, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false],
        ["rotationFactor", 0, 87.67, 0, 112, false, false],
        ["rot2", 0, 1112, 0, 1112, false, false],
        ["yDiv2", 0, 9.81, 0, 12, false, false],
        ["wap", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 8.768, 0, 88, false, false],
        ["ballSize", 0, 29.087, 0, 31.538, false, false],
        ["contrast", 0, 2.15, 0, 4.3, false, false],
        ["radius", 0, 18.114, 0, 119.76, false, false],
        ["yOuter", 0, 2.31, 0, 3, false, false],
        ["xOuter", 0, 6.981, 0, 13.42, false, false],
        ["mirror", 1, true, null, null, false, false],
        ["xMultiplier", 0, 0.74, 0, 1.3, false, false],
        ["yMultiplier", 0, 1.881, 0, 9.68, false, false],
        ["divider", 0, 20.309, 0, 56, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xDiv", 0, 4.51, 0, 32, false, false],
        ["colorSpeed", 0, 64.79, 0, 112, false, false],
        ["rotationSpeed", 0, 1.75, 0, 21, false, false],
        ["yDiv", 0, 10.09, 0, 50, false, false],
        ["sinMul", 0, 330.32, 20, 600, false, false],
        ["xDiv2", 0, 1.17, 0, 2, false, false],
        ["rotationFactor", 0, 87.67, 0, 112, false, false],
        ["rot2", 0, 1112, 0, 1112, false, false],
        ["yDiv2", 0, 9.81, 0, 12, false, false],
        ["wap", 0, 2, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 30.768, 0, 88, false, false],
        ["ballSize", 0, 25.846, 0, 31.538, false, false],
        ["contrast", 0, 2.088, 0, 4.3, false, false],
        ["radius", 0, 30.748, 0, 119.76, false, false],
        ["yOuter", 0, 1.5, 0, 3, false, false],
        ["xOuter", 0, 6.71, 0, 13.42, false, false],
        ["mirror", 1, true, null, null, false, false],
        ["xMultiplier", 0, 0.65, 0, 1.3, false, false],
        ["yMultiplier", 0, 4.84, 0, 9.68, false, false],
        ["divider", 0, 0.433, 0, 56, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xDiv", 0, 30.19, 0, 32, false, false],
        ["colorSpeed", 0, 12.49, 0, 112, false, false],
        ["rotationSpeed", 0, 1.67, 0, 21, false, false],
        ["yDiv", 0, 28.3, 0, 50, false, false],
        ["sinMul", 0, 330.32, 20, 600, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false],
        ["rotationFactor", 0, 108.54, 0, 112, false, false],
        ["rot2", 0, 1112, 0, 1112, false],
        ["yDiv2", 0, 9.81, 0, 12, false, false],
        ["wap", 0, 8.43, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 11.833, 0, 88, false, false],
        ["ballSize", 0, 15.769, 0, 31.538, false, false],
        ["contrast", 0, 2.15, 0, 4.3, false, false],
        ["radius", 0, 4.88, 0, 9.76, false, false],
        ["yOuter", 0, 1.5, 0, 3, false, false],
        ["xOuter", 0, 6.71, 0, 13.42, false, false],
        ["mirror", 1, true, null, null, false, false],
        ["xMultiplier", 0, 0.65, 0, 1.3, false, false],
        ["yMultiplier", 0, 4.84, 0, 9.68, false, false],
        ["divider", 0, 28, 0, 56, false, false],
        ["rotation", 0, 0, 0, 0, false, false],
        ["xDiv", 0, 30.19, 0, 32, false, false],
        ["colorSpeed", 0, 64.79, 0, 112, false, false],
        ["rotationSpeed", 0, 1.75, 0, 21, false, false],
        ["yDiv", 0, 28.3, 0, 50, false, false],
        ["sinMul", 0, 330.32, 20, 600, false, false],
        ["xDiv2", 0, 1, 0, 2, false, false],
        ["rotationFactor", 0, 87.67, 0, 112, false, false],
        ["rot2", 0, 1112, 0, 1112, false, false],
        ["yDiv2", 0, 9.81, 0, 12, false, false],
        ["wap", 0, 1, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8e9"
    },
    "shader": "mat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{ \n\tp = vec2 (dot (p, vec2 (1227.1, 311.7)),\n\t\t\t  dot (p, vec2 (269.5, 183.3)));\n\n\treturn -1. + 102.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n\tvec2 i = floor (p + (p.x + p.y)*K1);\n\t\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n\tvec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n\t\t\t\t\t\t   dot (b, hash (i + o)),\n\t\t\t\t\t\t   dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (3.));\n}\n\nfloat fbm (in vec2 p)\n{\n\tmat2 rot = r2d (11111111.5);\n    float d = noise (p); p *= rot;\n    d += 1.5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .625*noise (p);\n\td /= (1. + .5 + .25 + .125 + .0625);\n\treturn d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    return uv;//- (sin(stream/5.+uv));\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi); \n}\n\nvec2 polar2cart (in vec2 polar)\n{\n  float x = polar.x;\n  float y= polar.y;\n  vec2 fuck = vec2(x, y);\n    return vec2 (fuck); \n}\n\nvoid main ()\n{\n   float stream = stream / 3.;\n    vec2 uv = mapToScreen (gl_FragCoord.xy/resolution.xy, zoom);\n    float len = length (sin(uv-stream));\n//  uv -= dot(uv, uv) - uv/2.;\n\n //  uv =(polar2cart (uv));\n\n\t\tfloat thicc = thickness * length(abs(uv))*length(sin(uv+stream));\n    float d1 = size*abs (sin(stream+uv.x*haze)*thicc * (cos(uv.x+stream) + abs(fbm (a*uv + stream))));\n    uv = abs(uv);\n    float d2 = size*abs (sin(stream-uv.y*haze)*thicc * (sin(uv.y-stream) * abs(fbm (b*uv + stream))));\n    float d3 = size*abs (cos(stream+uv.x*uv.y/haze)*thicc / (uv.x+log(uv.y) + fbm (c*uv + stream)));\n    vec3 col = vec3 (.0);\n\tcol += d1*size*abs(sin(col1-stream/20.));\n\tcol += d2*size*abs(cos(col2-stream/20.));\n\tcol += d3*size*col3;\n\n    gl_FragColor = vec4 (.5-1.*sin(log(col)), 1.);\n}",
    "variants": [
      [
        ["speed", 0, 0.023, 0, 0.03, false, false],
        ["bump", 0, 0.18, 0, 0.2, false, false],
        ["zoom", 0, 0.52, 0, 2, false, false],
        ["thickness", 0, 0.0028, 0, 0.1, false, false],
        ["haze", 0, 2, 2, 100, false, false],
        ["col1", 3, [0.9529411764705882, 0.9137254901960784, 0.3686274509803922], null, null, false, false],
        ["col2", 3, [0.12156862745098039, 0.8235294117647058, 1], null, null, false, false],
        ["col3", 3, [0, 1, 0.06666666666666667], null, null, false, false],
        ["size", 0, 0.005, 0, 0.05, false, false],
        ["a", 0, 24.47, 0, 100, false, false],
        ["b", 0, 4.95, 0, 50, false, false],
        ["c", 0, 11.59, 0, 50, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ea"
    },
    "shader": "#define BALLS 15\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(abs(uv) + sin(abs(uv)-stream)) * length(uv);\n//  uv /= .1*tan(.1*dot(1.1*tan(uv), 5.*atan(uv)) - stream/5.);\n // uv /= dot(sin(uv+stream), cos(uv+stream));\n // uv += sin(.01*dot(tan(uv+stream/20.), tan(uv-stream/20.)) - stream/5.);\n  uv *= rotate2d(rotation);\n  for (int i = 0; i < BALLS; i++) {\n    float dist = length(uv);\n\t\tuv.y += yOuter*sin(uv.y/yDivider + stream/5.) / 1.*sin(uv.x/1. - stream/3.);\n    uv.x -= xOuter*sin(uv.x/xDivider - stream/5.) / 1.*sin(uv.x/1.1 + stream/1.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) + stream/5000.;\n    float _multiplier = dist*multiplier * sin(uv.x);\n    vec2 p = vec2(radius*-2.*tan(t*multiplier), 2.*radius*sin(t*multiplier));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 20. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .75) * ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["speed", 0, 0.04, 0, 0.1, false, false],
        ["bump", 0, 0.53, 0, 1, false, false],
        ["zoom", 0, 27.87, 0, 150, false, false],
        ["yDivider", 0, 187.19, 0.1, 1000, false, false],
        ["xDivider", 0, 130.77, 0.1, 1000, false, false],
        ["multiplier", 0, 583.53, 0.1, 1101, false, false],
        ["ballSize", 0, 1.8, 0, 2, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 19.36, 0, 111, false, false],
        ["yOuter", 0, 0.42, 0, 1, false, false],
        ["xOuter", 0, 0.42, 0, 1, false, false],
        ["rotation", 0, 0.58, 0, 5, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ec"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom / 1.5;\n  float stream = stream / 5.;\n  float dist = length(uv);\n  uv *= k_rotate2d(-stream/13.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv += sin(dotMul * dot(uv + sinMul * sin(uv - stream/.4), uv));\n  uv *= k_rotate2d(stream/1.5);\n  uv /= dot(tan(uv), cos(uv));\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan((t - stream / 4.2));\n    float y = radius * cos((t));\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, pow(volume, .25) * uv.y * .02 * dist + orbSize*1.5* pow(volume, .5), position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 10.222483, 0, 20, false, false],
        ["contrast", 0, 2.19, 0, 4.42, false, false],
        ["orbSize", 0, 0.573, 0, 0.76, false, false],
        ["radius", 0, 2.499, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 3.248, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.449923, 0, 0.6, false, false],
        ["sinMul", 0, 5.834043, 0, 14.54, false, false]
      ],
      [
        ["zoom", 0, 7.411, 0, 20, false, false],
        ["contrast", 0, 2.490571, 0, 4.42, false, false],
        ["orbSize", 0, 0.284351, 0, 0.76, false, false],
        ["radius", 0, 1.45411, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 1.982842, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.6, 0, 0.6, false, false],
        ["sinMul", 0, 2.761415, 0, 14.54, false, false]
      ],
      [
        ["zoom", 0, 8.535869, 0, 20, false, false],
        ["contrast", 0, 2.544121, 0, 4.42, false, false],
        ["orbSize", 0, 0.76, 0, 0.76, false, false],
        ["radius", 0, 3.52, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 0.586818, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.219598, 0, 0.6, false, false],
        ["sinMul", 0, 3.851995, 0, 14.54, false, false]
      ],
      [
        ["zoom", 0, 1.935531, 0, 20, false, false],
        ["contrast", 0, 2.591991, 0, 4.42, false, false],
        ["orbSize", 0, 0.369118, 0, 0.76, false, false],
        ["radius", 0, 2.299153, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 0.760752, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.6, 0, 0.6, false, false],
        ["sinMul", 0, 11.975028, 0, 14.54, false, false]
      ],
      [
        ["zoom", 0, 12.832807, 0, 20, false, false],
        ["contrast", 0, 2.591991, 0, 4.42, false, false],
        ["orbSize", 0, 0.694402, 0, 0.76, false, false],
        ["radius", 0, 0.893505, 0, 3.52, false, false],
        ["colorShift", 0, 9.38, 0, 9.38, false, false],
        ["center", 0, 4.290152, 0, 5.64, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["dotMul", 0, 0.387826, 0, 0.6, false, false],
        ["sinMul", 0, 4.995423, 0, 14.54, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8eb"
    },
    "shader": "void main () {\nfloat stream = stream / 3.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  mat2 rotation = k_rotate2d(stream/2.);\n  float ot = ot;\n  for (float i = 0.; i < 20.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator - 1.;\n    ot = dot(uv, uv) - atan(length(-1. + 2. * gl_FragCoord.xy / resolution.xy) / L + stream/1.569);\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, volume/10., vec2(sin((-1. + 2. * gl_FragCoord.xy / resolution.xy).x), cos((-1. + 2. * gl_FragCoord.xy / resolution.xy).y)),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 3.135, 0, "21", false, false],
        ["iterator", 0, 1.071, 0, "2", false, false],
        ["ot", 0, 63.521, 0, "151", false, false],
        ["I", 0, 2.264, 0, "3", false, false],
        ["J", 0, 1.356, 0, "3", false, false],
        ["K", 0, 3.881, 0, "11", false, false],
        ["iterations", 0, 18.705, 0, "33", false, false],
        ["L", 0, 0.651, 0, "3", false, false],
        ["M", 0, 9.278, 0, "11", false, false],
        ["colorShift", 0, 0.676, 0, 1, false, false],
        ["colorOffset", 0, 0.5, 0, 1, false, false],
        ["contrast", 0, 1.676, 0, "2", false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ed"
    },
    "shader": "void main() {\n  float stream = stream / 7.8;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= k_rotate2d(stream/1.);\n  for (float i = 0.; i < 10.; i++) {\n    uv.x += a * cos(b * uv.y);\n    uv.y += c * cos(d * uv.x + stream/.15);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t - stream/2.4);\n    float y = radius * cos(t - stream/1.7);\n    vec2 position = vec2(x, y);\n    vec3 color = k_rainbow(i / orbs, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, .6) * orbSize, position, color, contrast);\n  }\n\n  gl_FragColor.xyz = 1. - pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n}",
    "variants": [
      [
        ["zoom", 0, 0.32, 0, 0.5, false],
        ["contrast", 0, 0.656, 0, 2.92, false],
        ["orbSize", 0, 1.488, 0, 15.4, false],
        ["radius", 0, 0, 0, 25.38, false],
        ["colorShift", 0, 0.962, 0, 2, false],
        ["orbs", 0, 16, 0, 30, true, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.43, 0, 1, false, false],
        ["colorOffset", 0, 0, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.307, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 2.979, 0, 25.38, false, false],
        ["colorShift", 0, 0, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, true, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.94, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 4.12, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.145, 0, 1, false, false],
        ["contrast", 0, 1.35, 0, 2.92, false, false],
        ["orbSize", 0, 8.789, 0, 15.4, false, false],
        ["radius", 0, 0, 0, 25.38, false, false],
        ["colorShift", 0, 1.277, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, true, false],
        ["a", 0, 5, 0, 5, false, false],
        ["b", 0, 0.19, 0, 5, false, false],
        ["c", 0, 1.77, 0, 5, false, false],
        ["d", 0, 0.47, 0, 1, false, false],
        ["colorOffset", 0, 2.06, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 1, 0, 1, false, false],
        ["contrast", 0, 1.358, 0, 2.92, false, false],
        ["orbSize", 0, 5.006, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.994, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, true, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0.56, 0, 5, false, false],
        ["c", 0, 0.8, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ],
      [
        ["zoom", 0, 0.089, 0, 1, false, false],
        ["contrast", 0, 0.617, 0, 2.92, false, false],
        ["orbSize", 0, 0.993, 0, 15.4, false, false],
        ["radius", 0, 8.327, 0, 25.38, false, false],
        ["colorShift", 0, 0.227, 0, 2, false, false],
        ["orbs", 0, 16, 0, 30, true, false],
        ["a", 0, 1.64, 0, 5, false, false],
        ["b", 0, 0, 0, 5, false, false],
        ["c", 0, 0, 0, 5, false, false],
        ["d", 0, 0.66, 0, 1, false, false],
        ["colorOffset", 0, 9.29, 0, 12, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 1,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ee"
    },
    "shader": "/* Anti-aliasing code */\n\n#define _AA_START               \\\nvec3 tot;                       \\\nfor (int j = 0; j < AA; j++)    \\\nfor (int k = 0; k < AA; k++) {  \\\nvec2 o = vec2(float(j), float(k)) / float(AA) - 0.5;\n\n#define _AA_END       \\\n} tot /= float(AA*AA);  \\\ngl_FragColor = vec4(tot, 1.); \\\n\n/* \"Digital Abyss\" by @kishimisu (2022) - https://www.shadertoy.com/view/Dsj3WW\n *   \n * Interact with the mouse!  */\n\n#define AA 1 // Antialiasing level\n\nvoid main() { \n_AA_START     \n    float r, t = 1.;\n    vec2 mouse = vec2(0., 0.);\n    vec2 i = k_uv() * zoom;\ni *= k_rotate2d(stream/15.);\n    for (float a = 0.; a < 32.; a++) {        i = abs(i);\n\n        i *= k_rotate2d(a/50.);\n\n        vec3 p = r*vec3(i, wap);\n\n        p.xy  *= mat2(120.*sin(cos(stream/100.-.01*r/i.y/116.-sub) - vec4(A, B, C, D)-stream/5.));\n              i = abs(i);\n\n        p.z   += stream*.47590611;\n\n        p = (abs(fract(p)-.5)); \n        r += t = (p.x + p.y + p.z -dep)*mul;        \n    }\n    tot += mix(.17 - vec3(r*r*length(i)), \n        1.2 * cos(r - (vec3(.1, .7, 1.1) - length(i))), \n        exp(-r*.0007)); \n_AA_END \n}",
    "variants": [
      [
        ["zoom", 0, 0.024, 0, 0.1, false],
        ["mul", 0, 0.46, 0, 1, false, false],
        ["rot", 0, 489.87, 0, 1112, false, false],
        ["sub", 0, 42.73, 0, 112, false, false],
        ["A", 0, 2.34, 0, 4, false, false],
        ["B", 0, 5.57, 0, 43, false, false],
        ["C", 0, 10.18, 0, 34, false, false],
        ["D", 0, 3.59, 0, 14, false, false],
        ["dep", 0, 0.11, 0, 1, false, false],
        ["wap", 0, 0.7, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 2,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8f0"
    },
    "shader": "void main () {\n  gl_FragColor = vec4(0);\n  vec2 uv = k_uv() * zoom * k_rotate2d(stream/20.);\n  float dist = length(uv);\n  for (float i = 0.; i < 5.; i++) {\n    uv *= k_rotate2d(rotation / (i + 1.));\n    float t = float(i) * PI / float(4.) * (5. + 1.) / divider;// + stream/50.;\n    vec2 p = vec2(xOuter-(cos(xMultiplier*uv.x - stream/2.))*uv.x/yMultiplier*PI+radius*cos(t-stream/-10.)\n                  * yMultiplier*cos(stream/.5 -uv.x * sin(uv.y/4.-stream/1.6)), radius*\n                  cos(stream/3000. - 9.1*yOuter*uv.x/.5+t+yMultiplier+1.));\n    vec3 col = cos(sin(uv.y/7.-stream/40.)+vec3(-2, 0, -1) * PI * 2. / 3. + PI * (10.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-(pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast)));\n}",
    "variants": [
      [
        ["zoom", 0, 20.93585278614458, 0, 50, false, false],
        ["ballSize", 0, 10, 2, 10, false, false],
        ["contrast", 0, 2.96, 0, 15, false, false],
        ["radius", 0, 32.010777484939766, 0, 50, false, false],
        ["yOuter", 0, 0, 0, 0.05, false, false],
        ["xOuter", 0, 21.24435240963856, 1, 241, false, false],
        ["xMultiplier", 0, 1.3759412650602412, 0, 10, false, false],
        ["yMultiplier", 0, 0.9386201054216868, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 2.778567394578314, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 3.170444277108434, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 28.778237951807235, 0, 50, false, false],
        ["yOuter", 0, 0.004550781250000001, 0, 0.05, false, false],
        ["xOuter", 0, 1, 1, 241, false, false],
        ["xMultiplier", 0, 2.145849021084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.6400000000000003, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 33.7234092620482, 0, 50, false, false],
        ["ballSize", 0, 6.476543674698796, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 31.092338102409645, 0, 50, false, false],
        ["yOuter", 0, 0.0005304028614457833, 0, 0.05, false, false],
        ["xOuter", 0, 130.72176204819277, 1, 241, false, false],
        ["xMultiplier", 0, 1.1696630271084338, 0, 10, false, false],
        ["yMultiplier", 0, 1.1726844879518075, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 3.607210090361446, 0, 5, false, false]
      ],
      [
        ["zoom", 0, 13.757765436746988, 0, 50, false, false],
        ["ballSize", 0, 6.476543674698796, 2, 10, false, false],
        ["contrast", 0, 5.053252070783133, 0, 15, false, false],
        ["radius", 0, 10.042356927710845, 0, 50, false, false],
        ["yOuter", 0, 0.011533635853503293, 0, 0.05, false, false],
        ["xOuter", 0, 18.25225903614458, 1, 241, false, false],
        ["xMultiplier", 0, 0.8655402861445785, 0, 10, false, false],
        ["yMultiplier", 0, 2, 0.2, 2, false, false],
        ["divider", 0, 1, 1, 2230, false, false],
        ["rotation", 0, 0, 0, 5, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8ef"
    },
    "shader": "void main () {\n  float stream =stream * 1.6;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream / 21.);\n  for (float i = 0.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream / 14.);\n    float b = radius * sin(uv.y + stream / -5.);\n    float c = radius * wave * sin(split * uv.x - stream / 2.5);\n    float d = radius * wave * cos(split * uv.y  - stream / 5.5);\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume,1.) * orbSize, vec2(x, x),  col, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 1.35424, 0, 3, false, false],
        ["iterator", 0, 1.07941, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.79378, 0, 3, false, false],
        ["colorOffset", 0, 29.16356, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.11947, 0, 6, false, false],
        ["wave", 0, 0.9217, 0, 20, false, false],
        ["split", 0, 7.46972, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 1.16404, 0, 3, false, false],
        ["iterator", 0, 0.92054, 0.7, 1.5, false, false],
        ["iterations", 0, 21.63525, 0, 33, false, false],
        ["colorShift", 0, 0.76422, 0, 3, false, false],
        ["colorOffset", 0, 19.50448, 15, 30, false, false],
        ["contrast", 0, 0.93552, 0, 3, false, false],
        ["orbSize", 0, 0.13542, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.43899, 0, 6, false, false],
        ["wave", 0, 1.61956, 0, 20, false, false],
        ["split", 0, 14.62046, 0, 15, false, false]
      ],
      [
        ["zoom", 0, 0.5544239457831327, 0, 3, false, false],
        ["iterator", 0, 1.00471, 0.7, 1.5, false, false],
        ["iterations", 0, 16.31461, 0, 33, false, false],
        ["colorShift", 0, 0.33359, 0, 3, false, false],
        ["colorOffset", 0, 21.77581, 15, 30, false, false],
        ["contrast", 0, 1.21895, 0, 3, false, false],
        ["orbSize", 0, 0.04777, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 3.11627, 0, 6, false, false],
        ["wave", 0, 1.07795, 0, 20, false, false],
        ["split", 0, 33.59867, 0, 44, false, false]
      ],
      [
        ["zoom", 0, 2.88861, 0, 6, false, false],
        ["iterator", 0, 0.80495, 0.7, 1.5, false, false],
        ["iterations", 0, 13.72489, 0, 33, false, false],
        ["colorShift", 0, 0.38237, 0, 2, false, false],
        ["colorOffset", 0, 15.97272, 15, 30, false, false],
        ["contrast", 0, 1.05403, 0, 3, false, false],
        ["orbSize", 0, 0.17637, 0, 1, false, false],
        ["div", 0, 1.37978, 0.01, 15, false, false],
        ["radius", 0, 4.26167, 0, 6, false, false],
        ["wave", 0, 1.11087, 0, 20, false, false],
        ["split", 0, 3.30232, 0, 44, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8db"
    },
    "shader": "#define BALLS 30\n\nvoid main() {\n  float stream =stream / 40.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  // uv = uv*uv;\n  if (mirrorTween) {\n    if (mirror) {\n      uv = mix(uv, uv * uv, (mirrorTweenProgress));\n    } else {\n      uv = mix(uv * uv, uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (int i = 0; i < BALLS; i++) {\n    uv *= k_rotate2d(rotation * 5. + -rotation + stream / 5.);\n    float t = float(i) * PI / float(BALLS) * (5. + 1.) / divider; // + stream/50.;\n    vec2 p = vec2(xOuter * (cos(uv.x - stream / .1)) * uv.x + radius * tan(t) * 20. * cos(uv.x + sin(uv.y / 100.)), radius * cos(.1 / dist * yOuter * uv.x / .5 + t + yMultiplier + 2. * stream));\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (stream / 3. / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(volume*ballSize / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1. - pow(abs(log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 1.78, 0, 3.56, false, false],
        ["ballSize", 0, 0.811, 0, 1.622, false, false],
        ["contrast", 0, 6.18, 0, 12.36, false, false],
        ["radius", 0, 0.37, 0, 0.74, false, false],
        ["yOuter", 0, 0, 0, 0, false, false],
        ["xOuter", 0, 55.27, 0, 110.54, false, false],
        ["mirror", 1, false, null, null, false, false],
        ["xMultiplier", 0, 4.14, 0, 8.28, false, false],
        ["yMultiplier", 0, 5.19, 0, 10.38, false, false],
        ["divider", 0, 4, 0, 8, false, false],
        ["rotation", 0, 0.0576, 0, 0.1152, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f297ad0265dcaccb28d8dd"
    },
    "shader": "#define orbs 20.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  uv *= k_rotate2d(stream / 12.);\n  uv = k_kale(uv, vec2(center), sides);\n  uv *= k_rotate2d(stream / -15.);\n  uv *= sin(dotMul * dot(uv + xDot * cos(uv), .1 / dist * uv + yDot * cos(uv)) - stream / 10.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = radius * sin(t + stream / 10.);\n    float y = radius * cos(t - stream / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_orb(uv, 1./length(uv)*pow(volume, .827) * orbSize, position, color, contrast);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 0.602, 0, 0.7, false, false],
        ["radius", 0, 1.82, 0, 3.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 7.68, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 2.982958668830698, 0, 5.965917337661396, false, false],
        ["yDot", 0, 2.59, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 0, 0, 0, false, false]
      ],
      [
        ["zoom", 0, 10.141, 0, 30, false, false],
        ["contrast", 0, 1.6, 0, 3.2, false, false],
        ["orbSize", 0, 1.535, 0, 22, false, false],
        ["radius", 0, 5.629, 0, 113.64, false, false],
        ["colorShift", 0, 17.42, 0, 34.84, false, false],
        ["center", 0, 5.341, 0, 15.36, false, false],
        ["sides", 0, 6, 0, 12, false, false],
        ["xDot", 0, 1.211, 0, 5.965917337661396, false, false],
        ["yDot", 0, 0.554, 0, 5.18, false, false],
        ["dotMul", 0, 0.11973979612093022, 0, 0.23947959224186044, false, false],
        ["rotation", 0, 6.332, 0, 33, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "updated": {
      "$date": "2024-09-24T10:42:53.159Z"
    },
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  },
  {
    "_id": {
      "$oid": "66f2d825d00fe62bf834580f"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6d"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(11. * uv.y);\n    float y = .1 * sin(uv.y / 1.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 4.225, 0, 12, false],
        ["contrast", 0, 1.956, 0, 4.86, false],
        ["orbSize", 0, 0.273, 0, 0.72, false],
        ["radius", 0, 3.411, 0, 30, false],
        ["colorShift", 0, 13.36, 0, 13.36, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T15:17:57.947Z"
    },
    "updated": {
      "$date": "2024-09-24T15:17:57.947Z"
    },
    "__v": 1
  },
  {
    "_id": {
      "$oid": "66f2d891d00fe62bf8345819"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6d"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 25.\n\nvoid main() {\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n  uv *= zoom;\n  float dist = length(uv);\n  // uv = k_kale(abs(uv), vec2(dist), 1.);\n  for (float i = 0.; i < 20.; i++) {\n    float t = i * PI / orbs * 2.;\n    float x = 1. * uv.x + radius * tan(t + stream) - sin(1. * uv.y);\n    float y = .1 * radius *sin(uv.y / 1.1) * uv.y / sin(stream);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += k_hue(k_orb(uv, orbSize, position, color, contrast), stream / .5);\n  }\n}",
    "variants": [
      [
        ["zoom", 0, 24.063, 0, 112, false],
        ["contrast", 0, 1.715, 0, 4.86, false],
        ["orbSize", 0, 0.383, 0, 0.72, false],
        ["radius", 0, 12.952, 0, 30, false],
        ["colorShift", 0, 13.36, 0, 13.36, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T15:19:45.889Z"
    },
    "updated": {
      "$date": "2024-09-24T15:19:45.889Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2e3499d4334d41427cb36"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define BALLS 18\n  \nfloat stepping(float t) {\n  if (t < 0.) return -1. + pow(1. + t, 2.);\n  else return 1. - pow(1. - t, 2.);\n}\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  gl_FragColor = vec4(0);\n  uv = normalize(uv) * length((uv));\n  float dist = length(uv);\n  uv *= k_rotate2d(PI /2.);\n\n  uv *= rotate2d(stream/10.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.y += a*float(i)*cos(uv.y/yDivider - stream/1.) + sin(uv.x/c - stream/1.);\n    uv.x += b*float(i)*cos(uv.y/xDivider - stream)+sin(uv.x/xDivider + stream) - sin(uv.y/d);\n    float t = .05*dist*float(i) * PI / float(BALLS) * (5. + 1.);\n    vec2 p = radius*vec2(-1.*cos(t), e*sin(t/multiplier));\n    p /= sin(PI * sin(uv.y/10.)*cos(uv.y/10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (stream / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(pow(volume, .7)*ballSize*1.1 / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(log(gl_FragColor.xyz), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 31.948, 0, 211, false],
        ["yDivider", 0, 1.5, 0.1, 32, false, false],
        ["xDivider", 0, 0.9, 0.1, 19, false, false],
        ["multiplier", 0, 1.07475, 0.01, 4, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 17.01, 0, 151, false, false],
        ["rotation", 0, 0.08, 0, 1, false, false],
        ["a", 0, 0.13, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 2.33, 0, 22, false, false],
        ["d", 0, 0.63, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 20.68, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 0.49, 0.1, 19, false, false],
        ["multiplier", 0, 64, 0.01, 64, false, false],
        ["ballSize", 0, 1.1, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 6.19, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 3.3, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.84005370031426, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.119977205335353, 0.1, 19, false, false],
        ["multiplier", 0, 8.310778794401344, 0.01, 64, false, false],
        ["ballSize", 0, 1.6599921687041703, 0, 11, false, false],
        ["contrast", 0, 0.8500047547153251, 0, 5, false, false],
        ["radius", 0, 4.0500299267376345, 0, 151, false, false],
        ["rotation", 0, 0.17, 0, 1, false, false],
        ["a", 0, 0.11999832186517936, 0, 1, false, false],
        ["b", 0, 0, 0, 21, false, false],
        ["c", 0, 6.879949935644517, 0, 22, false, false],
        ["d", 0, 0.71, 0, 2, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 16.43, 0, 111, false, false],
        ["yDivider", 0, 3.47, 0.1, 32, false, false],
        ["xDivider", 0, 0.79, 0.1, 19, false, false],
        ["multiplier", 0, 0.83, 0.01, 4, false, false],
        ["ballSize", 0, 3.58, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 13.28, 0, 151, false, false],
        ["rotation", 0, 0.16, 0, 1, false, false],
        ["a", 0, 0.53, 0, 1, false, false],
        ["b", 0, 0.08, 0, 1, false, false],
        ["c", 0, 2.12, 0, 22, false, false],
        ["d", 0, 1.16, 0, 12, false, false],
        ["e", 0, 1, 0, 2, false, false]
      ],
      [
        ["zoom", 0, 14.53, 0, 111, false, false],
        ["yDivider", 0, 19.63, 0.1, 32, false, false],
        ["xDivider", 0, 2.73, 0.1, 19, false, false],
        ["multiplier", 0, 5.73, 0.01, 64, false, false],
        ["ballSize", 0, 2.16, 0, 11, false, false],
        ["contrast", 0, 1.19, 0, 5, false, false],
        ["radius", 0, 0.18, 0, 151, false, false],
        ["rotation", 0, 0.03, 0, 1, false, false],
        ["a", 0, 0, 0, 1, false, false],
        ["b", 0, 1.56, 0, 21, false, false],
        ["c", 0, 7.05, 0, 22, false, false],
        ["d", 0, 1.29, 0, 2, false, false],
        ["e", 0, 0.94, 0, 2, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T16:05:29.622Z"
    },
    "updated": {
      "$date": "2024-09-24T16:05:29.622Z"
    },
    "__v": 1
  },
  {
    "_id": {
      "$oid": "66f2ead217196506820da40f"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a35"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.33726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  uv = abs(uv);\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.1);\n    float c = radius * wave * sin(split * uv.x - (stream / -.0355));\n    float d = radius * wave * cos(split * uv.y  - (stream / .035));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.5)* orbSize, vec2(x, x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, stream/.5 + length(uv/.2));\n}",
    "variants": [
      [
        ["zoom", 0, 0.267, 0, 3, false],
        ["iterator", 0, 1.5, 0.7, 2, false],
        ["iterations", 0, 1.412, 0, 33, false],
        ["colorShift", 0, 0.035, 0, 3, false],
        ["colorOffset", 0, 20.312, 15, 30, false],
        ["contrast", 0, 1.294, 0, 3, false],
        ["orbSize", 0, 4.34, 0, 15, false],
        ["div", 0, 14.233, 0.01, 15, false],
        ["radius", 0, 5.486, 0, 30, false],
        ["wave", 0, 17.67, 0, 20, false],
        ["split", 0, 500, 0, 500, false],
        ["inner", 0, 9689533.356, 0, 11512120, false],
        ["outer", 0, 2.616, 0, 401, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T16:37:38.277Z"
    },
    "updated": {
      "$date": "2024-09-24T16:37:38.277Z"
    },
    "__v": 2
  },
  {
    "_id": {
      "$oid": "66f2eb5517196506820da41c"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main () {\n  float stream = stream / 75.;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom / 1090.;\n  uv *= k_rotate2d(stream/-.33726);\n  uv *= outer * (1.1 + cos(inner*dot(uv, uv) - stream/-.061271));\n  uv = abs(uv);\n  for (float i = 5.; i < 15.; i++) {\n    uv = uv * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    float a = radius * cos(uv.x + stream/.05);\n    float b = radius * sin(uv.y - stream/-.1);\n    float c = radius * wave * sin(split * uv.x - (stream / -.0355));\n    float d = radius * wave * cos(split * uv.y  - (stream / .035));\n    float x = a * b - c + d;\n    gl_FragColor += k_orb(uv,zoom* pow(volume, 1.)* orbSize, vec2(x, x),  col, contrast);\n  }\n\n  gl_FragColor = k_hue(gl_FragColor, stream/.5 + length(uv/.2));\n}",
    "variants": [
      [
        ["zoom", 0, 0.267, 0, 3, false],
        ["iterator", 0, 1.5, 0.7, 2, false],
        ["iterations", 0, 1.412, 0, 33, false],
        ["colorShift", 0, 0.035, 0, 3, false],
        ["colorOffset", 0, 20.312, 15, 30, false],
        ["contrast", 0, 1.294, 0, 3, false],
        ["orbSize", 0, 7.351, 0, 15, false],
        ["div", 0, 14.233, 0.01, 15, false],
        ["radius", 0, 5.486, 0, 30, false],
        ["wave", 0, 17.67, 0, 20, false],
        ["split", 0, 500, 0, 500, false],
        ["inner", 0, 9689533.356, 0, 11512120, false],
        ["outer", 0, 2.616, 0, 401, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T16:39:49.092Z"
    },
    "updated": {
      "$date": "2024-09-24T16:39:49.092Z"
    },
    "__v": 1
  },
  {
    "_id": {
      "$oid": "66f2ef2517196506820da429"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 5.\n\nvoid main () {\n  float stream = stream / 30.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= k_rotate2d(stream / .4);\n  uv /= dot(uv, uv);\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-.08));\n  uv -= 21212.5*tan(uv.x/zoom - stream/.28);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(- t*PI), radius*sin(t - stream/-.08));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.035- uv.y/(.9*y + .26*y*sin(stream/.3123))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*pow(volume, .4)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 402043.804, 0.01, 2111000, false],
        ["ballSize", 0, 100999.516, 0, 199999, false],
        ["contrast", 0, 0.902, 0, 5, false],
        ["radius", 0, 15666547.614, 0, 331115555, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 31929999, 100, 31929999, false],
        ["y", 0, 40348628.99, 0, 119133112, false],
        ["rotation", 0, 0.014, 0, 0.1, false],
        ["colorOffset", 0, 326.72, 0, 2110, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 100000, 1, 100000, false],
        ["div2", 0, 1031881.214, 0, 1313311, false],
        ["wad", 0, 8.806, 1, 18, false],
        ["woot", 0, 0.223, 0, 2, false],
        ["wat", 0, 0.075, 0, 0.4, false],
        ["wob", 0, 61.937, 0, 160, false],
        ["outer", 0, 133, 0, 133, false],
        ["outer2", 0, 50.949, 0, 132, false],
        ["wave", 0, 2.122, 0, 11, false],
        ["aWave", 0, 0.336, 0, 1, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T16:56:05.129Z"
    },
    "updated": {
      "$date": "2024-09-24T16:56:05.129Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2ef2a17196506820da42e"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 5.\n\nvoid main () {\n  float stream = stream / 30.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= k_rotate2d(stream / .4);\n  uv /= dot(uv, uv);\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 2.);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-.08));\n  uv -= 21212.5*tan(uv.x/zoom - stream/.28);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(- t*PI), radius*sin(t - stream/-.08));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.035- uv.y/(.9*y + .26*y*sin(stream/.3123))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*pow(volume, .4)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 301487.844, 0.01, 2111000, false],
        ["ballSize", 0, 37126.406, 0, 199999, false],
        ["contrast", 0, 0.902, 0, 5, false],
        ["radius", 0, 15666547.614, 0, 331115555, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 31929999, 100, 31929999, false],
        ["y", 0, 40348628.99, 0, 119133112, false],
        ["rotation", 0, 0.014, 0, 0.1, false],
        ["colorOffset", 0, 326.72, 0, 2110, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 100000, 1, 100000, false],
        ["div2", 0, 1031881.214, 0, 1313311, false],
        ["wad", 0, 8.806, 1, 18, false],
        ["woot", 0, 0.223, 0, 2, false],
        ["wat", 0, 0.075, 0, 0.4, false],
        ["wob", 0, 61.937, 0, 160, false],
        ["outer", 0, 133, 0, 133, false],
        ["outer2", 0, 50.949, 0, 132, false],
        ["wave", 0, 2.122, 0, 11, false],
        ["aWave", 0, 0.336, 0, 1, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T16:56:10.587Z"
    },
    "updated": {
      "$date": "2024-09-24T16:56:10.587Z"
    },
    "__v": 3
  },
  {
    "_id": {
      "$oid": "66f2fc9a17196506820da498"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a43"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream/33.) + stream/2.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x/2.));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-4.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 6.483, 0, 15, false],
        ["contrast", 0, 1.524, 0, 2, false],
        ["orbSize", 0, 1.692, 0.01, 2, false],
        ["radius", 0, 3.824, 1, 50, false],
        ["colorShift", 0, 5.092, 4, 10, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 6.1, 0, 15, false, false],
        ["contrast", 0, 1.38, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 6.06, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 7.54, 0, 15, false, false],
        ["contrast", 0, 1.17, 0, 2, false, false],
        ["orbSize", 0, 0.56, 0.01, 1, false, false],
        ["radius", 0, 5.64, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 87.57, 0, 115, false, false],
        ["contrast", 0, 0.75, 0, 2, false, false],
        ["orbSize", 0, 1, 0.01, 1, false, false],
        ["radius", 0, 23.9, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 6, 0, 6, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ],
      [
        ["zoom", 0, 34.31, 0, 115, false, false],
        ["contrast", 0, 1.87, 0, 2, false, false],
        ["orbSize", 0, 5, 0.01, 5, false, false],
        ["radius", 0, 13.4, 1, 50, false, false],
        ["colorShift", 0, 7.26, 4, 10, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 30.99, 0, 61, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T17:53:30.827Z"
    },
    "updated": {
      "$date": "2024-09-24T17:53:30.827Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2fc9e17196506820da49d"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 20.\n\n  void main () {\n    vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n    uv.x *= resolution.x/resolution.y;\n    uv *= zoom;\n    uv *= k_rotate2d(stream/62.);\n    float dist = length(sin(cos(uv+stream/33.) + stream/2.5));\n    for (float i = 0.; i < orbs; i++) {\n      uv.x *= abs(dist+.001* dist*(i) * (uv.x/2.));\n      float t = (i+1.) * PI / orbs * 2.;\n      float x = radius * tan(t+stream/-4.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i+100.) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, 1.)*orbSize, position, color, contrast);\n    }\n  }",
    "variants": [
      [
        ["zoom", 0, 6.197, 0, 15, false],
        ["contrast", 0, 1.682, 0, 2, false],
        ["orbSize", 0, 1.314, 0.01, 2, false],
        ["radius", 0, 7.257, 1, 50, false],
        ["colorShift", 0, 5.092, 4, 10, false],
        ["mirror", 1, false, null, null, null, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["center", 0, 1, 0, 1, false, false],
        ["sides", 0, 3, 0, 8, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T17:53:34.034Z"
    },
    "updated": {
      "$date": "2024-09-24T17:53:34.034Z"
    },
    "__v": 4
  },
  {
    "_id": {
      "$oid": "66f2fd5b17196506820da4c2"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "\n  #define orbs 20.\n\n  vec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n} \n\nvec4 hue(vec4 color, float shift) {\n  const vec4 kRGBToYPrime = vec4(0.299, 0.587, 0.114, 0.0);\n  const vec4 kRGBToI = vec4(0.596, -0.275, -0.321, 0.0);\n  const vec4 kRGBToQ = vec4(0.212, -0.523, 0.311, 0.0);\n  const vec4 kYIQToR = vec4(1.0, 0.956, 0.621, 0.0);\n  const vec4 kYIQToG = vec4(1.0, -0.272, -0.647, 0.0);\n  const vec4 kYIQToB = vec4(1.0, -1.107, 1.704, 0.0);\n  float YPrime = dot(color, kRGBToYPrime);\n  float I = dot(color, kRGBToI);\n  float Q = dot(color, kRGBToQ);\n  float hue = atan(Q, I);\n  float chroma = sqrt(I * I + Q * Q);\n  hue += shift;\n  Q = chroma * sin(hue);\n  I = chroma * cos(hue);\n  vec4 yIQ = vec4(YPrime, I, Q, 0.0);\n  color.r = dot(yIQ, kYIQToR);\n  color.g = dot(yIQ, kYIQToG);\n  color.b = dot(yIQ, kYIQToB);\n  return color;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(2. * PI * (c * t + d));\n}\n\nvec4 orb (vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate (float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main () {\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= rotate(stream/5.);\n  float dist = length(uv);\n  if (mirrorTween) {\n   \tif (mirror) { \n    \tuv = mix(uv, abs(uv), (mirrorTweenProgress));\n    } else {\n      uv = mix(abs(uv), uv, (mirrorTweenProgress));\n    }\n  } else if (mirror) {\n    uv = abs(uv);\n  }\n  //uv *= rotate(rotation*stream/5.);\n  uv /= dot(uv, uv);\n  //uv = kale(uv, vec2(0), sides);\n  //uv *= rotate(rotation*stream/10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + stream*xSpeed) - cos(uv.y/yDivide-stream/2.);\n    uv.y += cosMul * cos(uv.x * xMul - stream*ySpeed) * sin(uv.x/xDivide-stream/2.);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t-stream/5.);\n    float y = radius * cos(t+stream/5.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    gl_FragColor += orb(uv, orbSize, position, color, contrast);\n  }\n}\n",
    "variants": [
      [
        ["zoom", 0, 0.31, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.06, 0, 1, false, false],
        ["contrast", 0, 1.59, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 18.4, 1, 115, false, false],
        ["colorShift", 0, 10, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.14, 0, 1, false, false],
        ["contrast", 0, 1.46, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 12.69, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.62, 0, 1, false, false],
        ["contrast", 0, 1.5, 0, 2, false, false],
        ["orbSize", 0, 2.7, 0.01, 5, false, false],
        ["radius", 0, 10.4, 1, 115, false, false],
        ["colorShift", 0, 4.31, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 0, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, 1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0059, 0.001, 0.01, false, false],
        ["yDivide", 0, 0.43, 0, 19, false, false],
        ["xDivide", 0, 12.45, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ],
      [
        ["zoom", 0, 0.05, 0, 1, false, false],
        ["contrast", 0, 1.68, 0, 2, false, false],
        ["orbSize", 0, 6.95, 0.01, 15, false, false],
        ["radius", 0, 55.15, 1, 115, false, false],
        ["colorShift", 0, 7.11, 4, 10, false, false],
        ["sides", 0, 7, 0, 12, false, false],
        ["rotation", 0, 0.66, 0, 2, false, false],
        ["sinMul", 0, 0, 0, 2, false, false],
        ["cosMul", 0, 1.09, 0, 5, false, false],
        ["yMul", 0, 0, 0, 5, false, false],
        ["xMul", 0, 0.26, 0, 5, false, false],
        ["xSpeed", 0, -1, -1, 1, false, false],
        ["ySpeed", 0, 1, 0, 1, false, false],
        ["gloop", 0, 0.0022, 0.001, 0.01, false, false],
        ["yDivide", 0, 3.33, 0, 19, false, false],
        ["xDivide", 0, 3.33, 0, 19, false, false],
        ["mirror", 1, false, null, null, null, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T17:56:43.005Z"
    },
    "updated": {
      "$date": "2024-09-24T17:56:43.005Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2fe6a17196506820da4d5"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a64"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define BALLS 45.\n\nvoid main() {\n  float stream = stream / 3.67950;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/8.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 30.; i < BALLS; i++) {\n    // uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * i * PI / BALLS * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .86)/3. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 248.939, 0, 1000, false],
        ["xDiv", 0, 322.096, 0, 1000, false],
        ["yDiv", 0, 486.62, 0, 2000, false],
        ["xDiv2", 0, 80.919, 0, 200, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 26.013, 0, 2000, false],
        ["yDiv3", 0, 26.786, 0, 2000, false, false],
        ["multiplier", 0, 5.982, 0, 20, false, false],
        ["ballSize", 0, 52.287, 0, 100, false],
        ["contrast", 0, 1.688, 0, 4, false],
        ["radius", 0, 26.877, 0, 250, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 3.482, 0, 20, false, false],
        ["yMul", 0, 4.196, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T18:01:14.691Z"
    },
    "updated": {
      "$date": "2024-09-24T18:01:14.691Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2fe7917196506820da4da"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define BALLS 45.\n\nvoid main() {\n  float stream = stream / 3.67950;\n  vec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x / resolution.y;\n\n  uv *= zoom;\n\n  // uv = abs(uv);\n  uv *= k_rotate2d(stream/8.);\n  gl_FragColor = vec4(0);\n  float dist = length(uv);\n  for (float i = 30.; i < BALLS; i++) {\n    // uv *= k_rotate2d(rotation * PI /1.);\n    uv.y -= float(i) / 12. * cos(uv.y / yDiv + stream / 1.) + sin(uv.x / xDiv2 - stream / 1.);\n    uv.x -= float(i) / 15. * sin(uv.x / xDiv + stream / 1.) - cos(uv.y / yDiv2 + stream / 1.);\n    float t = 1.1 * i * PI / BALLS * (5. + 1.);\n    float _multiplier = dist / multiplier * sin(uv.x - stream / 1.);\n    vec2 p = radius * vec2(xMul * tan(t + stream / 2.), yMul * sin(t / multiplier + stream / 1.));\n    p /= cos(PI * sin(uv.x / xDiv3 + stream / 1.) * sin(uv.y / yDiv3 - stream / 1.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. - float(i) / PI)) * 0.5 + 0.5;\n    gl_FragColor += vec4(ballSize * pow(volume, .86)/3. / length(uv - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = pow(gl_FragColor.xyz, vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 248.939, 0, 1000, false],
        ["xDiv", 0, 322.096, 0, 1000, false],
        ["yDiv", 0, 486.62, 0, 2000, false],
        ["xDiv2", 0, 80.919, 0, 200, false],
        ["yDiv2", 0, 116.964, 0, 200, false, false],
        ["xDiv3", 0, 26.013, 0, 2000, false],
        ["yDiv3", 0, 26.786, 0, 2000, false, false],
        ["multiplier", 0, 5.982, 0, 20, false, false],
        ["ballSize", 0, 52.287, 0, 100, false],
        ["contrast", 0, 1.688, 0, 4, false],
        ["radius", 0, 26.877, 0, 250, false],
        ["rotation", 0, 0, 0, 11, false, false],
        ["xMul", 0, 3.482, 0, 20, false, false],
        ["yMul", 0, 4.196, 0, 20, false, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T18:01:29.656Z"
    },
    "updated": {
      "$date": "2024-09-24T18:01:29.656Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f2ff5417196506820da4ed"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 14.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 4.);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .15) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/1.3 - t*PI), radius*tan(t - stream/-.8));\n    p /= (cos(wad * cos(stream/.3 - uv.x/x))*sin(stream/-.3- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 391569.402, 0.01, 2111000, false, false],
        ["ballSize", 0, 58607.908, 0, 99999, false, false],
        ["contrast", 0, 3.38, 0, 5, false, false],
        ["radius", 0, 21822654.66, 0, 331115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 133300768.7, 10000000, 192999999, false, false],
        ["y", 0, 7915426.66, 0, 119133112, false, false],
        ["rotation", 0, 0, 0, 0.01, false, false],
        ["colorOffset", 0, 96.5, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 39960.707, 1, 100000, false, false],
        ["div2", 0, 916935.078, 0, 1313311, false, false],
        ["wad", 0, 3.154, 1, 18, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.315, 0, 0.4, false, false],
        ["wob", 0, 70.691, 0, 160, false, false],
        ["outer", 0, 133, 0, 133, false, false],
        ["outer2", 0, 40.203, 0, 132, false, false],
        ["wave", 0, 2.717, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ],
      [
        ["zoom", 0, 596124.912, 0.01, 2111000, false, false],
        ["ballSize", 0, 3560.215, 0, 6122, false, false],
        ["contrast", 0, 2.09, 0, 5, false, false],
        ["radius", 0, 6722295.77, 0, 31115555, false, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 33874060.38, 0, 818888881, false, false],
        ["y", 0, 6846884.45, 0, 19133112, false, false],
        ["rotation", 0, 0.00133, 0, 0.01, false, false],
        ["colorOffset", 0, 64.84, 0, 2110, false, false],
        ["sides", 0, 3, 0, 12, false, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 36465.301, 1, 100000, false, false],
        ["div2", 0, 299012.772, 0, 1313311, false, false],
        ["wad", 0, 10.028, 1, 180, false, false],
        ["woot", 0, 0.176, 0, 2, false, false],
        ["wat", 0, 0.768, 0, 1, false, false],
        ["wob", 0, 37.173, 0, 160, false, false],
        ["outer", 0, 48.182, 0, 133, false, false],
        ["outer2", 0, 11.052, 0, 132, false, false],
        ["wave", 0, 1.743, 0, 11, false, false],
        ["aWave", 0, 0.1027, 0, 1, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T18:05:08.915Z"
    },
    "updated": {
      "$date": "2024-09-24T18:05:08.915Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "66f3010917196506820da4f5"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a44"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 17.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 1.28);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/31.3 - t*PI), radius*tan(t - stream/-33.8));\n    p /= (cos(wad * cos(stream/.27 - uv.x/x))*sin(stream/-.29- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 419328.267, 0.01, 2111000, false],
        ["ballSize", 0, 9569.469, 0, 299999, false],
        ["contrast", 0, 2.176, 0, 5, false],
        ["radius", 0, 3832855.202, 0, 33331555, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 129670504.048, 10000000, 192999999, false],
        ["y", 0, 6535949.534, 0, 119133112, false],
        ["rotation", 0, 0.006, 0, 0.01, false],
        ["colorOffset", 0, 451.118, 0, 2110, false],
        ["sides", 0, 3.5, 0, 12, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 37429.995, 1, 100000, false],
        ["div2", 0, 500328.954, 0, 1313311, false],
        ["wad", 0, 1.945, 1, 18, false],
        ["woot", 0, 0.132, 0, 2, false],
        ["wat", 0, 0.232, 0, 0.4, false],
        ["wob", 0, 39.916, 0, 160, false],
        ["outer", 0, 133, 0, 133, false],
        ["outer2", 0, 65.295, 0, 132, false],
        ["wave", 0, 1.181, 0, 11, false],
        ["aWave", 0, 0.28, 0, 1, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-09-24T18:12:25.571Z"
    },
    "updated": {
      "$date": "2024-09-24T18:12:25.571Z"
    },
    "__v": 1
  },
  {
    "_id": {
      "$oid": "66f3011917196506820da4fe"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "#define orbs 10.\n\nvoid main () {\n  float stream = stream / 17.;\n  vec2 uv = -1. + 2.* gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  // gl_FragColor = vec4(0);\n  // float dist = length(uv);\n  uv *= k_rotate2d(stream / 1.28);\n  // uv /= dot(uv, uv);\n  // uv *= log(abs(uv));\n  // uv = normalize(uv) * length((uv));\n  vec2 _uv = uv;\n  uv *= (outer + outer2*sin(woot*cos(_uv.x/div2 + stream / .25) * _uv.y/div - stream/-1.18));\n  // uv= .5*tan(uv.y/300. - stream/.8);\n  for (float i = 0.; i < orbs; i++) {\n    uv *= k_rotate2d(rotation * PI);\n    float t = float(i) * PI / float(orbs) * (2. + 1.);\n    vec2 p = vec2(radius*wat*tan(stream/31.3 - t*PI), radius*tan(t - stream/-33.8));\n    p /= (cos(wad * cos(stream/.27 - uv.x/x))*sin(stream/-.29- uv.y/(.9*y + .6*y*sin(stream/.23))));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (.9 * float(i) / 5.)) * 0.5 + 0.5;\n    gl_FragColor += vec4(colorOffset*float(i)*ballSize / length(uv  - p * 0.9) * col, contrast);\n  }\n  gl_FragColor.xyz = 1.-pow(abs(1.-log(abs(gl_FragColor.xyz))), vec3(contrast));\n  gl_FragColor.w = 1.0;\n}",
    "variants": [
      [
        ["zoom", 0, 419328.267, 0.01, 2111000, false],
        ["ballSize", 0, 9569.469, 0, 299999, false],
        ["contrast", 0, 2.176, 0, 5, false],
        ["radius", 0, 3832855.202, 0, 33331555, false],
        ["mirror", 1, false, null, null, null, false],
        ["x", 0, 129670504.048, 10000000, 192999999, false],
        ["y", 0, 6535949.534, 0, 119133112, false],
        ["rotation", 0, 0.006, 0, 0.01, false],
        ["colorOffset", 0, 451.118, 0, 2110, false],
        ["sides", 0, 3.5, 0, 12, false],
        ["kaleidoscope", 1, false, null, null, null, false],
        ["div", 0, 37429.995, 1, 100000, false],
        ["div2", 0, 500328.954, 0, 1313311, false],
        ["wad", 0, 1.945, 1, 18, false],
        ["woot", 0, 0.132, 0, 2, false],
        ["wat", 0, 0.232, 0, 0.4, false],
        ["wob", 0, 39.916, 0, 160, false],
        ["outer", 0, 133, 0, 133, false],
        ["outer2", 0, 65.295, 0, 132, false],
        ["wave", 0, 1.181, 0, 11, false],
        ["aWave", 0, 0.28, 0, 1, false]
      ]
    ],
    "public": true,
    "created": {
      "$date": "2024-09-24T18:12:41.934Z"
    },
    "updated": {
      "$date": "2024-09-24T18:12:41.934Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "6705290d1ae1c8822992404c"
    },
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      [
        ["zoom", 0, 0.259535, 0, 2, false, false],
        ["color", 3, [0.4745098039215686, 0.44313725490196076, 0.9568627450980393], null, null, null, false],
        ["shift", 0, 78.474472, 0, 182, false, false],
        ["offset", 0, 11.60847, 0, 12, false, false],
        ["height", 0, 9.688396, 0, 11, false, false],
        ["xDiv", 0, 17508.178034, 11, 20000, false, false],
        ["width", 0, 0.000675, 0, 0.001, false, false],
        ["stretch", 0, 1.197543, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-10-08T12:43:57.344Z"
    },
    "updated": {
      "$date": "2024-10-08T12:43:57.345Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "670529961ae1c8822992404f"
    },
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      [
        ["zoom", 0, 0.259535, 0, 2, false, false],
        ["color", 3, [0.4745098039215686, 0.44313725490196076, 0.9568627450980393], null, null, null, false],
        ["shift", 0, 78.474472, 0, 182, false, false],
        ["offset", 0, 11.60847, 0, 12, false, false],
        ["height", 0, 9.688396, 0, 11, false, false],
        ["xDiv", 0, 17508.178034, 11, 20000, false, false],
        ["width", 0, 0.000675, 0, 0.001, false, false],
        ["stretch", 0, 1.197543, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-10-08T12:46:14.355Z"
    },
    "updated": {
      "$date": "2024-10-08T12:46:14.355Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "67052a341ae1c88229924052"
    },
    "shader": "#define S smoothstep\n#define ticks 30.\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    float stream = stream /2. / PI/2.;\n    uv.y += S(1., 0., abs(5.*uv.x)) * sin(stream * speed + 5.*uv.y * height) * stretch * pow(volume, .5);\n    return vec4(length(1.-uv) * S(.075 * S(0.01, pow(volume, .5), sin(uv.x/2.)), 0., abs(uv.y/1.5) - width) * col, .2) * S(pow(volume, .5) * 20., .1, abs(uv.y/.1));\n}\n\nvoid main() {\n  vec2 uv = k_uv() * zoom;\n  uv *= k_rotate2d(stream/-20.);\n  gl_FragColor = vec4 (0.);\n  for (float i = 5.; i <= ticks; i += 2.) {\n    float t = i / ticks;\n    uv *= k_rotate2d(stream/20.*PI/4.);\n    vec3 col = k_rainbow(t, shift, offset);\n    gl_FragColor += Line(uv, 20.*uv.y/xDiv + t, volume * height, color * col);\n  }\n  \n  gl_FragColor = pow(gl_FragColor, vec4(.5));\n  // gl_FragColor = k_hue(gl_FragColor, stream);\n}",
    "variants": [
      [
        ["zoom", 0, 0.259535, 0, 2, false, false],
        ["color", 3, [0.4745098039215686, 0.44313725490196076, 0.9568627450980393], null, null, null, false],
        ["shift", 0, 78.474472, 0, 182, false, false],
        ["offset", 0, 11.60847, 0, 12, false, false],
        ["height", 0, 9.688396, 0, 11, false, false],
        ["xDiv", 0, 17508.178034, 11, 20000, false, false],
        ["width", 0, 0.000675, 0, 0.001, false, false],
        ["stretch", 0, 1.197543, 0, 20, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-10-08T12:48:52.655Z"
    },
    "updated": {
      "$date": "2024-10-08T12:48:52.655Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "6737ea21d249204f58003f97"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main() {\n    vec2 uv = k_uv();\n    uv *=  zoom;//(zoom * cos(stream/5000.) + zoom);\n    vec2 frac = abs(fract(uv) - .5) * 1.;\n  \n    uv *= k_rotate2d(stream/-3.);\n  \n    float dist = distance(uv, vec2(0.));\n    vec2 rotated = uv * k_rotate2d(dist/210. * stream/22.);\n    vec2 rotated2 = uv * k_rotate2d(dist/100. + stream/4.);// * sin(uv.x) * cos(uv.y);\n    uv *= k_rotate2d(stream/2.);\n    uv = mix(rotated, rotated2, cos(dist - stream/5.5));\n    uv = k_kale(uv, vec2(0), sides);\n\n    // uv /= atan(dot(uv, uv));\n    vec4 result = vec4(0, 0, 0, 1);\n    float t = 0.;\n    float base = 1. * atan(length(uv));\n    for (int p = 0; p < 3; p++) {\n        uv *= k_rotate2d(stream/15.);\n      float a = dist*cos((t * base) );\n      float b = cos(lines * uv.x / + dist);\n      result[p] = pMul * a + bMul  * b + base / 2.;\n      t += offset;\n    }\n    float col =  k_hue(result.xyxy, stream / 2.).g;\n    result.xyz *= brightness * result.x;\n    gl_FragColor =  2.-log(1.-abs(result)); \n    gl_FragColor.r *= red;\n    gl_FragColor.g *= green;\n    gl_FragColor.b *= blue;\n    gl_FragColor = k_hue(gl_FragColor, stream/1. - dist/4.); \n  }",
    "variants": [
      [
        ["zoom", 0, 0.724369, 0.01, 10.1, false, false],
        ["brightness", 0, 4, 0.001, 4, false, false],
        ["red", 0, 0.219879, 0, 1, false, false],
        ["green", 0, 0.2, 0, 1, false, false],
        ["blue", 0, 0.25, 0, 1, false, false],
        ["sides", 0, 1, 1, 8, true, false],
        ["offset", 0, 1, 1, 1250, false, false],
        ["lines", 0, 7.685157, 0, 15, false, false],
        ["ySpread", 0, 78.74546, 1, 800, false, false],
        ["pMul", 0, 2.395309, 0, 22, false, false],
        ["bMul", 0, 2.943299, 0, 12, false, false]
      ]
    ],
    "public": false,
    "created": {
      "$date": "2024-11-16T00:41:05.029Z"
    },
    "updated": {
      "$date": "2024-11-16T00:41:05.029Z"
    },
    "__v": 5
  },
  {
    "_id": {
      "$oid": "6737f9bed249204f58003fc2"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [[["zoom", 0, 1, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2024-11-16T01:47:42.924Z"
    },
    "updated": {
      "$date": "2024-11-16T01:47:42.924Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "67ebbcd8c8ed129a42138550"
    },
    "study": {
      "$oid": "67ebbcd8c8ed129a4213854e"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [[["zoom", 0, 1, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2025-04-01T10:15:52.988Z"
    },
    "updated": {
      "$date": "2025-04-01T10:15:52.988Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "67f34aa2ab0cc7f4153d3bcd"
    },
    "study": {
      "$oid": "66d117b92396a72915a21a6c"
    },
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "shader": "void main () {\n  vec2 uv = k_uv() * zoom;\n\n  float r = sin(uv.x);\n  float g = cos(uv.y);\n  float b = sin(uv.y);\n\n  gl_FragColor = vec4(r, g, b, 1.);\n}",
    "variants": [[["zoom", 0, 1, 0, 2, false, false]]],
    "public": false,
    "created": {
      "$date": "2025-04-07T03:46:42.561Z"
    },
    "updated": {
      "$date": "2025-04-07T03:46:42.561Z"
    },
    "__v": 0
  },
  {
    "_id": {
      "$oid": "685391ef02fb9e6727d0298a"
    },
    "shader": "void main () {\n  float stream = stream / 1.5; \nvec2 uv = -1. + 2. * gl_FragCoord.xy / resolution.xy;\n  uv.x *= resolution.x/resolution.y;\n  uv *= zoom;\n  uv *= k_rotate2d(stream /-10.);\n  vec2 _uv = uv;\n  mat2 rotation = k_rotate2d(stream/ (PI*6.));\n  for (float i = 0.; i < 10.; i++) {\n    uv *= rotation;\n    uv = abs(uv) * iterator;\n    vec3 col = k_rainbow(i / iterations, colorShift, colorOffset);\n    gl_FragColor += k_orb(uv, pow(volume, 1.) * orbSize, vec2(radius*abs(cos(stream/-.8+uv.x/div)) * L * sin(stream/.7 - uv.y), radius*cos(stream/.7+uv.y/div)),  col, contrast);\n  }\n\n    uv = _uv;\n\n    uv *= zoom / 50.;\n    uv *= (wob / dot(uv, uv));\n    uv *= k_rotate2d(stream/-10.);\n    float dist = length(sin(cos(uv+stream/1.)));\n    for (float i = 10.; i < 20.; i++) {\n      uv.x *= tan(dist+.000001* dist*(i) * (uv.x));\n      float t = (i+1.) * PI / 10. * PI * 1.5 + uv.x/20.;\n      float x = radius * tan(t - stream/10.);//* cos(t-stream/1.) / sin(t);\n      float y = radius * sin(t + stream/30.);// / sin(t-stream/1.) / cos(t);\n      vec2 position = vec2(x, y);\n      vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i-i*PI) / colorShift)) * 0.5 + 0.5;\n      gl_FragColor += k_orb(uv, pow(volume, .8) * orbSize, position, color, contrast);\n    }\n  gl_FragColor.g *= .2;\n}",
    "variants": [
      [
        ["zoom", 0, 0.6347062999362257, 0.2, 0.6, false, false],
        ["iterator", 0, 9.545699904913453, 1, 12, false, false],
        ["ot", 0, 63.45670382482259, 0, 151, false, false],
        ["I", 0, 2.004611658162746, 0, 3, false, false],
        ["J", 0, 0.9292826277731768, 0, 3, false, false],
        ["K", 0, 1.7887850816908168, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 1.1279381425603259, 1, 2, false, false],
        ["M", 0, 0.43865731802863905, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 4.816923703081921, 4, 10, false, false],
        ["contrast", 0, 2.172935900983824, 1, 1.5, false, false],
        ["orbSize", 0, 1.3638092748249202, 0.5, 2, false, false],
        ["div", 0, 0.18712700275218697, 0.01, 0.5, false, false],
        ["radius", 0, 4.478964174125304, 3, 10, false, false],
        ["wob", 0, 0.027189022299892483, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.252383, 0.2, 0.6, false, false],
        ["iterator", 0, 7.569259349233938, 1, 12, false, false],
        ["ot", 0, 77.22702061398316, 0, 151, false, false],
        ["I", 0, 2.5421969305949066, 0, 3, false, false],
        ["J", 0, 2.3204582724811766, 0, 3, false, false],
        ["K", 0, 10.66774605644863, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.4078496791886295, 1, 2, false, false],
        ["M", 0, 0.49353160809578367, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 5.7879599494522385, 4, 10, false, false],
        ["contrast", 0, 1.72852776965142, 1, 1.5, false, false],
        ["orbSize", 0, 2, 0.5, 2, false, false],
        ["div", 0, 0.08027884559708552, 0.01, 0.5, false, false],
        ["radius", 0, 3.306594, 3, 10, false, false],
        ["wob", 0, 0.09822452407689686, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.5518645466466255, 0.2, 0.6, false, false],
        ["iterator", 0, 9.345306061754322, 1, 12, false, false],
        ["ot", 0, 76.95672847031916, 0, 151, false, false],
        ["I", 0, 2.0299764684706196, 0, 3, false, false],
        ["J", 0, 0.5775865735935444, 0, 3, false, false],
        ["K", 0, 4.5782725349372235, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.5327226221179027, 1, 2, false, false],
        ["M", 0, 0.9855923008127525, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 7.124793907730577, 4, 10, false, false],
        ["contrast", 0, 1.8673261085401902, 1, 1.5, false, false],
        ["orbSize", 0, 1.6922743948115222, 0.5, 2, false, false],
        ["div", 0, 0.06848968434306733, 0.01, 0.5, false, false],
        ["radius", 0, 3.145716, 3, 10, false, false],
        ["wob", 0, 0.003, 0.003, 0.1, false, false]
      ],
      [
        ["zoom", 0, 0.380322, 0.2, 0.6, false, false],
        ["iterator", 0, 9.218471677489154, 1, 12, false, false],
        ["ot", 0, 131.63249519716393, 0, 151, false, false],
        ["I", 0, 1.3802125534214826, 0, 3, false, false],
        ["J", 0, 1.395041179704047, 0, 3, false, false],
        ["K", 0, 2.951226237343881, 0, 11, false, false],
        ["iterations", 0, 0.485278, 0, 1, false, true],
        ["L", 0, 2.974272682393624, 1, 2, false, false],
        ["M", 0, 0.8482203936410846, 0, 1, false, false],
        ["colorShift", 0, 1.2714860957637544, 1.1, 1.2999999999999998, false, true],
        ["colorOffset", 0, 8.985077800486769, 4, 10, false, false],
        ["contrast", 0, 1.87270215686231, 1, 1.5, false, false],
        ["orbSize", 0, 0.8984214901639822, 0.5, 2, false, false],
        ["div", 0, 0.07098858854079364, 0.01, 0.5, false, false],
        ["radius", 0, 7.968495755292857, 3, 10, false, false],
        ["wob", 0, 0.012046381298866725, 0.003, 0.1, false, false]
      ]
    ],
    "public": true,
    "created": "2024-08-30T00:46:40.733Z",
    "updated": "2024-08-30T00:46:40.733Z",
    "__v": 0,
    "author": {
      "$oid": "6736e4e2326b7660ad017bc6"
    },
    "study": {
      "$oid": "66f2980c92cc9d303e380427"
    }
  }
]
